<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>1. 两数之和</title>
    <link href="/2021/12/09/LeetCode/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2021/12/09/LeetCode/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/two-sum/">本题链接</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br><br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; dig_map;<br>        <br>        <span class="hljs-comment">//以&#123;nums[i],i&#125;的形式存入哈希表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;nums.<span class="hljs-built_in">size</span>();++i)<br>            <span class="hljs-keyword">if</span>(dig_map.<span class="hljs-built_in">find</span>(nums[i]) == dig_map.<span class="hljs-built_in">end</span>())<span class="hljs-comment">//如果哈希表没记录</span><br>                dig_map[nums[i]] = i;<span class="hljs-comment">//存入哈希表</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*nums[i] == target)<span class="hljs-comment">//如果哈希表有记录,判断是否这个值的两倍是否为目标值</span><br>                <span class="hljs-keyword">return</span> &#123;dig_map[nums[i]],i&#125;;<br>                <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; [digit,_]:dig_map)<br>            <span class="hljs-keyword">if</span>(dig_map.<span class="hljs-built_in">find</span>(target - digit) != dig_map.<span class="hljs-built_in">end</span>())<span class="hljs-comment">//找到目标值</span><br>                <span class="hljs-keyword">return</span> &#123;dig_map[target - digit],dig_map[digit]&#125;;<br><br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用哈希表存储值和它的下标，然后再去哈希表中查找是否有两者值的和为目标值的元素，若存在，就返回。</p><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;++i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>;j &lt; nums.<span class="hljs-built_in">size</span>();++j)<br>                <span class="hljs-keyword">if</span>(nums[i] + nums[j] == target) <span class="hljs-keyword">return</span> &#123;i,j&#125;;<br><br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>思路不重要，思路很直观，如果数据量很小的话感觉暴力算法甚至更快</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>暴力</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>101. 对称二叉树</title>
    <link href="/2021/12/09/LeetCode/101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2021/12/09/LeetCode/101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/symmetric-tree/">本题链接</a></p><h2 id="迭代-层序遍历"><a href="#迭代-层序遍历" class="headerlink" title="迭代+层序遍历"></a>迭代+层序遍历</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        vector&lt;string&gt; tmp;<br>        queue&lt;TreeNode*&gt; node_queue;<br>        TreeNode* cur_node;<br>        <span class="hljs-comment">//中序遍历存储到数组</span><br><br>        node_queue.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!node_queue.<span class="hljs-built_in">empty</span>())&#123;<br><br>            <span class="hljs-keyword">int</span> size = node_queue.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">if</span>(tmp.<span class="hljs-built_in">capacity</span>() &lt; size) tmp.<span class="hljs-built_in">resize</span>(size,<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//如果tmp空间不足 扩容</span><br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; size;++i)&#123;<br><br>                cur_node = node_queue.<span class="hljs-built_in">front</span>();node_queue.<span class="hljs-built_in">pop</span>();<br><br>                <span class="hljs-keyword">if</span>(!cur_node)&#123;<span class="hljs-comment">//如果节点为空</span><br>                    tmp[i] = <span class="hljs-string">&quot;null&quot;</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果节点不为空</span><br>                    tmp[i] = cur_node-&gt;val;<br>                    node_queue.<span class="hljs-built_in">push</span>(cur_node-&gt;left);<br>                    node_queue.<span class="hljs-built_in">push</span>(cur_node-&gt;right);<br>                &#125;<br><br>            &#125;<br>            <br>            <span class="hljs-comment">//进行比较</span><br>            <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = size - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(left &lt;= right)<br>                <span class="hljs-keyword">if</span>(tmp[left++] != tmp[right--]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果不相等</span><br>            tmp.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//清空</span><br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一棵二叉树如果是镜像对称的，那么它的每一层都是对称的，实际上就是回文。那么可以按照层序遍历的思路，在每一层都进行回文比较。</p><h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isCheck</span>(root,root);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isCheck</span><span class="hljs-params">(TreeNode* p1,TreeNode* p2)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!p1 &amp;&amp; !p2) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//两个都为空</span><br>        <span class="hljs-keyword">if</span>(!p1 || !p2) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//其中一个为空</span><br><br>        <span class="hljs-keyword">if</span>(p1-&gt;val != p2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//若两者的值不相等</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isCheck</span>(p1-&gt;left,p2-&gt;right) &amp;&amp; <span class="hljs-built_in">isCheck</span>(p1-&gt;right,p2-&gt;left);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>具体看官方解析<a href="https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution/">https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution/</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代</tag>
      
      <tag>层序遍历</tag>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1011. 在 D 天内送达包裹的能力</title>
    <link href="/2021/12/09/LeetCode/1011.%20%E5%9C%A8%20D%20%E5%A4%A9%E5%86%85%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B/"/>
    <url>/2021/12/09/LeetCode/1011.%20%E5%9C%A8%20D%20%E5%A4%A9%E5%86%85%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">本题链接</a></p><h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shipWithinDays</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; weights, <span class="hljs-keyword">int</span> days)</span> </span>&#123;<br><br>        <span class="hljs-comment">//先获取运载能力的上下限,作为二分查找的边界</span><br>        <span class="hljs-keyword">int</span> left = *<span class="hljs-built_in">max_element</span>(weights.<span class="hljs-built_in">begin</span>(),weights.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">accumulate</span>(weights.<span class="hljs-built_in">begin</span>(),weights.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-keyword">int</span> loop_weights,day,mid;<br><br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br><br>            mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            loop_weights = <span class="hljs-number">0</span>;<br>            day = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//对货物进行遍历</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> &amp;goods:weights)&#123;<br>                <br>                <span class="hljs-keyword">if</span>(loop_weights + goods &gt; mid)&#123;<span class="hljs-comment">//如果已存的货物重量大于载重量</span><br>                    loop_weights = <span class="hljs-number">0</span>;<br>                    ++day;<br>                &#125;<br>                loop_weights += goods;<br>        <br>            &#125;<br>            <span class="hljs-keyword">if</span>(day &lt;= days) right = mid;<span class="hljs-comment">//说明载重量太大</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(day &gt; days) left = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//说明载重量太小</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> left;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>依照题意，可知船的载重量不会小于最大货物的重量；而船的最大载重量取决于所有的货物总量。那么可以按照这两个量作为左右边界，二分搜索最佳载重量，让天数匹配。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>102. 二叉树的层序遍历</title>
    <link href="/2021/12/09/LeetCode/102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2021/12/09/LeetCode/102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">本题链接</a></p><h2 id="层次遍历-迭代1"><a href="#层次遍历-迭代1" class="headerlink" title="层次遍历+迭代1"></a>层次遍历+迭代1</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        TreeNode* node;<br>        <span class="hljs-keyword">int</span> height;<br>    &#125;Elem;<br><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        <span class="hljs-keyword">int</span> val;<br>        <span class="hljs-keyword">int</span> height;<br>    &#125;Value;<br>    <br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>        vector&lt;Value&gt; tmp;<span class="hljs-comment">//存入&#123;节点的值,节点所在的层数&#125;</span><br>        queue&lt;Elem&gt; node_q;<span class="hljs-comment">//存入&#123;节点,节点所在的层数&#125;</span><br><br>        <span class="hljs-comment">//层次遍历 存入数组中</span><br>        node_q.<span class="hljs-built_in">push</span>(&#123;root,<span class="hljs-number">0</span>&#125;);<span class="hljs-comment">//存入第一个节点</span><br>        <span class="hljs-keyword">while</span>(!node_q.<span class="hljs-built_in">empty</span>())&#123;<span class="hljs-comment">//当队列非空</span><br><br>            TreeNode* loop_node = ((Elem)node_q.<span class="hljs-built_in">front</span>()).node;<span class="hljs-comment">//从队列头获取当前节点</span><br>            <span class="hljs-keyword">int</span> height = ((Elem)node_q.<span class="hljs-built_in">front</span>()).height;<span class="hljs-comment">//从队列头获取当前高度</span><br><br>            tmp.<span class="hljs-built_in">push_back</span>(&#123;loop_node-&gt;val,height&#125;);<span class="hljs-comment">//将节点的值和高度存入tmp数组</span><br>            <br>            <span class="hljs-keyword">if</span>(loop_node-&gt;left) node_q.<span class="hljs-built_in">push</span>(&#123;loop_node-&gt;left,height+<span class="hljs-number">1</span>&#125;);<span class="hljs-comment">//存入左孩子到队列</span><br>            <span class="hljs-keyword">if</span>(loop_node-&gt;right) node_q.<span class="hljs-built_in">push</span>(&#123;loop_node-&gt;right,height+<span class="hljs-number">1</span>&#125;);<span class="hljs-comment">//存入右孩子到队列</span><br>                <br>            node_q.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//将当前节点出队</span><br>        &#125;<br><br>        <span class="hljs-comment">//开辟结果数组,大小与最后一个节点的高度有关</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res = vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;(((Value)tmp[tmp.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]).height + <span class="hljs-number">1</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;&#125;);<br><br>        <span class="hljs-comment">//遍历tmp中的所有元素,存放到相应的数组中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; tmp.<span class="hljs-built_in">size</span>();++i)<br>            res[((Value)tmp[i]).height].<span class="hljs-built_in">push_back</span>(((Value)tmp[i]).val);<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>该题的关键就是如何保存每一层的高度，可以在层次遍历时记录每个节点的高度，然后将每个节点的值以及高度保存在数组里，最后再由这个数组构造结果。</p><h2 id="层次遍历-迭代2"><a href="#层次遍历-迭代2" class="headerlink" title="层次遍历+迭代2"></a>层次遍历+迭代2</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>        queue&lt;TreeNode*&gt; node_queue;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br><br>        node_queue.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!node_queue.<span class="hljs-built_in">empty</span>())&#123;<br><br>            <span class="hljs-keyword">int</span> size = node_queue.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//该层大小</span><br>            vector&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; size;++i)&#123;<br>                <br>                <span class="hljs-keyword">if</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;left) node_queue.<span class="hljs-built_in">push</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;left);<br>                <span class="hljs-keyword">if</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;right) node_queue.<span class="hljs-built_in">push</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;right);<br>                tmp.<span class="hljs-built_in">push_back</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;val);<br>                <br>                node_queue.<span class="hljs-built_in">pop</span>();<br>            &#125;   <br><br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>对比层序遍历1，无需保存层数，其实层数就隐藏在队列中…</p><h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br><br>        <span class="hljs-built_in">func</span>(root,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(TreeNode* root,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; depth)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">//若没有空间</span><br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>()  &lt; depth + <span class="hljs-number">1</span>)<br>            res.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;&#125;);<br>        <br>        res[depth].<span class="hljs-built_in">push_back</span>(root-&gt;val);<span class="hljs-comment">//将自己存入结果数组中</span><br><br>        <span class="hljs-built_in">func</span>(root-&gt;left,depth+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">func</span>(root-&gt;right,depth+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>关键点在于对一个节点的左右孩子进行递归深入时，深度记得累加就行。该递归其实就是先序遍历。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代</tag>
      
      <tag>层序遍历</tag>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>103. 二叉树的锯齿形层序遍历</title>
    <link href="/2021/12/09/LeetCode/103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2021/12/09/LeetCode/103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">本题链接</a></p><h2 id="迭代-层序遍历"><a href="#迭代-层序遍历" class="headerlink" title="迭代+层序遍历"></a>迭代+层序遍历</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>        queue&lt;TreeNode*&gt; node_queue;<br>        <span class="hljs-keyword">bool</span> dirc = <span class="hljs-literal">true</span>;<br>        TreeNode* node;<br><br>        node_queue.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!node_queue.<span class="hljs-built_in">empty</span>())&#123;<br><br>            <span class="hljs-keyword">int</span> size = node_queue.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(size,<span class="hljs-number">0</span>)</span></span>;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; size;++i)&#123;<br><br>                node = node_queue.<span class="hljs-built_in">front</span>();node_queue.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//获得节点</span><br>                <br>                <span class="hljs-keyword">if</span>(node-&gt;left) node_queue.<span class="hljs-built_in">push</span>(node-&gt;left);<span class="hljs-comment">//存入左孩子</span><br>                <span class="hljs-keyword">if</span>(node-&gt;right) node_queue.<span class="hljs-built_in">push</span>(node-&gt;right);<span class="hljs-comment">//存入右孩子</span><br><br>                <span class="hljs-keyword">if</span>(dirc) tmp[i] = node-&gt;val;<span class="hljs-comment">//正向</span><br>                <span class="hljs-keyword">else</span> tmp[size<span class="hljs-number">-1</span>-i] = node-&gt;val;<span class="hljs-comment">//反向</span><br><br>            &#125;<br><br>            dirc = !dirc;<span class="hljs-comment">//方向反转</span><br>            res.<span class="hljs-built_in">push_back</span>(tmp);<span class="hljs-comment">//保存结果</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>跟普通的层序遍历一样，就是每次存入一个结果时需要反转方向。用层数的奇偶也能表示是否反转。以上的代码可以继续优化，没必要在每个节点都判断一次反转方向，因为反转方向的单位是每层的元素。</p><p><code>while</code>更改：（使用代码冗余来换取速度）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><br><span class="hljs-keyword">while</span>(!node_queue.<span class="hljs-built_in">empty</span>())&#123;<br><br>    <span class="hljs-keyword">int</span> size = node_queue.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(size,<span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-keyword">if</span>(dirc)&#123;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; size;++i)&#123;<br><br>            node = node_queue.<span class="hljs-built_in">front</span>();node_queue.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//获得节点</span><br>        <br>            <span class="hljs-keyword">if</span>(node-&gt;left) node_queue.<span class="hljs-built_in">push</span>(node-&gt;left);<span class="hljs-comment">//存入左孩子</span><br>            <span class="hljs-keyword">if</span>(node-&gt;right) node_queue.<span class="hljs-built_in">push</span>(node-&gt;right);<span class="hljs-comment">//存入右孩子</span><br><br>            tmp[i] = node-&gt;val;<span class="hljs-comment">//正向</span><br><br>        &#125;<br>        <br>    &#125;<span class="hljs-keyword">else</span>&#123;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; size;++i)&#123;<br><br>            node = node_queue.<span class="hljs-built_in">front</span>();node_queue.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//获得节点</span><br>        <br>            <span class="hljs-keyword">if</span>(node-&gt;left) node_queue.<span class="hljs-built_in">push</span>(node-&gt;left);<span class="hljs-comment">//存入左孩子</span><br>            <span class="hljs-keyword">if</span>(node-&gt;right) node_queue.<span class="hljs-built_in">push</span>(node-&gt;right);<span class="hljs-comment">//存入右孩子</span><br><br>            tmp[size<span class="hljs-number">-1</span>-i] = node-&gt;val;<span class="hljs-comment">//反向</span><br><br>        &#125;<br>    &#125;<br>    dirc = !dirc;<span class="hljs-comment">//方向反转</span><br>    res.<span class="hljs-built_in">push_back</span>(tmp);<span class="hljs-comment">//保存结果</span><br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代</tag>
      
      <tag>层序遍历</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>104. 二叉树的最大深度</title>
    <link href="/2021/12/09/LeetCode/104.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <url>/2021/12/09/LeetCode/104.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">本题链接</a></p><h2 id="递归-dfs"><a href="#递归-dfs" class="headerlink" title="递归+dfs"></a>递归+dfs</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>       <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left),<span class="hljs-built_in">maxDepth</span>(root-&gt;right));<br><br>       <span class="hljs-comment">//return root ? 1 + max(maxDepth(root-&gt;left),maxDepth(root-&gt;right)) : 0;</span><br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在递归函数里取左右子树的最大深度并加上自己</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1047. 删除字符串中的所有相邻重复项</title>
    <link href="/2021/12/09/LeetCode/1047.%20%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <url>/2021/12/09/LeetCode/1047.%20%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">本题链接</a></p><h2 id="使用栈"><a href="#使用栈" class="headerlink" title="使用栈"></a>使用栈</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> s;<br>        string res;<br><br>        stack&lt;<span class="hljs-keyword">char</span>&gt; c_stack;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>() ; ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>( !c_stack.<span class="hljs-built_in">empty</span>() &amp;&amp; c_stack.<span class="hljs-built_in">top</span>() == s[i]) c_stack.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">else</span> c_stack.<span class="hljs-built_in">push</span>(s[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(!c_stack.<span class="hljs-built_in">empty</span>())&#123;<br><br>            res.<span class="hljs-built_in">insert</span>(res.<span class="hljs-built_in">begin</span>(),c_stack.<span class="hljs-built_in">top</span>());<br>            c_stack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="模拟栈"><a href="#模拟栈" class="headerlink" title="模拟栈"></a>模拟栈</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> s;<br>        <br>        <span class="hljs-keyword">int</span> stack_top = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> len = s.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">while</span>(len--)&#123;<br><br>           <span class="hljs-keyword">if</span>(stack_top != <span class="hljs-number">-1</span> &amp;&amp; s[stack_top] == s[stack_top+<span class="hljs-number">1</span>]) <br>           &#123;<br>                s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>() + stack_top,s.<span class="hljs-built_in">begin</span>() + stack_top + <span class="hljs-number">2</span>);<br>                --stack_top;<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               ++stack_top;<br>           &#125;<br>           <br>        <br>        &#125;<br>       <br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="模拟栈-就地算法"><a href="#模拟栈-就地算法" class="headerlink" title="模拟栈+就地算法"></a>模拟栈+就地算法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> s;<br>        <br>        <span class="hljs-keyword">int</span> stack_top = <span class="hljs-number">-1</span>;<span class="hljs-comment">//模拟栈顶</span><br>        <span class="hljs-keyword">int</span> org = <span class="hljs-number">0</span>;<span class="hljs-comment">//原字符串指针</span><br><br>        <span class="hljs-comment">//遍历每一个字符</span><br>        <span class="hljs-keyword">while</span>(org &lt; s.<span class="hljs-built_in">size</span>())&#123;<br><br>           <span class="hljs-keyword">if</span>(stack_top != <span class="hljs-number">-1</span> &amp;&amp; s[stack_top] == s[org])<span class="hljs-comment">//如果相等,模拟退出栈元素</span><br>           &#123;<br>                --stack_top;<br>                ++org;<br><br>           &#125;<span class="hljs-keyword">else</span>&#123;<br><br>               s[++stack_top] = s[org++];<span class="hljs-comment">//模拟元素入栈</span><br>           &#125;<br>           <br>        &#125;<br>        s.<span class="hljs-built_in">resize</span>(stack_top+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用就地算法，配合双指针，在原来的字符串上操作。栈底为字符串的begin()的前一位，栈顶指向的就是当前判断元素的上一个。</p><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>字符串或是数组类型的都可以使用就地算法来避免大量的移动开销。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>就地算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>105. 从前序与中序遍历序列构造二叉树</title>
    <link href="/2021/12/09/LeetCode/105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2021/12/09/LeetCode/105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">本题链接</a></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">int</span> p_index = <span class="hljs-number">0</span>;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;<br><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>();<br><br>        <span class="hljs-comment">//此刻preorder的第一个元素为inorder中代表根节点的元素</span><br>        <span class="hljs-built_in">addNode</span>(preorder,inorder,<span class="hljs-number">0</span>,inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>,root);<br><br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br>    <span class="hljs-comment">//进入该函数的节点都视作子树的根节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder,vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; lo,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; hi,TreeNode* root)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(p_index == preorder.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//在inorder的[lo,hi]中找到preorder[p_index]</span><br>        <span class="hljs-keyword">int</span> index = <span class="hljs-built_in">getElemIndexInVec</span>(preorder[p_index],inorder,lo,hi);<br>        root-&gt;val = preorder[p_index++];<span class="hljs-comment">//给根节点赋值</span><br>        <span class="hljs-comment">//递归进入左子树</span><br>        <span class="hljs-keyword">if</span>(lo &lt; index)&#123;<br>            TreeNode* left_child = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>();<br>            root-&gt;left = left_child;<br>            <span class="hljs-built_in">addNode</span>(preorder,inorder,lo,index - <span class="hljs-number">1</span>,left_child);<br>        &#125;<br>        <span class="hljs-comment">//递归进入右子树</span><br>        <span class="hljs-keyword">if</span>(index &lt; hi)&#123;<br>            TreeNode* right_child = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>();<br>            root-&gt;right = right_child;<br>            <span class="hljs-built_in">addNode</span>(preorder,inorder,index + <span class="hljs-number">1</span>,hi,right_child);<br>        &#125; <br>    &#125;<br><br>    <span class="hljs-comment">//返回vector中elem的索引</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getElemIndexInVec</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; elem,vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; vec,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; lo,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; hi)</span> <span class="hljs-keyword">const</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = lo;i &lt;= hi;++i)<br>            <span class="hljs-keyword">if</span>(vec[i] == elem) <span class="hljs-keyword">return</span> i;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据二叉树的前序与中序遍历的序列可知，每个时刻前序遍历的当前元素都是中序遍历序列中某个子树的根节点。使用递归可以很直观的反应思路，但是每次都要在中序遍历序列中找子树根节点，该操作($O(n)$)会造成很大的开销</p><h2 id="递归-哈希表"><a href="#递归-哈希表" class="headerlink" title="递归+哈希表"></a>递归+哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">int</span> p_index = <span class="hljs-number">0</span>;<br>    unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; hash;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;<br><br>        <span class="hljs-comment">//构造hash表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; inorder.<span class="hljs-built_in">size</span>();++i)<br>            hash[inorder[i]] = i;<br>        <br><br>        <span class="hljs-comment">//此刻preorder的第一个元素为inorder中代表根节点的元素</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">addNode</span>(preorder,<span class="hljs-number">0</span>,inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//进入该函数的节点都视作子树的根节点</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">addNode</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; lo,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; hi)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(lo &gt; hi) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">//在inorder的[lo,hi]中找到preorder[p_index]</span><br>        <span class="hljs-keyword">int</span> index = hash[preorder[p_index]];<br><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[p_index++]);<br><br>        root-&gt;left = <span class="hljs-built_in">addNode</span>(preorder,lo,index - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">addNode</span>(preorder,index + <span class="hljs-number">1</span>,hi);<br>   <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>同第一个递归的思路一致，然后使用哈希表加速中序遍历序列元素下标的查找。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>107. 二叉树的层序遍历 II</title>
    <link href="/2021/12/09/LeetCode/107.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%20II/"/>
    <url>/2021/12/09/LeetCode/107.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%20II/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">本题链接</a></p><h2 id="递归版1-数组反转"><a href="#递归版1-数组反转" class="headerlink" title="递归版1+数组反转"></a>递归版1+数组反转</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrderBottom</span>(TreeNode* root) &#123;<br><br>        <span class="hljs-built_in">func</span>(root,<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//反转结果</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = res.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-built_in">swap</span>(res[left++],res[right--]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(TreeNode* root,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; depth)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">//若没有空间</span><br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>()  &lt; depth + <span class="hljs-number">1</span>)<br>            res.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;&#125;);<br>        <br>        res[depth].<span class="hljs-built_in">push_back</span>(root-&gt;val);<span class="hljs-comment">//将自己存入结果数组中</span><br><br>        <span class="hljs-built_in">func</span>(root-&gt;left,depth+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">func</span>(root-&gt;right,depth+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和&lt;&lt;<strong>102. 二叉树的层序遍历</strong>&gt;&gt;的思路一样，最后在返回结果的时候反转一下结果数组就行了…</p><h2 id="递归版2"><a href="#递归版2" class="headerlink" title="递归版2"></a>递归版2</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res&#123;vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;&#125;&#125;;<br>    <br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrderBottom</span>(TreeNode* root) &#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>&#123;&#125;;<br><br>        <span class="hljs-built_in">func</span>(root,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(TreeNode* root,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; depth)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">//若没有空间</span><br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>()  &lt; depth + <span class="hljs-number">1</span>)<br>            res.<span class="hljs-built_in">insert</span>(res.<span class="hljs-built_in">begin</span>(),vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;&#125;);<br><br>        <span class="hljs-built_in">func</span>(root-&gt;left,depth+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">func</span>(root-&gt;right,depth+<span class="hljs-number">1</span>);<br><br>        res[(res.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>) - depth].<span class="hljs-built_in">push_back</span>(root-&gt;val);<span class="hljs-comment">//将自己存入结果数组中</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>和&lt;&lt;<strong>102. 二叉树的层序遍历</strong>&gt;&gt;的思路一样，不过此时视作后序遍历。但是很耗时，原因在于在递归中对<code>res</code>的插入操作。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>层序遍历</tag>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>108. 将有序数组转换为二叉搜索树</title>
    <link href="/2021/12/09/LeetCode/108.%20%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2021/12/09/LeetCode/108.%20%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">本题链接</a></p><h2 id="递归-中序遍历"><a href="#递归-中序遍历" class="headerlink" title="递归+中序遍历"></a>递归+中序遍历</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">addNodeByInOrder</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">addNodeByInOrder</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; lo,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; hi)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(lo &gt; hi) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//如果到达边界</span><br><br>        <span class="hljs-comment">//每次取[lo,hi]的中点</span><br>        <span class="hljs-keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="hljs-number">1</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br><br>        root-&gt;left = <span class="hljs-built_in">addNodeByInOrder</span>(nums,lo,mid<span class="hljs-number">-1</span>);<span class="hljs-comment">//添加左孩子</span><br>        root-&gt;right = <span class="hljs-built_in">addNodeByInOrder</span>(nums,mid+<span class="hljs-number">1</span>,hi);<span class="hljs-comment">//添加右孩子</span><br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>其实中序遍历序列就是对树的投影，题目给的数组不仅有序，且要求的是高度平衡的二叉树。所以取子树根节点的时候，尽量让这个节点左右两侧的节点数量相等，以满足高度平衡二叉树的要求。所以根节点应该在一段连续的左闭右闭区间内选择中点，让左侧的元素作为左子树，让右侧的元素作为右子树。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
      <tag>中序遍历</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11. 盛最多水的容器</title>
    <link href="/2021/12/09/LeetCode/11.%20%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <url>/2021/12/09/LeetCode/11.%20%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/container-with-most-water/">本题链接</a></p><h2 id="暴力-双指针（超时）"><a href="#暴力-双指针（超时）" class="headerlink" title="暴力+双指针（超时）"></a>暴力+双指针（超时）</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; height)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>,hi = <span class="hljs-number">0</span>,res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(; lo &lt; height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; lo++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(hi = lo + <span class="hljs-number">1</span>;hi &lt; height.<span class="hljs-built_in">size</span>();hi++)<br>            &#123;<br>                res = <span class="hljs-built_in">max</span>( res , <span class="hljs-built_in">min</span>( height[lo] , height[hi] )*(hi - lo) );<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="贪心-双指针"><a href="#贪心-双指针" class="headerlink" title="贪心+双指针"></a>贪心+双指针</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; height)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>,hi = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>,res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(lo &lt; hi)&#123;<br><br>            res = <span class="hljs-built_in">max</span>( res , <span class="hljs-built_in">min</span>( height[lo] , height[hi] )*(hi - lo) );<br>            <span class="hljs-keyword">if</span>(height[lo] &gt; height[hi]) --hi;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(height[lo] == height[hi]) height[lo+<span class="hljs-number">1</span>] &gt; height[hi<span class="hljs-number">-1</span>] ? ++lo : --hi;<br>            <span class="hljs-keyword">else</span> ++lo;            <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>前后两个指针分别从头尾开始。既然往中间靠拢，那么就要求两根柱子尽量大，使面积尽可能的大。那么每次迭代的时候就需要舍弃当前两根柱子中最小的那个。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>双指针</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>110. 平衡二叉树</title>
    <link href="/2021/12/09/LeetCode/110.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2021/12/09/LeetCode/110.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">本题链接</a></p><h2 id="递归版1"><a href="#递归版1" class="headerlink" title="递归版1"></a>递归版1</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">bool</span> res = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">dfs</span>(root,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root,<span class="hljs-keyword">bool</span>&amp; res)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">int</span> left_height = <span class="hljs-built_in">dfs</span>(root-&gt;left,res);<br>        <span class="hljs-keyword">int</span> right_height = <span class="hljs-built_in">dfs</span>(root-&gt;right,res);<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(left_height - right_height) &gt; <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//计算本节点是否平衡</span><br>            res = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(left_height,right_height);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于平衡二叉树的要求是对于树中的每个子树都是平衡的，所以只要其中一个子树不是平衡，就将结果设置为false。不过该方法可以优化，因为当res=false时，实际上已经没必要再去核对其他子树是否平衡了。</p><h2 id="递归版2-优化"><a href="#递归版2-优化" class="headerlink" title="递归版2(优化)"></a>递归版2(优化)</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">bool</span> res = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!res || !root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//此处判断res</span><br><br>        <span class="hljs-keyword">int</span> left_height = <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-keyword">int</span> right_height = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br><br>        <span class="hljs-keyword">if</span>(res &amp;&amp; <span class="hljs-built_in">abs</span>(left_height - right_height) &gt; <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//此处判断res</span><br>            res = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(left_height,right_height);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>对于递归版1，新增了在两个地方判断res，以避免不必要的开销。并且将res设置为类成员变量。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>111. 二叉树的最小深度</title>
    <link href="/2021/12/09/LeetCode/111.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
    <url>/2021/12/09/LeetCode/111.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">本题链接</a></p><h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">int</span> res  = <span class="hljs-number">-1</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root,<span class="hljs-keyword">int</span> depth = <span class="hljs-number">1</span>)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">if</span>((<span class="hljs-built_in">minDepth</span>(root-&gt;left,depth + <span class="hljs-number">1</span>) + <span class="hljs-built_in">minDepth</span>(root-&gt;right,depth + <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>)<span class="hljs-comment">//到达叶子节点</span><br>            <span class="hljs-comment">//这里的判断是为了避免树退化成单链表的情况出现错误</span><br>            res = res == <span class="hljs-number">-1</span> ? depth : <span class="hljs-built_in">min</span>(depth,res);<br><br>        <span class="hljs-comment">//其实这个返回值只对第一个函数有意义</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对结果的赋值操作出现在叶子节点，所以只要在叶子节点进行判断即可。</p><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>…</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">int</span> res  = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root,<span class="hljs-keyword">int</span> depth = <span class="hljs-number">1</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> root?((<span class="hljs-built_in">minDepth</span>(root-&gt;left,depth+<span class="hljs-number">1</span>)+<span class="hljs-built_in">minDepth</span>(root-&gt;right,depth+<span class="hljs-number">1</span>))==<span class="hljs-number">0</span>?res=(res==<span class="hljs-number">0</span>?depth:<span class="hljs-built_in">min</span>(depth,res)):res):<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1110. 删点成林</title>
    <link href="/2021/12/09/LeetCode/1110.%20%E5%88%A0%E7%82%B9%E6%88%90%E6%9E%97/"/>
    <url>/2021/12/09/LeetCode/1110.%20%E5%88%A0%E7%82%B9%E6%88%90%E6%9E%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/delete-nodes-and-return-forest/">本题链接</a></p><h2 id="迭代-哈希表"><a href="#迭代-哈希表" class="headerlink" title="迭代+哈希表"></a>迭代+哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">delNodes</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; to_delete)</span> </span>&#123;<br>        <br>        vector&lt;TreeNode*&gt; res;<span class="hljs-comment">//结果</span><br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">delete_set</span><span class="hljs-params">(to_delete.begin(),to_delete.end())</span></span>;<span class="hljs-comment">//要被删除的节点</span><br>        unordered_set&lt;TreeNode*&gt; unqinue_set;<span class="hljs-comment">//放入该哈希表的节点都不能作为根节点</span><br><br>        queue&lt;TreeNode*&gt; node_queue;<br>        TreeNode* cur_node;<br><br>        node_queue.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!node_queue.<span class="hljs-built_in">empty</span>())&#123;<br><br>            cur_node = node_queue.<span class="hljs-built_in">front</span>();node_queue.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">bool</span> self = delete_set.<span class="hljs-built_in">find</span>(cur_node-&gt;val) == delete_set.<span class="hljs-built_in">end</span>();<span class="hljs-comment">//自己是否被删除</span><br>            <br>            <span class="hljs-comment">//如果自己不会被删除,并且自己不属于其他节点</span><br>            <span class="hljs-keyword">if</span>(self &amp;&amp; unqinue_set.<span class="hljs-built_in">find</span>(cur_node) == unqinue_set.<span class="hljs-built_in">end</span>()) res.<span class="hljs-built_in">push_back</span>(cur_node);<br>            <br>            <span class="hljs-keyword">if</span>(cur_node-&gt;left)&#123;<span class="hljs-comment">//如果存在左孩子</span><br>                node_queue.<span class="hljs-built_in">push</span>(cur_node-&gt;left);<span class="hljs-comment">//将左孩子入队</span><br>                <span class="hljs-comment">//如果自己不用被删除,那么左孩子不能作为树的根节点</span><br>                <span class="hljs-keyword">if</span>(self) unqinue_set.<span class="hljs-built_in">insert</span>(cur_node-&gt;left);<br>                <span class="hljs-comment">//如果左孩子是被删除的节点,那么就把自己左孩子的引用删除掉</span><br>                <span class="hljs-keyword">if</span>(delete_set.<span class="hljs-built_in">find</span>(cur_node-&gt;left-&gt;val) != delete_set.<span class="hljs-built_in">end</span>()) cur_node-&gt;left = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(cur_node-&gt;right)&#123;<span class="hljs-comment">//如果存在右孩子</span><br>                node_queue.<span class="hljs-built_in">push</span>(cur_node-&gt;right);<span class="hljs-comment">//将右孩子入队</span><br>                <span class="hljs-comment">//如果自己不用被删除,那么右孩子不能作为树的根节点</span><br>                <span class="hljs-keyword">if</span>(self) unqinue_set.<span class="hljs-built_in">insert</span>(cur_node-&gt;right);<br>                <span class="hljs-comment">//如果右孩子是被删除的节点,那么就把自己右孩子的引用删除掉</span><br>                <span class="hljs-keyword">if</span>(delete_set.<span class="hljs-built_in">find</span>(cur_node-&gt;right-&gt;val) != delete_set.<span class="hljs-built_in">end</span>()) cur_node-&gt;right = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>节点的删除，因为有对左右孩子引用的存在，且是单向的，所以有两种情况：</p><ol><li>自己将会被删除。那么只要将左右孩子入队参加节点遍历即可。</li><li>若自己不会被删除，说明自己将成为一棵树的根节点。<ul><li>若左右孩子会被删除，那么先将自己的左右孩子入队参加节点遍历，以防止之后的节点丢失。然后再将自己对删除节点的引用设置为<code>nullptr</code></li><li>若左右孩子不会被删除，不仅要将自己的左右孩子入队参加节点遍历，而且还要防止自己的左右孩子作为一棵树的根节点</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>迭代</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>112. 路径总和</title>
    <link href="/2021/12/09/LeetCode/112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <url>/2021/12/09/LeetCode/112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/path-sum/">本题链接</a></p><h2 id="递归-dfs"><a href="#递归-dfs" class="headerlink" title="递归+dfs"></a>递归+dfs</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; targetSum)</span> </span>&#123;<br><br>        <span class="hljs-comment">//出现在节点只有一个孩子的向下递归情况</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">//出现在叶子节点</span><br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;<br>            <span class="hljs-keyword">if</span>(targetSum == root-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasPathSum</span>(root-&gt;left,targetSum - root-&gt;val)||<span class="hljs-built_in">hasPathSum</span>(root-&gt;right,targetSum - root-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于题目要求是从根节点到叶子节点，所以只有当递归函数进入到叶子节点时才能知道是否满足结果。还有就是对于任何一个节点来说，只要它的左右孩子中有一个满足条件，那么这个节点就是满足条件的。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>113. 路径总和 II</title>
    <link href="/2021/12/09/LeetCode/113.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20II/"/>
    <url>/2021/12/09/LeetCode/113.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20II/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/path-sum-ii/">本题链接</a></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-keyword">int</span> targetSum) &#123;<br>        <span class="hljs-built_in">hasPathSum</span>(root,targetSum);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;   <br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; targetSum)</span> </span>&#123;<br><br>        <span class="hljs-comment">//出现在节点只有一个孩子的向下递归情况</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <br>        tmp.<span class="hljs-built_in">push_back</span>(root-&gt;val);<span class="hljs-comment">//保存自己的值</span><br><br>        <span class="hljs-comment">//出现在叶子节点</span><br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;<br>            <span class="hljs-keyword">if</span>(targetSum == root-&gt;val) res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">hasPathSum</span>(root-&gt;left,targetSum - root-&gt;val);<br>            <span class="hljs-built_in">hasPathSum</span>(root-&gt;right,targetSum - root-&gt;val);  <br>        &#125;<br>        <br>        tmp.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//返回上一个函数时拿出自己的值</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题思路与&lt;&lt;<strong>112. 路径总和</strong>&gt;&gt;一致。特别注意的是递归到当前时刻的条件不可被改变，所以加了个<strong>const</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>119. 杨辉三角 II</title>
    <link href="/2021/12/09/LeetCode/119.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%20II/"/>
    <url>/2021/12/09/LeetCode/119.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%20II/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/">本题链接</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getRow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rowIndex)</span> </span>&#123;<br><br>        map&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;,<span class="hljs-keyword">int</span>&gt; dp;<br>        dp[&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;] = <span class="hljs-number">1</span>;<br>        dp[&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;] = <span class="hljs-number">1</span>;<br>        dp[&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> row = <span class="hljs-number">2</span>;row &lt;= rowIndex;++row)&#123;<br>            dp[&#123;row,<span class="hljs-number">0</span>&#125;] = <span class="hljs-number">1</span>;<span class="hljs-comment">//左边的1</span><br>            dp[&#123;row,row&#125;] = <span class="hljs-number">1</span>;<span class="hljs-comment">//右边的1</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> col = <span class="hljs-number">1</span>;col &lt; row;++col)&#123;<br>                dp[&#123;row,col&#125;] = dp[&#123;row - <span class="hljs-number">1</span>,col&#125;] + dp[&#123;row - <span class="hljs-number">1</span>,col - <span class="hljs-number">1</span>&#125;];<br>                <br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//结果</span><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= rowIndex;++i)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(dp[&#123;rowIndex,i&#125;]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据杨辉三角的规律可得状态转移方程：</p><script type="math/tex; mode=display">dp[r][c]=dp[r-1][c-1]+dp[r-1][c]</script><p>其中，r为当前行，c为当前行的元素下标，$dp[r][c]$为当前元素的值。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>122. 买卖股票的最佳时机 II</title>
    <link href="/2021/12/09/LeetCode/122.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II/"/>
    <url>/2021/12/09/LeetCode/122.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">本题链接</a></p><h1 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a>122. 买卖股票的最佳时机 II</h1><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(prices.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(prices[i+<span class="hljs-number">1</span>]&gt;prices[i])&#123;<br>                max += ( prices[i+<span class="hljs-number">1</span>] - prices[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>思路：这题过于简单，有点像脑筋急转弯。如果在能当天买入及卖出的情况下，那么根据贪心策略，只要第二天的价格大于前一天的价格就把差价累计即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>贪心</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>128. 最长连续序列</title>
    <link href="/2021/12/09/LeetCode/128.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
    <url>/2021/12/09/LeetCode/128.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">本题链接</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        unordered_set&lt;<span class="hljs-keyword">int</span>&gt; us;<br>        <span class="hljs-comment">//将数字存入哈希表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)<br>            us.<span class="hljs-built_in">insert</span>(nums[i]);<br>        <br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!us.<span class="hljs-built_in">empty</span>())&#123;<br><br>            <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//往前找</span><br>            <span class="hljs-keyword">int</span> cur = *(us.<span class="hljs-built_in">begin</span>());<br>            <span class="hljs-keyword">while</span>(us.<span class="hljs-built_in">find</span>(++cur) != us.<span class="hljs-built_in">end</span>())&#123;<br>                ++count;<br>                us.<span class="hljs-built_in">erase</span>(cur);<br>            &#125;<br>            <span class="hljs-comment">//往后找</span><br>            cur = *(us.<span class="hljs-built_in">begin</span>());<br>            <span class="hljs-keyword">while</span>(us.<span class="hljs-built_in">find</span>(--cur) != us.<span class="hljs-built_in">end</span>())&#123;<br>                ++count;<br>                us.<span class="hljs-built_in">erase</span>(cur);<br>            &#125;<br><br>            us.<span class="hljs-built_in">erase</span>(*(us.<span class="hljs-built_in">begin</span>()));<span class="hljs-comment">//删除自己</span><br>            res = <span class="hljs-built_in">max</span>(res,count);<span class="hljs-comment">//取最大值</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先将数组的值放入哈希表中，然后每次取出哈希表的第一个值，在哈希表中找这个值的之前和之后的数累计数量即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>130. 被围绕的区域</title>
    <link href="/2021/12/09/LeetCode/130.%20%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/"/>
    <url>/2021/12/09/LeetCode/130.%20%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/surrounded-regions/">本题链接</a></p><h2 id="BFS-递归"><a href="#BFS-递归" class="headerlink" title="BFS+递归"></a>BFS+递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> sint;<br>    <span class="hljs-keyword">typedef</span> pair&lt;sint,sint&gt; point;<br>    sint row,col,head,tail,last;<br>    sint dirc[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<span class="hljs-comment">//上 右 下 左</span><br>    vector&lt;point&gt; state_vec;<br>    point new_p;<br>    <span class="hljs-keyword">bool</span> is_touch_J = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br><br>        row = board.<span class="hljs-built_in">size</span>();<br>        col = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); <br>        <br>        <span class="hljs-comment">//异常情况</span><br>        <span class="hljs-keyword">if</span>(row &lt;= <span class="hljs-number">2</span> || col &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-built_in">init</span>(board);<span class="hljs-comment">//O状态:O:空闲 B:待办 J:倒霉</span><br>     <br>        <span class="hljs-keyword">for</span>(sint r = <span class="hljs-number">1</span>;r &lt; row;++r)<br>            <span class="hljs-keyword">for</span>(sint c = <span class="hljs-number">1</span>;c &lt; col;++c)<br>                <span class="hljs-keyword">if</span>(board[r][c] == <span class="hljs-string">&#x27;O&#x27;</span>)&#123;<span class="hljs-built_in">setB</span>(&#123;r,c&#125;,board);<span class="hljs-built_in">bfs</span>(&#123;r,c&#125;,board);<span class="hljs-built_in">isTouchJ</span>(board);<span class="hljs-built_in">setStateVec</span>();&#125;<br>            <br>        <span class="hljs-built_in">draw</span>(board);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStateVec</span><span class="hljs-params">()</span></span>&#123;<br>        last = head = tail = state_vec.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> ;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isTouchJ</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span></span>&#123;<br><br>         <span class="hljs-keyword">if</span>(is_touch_J)&#123;<br>            <span class="hljs-keyword">for</span>(sint i = state_vec.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i &gt; last;--i)<br>                board[state_vec[i].first][state_vec[i].second] = <span class="hljs-string">&#x27;J&#x27;</span>; <br>            is_touch_J = <span class="hljs-literal">false</span>;<br>         &#125;<br>                 <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span></span>&#123;<span class="hljs-comment">//重新还原</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = state_vec.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span> ;--i)&#123;<br>            board[state_vec[i].first][state_vec[i].second] = board[state_vec[i].first][state_vec[i].second] == <span class="hljs-string">&#x27;J&#x27;</span>?<span class="hljs-string">&#x27;O&#x27;</span>:<span class="hljs-string">&#x27;X&#x27;</span>;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setB</span><span class="hljs-params">(<span class="hljs-keyword">const</span> point&amp; p,vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span></span>&#123;<br>        board[p.first][p.second] = <span class="hljs-string">&#x27;B&#x27;</span>;<span class="hljs-comment">//设置该点状态</span><br>        state_vec.<span class="hljs-built_in">push_back</span>(p);<span class="hljs-comment">//保存该点状态</span><br>        ++tail;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> point&amp; p,vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span></span>&#123;<br><br>        <span class="hljs-comment">//对四个方向遍历</span><br>        <span class="hljs-keyword">for</span>(sint d = <span class="hljs-number">0</span>;d &lt; <span class="hljs-number">4</span>;++d)&#123;<br><br>            new_p.first = p.first + dirc[d];<br>            new_p.second = p.second + dirc[d+<span class="hljs-number">1</span>];<br><br>            <span class="hljs-keyword">if</span>(board[new_p.first][new_p.second] != <span class="hljs-string">&#x27;O&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(board[new_p.first][new_p.second] == <span class="hljs-string">&#x27;J&#x27;</span>) is_touch_J = <span class="hljs-literal">true</span>;<span class="hljs-comment">//如果碰到倒霉蛋</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">setB</span>(new_p,board);<br><br>        &#125;<br><br>        <span class="hljs-comment">//广度优先搜索完之后</span><br>        <span class="hljs-keyword">while</span>(++head &lt; state_vec.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-built_in">bfs</span>(&#123;state_vec[head].first,state_vec[head].second&#125;,board);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span></span>&#123;<br><br>        <span class="hljs-comment">//预处理:设置所有边界的O为&quot;倒霉&quot;</span><br>        <span class="hljs-keyword">for</span>(sint i = <span class="hljs-number">0</span>,tmp_row = row - <span class="hljs-number">1</span>;i &lt; col; ++i)&#123;<span class="hljs-comment">//行</span><br>            <span class="hljs-keyword">if</span>(board[<span class="hljs-number">0</span>][i] == <span class="hljs-string">&#x27;O&#x27;</span>)&#123;<br>                state_vec.<span class="hljs-built_in">push_back</span>(point&#123;<span class="hljs-number">0</span>,i&#125;);<br>                board[<span class="hljs-number">0</span>][i] = <span class="hljs-string">&#x27;J&#x27;</span>;<br>            &#125; <br>            <span class="hljs-keyword">if</span>(board[tmp_row][i] == <span class="hljs-string">&#x27;O&#x27;</span>)&#123;<br>                state_vec.<span class="hljs-built_in">push_back</span>(point&#123;tmp_row,i&#125;);<br>                board[tmp_row][i] = <span class="hljs-string">&#x27;J&#x27;</span>;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">for</span>(sint i = <span class="hljs-number">0</span>,tmp_col = col - <span class="hljs-number">1</span>;i &lt; row; ++i)&#123;<span class="hljs-comment">//列</span><br>            <span class="hljs-keyword">if</span>(board[i][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span>)&#123;<br>                state_vec.<span class="hljs-built_in">push_back</span>(point&#123;i,<span class="hljs-number">0</span>&#125;);<br>                board[i][<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;J&#x27;</span>;<br>            &#125; <br>            <span class="hljs-keyword">if</span>(board[i][tmp_col] == <span class="hljs-string">&#x27;O&#x27;</span>)&#123;<br>                state_vec.<span class="hljs-built_in">push_back</span>(point&#123;i,tmp_col&#125;);<br>                board[i][tmp_col] = <span class="hljs-string">&#x27;J&#x27;</span>;<br>            &#125; <br>        &#125;<br><br>        <span class="hljs-built_in">setStateVec</span>();<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将原数组的O设置成三种状态：</p><ul><li>‘O’：没有遍历过的O</li><li>‘B’：遍历过的O</li><li>‘J’：失效的O</li></ul><p>在对一个状态为’O’的O进行广度优先搜索后，只要在过程中碰到一个’J’，那么此次广度优先搜索所涉及的所有O都设置为失效。那么当对所有的点都进行了BFS后，数组中状态为’O’的元素就是被围绕的O。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>广度优先搜索</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1334. 阈值距离内邻居最少的城市</title>
    <link href="/2021/12/09/LeetCode/1334.%20%E9%98%88%E5%80%BC%E8%B7%9D%E7%A6%BB%E5%86%85%E9%82%BB%E5%B1%85%E6%9C%80%E5%B0%91%E7%9A%84%E5%9F%8E%E5%B8%82/"/>
    <url>/2021/12/09/LeetCode/1334.%20%E9%98%88%E5%80%BC%E8%B7%9D%E7%A6%BB%E5%86%85%E9%82%BB%E5%B1%85%E6%9C%80%E5%B0%91%E7%9A%84%E5%9F%8E%E5%B8%82/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/">本题链接</a></p><h2 id="最短路Floyd算法"><a href="#最短路Floyd算法" class="headerlink" title="最短路Floyd算法"></a>最短路Floyd算法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> src 0 <span class="hljs-comment">//源节点</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> tar 1 <span class="hljs-comment">//指向的节点</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dist 2 <span class="hljs-comment">//两个节点之间的距离</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTheCity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; edges, <span class="hljs-keyword">int</span> distanceThreshold)</span> </span>&#123;<br><br>        <span class="hljs-comment">//Floyd算法</span><br>        <span class="hljs-comment">//中转节点表path 初始化时将所有节点的中转节点设置为-1,因为数组的下标不可能为-1</span><br>        <span class="hljs-comment">//vector&lt;vector&lt;int&gt;&gt; path(n,vector&lt;int&gt;(n,-1));</span><br>        <span class="hljs-comment">//最短路径表A 初始化时将所有节点之间的距离设置为无穷大</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">A</span>(n,vector&lt;<span class="hljs-keyword">int</span>&gt;(n,INT_MAX));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; info : edges)&#123;<br>            <span class="hljs-comment">//设置连通节点之间的距离 (无向图) 若是有向图只需设置一个</span><br>            A[info[src]][info[tar]] = info[dist];<br>            A[info[tar]][info[src]] = info[dist];<br>        &#125;<br>        <span class="hljs-comment">//将自己到自己的距离设置为0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; A.<span class="hljs-built_in">size</span>();++i)&#123;<br>            A[i][i] = <span class="hljs-number">0</span>;<br>        &#125;   <br><br><br>        <span class="hljs-comment">//Floyd算法主流程</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;t &lt; n;++t)&#123;<span class="hljs-comment">//逐次的将每个节点当成中转点 </span><br>            <span class="hljs-comment">//对A表中的每个点进行遍历</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;row &lt; n;++row)&#123;<span class="hljs-comment">//逐行 row行表示点A</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>;col &lt; n;++col)&#123;<span class="hljs-comment">//逐列 col列表示点B</span><br>                    <span class="hljs-keyword">if</span>(A[row][t] == INT_MAX || A[t][col] == INT_MAX) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-comment">//如果点A经过中转点到点B的距离比点A直接到点B还小</span><br>                    <span class="hljs-keyword">if</span>(A[row][t] + A[t][col] &lt; A[row][col])&#123;<span class="hljs-comment">//(A[row][t] == INT_MAX || A[t][col] == INT_MAX) || </span><br>                        A[row][col] = A[row][t] + A[t][col];<span class="hljs-comment">//更新最小的距离</span><br>                        <span class="hljs-comment">//path[row][col] = t;//并更新点A到B的中转点</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">//以下为题目要求</span><br><br>        <span class="hljs-comment">//遍历A表 保存所有点A到点B的距离小于等于阈值</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">res</span>(n,vector&lt;<span class="hljs-keyword">int</span>&gt;());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;row &lt; n;++row)&#123;<span class="hljs-comment">//逐行 row行表示点A</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>;col &lt; n;++col)&#123;<span class="hljs-comment">//逐列 col列表示点B</span><br>                <span class="hljs-keyword">if</span>(A[row][col] &lt;= distanceThreshold)&#123;<br>                    res[row].<span class="hljs-built_in">emplace_back</span>(col);<span class="hljs-comment">//加入结果</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//找到最少城市的最小点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; res.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">if</span>(res[i].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(res[i].<span class="hljs-built_in">size</span>() &lt; res[ret].<span class="hljs-built_in">size</span>())&#123;<span class="hljs-comment">//优先考虑城市数量,城市数量小的优先</span><br>                ret = i;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res[i].<span class="hljs-built_in">size</span>() == res[ret].<span class="hljs-built_in">size</span>())&#123;<span class="hljs-comment">//城市数量相等时</span><br>                ret = i &gt; ret ? i : ret ;<span class="hljs-comment">//编号最大的优先</span><br>            &#125;<br>        &#125;<br>       <br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用最短路Floyd算法</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图</tag>
      
      <tag>最短路Floyd算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1337. 矩阵中战斗力最弱的 K 行</title>
    <link href="/2021/12/09/LeetCode/1337.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%88%98%E6%96%97%E5%8A%9B%E6%9C%80%E5%BC%B1%E7%9A%84%20K%20%E8%A1%8C/"/>
    <url>/2021/12/09/LeetCode/1337.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%88%98%E6%96%97%E5%8A%9B%E6%9C%80%E5%BC%B1%E7%9A%84%20K%20%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/">本题链接</a></p><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">kWeakestRows</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; mat, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(k,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">auto</span> cmp = [](pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&amp; a,pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&amp; b)&#123;<br>            <span class="hljs-keyword">if</span>(a.second == b.second) <span class="hljs-keyword">return</span> a.first &gt; b.first;<br>            <span class="hljs-keyword">return</span> a.second &gt; b.second;&#125;;<br>        priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;,<span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">p_q</span>(cmp);<span class="hljs-comment">//优先级队列:小顶</span><br><br>        <span class="hljs-comment">//计算每行的战斗力</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;r &lt; mat.<span class="hljs-built_in">size</span>();++r)&#123;<br>            <br>            <span class="hljs-keyword">int</span> atta = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;c &lt; mat[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();++c)&#123;<br>                <span class="hljs-keyword">if</span>(mat[r][c] == <span class="hljs-number">1</span>) ++atta;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            &#125;<br>            p_q.<span class="hljs-built_in">push</span>(&#123;r,atta&#125;);<span class="hljs-comment">//按照战斗力优先,行号次之的顺序放入到小顶堆</span><br>        &#125;<br><br>        <span class="hljs-comment">//从小顶堆中取出前K个</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; k;++i)&#123;<br>            res[i] = ((pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;)p_q.<span class="hljs-built_in">top</span>()).first;<br>            p_q.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先计算每行的战斗力，然后根据战斗力优先，行号次之的顺序放入到小顶堆。最后从堆顶取出k个元素即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>优先级队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>135. 分发糖果</title>
    <link href="/2021/12/09/LeetCode/135.%20%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/"/>
    <url>/2021/12/09/LeetCode/135.%20%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/candy/">本题链接</a></p><h2 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;<br><br>        <span class="hljs-comment">//异常情况</span><br>        <span class="hljs-keyword">if</span>(ratings.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> ratings.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-comment">//预处理</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">( ratings.size(), <span class="hljs-number">1</span> )</span></span>;<br><br>        <span class="hljs-comment">//只处理上升区间</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; ratings.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(ratings[i+<span class="hljs-number">1</span>]&gt;ratings[i]) res[i+<span class="hljs-number">1</span>] = res[i] + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//处理下降区间</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = ratings.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span> ; i--)<br>        &#123;<br>            <span class="hljs-keyword">if</span>( ratings[i] &gt; ratings[i+<span class="hljs-number">1</span>] ) <br>            &#123;   <br>                res[i] = <span class="hljs-built_in">max</span>(res[i],res[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.<span class="hljs-built_in">size</span>(); i++) cnt += res[i];<br>        <span class="hljs-keyword">return</span> cnt;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题实际上分递增递减区间两种情况讨论，只要先完成递增区间即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>136. 只出现一次的数字</title>
    <link href="/2021/12/09/LeetCode/136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2021/12/09/LeetCode/136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/single-number/">本题链接</a></p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; num:nums)&#123;<br>            res ^= num;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据异或的性质：</p><ul><li>a ^ b ^ c &lt;=&gt; a ^ c ^ b 交换律</li><li>a ^ a = 0</li><li>a ^ 0 = a</li></ul><p>不停的异或数组里的所有值，由于两个相同的数异或会等于0，那么最后剩下的结果就是数组中个数只有一个的数。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>138. 复制带随机指针的链表</title>
    <link href="/2021/12/09/LeetCode/138.%20%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/12/09/LeetCode/138.%20%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">本题链接</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* random;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">        random = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>       <br>        unordered_map&lt;Node*,<span class="hljs-keyword">int</span>&gt; hash;<span class="hljs-comment">//建立原节点与链表的位置关系</span><br>        Node* tmp = head;<br>        <span class="hljs-comment">//设置每个节点在链表的位置</span><br>        <span class="hljs-keyword">int</span> node_cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(tmp)&#123;<br>            hash[tmp] = node_cnt++;<br>            tmp = tmp-&gt;next;<br>        &#125;<br>        hash[<span class="hljs-number">0x0</span>] = node_cnt++;<span class="hljs-comment">//放入空节点</span><br><br>        vector&lt;Node*&gt; clone_vec;<span class="hljs-comment">//新的节点数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; node_cnt - <span class="hljs-number">1</span>;++i)<br>            clone_vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">0</span>));<br>        clone_vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-comment">//放入最后一个空节点</span><br><br>        tmp = head;<br>        <span class="hljs-comment">//根据原链表中的映射关系串接新链表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; clone_vec.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;++i)&#123;<span class="hljs-comment">//这里循环条件clone_vec.size() - 1是为了避开最后一个空节点</span><br>            clone_vec[i]-&gt;val = tmp-&gt;val;<br>            clone_vec[i]-&gt;next = clone_vec[hash[tmp-&gt;next]];<br>            clone_vec[i]-&gt;random = clone_vec[hash[tmp-&gt;random]];<br>            tmp = tmp-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> clone_vec[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于节点中有一个随机节点引用的存在，所以可以依靠节点在链表中的关系来构建哈希表，即哈希表的key为节点，value为节点在链表中的位置。因为数组和链表在逻辑上是一样的，所以只要在一个数组中建立所有的新节点，并且依照这个哈希表的映射关系，可以很快的得到随机节点在数组中的下标。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>139. 单词拆分</title>
    <link href="/2021/12/09/LeetCode/139.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
    <url>/2021/12/09/LeetCode/139.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/word-break/">本题链接</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;<br><br>        <span class="hljs-comment">//使用哈希表</span><br>        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">hash</span><span class="hljs-params">(wordDict.begin(),wordDict.end())</span></span>;<span class="hljs-comment">//将单词存入哈希表</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size() + <span class="hljs-number">1</span>,<span class="hljs-literal">false</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= s.<span class="hljs-built_in">size</span>();++i)&#123;<span class="hljs-comment">//遍历整个字符串</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; i;++j)&#123;<span class="hljs-comment">//分割点前进</span><br>                <span class="hljs-keyword">if</span>(dp[j] &amp;&amp; hash.<span class="hljs-built_in">find</span>(s.<span class="hljs-built_in">substr</span>(j,i-j)) != hash.<span class="hljs-built_in">end</span>())&#123;<br>                    dp[i] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> dp[dp.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>具体见<a href="https://leetcode-cn.com/problems/word-break/solution/dan-ci-chai-fen-by-leetcode-solution/">官方解析</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>142. 环形链表 II</title>
    <link href="/2021/12/09/LeetCode/142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II/"/>
    <url>/2021/12/09/LeetCode/142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">本题链接</a></p><h2 id="Floyd判圈法"><a href="#Floyd判圈法" class="headerlink" title="Floyd判圈法"></a>Floyd判圈法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br><br>        <span class="hljs-comment">//使用floyd判圈法</span><br>        <span class="hljs-comment">//使用快慢指针</span><br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <br>            <span class="hljs-comment">//移动指针</span><br>            <span class="hljs-keyword">if</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;fast = fast-&gt;next-&gt;next;slow = slow-&gt;next;&#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>            <span class="hljs-comment">//判断是否相等</span><br>            <span class="hljs-keyword">if</span>(fast == slow) &#123;fast = head;<span class="hljs-keyword">break</span>;&#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//第二次相遇位置即环路路口</span><br>        <span class="hljs-keyword">while</span>(fast != slow)&#123;<br><br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> fast;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用floyd判圈法即可。</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br><br>        unordered_set&lt;ListNode*&gt; hash;<br>        <span class="hljs-keyword">while</span>(head)&#123;<br>            <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">find</span>(head) == hash.<span class="hljs-built_in">end</span>())&#123;<br>                hash.<span class="hljs-built_in">insert</span>(head);<br>                head = head-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>使用哈希表存储出现过的节点，如果存入节点时发现哈希表中已经有该节点了，那么该节点就是环的入口节点。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>链表</tag>
      
      <tag>Floyd判圈法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>144. 二叉树的前序遍历</title>
    <link href="/2021/12/09/LeetCode/144.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2021/12/09/LeetCode/144.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">本题链接</a></p><h2 id="栈-迭代1"><a href="#栈-迭代1" class="headerlink" title="栈+迭代1"></a>栈+迭代1</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; node_stack;<br>        TreeNode* cur_node;<br><br>        node_stack.<span class="hljs-built_in">push</span>(root);<span class="hljs-comment">//将第一个节点压栈</span><br>        <span class="hljs-keyword">while</span>(!node_stack.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-comment">//获得当前节点，并将当前节点出栈</span><br>            cur_node = node_stack.<span class="hljs-built_in">top</span>();node_stack.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">//将结果保存到数组中</span><br>            res.<span class="hljs-built_in">push_back</span>(cur_node-&gt;val);<br>            <span class="hljs-comment">//根据栈先进后出的特性，先将右孩子入栈</span><br>            <span class="hljs-keyword">if</span>(cur_node-&gt;right) node_stack.<span class="hljs-built_in">push</span>(cur_node-&gt;right);<br>            <span class="hljs-keyword">if</span>(cur_node-&gt;left) node_stack.<span class="hljs-built_in">push</span>(cur_node-&gt;left);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>只要对<strong>局部的子树</strong>进行前序遍历，再借由栈的特性进行入栈出栈即可。</p><h2 id="栈-迭代2"><a href="#栈-迭代2" class="headerlink" title="栈+迭代2"></a>栈+迭代2</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; node_stack;<br>        TreeNode* cur_node = root;<br>        <br>        <span class="hljs-keyword">while</span>(!node_stack.<span class="hljs-built_in">empty</span>() || cur_node)&#123;<br>            <br>            <span class="hljs-keyword">if</span>(cur_node)&#123;<span class="hljs-comment">//如果当前节点存在</span><br>                <br>                res.<span class="hljs-built_in">push_back</span>(cur_node-&gt;val);<span class="hljs-comment">//保存当前节点的值</span><br>                node_stack.<span class="hljs-built_in">push</span>(cur_node-&gt;right);<span class="hljs-comment">//将右孩子入栈</span><br>                cur_node = cur_node-&gt;left;<span class="hljs-comment">//控制权交给右孩子</span><br><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                cur_node = node_stack.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//将当前节点更换成栈顶节点</span><br>                node_stack.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//将栈顶节点出栈</span><br>            &#125;<br>            <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>按照前序遍历的次序，每次将控制权交给左孩子，然后让右孩子入栈。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-built_in">preOrder</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br><br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<span class="hljs-comment">//优先处理自己</span><br>        <span class="hljs-built_in">preOrder</span>(root-&gt;left);<br>        <span class="hljs-built_in">preOrder</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>递归直观简单，只需要按照前序遍历的顺序优先处理自己即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代</tag>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
      <tag>栈</tag>
      
      <tag>前序遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>145. 二叉树的后序遍历</title>
    <link href="/2021/12/09/LeetCode/145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2021/12/09/LeetCode/145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">本题链接</a></p><h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">postOrder</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-built_in">postOrder</span>(root-&gt;left);<span class="hljs-comment">//先处理左孩子</span><br>        <span class="hljs-built_in">postOrder</span>(root-&gt;right);<span class="hljs-comment">//再处理右孩子</span><br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<span class="hljs-comment">//最后处理自己</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>递归简洁直观，只需按照后序遍历的顺序即可。</p><h2 id="迭代版-栈-哈希表"><a href="#迭代版-栈-哈希表" class="headerlink" title="迭代版+栈+哈希表"></a>迭代版+栈+哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br><br>        stack&lt;TreeNode*&gt; node_stack;<br>        unordered_set&lt;TreeNode*&gt; unique_hash;<span class="hljs-comment">//避免重复放入孩子</span><br>        TreeNode* cur_node;<br><br>        node_stack.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!node_stack.<span class="hljs-built_in">empty</span>())&#123;<br><br>            cur_node = node_stack.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//当前的栈顶节点</span><br><br>            <span class="hljs-keyword">bool</span> hasRight = cur_node-&gt;right &amp;&amp; unique_hash.<span class="hljs-built_in">find</span>(cur_node-&gt;right) == unique_hash.<span class="hljs-built_in">end</span>();<span class="hljs-comment">//是否放入右孩子</span><br>            <br>            <span class="hljs-keyword">if</span>(hasRight) node_stack.<span class="hljs-built_in">push</span>(cur_node-&gt;right);<span class="hljs-comment">//放入右孩子</span><br><br>            <span class="hljs-keyword">if</span>(cur_node-&gt;left &amp;&amp; unique_hash.<span class="hljs-built_in">find</span>(cur_node-&gt;left) == unique_hash.<span class="hljs-built_in">end</span>()) node_stack.<span class="hljs-built_in">push</span>(cur_node-&gt;left);<span class="hljs-comment">//放入左孩子</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!hasRight)&#123;<span class="hljs-comment">//若同时也不放入右孩子</span><br>                res.<span class="hljs-built_in">push_back</span>(cur_node-&gt;val);<span class="hljs-comment">//保存结果</span><br>                unique_hash.<span class="hljs-built_in">insert</span>(cur_node);<span class="hljs-comment">//标记当前节点已被使用</span><br>                node_stack.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//将当前节点出栈</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>按照后序遍历的顺序放入左右节点，然后使用哈希表记录已经被使用的节点，防止左右孩子重复入栈。当该节点为叶子节点时就使用，或者当该节点的孩子都被使用过，那么该节点也可以看成叶子节点。</p><h2 id="迭代版-栈"><a href="#迭代版-栈" class="headerlink" title="迭代版+栈"></a>迭代版+栈</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; node_stack;<br>        TreeNode* cur_node = root;<br>        TreeNode* tmp;<br><br>        <span class="hljs-keyword">while</span>(!node_stack.<span class="hljs-built_in">empty</span>() || cur_node)&#123;<br><br>            <span class="hljs-keyword">if</span>(cur_node)&#123;<span class="hljs-comment">//沿着左侧链下行</span><br><br>                node_stack.<span class="hljs-built_in">push</span>(cur_node);<br>                cur_node = cur_node-&gt;left;<br><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                cur_node = node_stack.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//取出栈顶的节点</span><br><br>                <span class="hljs-comment">//如果没有右孩子或者右孩子已经被遍历过</span><br>                <span class="hljs-keyword">if</span>(cur_node-&gt;right == <span class="hljs-literal">nullptr</span> || cur_node-&gt;right == tmp)&#123;<br>                    <br>                    res.<span class="hljs-built_in">push_back</span>(cur_node-&gt;val);<span class="hljs-comment">//将元素保存到res</span><br>                    node_stack.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//将栈顶元素出栈</span><br>                    tmp = cur_node;<span class="hljs-comment">//将上一个右孩子节点设置为当前节点</span><br>                    cur_node = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//将当前节点置空</span><br><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    cur_node = cur_node-&gt;right;<span class="hljs-comment">//将当前节点设置为自己的右孩子</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>根据后序遍历的性质，使用了一个临时变量来存储被使用过的右孩子，以避免重复入栈。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
      <tag>栈</tag>
      
      <tag>后序遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>148. 排序链表</title>
    <link href="/2021/12/09/LeetCode/148.%20%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/12/09/LeetCode/148.%20%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-list/">本题链接</a></p><h2 id="借助辅助空间排序"><a href="#借助辅助空间排序" class="headerlink" title="借助辅助空间排序"></a>借助辅助空间排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; dig_vec;<br>        <br>        <span class="hljs-comment">//读取链表中的所有数到数组里</span><br>        ListNode* dig = head;<br>        <span class="hljs-keyword">while</span>(dig)&#123;<br>            dig_vec.<span class="hljs-built_in">push_back</span>(dig-&gt;val);<br>            dig = dig-&gt;next;<br>        &#125;<br><br>        <span class="hljs-comment">//对数组排序</span><br>        <span class="hljs-built_in">sort</span>(dig_vec.<span class="hljs-built_in">begin</span>(),dig_vec.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-comment">//将数组的值回写到链表</span><br>        ListNode* in = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;dig_vec.<span class="hljs-built_in">size</span>();++i)&#123;<br>            in-&gt;val = dig_vec[i];<br>            in = in-&gt;next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>简单粗暴，避免了对链表操作的断链续链问题。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>149. 直线上最多的点数</title>
    <link href="/2021/12/09/LeetCode/149.%20%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/"/>
    <url>/2021/12/09/LeetCode/149.%20%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/max-points-on-a-line/">本题链接</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxPoints</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (points.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> points.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//异常情况</span><br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">//两两求斜率</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> p1 = <span class="hljs-number">0</span>;p1 &lt; points.<span class="hljs-built_in">size</span>();++p1)&#123;<br><br>            <span class="hljs-comment">//如果大于点数的一半 说明已经是最大值</span><br>            <span class="hljs-keyword">if</span>(res &gt; points.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> res;<br>            unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; k_map;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> p2 = p1 + <span class="hljs-number">1</span>;p2 &lt; points.<span class="hljs-built_in">size</span>();++p2)&#123;<br><br>                <span class="hljs-keyword">int</span> x = points[p1][<span class="hljs-number">0</span>] - points[p2][<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">int</span> y = points[p1][<span class="hljs-number">1</span>] - points[p2][<span class="hljs-number">1</span>];<br><br>                <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) y = <span class="hljs-number">1</span>;<span class="hljs-comment">//两个点x相等,所处直线垂直x轴</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>) x = <span class="hljs-number">1</span>;<span class="hljs-comment">//两个点y相等,所处直线平行x轴</span><br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (y &lt; <span class="hljs-number">0</span>) &#123;<br>                        x = -x;<br>                        y = -y;<br>                    &#125;<br>                    <span class="hljs-keyword">int</span> gcdXY = <span class="hljs-built_in">gcd</span>(<span class="hljs-built_in">abs</span>(x), <span class="hljs-built_in">abs</span>(y));<br>                    x /= gcdXY, y /= gcdXY;<br>                &#125;<br>                ++k_map[y + x * <span class="hljs-number">20001</span>];<br>            &#125;<br><br>            <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; [_,num]:k_map)&#123;<br>                maxn = <span class="hljs-built_in">max</span>(maxn,num + <span class="hljs-number">1</span>);<span class="hljs-comment">//+1为p1自身</span><br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res,maxn);<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">//辗转相除法 求最大公约数</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b, a % b) : a;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>暴力算法对点进行两两求斜率很容易想到，为了把斜率保存到哈希表，对斜率的转化比较棘手。</p><p>具体看官方解析：<a href="https://leetcode-cn.com/problems/max-points-on-a-line/solution/zhi-xian-shang-zui-duo-de-dian-shu-by-le-tq8f/">直线上最多的点数</a>。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15.三数之和</title>
    <link href="/2021/12/09/LeetCode/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2021/12/09/LeetCode/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/3sum/">本题链接</a></p><h2 id="双指针-暴力"><a href="#双指针-暴力" class="headerlink" title="双指针+暴力"></a>双指针+暴力</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;  <br>        <br>        <span class="hljs-comment">//异常情况</span><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-comment">//结果</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>        <span class="hljs-comment">//排序数组</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">//记录上一个开始的数,防止出现对同一个第一个值,以导致重复结果的出现</span><br>        <span class="hljs-keyword">int</span> last_first = nums[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//双指针搜索</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<span class="hljs-comment">//设置第一个值</span><br><br>            <span class="hljs-comment">//如果和上一趟遍历的值相同,就跳过此次循环</span><br>            <span class="hljs-comment">//避免数组为&#123;-3,-3,1,2&#125;,i = 0和i = 1的情况时</span><br>            <span class="hljs-comment">//重复写入&#123;-3,1,2&#125;的情况发生</span><br>            <span class="hljs-keyword">if</span>(last_first == nums[i]) <span class="hljs-keyword">continue</span>;<br>            last_first = nums[i];<span class="hljs-comment">//设置上一次开始的数</span><br>            <span class="hljs-keyword">int</span> target = <span class="hljs-number">0</span> - nums[i];<span class="hljs-comment">//设置目标值</span><br>            <span class="hljs-keyword">int</span> last_second = nums[i] - <span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> last_third = nums[i] - <span class="hljs-number">1</span>;<span class="hljs-comment">//设置上一次保存的结果值</span><br>            <span class="hljs-keyword">int</span> left = i + <span class="hljs-number">1</span>,right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-comment">//设置头尾指针</span><br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br><br>                <span class="hljs-keyword">int</span> loop_res = nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span>(loop_res == target)&#123;<br>                    <span class="hljs-comment">//如果与上一次的保存的结果值不相等</span><br>                    <span class="hljs-comment">//避免数组为&#123;-3,1,1,2,2&#125;,i = 0的情况时</span><br>                    <span class="hljs-comment">//重复写入&#123;-3,1,2&#125;的情况发生</span><br>                    <span class="hljs-keyword">if</span>(nums[left] != last_second &amp;&amp; nums[right] != last_third)&#123;<br>                        res.<span class="hljs-built_in">push_back</span>(&#123;nums[i],nums[left],nums[right]&#125;);<span class="hljs-comment">//保存结果</span><br>                        last_second = nums[left];last_third = nums[right];<span class="hljs-comment">//设置此次的结果</span><br>                    &#125;<br>                    ++left;--right;<span class="hljs-comment">//排序后的数组不会出现跳过隐藏答案的情况</span><br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(loop_res &gt; target) --right;  <br>                <span class="hljs-keyword">else</span> ++left;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先对原数组排序，然后使用两次循环，第一层循环选择一个目标值，第二层循环在数组中寻找两个与目标值相加等于0的元素。</p><p>注意需要保存上一次第一层循环选择的数，和第二层循环加入结果的两个值，这三个用于去重操作。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>155. 最小栈</title>
    <link href="/2021/12/09/LeetCode/155.%20%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <url>/2021/12/09/LeetCode/155.%20%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/min-stack/">本题链接</a></p><h2 id="两个栈实现"><a href="#两个栈实现" class="headerlink" title="两个栈实现"></a>两个栈实现</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-built_in">MinStack</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br><br>        <span class="hljs-comment">//将参数放入</span><br>        var_s.<span class="hljs-built_in">push</span>(val);<br><br>        <span class="hljs-keyword">int</span> size = var_s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(!min_s.<span class="hljs-built_in">empty</span>() &amp;&amp; min_s.<span class="hljs-built_in">top</span>() &lt; val)&#123;<span class="hljs-comment">//直到min_s.top() &gt;= val</span><br>            var_s.<span class="hljs-built_in">push</span>(min_s.<span class="hljs-built_in">top</span>());<br>            min_s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        min_s.<span class="hljs-built_in">push</span>(val);<span class="hljs-comment">//放入最小栈</span><br>        size = var_s.<span class="hljs-built_in">size</span>() - size;<span class="hljs-comment">//回放次数</span><br>        <span class="hljs-keyword">while</span>(size &gt; <span class="hljs-number">0</span>)&#123;<br>            min_s.<span class="hljs-built_in">push</span>(var_s.<span class="hljs-built_in">top</span>());<br>            var_s.<span class="hljs-built_in">pop</span>();<br>            --size;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(var_s.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">int</span> top = var_s.<span class="hljs-built_in">top</span>();<br>        var_s.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-comment">//找到min_s中与top相等的元素</span><br>        <span class="hljs-keyword">int</span> size = var_s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(top != min_s.<span class="hljs-built_in">top</span>())&#123;<br>            var_s.<span class="hljs-built_in">push</span>(min_s.<span class="hljs-built_in">top</span>());<br>            min_s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-comment">//找到后</span><br>        size = var_s.<span class="hljs-built_in">size</span>() - size;<br>        <span class="hljs-comment">//弹出</span><br>        min_s.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//回写</span><br>        <span class="hljs-keyword">while</span>(size &gt; <span class="hljs-number">0</span>)&#123;<br>            min_s.<span class="hljs-built_in">push</span>(var_s.<span class="hljs-built_in">top</span>());<br>            var_s.<span class="hljs-built_in">pop</span>();<br>            --size;<br>        &#125;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> var_s.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> min_s.<span class="hljs-built_in">top</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><br>    stack&lt;<span class="hljs-keyword">int</span>&gt; var_s;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; min_s;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack* obj = new MinStack();</span><br><span class="hljs-comment"> * obj-&gt;push(val);</span><br><span class="hljs-comment"> * obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * int param_4 = obj-&gt;getMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>var_s用于按照入栈顺序存放的数值</li><li>min_s用于按照元素大小存放的数值，栈顶一定为最小元素</li></ul><p>但是极端情况下太慢了…..</p><h2 id="记录每个时刻的栈最小值"><a href="#记录每个时刻的栈最小值" class="headerlink" title="记录每个时刻的栈最小值"></a>记录每个时刻的栈最小值</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> &#123;</span><br><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        <span class="hljs-keyword">int</span> var;<br>        <span class="hljs-keyword">int</span> min;<br>    &#125;stact_var;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-built_in">MinStack</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        s.<span class="hljs-built_in">push</span>(&#123;val,s.<span class="hljs-built_in">empty</span>() || val &lt;= <span class="hljs-built_in">getMin</span>() ? val : <span class="hljs-built_in">getMin</span>()&#125;);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        s.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ((stact_var)s.<span class="hljs-built_in">top</span>()).var;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ((stact_var)s.<span class="hljs-built_in">top</span>()).min;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    stack&lt;stact_var&gt; s;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack* obj = new MinStack();</span><br><span class="hljs-comment"> * obj-&gt;push(val);</span><br><span class="hljs-comment"> * obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * int param_4 = obj-&gt;getMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>使用一个栈，然后这个栈的元素由两部分组成，一个是传入的值，还有一个为当前时刻栈中的最小值（包括传入的值）。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>160. 相交链表</title>
    <link href="/2021/12/09/LeetCode/160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/12/09/LeetCode/160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">本题链接</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br><br>        unordered_set&lt;ListNode*&gt; list_set;<br><br>        <span class="hljs-keyword">while</span>(headA || headB)&#123;<br><br>            <span class="hljs-keyword">if</span>(headA)&#123;<br>                <span class="hljs-keyword">if</span>(list_set.<span class="hljs-built_in">find</span>(headA) == list_set.<span class="hljs-built_in">end</span>())&#123;<br>                    list_set.<span class="hljs-built_in">insert</span>(headA);<br>                    headA = headA-&gt;next;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> headA;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(headB)&#123;<br>                <span class="hljs-keyword">if</span>(list_set.<span class="hljs-built_in">find</span>(headB) == list_set.<span class="hljs-built_in">end</span>())&#123;<br>                    list_set.<span class="hljs-built_in">insert</span>(headB);<br>                    headB = headB-&gt;next;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> headB;<br>                &#125;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用哈希表存储两条链表中出现过的节点，如果某条链表存储节点时发现该节点已经被保存过，那么这个节点就是相交的节点。</p><h2 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode* p1 = headA;ListNode* p2 = headB;<br>        <span class="hljs-keyword">while</span>(p1 != p2)&#123;<br>           p1 ? p1 = p1-&gt;next : p1 = headB;<br>           p2 ? p2 = p2-&gt;next : p2 = headA;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p1;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>将两条链表到相交点的距离分别设置为A和B，然后相交点到链表的距离为C，那么对于两条路径就有</p><script type="math/tex; mode=display">A+C+B=B+C+A</script>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>链表</tag>
      
      <tag>奇技淫巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>162. 寻找峰值</title>
    <link href="/2021/12/09/LeetCode/162.%20%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/"/>
    <url>/2021/12/09/LeetCode/162.%20%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-peak-element/">本题链接</a></p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]&gt;nums[<span class="hljs-number">1</span>]?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>,r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>,mid;<br><br>        <span class="hljs-keyword">while</span>((l + <span class="hljs-number">2</span>) &lt;= r)&#123;<br>            <br>            mid = (r + l)  / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] &gt; nums[mid - <span class="hljs-number">1</span>] &amp;&amp; nums[mid] &gt; nums[mid + <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; nums[mid - <span class="hljs-number">1</span>] &amp;&amp; nums[mid] &lt; nums[mid + <span class="hljs-number">1</span>]) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &gt; nums[<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>] &gt; nums[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> l + <span class="hljs-number">1</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将峰值限制在左边界和右边界之间即可,主要考虑特殊情况</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>167. 两数之和 II - 输入有序数组</title>
    <link href="/2021/12/09/LeetCode/167.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2021/12/09/LeetCode/167.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">本题链接</a></p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">int</span> r = numbers.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; <br><br>        <span class="hljs-keyword">while</span>(l!=r)&#123;<br><br>            <span class="hljs-keyword">if</span>((numbers[l] + numbers[r]) == target) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((numbers[l] + numbers[r]) &gt; target) r--;<br>            <span class="hljs-keyword">else</span> l++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;l+<span class="hljs-number">1</span>,r+<span class="hljs-number">1</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为是排好序的数组，所以只要两个指针分别从头尾往内移动，然后判断和目标值的大小，来决定要移动哪个指针。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>172. 阶乘后的零</title>
    <link href="/2021/12/09/LeetCode/172.%20%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/"/>
    <url>/2021/12/09/LeetCode/172.%20%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/">本题链接</a></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trailingZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> ? n / <span class="hljs-number">5</span> + <span class="hljs-built_in">trailingZeroes</span>(n / <span class="hljs-number">5</span>) : <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>阶乘后面的0是因为质因子2和质因子5相乘产生的，所以统计阶乘后面的0转化为统计质因子2和5的个数。又因为阶乘中质因子2的数量明显会比5多，所以统计5的个数就行。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>18. 四数之和</title>
    <link href="/2021/12/09/LeetCode/18.%20%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2021/12/09/LeetCode/18.%20%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/4sum/">本题链接</a></p><h2 id="双指针-暴力"><a href="#双指针-暴力" class="headerlink" title="双指针+暴力"></a>双指针+暴力</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target) &#123;<br><br>        <span class="hljs-comment">//异常情况</span><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-comment">//结果</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>        <span class="hljs-comment">//排序数组</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <br>        <span class="hljs-keyword">int</span> last_first = nums[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">3</span>;++i)&#123;<span class="hljs-comment">//设置第一个值</span><br><br>            <span class="hljs-keyword">if</span>(last_first == nums[i]) <span class="hljs-keyword">continue</span>;<br>            last_first = nums[i];<span class="hljs-comment">//设置上一次开始的数</span><br><br>            <span class="hljs-keyword">int</span> last_second = nums[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>;j &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>;++j)&#123;<span class="hljs-comment">//设置第二个值</span><br><br>                <span class="hljs-keyword">if</span>(last_second == nums[j]) <span class="hljs-keyword">continue</span>;<br>                last_second = nums[j];<span class="hljs-comment">//设置上一次开始的数</span><br><br>                <span class="hljs-keyword">int</span> loop_target = target - (nums[i] + nums[j]);<span class="hljs-comment">//设置目标值</span><br>                <span class="hljs-keyword">int</span> last_third = nums[i] - <span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> last_fourth = nums[i] - <span class="hljs-number">1</span>;<span class="hljs-comment">//设置上一次保存的结果值</span><br>                <span class="hljs-keyword">int</span> left = j + <span class="hljs-number">1</span>,right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-comment">//设置头尾指针</span><br>                <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br><br>                    <span class="hljs-keyword">int</span> loop_res = nums[left] + nums[right];<br>                    <span class="hljs-keyword">if</span>(loop_res == loop_target)&#123;<br>                        <span class="hljs-comment">//如果与上一次的保存的结果值不相等</span><br>                        <span class="hljs-keyword">if</span>(nums[left] != last_third &amp;&amp; nums[right] != last_fourth)&#123;<br>                            res.<span class="hljs-built_in">push_back</span>(&#123;nums[i],nums[j],nums[left],nums[right]&#125;);<span class="hljs-comment">//保存结果</span><br>                            last_third = nums[left];last_fourth = nums[right];<span class="hljs-comment">//设置此次的结果</span><br>                        &#125;<br>                        ++left;--right;<span class="hljs-comment">//排序后的数组不会出现跳过隐藏答案的情况</span><br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(loop_res &gt; loop_target) --right;  <br>                    <span class="hljs-keyword">else</span> ++left;<br>            &#125; <br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路与&lt;&lt;<strong>15. 三数之和</strong>&gt;&gt;一样。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>19. 删除链表的倒数第 N 个结点</title>
    <link href="/2021/12/09/LeetCode/19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <url>/2021/12/09/LeetCode/19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">本题链接</a></p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> head;<br><br>        <span class="hljs-function">ListNode <span class="hljs-title">dummy</span><span class="hljs-params">(<span class="hljs-number">0</span>,head)</span></span>;<br>        ListNode* p1 = head;ListNode* p2 = &amp;dummy;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n - <span class="hljs-number">1</span>; ++i)<span class="hljs-comment">//p1往前递进n-1个</span><br>            p1 = p1-&gt;next;<br>        <br>        <span class="hljs-comment">//两个指针一起走,直到p1到达末尾</span><br>        <span class="hljs-comment">//p2从head的前一个节点开始</span><br>        <span class="hljs-keyword">while</span>(p1-&gt;next)&#123;<br>            p1 = p1-&gt;next;<br>            p2 = p2-&gt;next;<br>        &#125;<br><br>        <span class="hljs-comment">//去除节点</span><br>        p2-&gt;next = p2-&gt;next-&gt;next;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用双指针，开始时第一个指针指向head，第二个指针指向head的前一个节点，先让第一个指针走n+1步，然后第二个指针也和第一个指针一样一起走，直到第一个指针走到最后一个节点，那么第二个指针指向的就是倒数第n+1个节点。至于为什么走到第n+1个节点而不是第n个节点的原因是，删除倒数第n个节点需要用到倒数第n+1个节点。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>链表</tag>
      
      <tag>快慢指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>190. 颠倒二进制位</title>
    <link href="/2021/12/09/LeetCode/190.%20%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"/>
    <url>/2021/12/09/LeetCode/190.%20%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-bits/">本题链接</a></p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">reverseBits</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">uint32_t</span> res = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">32</span>;++i)&#123;<br><br>            res &lt;&lt;= <span class="hljs-number">1</span>;<br>            res += n &amp; <span class="hljs-number">1</span>;<br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在for循环的每次迭代中，都将n的最低位复制到res的最低位。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>198. 打家劫舍</title>
    <link href="/2021/12/09/LeetCode/198.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <url>/2021/12/09/LeetCode/198.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/house-robber/">本题链接</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(),nums[<span class="hljs-number">0</span>])</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);<br><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-2</span>]+nums[i]);<br>            <br>        <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为在在第i个房子的时候，要么选择打劫，要么选择跳过。所以只要求出状态方程：</p><script type="math/tex; mode=display">dp[i] = max(dp[i-1],dp[i-2]+num[i])</script>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.两数相加</title>
    <link href="/2021/12/09/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <url>/2021/12/09/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/add-two-numbers/">本题链接</a></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;<br>        ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>,head);<br><br>        <span class="hljs-keyword">while</span>(l1||l2)&#123;<br><br>            tmp = (l1 ? l1-&gt;val : <span class="hljs-number">0</span>) + (l2 ? l2-&gt;val : <span class="hljs-number">0</span>) + t;<br>            tmp &gt;= <span class="hljs-number">10</span> ? (tmp = tmp % <span class="hljs-number">10</span> , t=<span class="hljs-number">1</span> ) : t=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(l1) l1 = l1-&gt;next;<br>            <span class="hljs-keyword">if</span>(l2) l2 = l2-&gt;next;<br><br><br>            node-&gt;next-&gt;val = tmp;<br>            node-&gt;next-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>            node = node-&gt;next;     <br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(t==<span class="hljs-number">1</span>) <br>            node-&gt;next-&gt;val = t;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">delete</span> node-&gt;next;<br>            node-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>            <br><br>        <span class="hljs-keyword">return</span> head; <br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>只要保存好进位就行，然后注意判断某个链表先空的情况。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20. 有效的括号</title>
    <link href="/2021/12/09/LeetCode/20.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <url>/2021/12/09/LeetCode/20.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/valid-parentheses/">本题链接</a></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || s.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">char</span>&gt; hash&#123;&#123;<span class="hljs-string">&#x27;&#125;&#x27;</span>,<span class="hljs-string">&#x27;&#123;&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;)&#x27;</span>,<span class="hljs-string">&#x27;(&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;]&#x27;</span>,<span class="hljs-string">&#x27;[&#x27;</span>&#125;&#125;;<br>        stack&lt;<span class="hljs-keyword">char</span>&gt; bracket_stack;<br>        bracket_stack.<span class="hljs-built_in">push</span>(s[<span class="hljs-number">0</span>]);<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <br>            <span class="hljs-comment">//如果是左边的括号</span><br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;&#123;&#x27;</span> || s[i] == <span class="hljs-string">&#x27;(&#x27;</span> || s[i] == <span class="hljs-string">&#x27;[&#x27;</span>) bracket_stack.<span class="hljs-built_in">push</span>(s[i]);<span class="hljs-comment">//如果是左边的括号</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bracket_stack.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果是右边的括号且此时栈为空,说明没有左括号与之匹配</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bracket_stack.<span class="hljs-built_in">top</span>() == hash[s[i]]) bracket_stack.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//左括号和右括号匹配成功</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//左括号和右括号不匹配</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> bracket_stack.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据括号的匹配方式和对字符串的遍历，每次碰到左括号，就把左括号压栈。碰到右括号，就和栈顶的左括号匹配。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度为栈所使用的$O(n)$空间和哈希表所使用的空间$O(m)$之和$O(n+m)$，哈希表所使用的空间取决于括号的数量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>204. 计数质数</title>
    <link href="/2021/12/09/LeetCode/204.%20%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/"/>
    <url>/2021/12/09/LeetCode/204.%20%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/count-primes/">本题链接</a></p><h2 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">prime</span><span class="hljs-params">(n + <span class="hljs-number">1</span>,<span class="hljs-literal">true</span>)</span></span>;<span class="hljs-comment">//假设n之前的所有数都为质数</span><br>        <span class="hljs-keyword">int</span> cnt = n - <span class="hljs-number">2</span>;<span class="hljs-comment">//去掉不是质数的0和1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= n; ++i)&#123;<span class="hljs-comment">//从2开始对n遍历</span><br>            <span class="hljs-keyword">if</span>(prime[i])&#123;<span class="hljs-comment">//如果i是质数</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span> * i;j &lt; n;j += i)&#123;<span class="hljs-comment">//寻找i的倍数j</span><br>                    <span class="hljs-keyword">if</span>(prime[j])&#123;<span class="hljs-comment">//如果j依然被标记为质数</span><br>                        prime[j] = <span class="hljs-literal">false</span>;<span class="hljs-comment">//将j的质数标记去除</span><br>                        --cnt;<span class="hljs-comment">//计数-1</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>埃氏筛法是非常常用的，判断一个整数是否是质数的方法。并且它可以在判断一个整数n时，同时判断所小于n的整数。其原理也十分易懂：从1到n遍历，假设当前遍历到m，则把所有小于n的、且是m的倍数的整数标记为和数；遍历完成后，没有被标记为和数的数字即为质数。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>埃氏筛法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>205. 同构字符串</title>
    <link href="/2021/12/09/LeetCode/205.%20%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2021/12/09/LeetCode/205.%20%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/isomorphic-strings/">本题链接</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isIsomorphic</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br><br>        unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">char</span>&gt; hashmap;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            <span class="hljs-keyword">if</span>(hashmap[s[i]] == <span class="hljs-string">&#x27;\0&#x27;</span>) hashmap[s[i]] = t[i];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(hashmap[s[i]] != t[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        &#125;<br><br>        hashmap.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            <span class="hljs-keyword">if</span>(hashmap[t[i]] == <span class="hljs-string">&#x27;\0&#x27;</span>) hashmap[t[i]] = s[i];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(hashmap[t[i]] != s[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>记录每个字符串对于另一个字符串的映射关系，由于是单射，所以遍历两次。也可以使用两个哈希表将遍历次数降至1。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>206. 反转链表</title>
    <link href="/2021/12/09/LeetCode/206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/12/09/LeetCode/206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">本题链接</a></p><h2 id="迭代版1"><a href="#迭代版1" class="headerlink" title="迭代版1"></a>迭代版1</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        ListNode* node_res_first = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//指向结果中的头节点</span><br>        ListNode* node_res_first_tmp;<span class="hljs-comment">//备份结果中的头节点</span><br>        ListNode* next_begin = head;<span class="hljs-comment">//在原链表中指向开始操作的第一个节点</span><br>        ListNode* next_begin_tmp;<span class="hljs-comment">//在原链表中备份下一次遍历开始的节点</span><br>        <span class="hljs-function">ListNode <span class="hljs-title">assist</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">//辅助节点</span><br><br>        <span class="hljs-keyword">while</span>(next_begin != <span class="hljs-literal">nullptr</span>)&#123;<br><br>            <span class="hljs-keyword">if</span>(next_begin-&gt;next == <span class="hljs-literal">nullptr</span>)<span class="hljs-comment">//如果next_begin的下一个节点为空</span><br>                next_begin-&gt;next = &amp;assist;<span class="hljs-comment">//接上辅助节点</span><br>    <br>            <span class="hljs-comment">//临时存储</span><br>            next_begin_tmp = next_begin-&gt;next-&gt;next;<span class="hljs-comment">//存储下一次开始遍历的节点</span><br>            node_res_first_tmp = next_begin-&gt;next;<span class="hljs-comment">//存储下一次遍历时结果中的头节点</span><br>            <span class="hljs-comment">//反转</span><br>            next_begin-&gt;next-&gt;next = next_begin;<span class="hljs-comment">//将开始节点的下一个节点指向开始节点 反转</span><br>            next_begin-&gt;next = node_res_first;<span class="hljs-comment">//将开始节点指向结果中的头节点</span><br>            <span class="hljs-comment">//从临时存储取值</span><br>            node_res_first = node_res_first_tmp;<span class="hljs-comment">//更改下一次结果中的头节点</span><br>            next_begin = next_begin_tmp;<span class="hljs-comment">//更改下次开始的地方</span><br><br>        &#125;<br><br>        <span class="hljs-comment">//去除辅助节点</span><br>        <span class="hljs-keyword">if</span>(node_res_first == &amp;assist)<br>            node_res_first = node_res_first-&gt;next;<br>        <br>        <span class="hljs-keyword">return</span> node_res_first;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每次处理链表中的两个节点，将第二个节点的指向改成第一个节点。注意需要保存这个过程中的一些节点，不然会由于更改了指向会造成节点丢失。</p><h2 id="迭代版2"><a href="#迭代版2" class="headerlink" title="迭代版2"></a>迭代版2</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        ListNode* res_head = <span class="hljs-literal">nullptr</span>;<br>        ListNode* node_tmp;<br><br>        <span class="hljs-keyword">while</span>(head)&#123;<br>            node_tmp = head-&gt;next;<span class="hljs-comment">//node_tmp保存head的下一个</span><br>            head-&gt;next = res_head;<span class="hljs-comment">//更改head指向为结果的第一个节点</span><br>            res_head = head;<span class="hljs-comment">//更改结果的第一个节点为head</span><br>            head = node_tmp;<span class="hljs-comment">//将head复位</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res_head;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>更直观，每次就处理一个节点。</p><h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head,ListNode* prev = <span class="hljs-literal">nullptr</span>,ListNode* node = <span class="hljs-literal">nullptr</span>)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> prev;<span class="hljs-comment">//到最后就返回结果头节点</span><br>        <br>        node = head-&gt;next;<span class="hljs-comment">//node保存head的下一个节点</span><br>        head-&gt;next = prev;<span class="hljs-comment">//将head指向prev</span><br>        prev = head;<span class="hljs-comment">//更新结果头节点</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverseList</span>(node,prev,node);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>与迭代版2一样，每次就处理一个节点。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代</tag>
      
      <tag>递归</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>207. 课程表</title>
    <link href="/2021/12/09/LeetCode/207.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8/"/>
    <url>/2021/12/09/LeetCode/207.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/course-schedule/">本题链接</a></p><h2 id="拓扑排序-深度优先搜索"><a href="#拓扑排序-深度优先搜索" class="headerlink" title="拓扑排序+深度优先搜索"></a>拓扑排序+深度优先搜索</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; edges;<span class="hljs-comment">//邻接矩阵</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; state;<span class="hljs-comment">//节点状态表 0:未搜索 1:搜索中 2:已搜索</span><br>    <span class="hljs-keyword">bool</span> res = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br><br>        <span class="hljs-comment">//初始化状态表</span><br>        state.<span class="hljs-built_in">resize</span>(numCourses);<br>        <span class="hljs-comment">//初始化邻接矩阵</span><br>        edges.<span class="hljs-built_in">resize</span>(numCourses);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; info : prerequisites)&#123;<br>            edges[info[<span class="hljs-number">1</span>]].<span class="hljs-built_in">emplace_back</span>(info[<span class="hljs-number">0</span>]);<br>        &#125;<br><br>        <span class="hljs-comment">//遍历所有节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; state.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">if</span>(state[i] == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//若节点未被搜索</span><br>                <span class="hljs-built_in">dfs</span>(i);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//如果出现环路 结束遍历</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;<br><br>        <span class="hljs-comment">//开始时将自己设置为搜索中</span><br>        state[u] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//对自己的邻接节点进行遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; v : edges[u])&#123;<br><br>            <span class="hljs-keyword">if</span>(state[v] == <span class="hljs-number">0</span>) <span class="hljs-built_in">dfs</span>(v);<span class="hljs-comment">//如果相邻节点未被搜索</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(state[v] == <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//如果遍历到一个正在搜索的节点,说明出现环路</span><br>                res = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//结束后设置自己的状态为已搜索</span><br>        state[u] = <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路与&lt;&lt;<strong>210. 课程表 II</strong>&gt;&gt;一致</p><h2 id="拓扑排序-广度优先搜索"><a href="#拓扑排序-广度优先搜索" class="headerlink" title="拓扑排序+广度优先搜索"></a>拓扑排序+广度优先搜索</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; edges;<span class="hljs-comment">//邻接矩阵</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; indeg;<span class="hljs-comment">//入度表</span><br>    <br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br><br>        <span class="hljs-comment">//初始化入度表</span><br>        indeg.<span class="hljs-built_in">resize</span>(numCourses);<br>        <span class="hljs-comment">//初始化邻接矩阵</span><br>        edges.<span class="hljs-built_in">resize</span>(numCourses);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; info : prerequisites)&#123;<br>            edges[info[<span class="hljs-number">1</span>]].<span class="hljs-built_in">emplace_back</span>(info[<span class="hljs-number">0</span>]);<br>            ++indeg[info[<span class="hljs-number">0</span>]];<br>        &#125;<br><br>        <span class="hljs-comment">//将所有入度为0的节点放入队列中</span><br>        queue&lt;<span class="hljs-keyword">int</span>&gt; node_queue;<br>        <span class="hljs-keyword">int</span> find_node_cnt = <span class="hljs-number">0</span>;<span class="hljs-comment">//已找到的节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; indeg.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">if</span>(indeg[i] == <span class="hljs-number">0</span>) &#123;<br>                node_queue.<span class="hljs-built_in">push</span>(i);<br>                ++find_node_cnt;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(!node_queue.<span class="hljs-built_in">empty</span>())&#123;<br><br>            <span class="hljs-keyword">int</span> u = node_queue.<span class="hljs-built_in">front</span>();node_queue.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; v : edges[u])&#123;<span class="hljs-comment">//遍历每一个邻接节点</span><br>                <br>                --indeg[v];<span class="hljs-comment">//将邻接节点的入度-1</span><br>                <span class="hljs-keyword">if</span>(indeg[v] == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//若邻接节点的入度为0,将其加入队列</span><br>                    ++find_node_cnt;<br>                    node_queue.<span class="hljs-built_in">push</span>(v);<br>                &#125;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> find_node_cnt == numCourses;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>思路与&lt;&lt;<strong>210. 课程表 II</strong>&gt;&gt;一致</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度优先搜索</tag>
      
      <tag>广度优先搜索</tag>
      
      <tag>图</tag>
      
      <tag>拓扑排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>208. 实现 Trie (前缀树)</title>
    <link href="/2021/12/09/LeetCode/208.%20%E5%AE%9E%E7%8E%B0%20Trie%20(%E5%89%8D%E7%BC%80%E6%A0%91)/"/>
    <url>/2021/12/09/LeetCode/208.%20%E5%AE%9E%E7%8E%B0%20Trie%20(%E5%89%8D%E7%BC%80%E6%A0%91)/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">本题链接</a></p><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR_COUNT 26</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span>&#123;</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TrieNode</span>&#123;</span><br><br>        TrieNode* childNode[CHAR_COUNT];<br>        <span class="hljs-keyword">bool</span> isVal;<br><br>        <span class="hljs-built_in">TrieNode</span>():<span class="hljs-built_in">isVal</span>(<span class="hljs-literal">false</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; CHAR_COUNT;++i)<br>                childNode[i] = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;;<br><br>    TrieNode* root;<br><br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">Trie</span>():<span class="hljs-built_in">root</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>())&#123;&#125;<br><br>    <span class="hljs-comment">//将新单词插入字典树</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp; word)</span> </span>&#123;<br><br>        TrieNode* tmp = root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>&amp; c : word)&#123;<br>            <span class="hljs-comment">//寻找字典树中是否存在&#x27;*c&#x27;前缀</span><br>            <span class="hljs-keyword">if</span>(!tmp-&gt;childNode[c-<span class="hljs-string">&#x27;a&#x27;</span>])&#123;<span class="hljs-comment">//若没有</span><br>                tmp-&gt;childNode[c-<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<span class="hljs-comment">//则创建一个</span><br>            &#125;<br>            tmp = tmp-&gt;childNode[c-<span class="hljs-string">&#x27;a&#x27;</span>];<span class="hljs-comment">//tmp前进</span><br>        &#125;<br>        tmp-&gt;isVal = <span class="hljs-literal">true</span>;<span class="hljs-comment">//设置当前单词存在</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//搜索单词</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp; word)</span> <span class="hljs-keyword">const</span></span>&#123;<br><br>        TrieNode* tmp = root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>&amp; c : word)&#123;<br>            <span class="hljs-keyword">if</span>(!tmp-&gt;childNode[c-<span class="hljs-string">&#x27;a&#x27;</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> tmp = tmp-&gt;childNode[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> tmp-&gt;isVal;<span class="hljs-comment">//返回单词是否存在</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//寻找单词前缀</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp; prefix)</span> <span class="hljs-keyword">const</span></span>&#123;<br><br>        TrieNode* tmp = root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>&amp; c : prefix)&#123;<br>            <span class="hljs-keyword">if</span>(!tmp-&gt;childNode[c-<span class="hljs-string">&#x27;a&#x27;</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> tmp = tmp-&gt;childNode[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Trie* obj = new Trie();</span><br><span class="hljs-comment"> * obj-&gt;insert(word);</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;search(word);</span><br><span class="hljs-comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>就是维护一个公共前缀树，具体可看<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/208-shi-xian-trie-qian-zhui-shu-bao-gua-insert-sea/">\208. 实现 Trie (前缀树) 包括insert、search、startwith、delete四种操作</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀树</tag>
      
      <tag>字典树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21. 合并两个有序链表</title>
    <link href="/2021/12/09/LeetCode/21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/12/09/LeetCode/21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">本题链接</a></p><h2 id="迭代版"><a href="#迭代版" class="headerlink" title="迭代版"></a>迭代版</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <br>        <span class="hljs-function">ListNode <span class="hljs-title">head</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>        ListNode* nextNode = &amp;head;<br><br>        <span class="hljs-keyword">while</span>(l1 &amp;&amp; l2)&#123;<br><br>            <span class="hljs-keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)&#123;<br>                nextNode-&gt;next = l1;<br>                l1 = l1-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                nextNode-&gt;next = l2;<br>                l2 = l2-&gt;next;<br>            &#125;<br>            nextNode = nextNode-&gt;next;<br>        &#125;<br><br>        nextNode-&gt;next = l1 ? l1 : l2;<br>        <span class="hljs-keyword">return</span> head.next;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>构建一个头节点，然后每次往这个节点依次添加两个链表中最小的节点</p><h2 id="递归版1"><a href="#递归版1" class="headerlink" title="递归版1"></a>递归版1</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br><br>        <span class="hljs-function">ListNode <span class="hljs-title">head</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>        ListNode* node = &amp;head;<br>        <span class="hljs-built_in">merge</span>(l1, l2,node);<br>        <span class="hljs-keyword">return</span> head.next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* l1, ListNode* l2,ListNode* node)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(l1 &amp;&amp; l2)&#123;<br><br>            <span class="hljs-keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)&#123;<br>                node-&gt;next = l1;<br>                l1 = l1-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                node-&gt;next = l2;<br>                l2 = l2-&gt;next;<br>            &#125;<br>            node = node-&gt;next;<br>            <span class="hljs-built_in">merge</span>(l1, l2,node);<br>            <br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            node-&gt;next = l1 ? l1 : l2;<br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>与迭代版一样</p><h2 id="递归版2"><a href="#递归版2" class="headerlink" title="递归版2"></a>递归版2</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br><br>        <br>        <span class="hljs-keyword">if</span>(!l1) <span class="hljs-keyword">return</span> l2;<br>        <br>        <span class="hljs-keyword">if</span>(!l2) <span class="hljs-keyword">return</span> l1;<br>        <br>        <span class="hljs-keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;<br>            l1-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(l1-&gt;next,l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br><br>        l2-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(l1,l2-&gt;next);<br>        <span class="hljs-keyword">return</span> l2;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>优化了递归版1，主要的思路就是每个递归函数返回给上一个递归函数需要挂接的节点。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代</tag>
      
      <tag>递归</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>210. 课程表 II</title>
    <link href="/2021/12/09/LeetCode/210.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8%20II/"/>
    <url>/2021/12/09/LeetCode/210.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8%20II/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/course-schedule-ii/">本题链接</a></p><h2 id="拓扑排序-深度优先搜索"><a href="#拓扑排序-深度优先搜索" class="headerlink" title="拓扑排序+深度优先搜索"></a>拓扑排序+深度优先搜索</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-comment">//有向图的存储</span><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; edges;<br>    <span class="hljs-comment">//标记每个节点的状态 0:未搜索 1:搜索中 2:已完成</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; visited;<br>    <span class="hljs-comment">//用数组来模拟栈，下标0为栈底，n-1为栈顶</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; result;<br>    <span class="hljs-comment">//判断有向图中是否有环</span><br>    <span class="hljs-keyword">bool</span> valid = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br><br>        <span class="hljs-comment">//对节点状态数组初始化</span><br>        visited.<span class="hljs-built_in">resize</span>(numCourses);<br>        <span class="hljs-comment">//对有向图数组初始化 </span><br>        edges.<span class="hljs-built_in">resize</span>(numCourses);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; info : prerequisites)&#123;<br>            edges[info[<span class="hljs-number">1</span>]].<span class="hljs-built_in">emplace_back</span>(info[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-comment">//每次挑选一个未搜索的节点,开始进行深度优先搜索</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; numCourses &amp;&amp; valid;++i)&#123;<br>            <span class="hljs-keyword">if</span>(!visited[i])&#123;<br>                <span class="hljs-built_in">dfs</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!valid) <span class="hljs-keyword">return</span> &#123;&#125;;<span class="hljs-comment">//如果有环,代表没有拓扑排序</span><br><br>        <span class="hljs-comment">//由于数组是模仿栈的行为,所以应该在返回结果前将数组反转</span><br>        <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(),result.<span class="hljs-built_in">end</span>());<br>        <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;<br><br>        <span class="hljs-comment">//将节点标记为搜索中</span><br>        visited[u] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//搜索其相邻节点</span><br>        <span class="hljs-comment">//只要发现有环，立即停止搜索</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v:edges[u])&#123;<br><br>            <span class="hljs-keyword">if</span>(visited[v] == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//如果这个相邻节点处于未遍历的状态</span><br>                <span class="hljs-built_in">dfs</span>(v);<span class="hljs-comment">//对该节点进行深度优先搜索</span><br>                <span class="hljs-keyword">if</span>(!valid) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//如果过程中出现了环</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(visited[v] == <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//如果这个相邻节点处于正在搜索的状态,那么就说明图中有环出现</span><br>                valid = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//对相邻节点搜索完毕后</span><br>        <span class="hljs-comment">//将自己设置成搜索完成</span><br>        visited[u] = <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//将自己入栈</span><br>        result.<span class="hljs-built_in">push_back</span>(u);<br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>详情见<a href="https://leetcode-cn.com/problems/course-schedule-ii/solution/ke-cheng-biao-ii-by-leetcode-solution/">官方解析</a></p><h2 id="拓扑排序-广度优先搜索"><a href="#拓扑排序-广度优先搜索" class="headerlink" title="拓扑排序+广度优先搜索"></a>拓扑排序+广度优先搜索</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-comment">// 存储有向图</span><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; edges;<br>    <span class="hljs-comment">// 存储每个节点的入度</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; indeg;<br>    <span class="hljs-comment">// 存储答案 </span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br><br>       <span class="hljs-comment">// 入度表初始化</span><br>       indeg.<span class="hljs-built_in">resize</span>(numCourses);<br>       <span class="hljs-comment">// 有向图初始化</span><br>       edges.<span class="hljs-built_in">resize</span>(numCourses);<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; info : prerequisites)&#123;<br>           edges[info[<span class="hljs-number">1</span>]].<span class="hljs-built_in">emplace_back</span>(info[<span class="hljs-number">0</span>]);<br>           ++indeg[info[<span class="hljs-number">0</span>]];<br>       &#125;<br><br>       <span class="hljs-comment">//节点队列</span><br>       queue&lt;<span class="hljs-keyword">int</span>&gt; node_queue;<br>       <span class="hljs-comment">// 将所有入度为0的节点放入队列中</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; numCourses;++i)&#123;<br>           <span class="hljs-keyword">if</span>(indeg[i] == <span class="hljs-number">0</span>)&#123;<br>               node_queue.<span class="hljs-built_in">push</span>(i);<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-keyword">while</span>(!node_queue.<span class="hljs-built_in">empty</span>())&#123;<br>           <span class="hljs-comment">// 从队首取出一个节点</span><br>           <span class="hljs-keyword">int</span> u = node_queue.<span class="hljs-built_in">front</span>();node_queue.<span class="hljs-built_in">pop</span>();<br>           <span class="hljs-comment">// 放入答案中</span><br>           res.<span class="hljs-built_in">emplace_back</span>(u);<br>           <span class="hljs-comment">// 遍历自己的邻接节点</span><br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v:edges[u])&#123;<br>               --indeg[v];<span class="hljs-comment">//将自己邻接节点的入度数量减一</span><br>               <span class="hljs-keyword">if</span>(indeg[v] == <span class="hljs-number">0</span>) node_queue.<span class="hljs-built_in">push</span>(v);<span class="hljs-comment">//如果相邻节点的入度为0,就把相邻节点入队</span><br>           &#125;<br>       &#125;<br><br>       <span class="hljs-comment">//若还有节点的入度不为0 那么说明图中出现了环路</span><br>       <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() != numCourses) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>       <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>详情见<a href="https://leetcode-cn.com/problems/course-schedule-ii/solution/ke-cheng-biao-ii-by-leetcode-solution/">官方解析</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度优先搜索</tag>
      
      <tag>广度优先搜索</tag>
      
      <tag>图</tag>
      
      <tag>拓扑排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>215. 数组中的第K个最大元素</title>
    <link href="/2021/12/09/LeetCode/215.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <url>/2021/12/09/LeetCode/215.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">本题链接</a></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> target = nums.<span class="hljs-built_in">size</span>() - k;<br>        <span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>,hi = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(lo &lt; hi)&#123;<br>            <span class="hljs-keyword">int</span> mid = <span class="hljs-built_in">getFindPivot</span>(nums,lo,hi);<br>            <span class="hljs-keyword">if</span>(mid == target) <span class="hljs-keyword">return</span> nums[mid];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mid &lt; target) lo = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> hi = mid - <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums[lo];<br>    &#125;<br><br>    <span class="hljs-comment">//返回一个基准点,采用快排思想</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getFindPivot</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> lo,<span class="hljs-keyword">int</span> hi)</span></span>&#123;<br><br>        <span class="hljs-keyword">int</span> left = lo + <span class="hljs-number">1</span>,right = hi;<br>        <span class="hljs-built_in">swap</span>(nums[lo], nums[lo + <span class="hljs-built_in">rand</span>() % ( hi - lo )]);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><br>            <span class="hljs-comment">//划分小于等于nums[lo]的区间</span><br>            <span class="hljs-keyword">while</span>(left &lt; hi &amp;&amp; nums[left] &lt;= nums[lo]) ++left;<br>            <br>            <span class="hljs-comment">//划分大于于等于nums[lo]的区间</span><br>            <span class="hljs-keyword">while</span>(right &gt; lo &amp;&amp; nums[right] &gt;= nums[lo]) --right;<br>            <br>            <span class="hljs-keyword">if</span>(left &gt;= right) <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-built_in">swap</span>(nums[left],nums[right]);<br>        &#125;<br><br>        <span class="hljs-built_in">swap</span>(nums[lo],nums[right]);<span class="hljs-comment">//将基准归位</span><br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按照快排的策略，每次对一个基准点进行归位。一直归位到这个基准点的后面有k-1个元素，那么这个基准点就是第k大值所在的位置。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>221. 最大正方形</title>
    <link href="/2021/12/09/LeetCode/221.%20%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <url>/2021/12/09/LeetCode/221.%20%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximal-square/">本题链接</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">int</span> row;<br>    <span class="hljs-keyword">int</span> col;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-comment">//初始化</span><br>        row = matrix.<span class="hljs-built_in">size</span>();<br>        col = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//初始化dp</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(row,vector&lt;<span class="hljs-keyword">int</span>&gt;(col,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;r &lt; row;++r)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;c &lt; col;++c)<br>                <span class="hljs-keyword">if</span>(matrix[r][c] == <span class="hljs-string">&#x27;1&#x27;</span>) dp[r][c] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//逐行逐列</span><br>        <span class="hljs-keyword">int</span> max_c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;r &lt; row;++r)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;c &lt; col;++c)<br>                <span class="hljs-keyword">if</span>(dp[r][c])&#123;<span class="hljs-comment">//非0</span><br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isLegal</span>(r,c<span class="hljs-number">-1</span>,dp) &amp;&amp; <span class="hljs-built_in">isLegal</span>(r<span class="hljs-number">-1</span>,c,dp) &amp;&amp; <span class="hljs-built_in">isLegal</span>(r<span class="hljs-number">-1</span>,c<span class="hljs-number">-1</span>,dp))&#123;<span class="hljs-comment">//如果该点能够合法的作为正方形的右下角  </span><br>                        dp[r][c] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(dp[r][c<span class="hljs-number">-1</span>],dp[r<span class="hljs-number">-1</span>][c<span class="hljs-number">-1</span>]),dp[r<span class="hljs-number">-1</span>][c]) + <span class="hljs-number">1</span>;<span class="hljs-comment">//获取min(左上,左边,右边)</span><br>                    &#125; <br>                    <span class="hljs-keyword">if</span>(max_c &lt; dp[r][c]) max_c = dp[r][c];<span class="hljs-comment">//判断哪个更大</span><br>                &#125;<br><br>        <span class="hljs-keyword">return</span> max_c * max_c;<br>    &#125;<br><br>    <span class="hljs-comment">//注意:单个1是个例外,无论判断与否都不影响结果 比如矩阵左上角的1</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isLegal</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; r,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; c,vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; dp)</span></span>&#123;<br>        <br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= r &amp;&amp; r &lt; row)<span class="hljs-comment">//如果在区间内</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= c &amp;&amp; c &lt; col)<span class="hljs-comment">//如果在区间内</span><br>                <span class="hljs-keyword">if</span>(!dp[r][c]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果值为0</span><br>                <span class="hljs-keyword">else</span>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>以当前遍历的元素作为正方形的右下角，可得状态方程：</p><script type="math/tex; mode=display">dp[r][c] = min(dp[r][c-1],dp[r-1][c-1],dp[r-1][c]) + 1;</script>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>225. 用队列实现栈</title>
    <link href="/2021/12/09/LeetCode/225.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <url>/2021/12/09/LeetCode/225.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">本题链接</a></p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyStack</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-comment">/** Push element x onto stack. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(reversal) q1.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-keyword">else</span> q2.<span class="hljs-built_in">push</span>(x);<br>        <br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> res;<br>        <span class="hljs-keyword">if</span>(reversal)&#123;<br><br>            <span class="hljs-keyword">while</span>(q1.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)&#123;<br>                q2.<span class="hljs-built_in">push</span>(q1.<span class="hljs-built_in">front</span>());<br>                q1.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            res = q1.<span class="hljs-built_in">front</span>();<br>            q1.<span class="hljs-built_in">pop</span>();<br><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br><br>            <span class="hljs-keyword">while</span>(q2.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)&#123;<br>                q1.<span class="hljs-built_in">push</span>(q2.<span class="hljs-built_in">front</span>());<br>                q2.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            res = q2.<span class="hljs-built_in">front</span>();<br>            q2.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        reversal = !reversal;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;   <br>    <br>    <span class="hljs-comment">/** Get the top element. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> reversal ? q1.<span class="hljs-built_in">back</span>() : q2.<span class="hljs-built_in">back</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns whether the stack is empty. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> q1.<span class="hljs-built_in">empty</span>() &amp;&amp; q2.<span class="hljs-built_in">empty</span>();<br>    &#125;<br><br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q1;<br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q2;<br>    <span class="hljs-keyword">bool</span> reversal = <span class="hljs-literal">true</span>;<span class="hljs-comment">//true表示q1为下次元素放入的队列,false表示q2...</span><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyStack* obj = new MyStack();</span><br><span class="hljs-comment"> * obj-&gt;push(x);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * bool param_4 = obj-&gt;empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义两个队列，每个队列都可能是下一次元素入栈存放元素的队列，所以使用一个标志位<code>reversal</code>来表示。当需要返回栈顶元素时，只需要将下一次存放元素的队列的值不断的放入另一个队列中，直到下一次存放元素的队列中只剩下一个元素，那么这个元素就是栈顶元素。这个标志位其实也不一定需要，只需要判断其中某个队列是否为空，也能判断下一次存放元素的队列是哪个。</p><p>实际上用一个队列也可以实现栈，就是每次取出栈顶元素的时候，需要让队列中除了最后一个入队的元素不动，其他元素再次出队然后入队，那么栈顶元素一定会出现在队头。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>227. 基本计算器 II</title>
    <link href="/2021/12/09/LeetCode/227.%20%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8%20II/"/>
    <url>/2021/12/09/LeetCode/227.%20%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8%20II/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/basic-calculator-ii/">本题链接</a></p><h2 id="栈-延迟缓冲"><a href="#栈-延迟缓冲" class="headerlink" title="栈(延迟缓冲)"></a>栈(延迟缓冲)</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        stack&lt;<span class="hljs-keyword">char</span>&gt; op_s;<span class="hljs-comment">//操作符栈</span><br>        stack&lt;<span class="hljs-keyword">int</span>&gt; di_s;<span class="hljs-comment">//操作数栈</span><br>        string digit;<br>        unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; op_map&#123;&#123;<span class="hljs-string">&#x27;+&#x27;</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-string">&#x27;-&#x27;</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-string">&#x27;*&#x27;</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-number">1</span>&#125;&#125;;<span class="hljs-comment">//操作符优先级</span><br>        s.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;+&#x27;</span>);<span class="hljs-comment">//预处理</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            <span class="hljs-keyword">while</span>(op_map.<span class="hljs-built_in">find</span>(s[i]) == op_map.<span class="hljs-built_in">end</span>()) digit+=s[i++];<span class="hljs-comment">//找到一个操作数</span><br>            di_s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoi</span>(digit));<span class="hljs-comment">//将操作数入操作数栈 stoi已对空格情况进行处理</span><br>            digit = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//将操作数清空</span><br><br>            <span class="hljs-keyword">while</span>(!op_s.<span class="hljs-built_in">empty</span>() &amp;&amp; op_map[s[i]] &lt;= op_map[op_s.<span class="hljs-built_in">top</span>()])&#123;<span class="hljs-comment">//若栈非空且当前操作符优先级低于栈顶元素优先级</span><br><br>                <span class="hljs-comment">//将操作数栈中取出值计算</span><br>                <span class="hljs-keyword">int</span> right = di_s.<span class="hljs-built_in">top</span>();di_s.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//右操作数</span><br>                <span class="hljs-keyword">int</span> left = di_s.<span class="hljs-built_in">top</span>();di_s.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//左操作数</span><br>                di_s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">getRes</span>(left,right,op_s.<span class="hljs-built_in">top</span>()));<span class="hljs-comment">//结合操作符获得结果,并放入操作数栈中</span><br>                op_s.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//丢弃已经使用过的操作符</span><br><br>            &#125;<br><br>            op_s.<span class="hljs-built_in">push</span>(s[i]);<span class="hljs-comment">//将当前的操作符入栈</span><br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> di_s.<span class="hljs-built_in">top</span>();<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getRes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; left,<span class="hljs-keyword">int</span>&amp; right,<span class="hljs-keyword">char</span> op)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;+&#x27;</span>) <span class="hljs-keyword">return</span> left + right;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> left - right;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-keyword">return</span> left * right;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;/&#x27;</span>) <span class="hljs-keyword">return</span> left / right;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将操作数和操作符分别用栈保存，每次取到新的操作符，就与栈顶的操作符对比，若栈顶的操作符优先级更高或优先级相等，便取出两个操作数与栈顶的操作符结合。直到栈顶的操作符优先级低于当前的操作符，再将当前的操作符入栈。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>延迟缓冲</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>230. 二叉搜索树中第K小的元素</title>
    <link href="/2021/12/09/LeetCode/230.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <url>/2021/12/09/LeetCode/230.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">本题链接</a></p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>        stack&lt;TreeNode*&gt; node_stack;<br><br>        TreeNode* cur_node = root;<br>        <span class="hljs-keyword">while</span>(!node_stack.<span class="hljs-built_in">empty</span>() || cur_node)&#123;<br><br>            <span class="hljs-keyword">if</span>(cur_node)&#123;<span class="hljs-comment">//沿着左侧链下行</span><br><br>                node_stack.<span class="hljs-built_in">push</span>(cur_node);<br>                cur_node = cur_node-&gt;left;<br><br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//当前左侧链已经到头</span><br><br>                cur_node = node_stack.<span class="hljs-built_in">top</span>();node_stack.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//取出栈顶的节点</span><br><br>                <span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> cur_node-&gt;val;<span class="hljs-comment">//若此时k为1,就说明该节点是第k小的元素</span><br>                <span class="hljs-keyword">else</span>&#123;<br>                    --k;<br>                    cur_node = cur_node-&gt;right;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二叉搜索树的中序遍历序列是单调递增的，所以二叉搜索树的第k小元素就是中序遍历中第k个元素。</p><ul><li>时间复杂度$O(h+k)$，h为树高，需要先向下到达叶子节点（左侧链）​​</li><li>空间复杂度$O(h+k)$​​</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>中序遍历</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>231. 2 的幂</title>
    <link href="/2021/12/09/LeetCode/231.%202%20%E7%9A%84%E5%B9%82/"/>
    <url>/2021/12/09/LeetCode/231.%202%20%E7%9A%84%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/power-of-two/">本题链接</a></p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> n &amp; (n - <span class="hljs-number">1</span>) ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果n的二进制表示中只有一个1，那么n就是2的幂次方。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>232. 用栈实现队列</title>
    <link href="/2021/12/09/LeetCode/232.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2021/12/09/LeetCode/232.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">本题链接</a></p><h2 id="两个栈实现一个队列"><a href="#两个栈实现一个队列" class="headerlink" title="两个栈实现一个队列"></a>两个栈实现一个队列</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyQueue</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-comment">/** Push element x to the back of queue. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>       <br>        <span class="hljs-keyword">while</span>(!tail_s.<span class="hljs-built_in">empty</span>())&#123;<br>            head_s.<span class="hljs-built_in">push</span>(tail_s.<span class="hljs-built_in">top</span>());<br>            tail_s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        head_s.<span class="hljs-built_in">push</span>(x);<br>        <br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-built_in">peek</span>();<br>        tail_s.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get the front element. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">while</span>(!head_s.<span class="hljs-built_in">empty</span>())&#123;<br>            tail_s.<span class="hljs-built_in">push</span>(head_s.<span class="hljs-built_in">top</span>());<br>            head_s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> tail_s.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns whether the queue is empty. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> head_s.<span class="hljs-built_in">size</span>()+tail_s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><br>    stack&lt;<span class="hljs-keyword">int</span>&gt; head_s;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; tail_s;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue* obj = new MyQueue();</span><br><span class="hljs-comment"> * obj-&gt;push(x);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;peek();</span><br><span class="hljs-comment"> * bool param_4 = obj-&gt;empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>分别用两个栈的栈底模拟队列的头和尾即可</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>234. 回文链表</title>
    <link href="/2021/12/09/LeetCode/234.%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/12/09/LeetCode/234.%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">本题链接</a></p><h2 id="数组-双指针"><a href="#数组-双指针" class="headerlink" title="数组+双指针"></a>数组+双指针</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        <span class="hljs-comment">//存储到数组中</span><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br>        <span class="hljs-keyword">while</span>(head)&#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(head-&gt;val);<br>            head = head-&gt;next;<br>        &#125;<br><br>        <span class="hljs-comment">//双指针从头尾向中间遍历</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = tmp.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-keyword">if</span>(tmp[left++] != tmp[right--])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>   <br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于是单向链表，所以使用能够双向遍历的数组存储链表的值，然后再判断是否回文。</p><h2 id="快慢指针-链表反转"><a href="#快慢指针-链表反转" class="headerlink" title="快慢指针+链表反转"></a>快慢指针+链表反转</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(!head-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-comment">//使用快慢指针找到中点</span><br>        ListNode* slow = head;ListNode* fast = head;<br>        <span class="hljs-keyword">while</span>(fast)&#123;<br>            slow = slow-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">break</span>;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <br><br>        <span class="hljs-comment">//反转后半部分链表 从slow开始</span><br>        ListNode* node_tmp;<br>        ListNode* back_head = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(slow)&#123;<br><br>            node_tmp = slow-&gt;next;<br>            slow-&gt;next = back_head;<br>            back_head = slow;<br>            slow = node_tmp;<br>            <br>        &#125;<br><br>        <span class="hljs-comment">//逐一对比</span><br>        <span class="hljs-keyword">while</span>(back_head &amp;&amp; head)&#123;<br><br>            <span class="hljs-keyword">if</span>(back_head-&gt;val == head-&gt;val)&#123;<br>                back_head = back_head-&gt;next;<br>                head = head-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>先使用快慢指针找到中点，然后反转从中点开始的后半段的链表，最后重新逐个比对即可，</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>链表</tag>
      
      <tag>快慢指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>235. 二叉搜索树的最近公共祖先</title>
    <link href="/2021/12/09/LeetCode/235.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2021/12/09/LeetCode/235.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">本题链接</a></p><h2 id="递归-中序遍历"><a href="#递归-中序遍历" class="headerlink" title="递归+中序遍历"></a>递归+中序遍历</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    TreeNode* res;    <br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br><br>        <span class="hljs-built_in">inOrder</span>(root,p,q);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;<br><br>        <span class="hljs-comment">//当节点为空或者已经有结果,就不再递归深入</span><br>        <span class="hljs-keyword">if</span>(!root || res) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">bool</span> left = <span class="hljs-built_in">inOrder</span>(root-&gt;left,p,q);<span class="hljs-comment">//左子树中是否存在</span><br>        <span class="hljs-keyword">bool</span> right = <span class="hljs-built_in">inOrder</span>(root-&gt;right,p,q);<span class="hljs-comment">//右子树中是否存在</span><br>        <span class="hljs-keyword">bool</span> self = root == p || root == q;<span class="hljs-comment">//自己是否符合条件</span><br><br>        <span class="hljs-comment">//1.如果自己符合条件且左右子树有一个符合条件</span><br>        <span class="hljs-comment">//2.如果左右子树都符合条件</span><br>        <span class="hljs-keyword">if</span>((self &amp;&amp; (left || right)) || (left &amp;&amp; right)) res = root;<br>        <br>        <span class="hljs-keyword">return</span> self || left || right;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接中序遍历递归，每当递归深入到一个节点时，判断它是否是两点之一，或者它的左右子树是否拥有两个点之一即可。返回true表示以这个节点为根节点的子树拥有两个点之一。</p><h2 id="迭代-利用平衡二叉树的性质"><a href="#迭代-利用平衡二叉树的性质" class="headerlink" title="迭代+利用平衡二叉树的性质"></a>迭代+利用平衡二叉树的性质</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>            <span class="hljs-comment">//如果p,q都在当前节点的左边,将节点更换成节点的左孩子</span><br>            <span class="hljs-keyword">if</span>(p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) root = root-&gt;left;<br>            <span class="hljs-comment">//如果p,q都在当前节点的右边,将节点更换成节点的右孩子</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) root = root-&gt;right;<br>            <span class="hljs-comment">//p,q分散在节点两边,其中节点可以包含p或q</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>一开始没注意看到是平衡二叉树，利用平衡二叉树的性质即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
      <tag>中序遍历</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>236. 二叉树的最近公共祖先</title>
    <link href="/2021/12/09/LeetCode/236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2021/12/09/LeetCode/236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">本题链接</a></p><h2 id="递归-中序遍历"><a href="#递归-中序遍历" class="headerlink" title="递归+中序遍历"></a>递归+中序遍历</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    TreeNode* res;  <br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br><br>        <span class="hljs-built_in">inOrder</span>(root,p,q);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;<br><br>        <span class="hljs-comment">//当节点为空或者已经有结果,就不再递归深入</span><br>        <span class="hljs-keyword">if</span>(!root || res) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">bool</span> left = <span class="hljs-built_in">inOrder</span>(root-&gt;left,p,q);<span class="hljs-comment">//左子树中是否存在</span><br>        <span class="hljs-keyword">bool</span> right = <span class="hljs-built_in">inOrder</span>(root-&gt;right,p,q);<span class="hljs-comment">//右子树中是否存在</span><br>        <span class="hljs-keyword">bool</span> self = root == p || root == q;<span class="hljs-comment">//自己是否符合条件</span><br><br>        <span class="hljs-comment">//1.如果自己符合条件且左右子树有一个符合条件</span><br>        <span class="hljs-comment">//2.如果左右子树都符合条件</span><br>        <span class="hljs-keyword">if</span>((self &amp;&amp; (left || right)) || (left &amp;&amp; right)) res = root;<br>        <br>        <span class="hljs-keyword">return</span> self || left || right;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接中序遍历递归，每当递归深入到一个节点时，判断它是否是两点之一，或者它的左右子树是否拥有两个点之一即可。返回true表示以这个节点为根节点的子树拥有两个点之一。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
      <tag>中序遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24. 两两交换链表中的节点</title>
    <link href="/2021/12/09/LeetCode/24.%20%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2021/12/09/LeetCode/24.%20%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">本题链接</a></p><h2 id="迭代版"><a href="#迭代版" class="headerlink" title="迭代版"></a>迭代版</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(head== <span class="hljs-literal">nullptr</span> ||head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br><br>        <span class="hljs-function">ListNode <span class="hljs-title">dummy</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>        ListNode* node = &amp;dummy;<br>        ListNode* tmp;<br>        <span class="hljs-keyword">while</span>(head)&#123;<br><br>            <span class="hljs-keyword">if</span>(head-&gt;next == <span class="hljs-literal">nullptr</span>)&#123;<br>                node-&gt;next = head;<br>                <span class="hljs-keyword">return</span> dummy.next;<br>            &#125;<br><br>            tmp = head-&gt;next-&gt;next;<span class="hljs-comment">//保存下一个开始值</span><br>            node-&gt;next = head-&gt;next;<span class="hljs-comment">//串接到结果上</span><br>            node-&gt;next-&gt;next = head;<span class="hljs-comment">//反转</span><br>            node = node-&gt;next-&gt;next;<span class="hljs-comment">//设置下一次挂接的点</span><br>            head = tmp;<span class="hljs-comment">//设置下一个开始值</span><br><br>        &#125;<br>        node-&gt;next = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//避免回环</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>两两交换，需要注意的是记得保存结果对接点和节点为空的情况判断。</p><h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        <span class="hljs-comment">//递归基判断</span><br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span>(!head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment">//交换操作</span><br>        ListNode* ret = head-&gt;next;<br>        ListNode* tmp = head-&gt;next-&gt;next;<br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-built_in">swapPairs</span>(tmp);<br>        <span class="hljs-comment">//返回给上一个递归需要对接的节点</span><br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>与迭代版一样</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代</tag>
      
      <tag>递归</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>240. 搜索二维矩阵 II</title>
    <link href="/2021/12/09/LeetCode/240.%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%20II/"/>
    <url>/2021/12/09/LeetCode/240.%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%20II/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">本题链接</a></p><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br><br>       <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">int</span> row = matrix.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>,col = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> cow_border = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">while</span>(row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt;= cow_border)&#123;<br><br>            <span class="hljs-keyword">if</span>(matrix[row][col] &gt; target) --row;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[row][col] &lt; target) ++col;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一开始还想着根据行对列进行二分查找，但是使用二分查找非常容易越过可能的搜索区域。</p><p>后面发现只要从矩阵左下角，每次向上或向右遍历就可以遍历完整个矩阵。而且从左下角出发的优势在于，当前元素大于上面的元素且小于右边的元素，这样迭代就不会有两个方向，可以把搜索范围缩小。而如果从左上角开始，每次向下或向右遍历，虽然也能遍历完整个矩阵，但是由于当前元素同时小于下边和右边的元素，所以迭代会有两个方向，在不理想的情况下需要回溯处理。</p><p>同理，从右上角也可以开始。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>二维数组</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>242. 有效的字母异位词</title>
    <link href="/2021/12/09/LeetCode/242.%20%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
    <url>/2021/12/09/LeetCode/242.%20%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/valid-anagram/">本题链接</a></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() != t.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">int</span> arr[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-comment">//memset(arr,0,sizeof(arr));</span><br>        <br>        <span class="hljs-comment">//同时遍历两个数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();++i)&#123;<br>            ++arr[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            --arr[t[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br><br>        <span class="hljs-comment">//遍历结果</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">26</span>;++i)<br>            <span class="hljs-keyword">if</span>(arr[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果有非0出现,说明两个字符串中出现的字符数量不对等</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>该题主要是统计两个字符串中字母出现的频次，也可以用哈希表进行对比。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>257. 二叉树的所有路径</title>
    <link href="/2021/12/09/LeetCode/257.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"/>
    <url>/2021/12/09/LeetCode/257.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-paths/">本题链接</a></p><h2 id="DFS-递归"><a href="#DFS-递归" class="headerlink" title="DFS+递归"></a>DFS+递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    string s;<br>    vector&lt;string&gt; res;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* node)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//节点为空就返回</span><br><br>        string val_str = <span class="hljs-built_in">to_string</span>(node-&gt;val);<br>        s = s + val_str + <span class="hljs-string">&quot;-&gt;&quot;</span>;<span class="hljs-comment">//字符串拼接</span><br>        <span class="hljs-keyword">bool</span> bl_res;<br><br>        <span class="hljs-keyword">if</span>(((bl_res = <span class="hljs-built_in">dfs</span>(node-&gt;left)) == <span class="hljs-built_in">dfs</span>(node-&gt;right)) &amp;&amp; (bl_res == <span class="hljs-literal">false</span>))&#123;<span class="hljs-comment">//node为叶子节点</span><br><br>            s.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//&quot;&gt;&quot;</span><br>            s.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//&quot;-&quot;</span><br>            res.<span class="hljs-built_in">push_back</span>(s);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; val_str.<span class="hljs-built_in">size</span>();++i)<span class="hljs-comment">//&quot;&quot;</span><br>                s.<span class="hljs-built_in">pop_back</span>();<br>            <br>            <br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//node非叶子节点</span><br><br>           s.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//&quot;&gt;&quot;</span><br>           s.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//&quot;-&quot;</span><br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; val_str.<span class="hljs-built_in">size</span>();++i)<br>                s.<span class="hljs-built_in">pop_back</span>();<br>            <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对每一个节点进行DFS，然后每次进入一个节点就构造字符串，退出该节点的时候表示这个节点已经结束了，就把刚才构造的字符串取消掉。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>26. 删除有序数组中的重复项</title>
    <link href="/2021/12/09/LeetCode/26.%20%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <url>/2021/12/09/LeetCode/26.%20%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">本题链接</a></p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="版本一：从前至后"><a href="#版本一：从前至后" class="headerlink" title="版本一：从前至后"></a>版本一：从前至后</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">int</span> org = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> next = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(next &lt;= nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[org] == nums[next]) nums.<span class="hljs-built_in">erase</span>(nums.<span class="hljs-built_in">begin</span>()+next);<br>            <span class="hljs-keyword">else</span> &#123;++org;++next;&#125;<br>        &#125;<br><br><br>        <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>从前至后太慢了…vector的属性导致它删除会有$O(n)$的复杂度！</li></ul><h3 id="版本二：从后至前"><a href="#版本二：从后至前" class="headerlink" title="版本二：从后至前"></a>版本二：从后至前</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">int</span> org = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> prev = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">while</span>( prev &gt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[org] == nums[prev]) nums.<span class="hljs-built_in">erase</span>(nums.<span class="hljs-built_in">begin</span>() + prev);<br>            --org;<br>            --prev;<br>        &#125;<br><br><br>        <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用双指针判断前后两个值是否相等。</p><p>版本一和版本二的差距很明显：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/ea0f37690922c0803905879f8dbcd0cc-5bf58.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>263. 丑数</title>
    <link href="/2021/12/09/LeetCode/263.%20%E4%B8%91%E6%95%B0/"/>
    <url>/2021/12/09/LeetCode/263.%20%E4%B8%91%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/ugly-number/">本题链接</a></p><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isUgly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">while</span>(n % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>)&#123;<br>            n /= <span class="hljs-number">5</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(n % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>)&#123;<br>            n /= <span class="hljs-number">3</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>            n /= <span class="hljs-number">2</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接按照题目给的条件组成流程就行….</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>279. 完全平方数</title>
    <link href="/2021/12/09/LeetCode/279.%20%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <url>/2021/12/09/LeetCode/279.%20%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/perfect-squares/">本题链接</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,INT_MAX)</span></span>;<span class="hljs-comment">//dp[0] = 0;</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;++i)<span class="hljs-comment">//遍历1~n</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>;k*k &lt;= i;++k)<br>                dp[i] = <span class="hljs-built_in">min</span>(dp[i],dp[i - k*k] + <span class="hljs-number">1</span>);<br>      <br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据题意推出状态方程：</p><script type="math/tex; mode=display">dp[i] = min(dp[i],dp[i - k^2]+1)</script><p>其中，$dp[i]$表示i需要的最少的完全平方数数量，$dp[i - k^2]+1$中，1表示$k^2$的数量。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>283. 移动零</title>
    <link href="/2021/12/09/LeetCode/283.%20%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <url>/2021/12/09/LeetCode/283.%20%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/move-zeroes/">本题链接</a></p><h2 id="双指针-就地算法"><a href="#双指针-就地算法" class="headerlink" title="双指针+就地算法"></a>双指针+就地算法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> pos_insert = <span class="hljs-number">0</span>,i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>( i &lt; nums.<span class="hljs-built_in">size</span>())&#123;<br><br>            <span class="hljs-keyword">if</span>( nums[i] != <span class="hljs-number">0</span>) <span class="hljs-built_in">swap</span>(nums[pos_insert++], nums[i++]);<br>            <span class="hljs-keyword">else</span> ++i;<br><br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><code>pos_insert</code>指针指向需要插入的地方，另一根<code>i</code>指针遍历数组，找到非零就插入到<code>pos_insert</code>指向的地方。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>就地算法</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. 无重复字符的最长子串</title>
    <link href="/2021/12/09/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2021/12/09/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">本题链接</a></p><h2 id="哈希表-队列"><a href="#哈希表-队列" class="headerlink" title="哈希表+队列"></a>哈希表+队列</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">size</span>();<br><br>        unordered_set&lt;<span class="hljs-keyword">char</span>&gt; hash;<br>        queue&lt;<span class="hljs-keyword">char</span>&gt; que;<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">find</span>(s[i]) == hash.<span class="hljs-built_in">end</span>())&#123;<span class="hljs-comment">//如果队列里没有该字符</span><br>                hash.<span class="hljs-built_in">emplace</span>(s[i]);<span class="hljs-comment">//将该字符加入哈希表</span><br>                que.<span class="hljs-built_in">push</span>(s[i]);<span class="hljs-comment">//将该字符加入队列</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                <span class="hljs-keyword">if</span>(que.<span class="hljs-built_in">size</span>() &gt; res) res = que.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//更新长度</span><br>  <br>                <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>() &amp;&amp; que.<span class="hljs-built_in">front</span>() != s[i])&#123;<span class="hljs-comment">//直到队列中重复字母的前一个字符</span><br>                    hash.<span class="hljs-built_in">erase</span>(que.<span class="hljs-built_in">front</span>());<span class="hljs-comment">//将字符从哈希表中去除</span><br>                    que.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//将该元素出队</span><br>                &#125;<br>                que.<span class="hljs-built_in">push</span>(que.<span class="hljs-built_in">front</span>());que.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//将该元素从队头更换至队尾</span><br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(que.<span class="hljs-built_in">size</span>() &gt; res) res = que.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>保持队列里的连续字串没有重复字母</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>字符串</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>303. 区域和检索 - 数组不可变</title>
    <link href="/2021/12/09/LeetCode/303.%20%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
    <url>/2021/12/09/LeetCode/303.%20%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">本题链接</a></p><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumArray</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NumArray</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums):<span class="hljs-built_in">res_vec</span>(nums)&#123;<br>       <span class="hljs-comment">//计算数组每个位置的总和</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>           res_vec[i] += res_vec[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; left, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; right)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> res_vec[right] - (left - <span class="hljs-number">0</span> ? res_vec[left<span class="hljs-number">-1</span>] : <span class="hljs-number">0</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res_vec;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumArray* obj = new NumArray(nums);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;sumRange(left,right);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><p>改进：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumArray</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NumArray</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums):<span class="hljs-built_in">res_vec</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;(nums.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>,<span class="hljs-number">0</span>))&#123;<br>       <span class="hljs-comment">//计算数组每个位置的前缀和</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>           res_vec[i + <span class="hljs-number">1</span>] = res_vec[i] + nums[i];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; left, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; right)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> res_vec[right+<span class="hljs-number">1</span>] - res_vec[left];<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res_vec;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumArray* obj = new NumArray(nums);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;sumRange(left,right);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于题目中的sumRange方法会大量调用，所以在sumRange中临时计算会非常耗时。所以可以事先求出数组中每个数的前缀和，在sumRange调用时返回就行。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>304. 二维区域和检索 - 矩阵不可变</title>
    <link href="/2021/12/09/LeetCode/304.%20%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
    <url>/2021/12/09/LeetCode/304.%20%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">本题链接</a></p><h2 id="积分图"><a href="#积分图" class="headerlink" title="积分图"></a>积分图</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumMatrix</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix) &#123;<br><br>        <span class="hljs-comment">//积分图初始化:在上面和左侧额外添加0,以避免额外的重复判断,空间复杂度依然为O(n)</span><br>        integral = vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;(matrix.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;(matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">1</span>;r &lt; integral.<span class="hljs-built_in">size</span>();++r)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">1</span>;c &lt; integral[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();++c)&#123;<br>                <span class="hljs-comment">//计算每个方块到[0,0]的积分</span><br>                integral[r][c] = integral[r<span class="hljs-number">-1</span>][c] + integral[r][c<span class="hljs-number">-1</span>] + matrix[r<span class="hljs-number">-1</span>][c<span class="hljs-number">-1</span>] - integral[r<span class="hljs-number">-1</span>][c<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; row1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; col1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; row2, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; col2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> integral[row2 + <span class="hljs-number">1</span>][col2 + <span class="hljs-number">1</span>] - integral[row1][col2 + <span class="hljs-number">1</span>] - integral[row2 + <span class="hljs-number">1</span>][col1] + integral[row1][col1];<br>    &#125;   <br><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; integral;<span class="hljs-comment">//积分图</span><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumMatrix object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumMatrix* obj = new NumMatrix(matrix);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;sumRegion(row1,col1,row2,col2);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在积分图中计算每个方块到$[0,0]$的积分，即当前积分=当前坐标的数字+上面长方形的数字和+左边长方形的数字和-上面长方形和左边长方形重合面积。求出某个区域的积分也是同理，只是前者求积分的逆过程。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二维数组</tag>
      
      <tag>矩阵</tag>
      
      <tag>积分图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>318. 最大单词长度乘积</title>
    <link href="/2021/12/09/LeetCode/318.%20%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/"/>
    <url>/2021/12/09/LeetCode/318.%20%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/">本题链接</a></p><h2 id="位运算-哈希表"><a href="#位运算-哈希表" class="headerlink" title="位运算+哈希表"></a>位运算+哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;<br><br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; hash;<br><br>        <span class="hljs-comment">//对每一个字符串建立在哈希表中的映射</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; s : words)&#123;<br>            <span class="hljs-comment">//mask用来表现字符串中出现过的字母</span><br>            <span class="hljs-keyword">int</span> mask = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> size = s.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; c : s)<br>                mask |= <span class="hljs-number">1</span> &lt;&lt; (c-<span class="hljs-string">&#x27;a&#x27;</span>);<br>            <span class="hljs-comment">//同个mask下选取一个最大的size</span><br>            <span class="hljs-comment">//比如aasd和asd中,选择aasd的size</span><br>            hash[mask] = <span class="hljs-built_in">max</span>(hash[mask],size);<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; [mask1,size1] : hash)<span class="hljs-comment">//选取第一个值</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; [mask2,size2] : hash)<span class="hljs-comment">//选取第二个值</span><br>                <span class="hljs-keyword">if</span>(!(mask1 &amp; mask2)) <span class="hljs-comment">//如果两者没有公共的字母</span><br>                    res = <span class="hljs-built_in">max</span>(res,size1*size2);<span class="hljs-comment">//那么选取一个最大的结果</span><br>            <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于题目已经约定都是小写字母，数量是26个，那么可以用一个32位的整数来表示在一个字符串中，哪些字符出现过。</p><script type="math/tex; mode=display">mask |= 1 << (c-'a')</script><p>其中，<code>c-&#39;a&#39;</code>表示1需要向左移动几位，1左移后，与mask相或，就可以在mask中的相应位置1。</p><p>之后在哈希表中对<code>size</code>两两相乘，选取一个最大的结果。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>326. 3的幂</title>
    <link href="/2021/12/09/LeetCode/326.%203%E7%9A%84%E5%B9%82/"/>
    <url>/2021/12/09/LeetCode/326.%203%E7%9A%84%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/power-of-three/">本题链接</a></p><h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPowerOfThree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">1162261467</span> % n == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>在int范围内3的最大次方是3^19 = 1162261467，如果n是3的整数次方，那么1162261467除以n的余数一定是0；反之亦然。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>328. 奇偶链表</title>
    <link href="/2021/12/09/LeetCode/328.%20%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/12/09/LeetCode/328.%20%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">本题链接</a></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">oddEvenList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        <span class="hljs-comment">//异常情况</span><br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">if</span>(!head-&gt;next) <span class="hljs-keyword">return</span> head;<br><br>        <span class="hljs-comment">//初始化</span><br>        <span class="hljs-function">ListNode <span class="hljs-title">odd_head</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;ListNode* odd_node = &amp;odd_head;<span class="hljs-comment">//奇数链表</span><br>        <span class="hljs-function">ListNode <span class="hljs-title">even_head</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;ListNode* even_node = &amp;even_head;<span class="hljs-comment">//偶数链表</span><br>        <span class="hljs-comment">//预处理</span><br>        odd_node-&gt;next = head;odd_node = odd_node-&gt;next;<span class="hljs-comment">//odd_node指向第一个奇数节点</span><br>        even_node-&gt;next = head-&gt;next;even_node = even_node-&gt;next;<span class="hljs-comment">//even_node指向第一个偶数节点</span><br><br>        <span class="hljs-keyword">while</span>(even_node)&#123;<br><br>            <span class="hljs-keyword">if</span>(!even_node-&gt;next) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//如果是奇数位置为空</span><br><br>            <span class="hljs-comment">//找到下一个奇数</span><br>            odd_node-&gt;next = even_node-&gt;next;<span class="hljs-comment">//将奇数节点串接</span><br>            odd_node = odd_node-&gt;next;<span class="hljs-comment">//奇数指针往前移</span><br>            <span class="hljs-comment">//找到下一个偶数</span><br>            even_node-&gt;next = odd_node-&gt;next;<span class="hljs-comment">//将偶数节点串接</span><br>            even_node = even_node-&gt;next;<span class="hljs-comment">//偶数指针往前移</span><br>        &#125;<br><br>        <span class="hljs-comment">//将偶数链表挂到奇数链表后面</span><br>        odd_node-&gt;next = even_head.next;<br><br>        <span class="hljs-keyword">return</span> odd_head.next;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用奇偶链表分别挂接奇偶节点，最后再将偶链表接到奇链表的后头就行。代码还可以优化，奇偶链表其实不是必须的，只要每次挂接的时候保持第一个偶数节点在最后一个奇数节点的后头就行。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>332. 重新安排行程</title>
    <link href="/2021/12/09/LeetCode/332.%20%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B/"/>
    <url>/2021/12/09/LeetCode/332.%20%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reconstruct-itinerary/">本题链接</a></p><h2 id="哈希表-栈"><a href="#哈希表-栈" class="headerlink" title="哈希表+栈"></a>哈希表+栈</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br><br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">res</span><span class="hljs-params">(tickets.size()+<span class="hljs-number">1</span>,<span class="hljs-string">&quot;&quot;</span>)</span></span>;<br>        unordered_map&lt;string,multiset&lt;string&gt;&gt; hash;<br>        <span class="hljs-comment">//将机票映射到hash中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; tickets.<span class="hljs-built_in">size</span>();++i)<br>            hash[tickets[i][<span class="hljs-number">0</span>]].<span class="hljs-built_in">insert</span>(tickets[i][<span class="hljs-number">1</span>]);<br>            <br>        stack&lt;string&gt; s;<br>        s.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;JFK&quot;</span>);<br>        <span class="hljs-keyword">int</span> pos = res.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())&#123;<br><br>            string next = s.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span>(!hash[next].<span class="hljs-built_in">empty</span>())&#123;<span class="hljs-comment">//如果非空,说明还能飞</span><br>                s.<span class="hljs-built_in">push</span>(*(hash[next].<span class="hljs-built_in">begin</span>()));<br>                hash[next].<span class="hljs-built_in">erase</span>(hash[next].<span class="hljs-built_in">begin</span>());<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果为空,说明已经没法继续飞了</span><br>                res[pos--] = s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先将每张机票的起点和终点设置映射关系，由于一个起点会对应多个终点，所以在<code>unordered_map</code>中使用<code>multiset&lt;string&gt;</code>存放多个终点。</p><p>之后维护一个栈，每次都寻找从栈顶元素出发的终点。若没有找到，说明这个栈顶元素已经无法继续飞了，就将栈顶元素弹出，存放到结果数组中。若还能继续飞，那么就将终点入栈，并把这个终点从映射表中删除。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>33. 搜索旋转排序数组</title>
    <link href="/2021/12/09/LeetCode/33.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2021/12/09/LeetCode/33.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">本题链接</a></p><h2 id="二分搜索-分治"><a href="#二分搜索-分治" class="headerlink" title="二分搜索+分治"></a>二分搜索+分治</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,mid;<br><br>        <span class="hljs-comment">//分情况讨论</span><br>        <span class="hljs-keyword">if</span>(target &gt; nums[<span class="hljs-number">0</span>])&#123;<span class="hljs-comment">//如果target在断层前</span><br><br>            <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br><br>                mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(nums[mid] &gt;= nums[left])&#123;<span class="hljs-comment">//[left,right)区间连续</span><br><br>                    <span class="hljs-keyword">if</span>(target &lt; nums[mid]) right = mid - <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &gt; nums[mid]) left = mid + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br><br>                &#125;<span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>;<span class="hljs-comment">//[left,right)区间不连续</span><br>                <br>            &#125;<br><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &lt; nums[<span class="hljs-number">0</span>])&#123;<span class="hljs-comment">//如果target在断层后</span><br><br>            <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br><br>                mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(nums[mid] &lt; nums[right])&#123;<span class="hljs-comment">//[left,right)区间连续</span><br><br>                    <span class="hljs-keyword">if</span>(target &lt; nums[mid]) right = mid - <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &gt; nums[mid]) left = mid + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br><br>                &#125;<span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//[left,right)区间不连续</span><br>            &#125;<br><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//直接命中</span><br>        <br>        <span class="hljs-keyword">return</span> nums[left] == target ? left:<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>整体复杂度已经达到进阶的$O(log_2{n})$​​。先满足[left,right)区间连续，再使用正常的二分搜索就行。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>二分搜索</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>338. 比特位计数</title>
    <link href="/2021/12/09/LeetCode/338.%20%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/"/>
    <url>/2021/12/09/LeetCode/338.%20%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/counting-bits/">本题链接</a></p><h2 id="位运算-动态规划"><a href="#位运算-动态规划" class="headerlink" title="位运算+动态规划"></a>位运算+动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;++i)&#123;<br><br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//如果是偶数</span><br>                dp[i] = dp[i/<span class="hljs-number">2</span>];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果是奇数</span><br>                dp[i] = dp[i/<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于偶数，一个数乘2等同于它左移一位，比特位的1的个数不变。</p><p>对于奇数，等于比他小的第一个偶数再加上1。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>340. 至多包含 K 个不同字符的最长子串</title>
    <link href="/2021/12/09/LeetCode/340.%20%E8%87%B3%E5%A4%9A%E5%8C%85%E5%90%AB%20K%20%E4%B8%AA%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2021/12/09/LeetCode/340.%20%E8%87%B3%E5%A4%9A%E5%8C%85%E5%90%AB%20K%20%E4%B8%AA%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-k-distinct-characters/">本题链接</a></p><h2 id="暴力-双指针-超时"><a href="#暴力-双指针-超时" class="headerlink" title="暴力+双指针(超时)"></a>暴力+双指针(超时)</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstringKDistinct</span><span class="hljs-params">(string s, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span> &amp;&amp; k &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> k;<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">int</span> org = <span class="hljs-number">0</span>,next = <span class="hljs-number">0</span>,cnt = k,max = <span class="hljs-number">0</span>;<br>        set&lt;<span class="hljs-keyword">char</span>&gt; c_set;<br><br>        <span class="hljs-keyword">for</span>(;org &lt; s.<span class="hljs-built_in">size</span>() - max &amp;&amp; next &lt;  s.<span class="hljs-built_in">size</span>(); ++next)&#123;<br>            <br>            <span class="hljs-keyword">if</span>( c_set.<span class="hljs-built_in">find</span>(s[next]) == c_set.<span class="hljs-built_in">end</span>() )<span class="hljs-comment">//不存在</span><br>            &#123;  <br>                <span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">0</span>)&#123;<br><br>                    <span class="hljs-keyword">if</span>((next  - org) &gt; max) max = next - org;<br>                    next = ++org;<br>                    next--;<br>                    c_set.<span class="hljs-built_in">clear</span>();<br>                    cnt = k;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                c_set.<span class="hljs-built_in">insert</span>(s[next]);<br>                cnt--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>((next  - org) &gt; max) max = next - org;<br><br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>保证在org和next指针之间的字符数量不会超过k，若超过便移动org指针。以此反复迭代查找最大字串。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>342. 4的幂</title>
    <link href="/2021/12/09/LeetCode/342.%204%E7%9A%84%E5%B9%82/"/>
    <url>/2021/12/09/LeetCode/342.%204%E7%9A%84%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/power-of-four/">本题链接</a></p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPowerOfFour</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-comment">//如果n小于0或者n中比特位的1不止一个</span><br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span> || n &amp; (n - <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//相与若为0,则不是4的幂次方</span><br>        <span class="hljs-keyword">return</span> n &amp; <span class="hljs-number">0x55555555</span>;<br>        <span class="hljs-comment">// return num % 3 == 1;也可以</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为4的幂在比特位的形式上与2的幂相似，都是二进制中只有一个1，然后这个1一定待在比特位的奇数位上。所以可以用10101…10101这种形式的与它相与，若结果不为0，说明就是4的幂。</p><p>另外，对于<code>return num % 3 == 1</code>的解释如下：</p><blockquote><p>由于 4=3+1， 那么4的N次方就是（3+1）^N，尝试展开多项式，比如(3+1)^2 =(3+1)<em>(3+1)，除了1</em>1以外永远都有3相乘，再展开3次方，(3+1)<em>(3+1)</em>(3+1)，结论一致，除了结尾的1都有3相乘，因此可以有结论，一个数的N次方-1总能除尽比这个数小1的数。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>344. 反转字符串</title>
    <link href="/2021/12/09/LeetCode/344.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2021/12/09/LeetCode/344.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-string/">本题链接</a></p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">char</span>&gt;&amp; s)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> r = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(r &gt;= l)&#123;<br>            <span class="hljs-built_in">swap</span>(s[l++],s[r--]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用双指针，每次迭代一前一后往中间靠拢并交换。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>347. 前 K 个高频元素</title>
    <link href="/2021/12/09/LeetCode/347.%20%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
    <url>/2021/12/09/LeetCode/347.%20%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">本题链接</a></p><h2 id="计数排序-map"><a href="#计数排序-map" class="headerlink" title="计数排序+map"></a>计数排序+map</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-comment">//计数排序</span><br>        map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; i_map;<br>        <span class="hljs-comment">//先存放数组到map中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">if</span>(i_map.<span class="hljs-built_in">find</span>(nums[i]) == i_map.<span class="hljs-built_in">end</span>()) i_map.<span class="hljs-built_in">insert</span>(&#123;nums[i],<span class="hljs-number">1</span>&#125;);<br>            <span class="hljs-keyword">else</span> ++i_map[nums[i]];<br>        &#125;<br><br>        <span class="hljs-comment">//将i_map的key和value对调放入一个新的multimap</span><br>        multimap&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; res_map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; pair:i_map)&#123;<br>            res_map.<span class="hljs-built_in">insert</span>(&#123;pair.second,pair.first&#125;);<br>        &#125;<br><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res_vec;<br>        <span class="hljs-comment">//逆向</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i = res_map.<span class="hljs-built_in">rbegin</span>();i != res_map.<span class="hljs-built_in">rend</span>() &amp;&amp; --k &gt;= <span class="hljs-number">0</span>;++i)&#123;<br>            res_vec.<span class="hljs-built_in">push_back</span>((*i).second);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res_vec;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用map存储每个数的出现次数，然后再使用multimap存储每种出现次数的数，最后遍历multimap取值即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>数组</tag>
      
      <tag>计数排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>384. 打乱数组</title>
    <link href="/2021/12/09/LeetCode/384.%20%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/"/>
    <url>/2021/12/09/LeetCode/384.%20%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/shuffle-an-array/">本题链接</a></p><h2 id="Fisher-Yates洗牌算法"><a href="#Fisher-Yates洗牌算法" class="headerlink" title="Fisher-Yates洗牌算法"></a>Fisher-Yates洗牌算法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; origin;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums):<span class="hljs-built_in">origin</span>(<span class="hljs-built_in">move</span>(nums)) &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-comment">/** Resets the array to its original configuration and return it. */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> origin;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns a random shuffling of the array. */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">shuffle</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(origin.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">shuffled</span><span class="hljs-params">(origin)</span></span>;<br><br>        <span class="hljs-comment">//正向</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; shuffled.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-built_in">swap</span>(shuffled[i],shuffled[<span class="hljs-built_in">rand</span>() % (i + <span class="hljs-number">1</span>)]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> shuffled;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Solution object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Solution* obj = new Solution(nums);</span><br><span class="hljs-comment"> * vector&lt;int&gt; param_1 = obj-&gt;reset();</span><br><span class="hljs-comment"> * vector&lt;int&gt; param_2 = obj-&gt;shuffle();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用Fisher-Yates洗牌算法，通过随机交换位置来实现随机打乱。正向遍历或反向遍历数组进行打乱皆可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fisher-Yates洗牌算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>406. 根据身高重建队列</title>
    <link href="/2021/12/09/LeetCode/406.%20%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/"/>
    <url>/2021/12/09/LeetCode/406.%20%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">本题链接</a></p><h2 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; people) &#123;<br><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>        <br>    <br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(),people.<span class="hljs-built_in">end</span>(),[](vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; a,vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; b)&#123;<br>            <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br>        &#125;);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; people.<span class="hljs-built_in">size</span>(); i++) <br>            res.<span class="hljs-built_in">insert</span>(res.<span class="hljs-built_in">begin</span>() + people[i][<span class="hljs-number">1</span>],people[i]);<br>            <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>思路：根据题意，在对people数组排序的时候，让最高的并且前面人数最少的那个人，排在前面就行。然后根据people顺序依次插入数组即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>413. 等差数列划分</title>
    <link href="/2021/12/09/LeetCode/413.%20%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/"/>
    <url>/2021/12/09/LeetCode/413.%20%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/arithmetic-slices/">本题链接</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">int</span> prevInt;<br>    <span class="hljs-keyword">int</span> midInt;<br>    <span class="hljs-keyword">int</span> pos;<br>&#125;num_pair;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numberOfArithmeticSlices</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <br>        <br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        vector&lt;num_pair&gt; dp;<br>        <br>        <span class="hljs-comment">//分离</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;++i)<br>            <span class="hljs-keyword">if</span>((nums[i<span class="hljs-number">-1</span>] - nums[i]) == (nums[i] - nums[i+<span class="hljs-number">1</span>]))<br>                dp.<span class="hljs-built_in">push_back</span>(num_pair&#123;nums[i],nums[i+<span class="hljs-number">1</span>],i+<span class="hljs-number">1</span>&#125;);<br><br>        <span class="hljs-comment">//合并</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; dp.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            <span class="hljs-keyword">if</span>(dp[i].pos == nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(dp[i].prevInt - dp[i].midInt == dp[i].midInt - nums[dp[i].pos+<span class="hljs-number">1</span>])<br>                dp.<span class="hljs-built_in">push_back</span>(num_pair&#123;dp[i].midInt,nums[dp[i].pos+<span class="hljs-number">1</span>],dp[i].pos+<span class="hljs-number">1</span>&#125;);<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">size</span>();<br>            <br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先将整个数组分离出<strong>最小</strong>的子数组，然后依次放入<strong>dp</strong>数组中。之后每次从<strong>dp</strong>数组拿出一个子数组，只要这个子数组的后两位与原数组中某个位置上的数组成等差数列，且这个位置正好是这个子数组中的最后一个数的下一位，那么又构成了一个新的子数组…..一直迭代，直到遍历到<strong>dp</strong>数组的最后一个。</p><p>观察后发现，每次迭代使用的数只有子数组的最后两位，还有就是子数组最后一位在原数组中的位置，那么只需要将这三个关键的点存储起来用于比较即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>415. 字符串相加</title>
    <link href="/2021/12/09/LeetCode/415.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/"/>
    <url>/2021/12/09/LeetCode/415.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/add-strings/">本题链接</a></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">addStrings</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br><br>        <span class="hljs-comment">//异常情况</span><br>        <span class="hljs-keyword">if</span>(!num1.<span class="hljs-built_in">size</span>() &amp;&amp; !num2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span>(!num1.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> num2;<span class="hljs-comment">//如果num1为空</span><br>        <span class="hljs-keyword">if</span>(!num2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> num1;<span class="hljs-comment">//如果num2为空</span><br>        <span class="hljs-comment">//预处理</span><br>        <span class="hljs-keyword">int</span> max_size = <span class="hljs-built_in">max</span>(num1.<span class="hljs-built_in">size</span>(),num2.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-function">string <span class="hljs-title">res</span><span class="hljs-params">(max_size + <span class="hljs-number">1</span>,<span class="hljs-string">&#x27;0&#x27;</span>)</span></span>;<br>        <span class="hljs-comment">//统一num1和num2的长度</span><br>        <span class="hljs-keyword">if</span>(num1.<span class="hljs-built_in">size</span>() == max_size) num2 = <span class="hljs-built_in">string</span>(max_size - num2.<span class="hljs-built_in">size</span>(),<span class="hljs-string">&#x27;0&#x27;</span>) + num2;<br>        <span class="hljs-keyword">else</span> num1 = <span class="hljs-built_in">string</span>(max_size - num1.<span class="hljs-built_in">size</span>(),<span class="hljs-string">&#x27;0&#x27;</span>) + num1;<br>        <span class="hljs-comment">//下标</span><br>        <span class="hljs-keyword">int</span> num1_index = num1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> num2_index = num2.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> res_index = res.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> dig = <span class="hljs-number">0</span>;<span class="hljs-comment">//进位</span><br><br>        <span class="hljs-keyword">while</span>(res_index &gt; <span class="hljs-number">0</span>)&#123;<br><br>            <span class="hljs-keyword">int</span> cur_dig = (num1[num1_index] - <span class="hljs-string">&#x27;0&#x27;</span>) +<br>                          (num2[num2_index] - <span class="hljs-string">&#x27;0&#x27;</span>) +<br>                          dig;<br><br>            <span class="hljs-keyword">if</span>(cur_dig &gt;= <span class="hljs-number">10</span>)&#123;<span class="hljs-comment">//如果有进位</span><br>                dig = <span class="hljs-number">1</span>;<br>                res[res_index] = (cur_dig % <span class="hljs-number">10</span>) + <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果没有进位</span><br>                dig = <span class="hljs-number">0</span>;<br>                res[res_index] = cur_dig + <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br><br>            res_index--;num1_index--;num2_index--;<br>        &#125;<br><br>        <span class="hljs-comment">//判断最后是否需要进位</span><br>        dig == <span class="hljs-number">1</span> ? res[res_index] = <span class="hljs-string">&#x27;1&#x27;</span> : ++res_index;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>(res.<span class="hljs-built_in">begin</span>()+res_index,res.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路就是模拟两个整数的加法操作，关键点在于需要保存<strong>进位</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>42. 接雨水</title>
    <link href="/2021/12/09/LeetCode/42.%20%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <url>/2021/12/09/LeetCode/42.%20%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/trapping-rain-water/">本题链接</a></p><h2 id="暴力-单指针"><a href="#暴力-单指针" class="headerlink" title="暴力+单指针"></a>暴力+单指针</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; height)</span> </span>&#123;<br><br><span class="hljs-keyword">if</span> (height.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> n = height.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">int</span> l_max = height[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> r_max = height[n - <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        l_max = <span class="hljs-built_in">max</span>(l_max, height[left]);<br>        r_max = <span class="hljs-built_in">max</span>(r_max, height[right]);<br><br>        <span class="hljs-comment">// ans += min(l_max, r_max) - height[i]</span><br>        <span class="hljs-keyword">if</span> (l_max &lt; r_max) &#123;<br>            ans += l_max - height[left];<br>            left++; <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans += r_max - height[right];<br>            right--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a26b608a43eeafca4a79a91a35564a8a-92b3c.png"  /></p><p>依靠一根指针，在每一层找到头尾两根柱子，找到后再往上一层。这样做的用意是找到图中白色区域的数量。</p><p>最后的结果就是这个图中去掉白色和黑色的大小。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>435. 无重叠区间</title>
    <link href="/2021/12/09/LeetCode/435.%20%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/"/>
    <url>/2021/12/09/LeetCode/435.%20%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">本题链接</a></p><h2 id="暴力-贪心"><a href="#暴力-贪心" class="headerlink" title="暴力+贪心"></a>暴力+贪心</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;<br><br>        <span class="hljs-comment">//异常处理</span><br>        <span class="hljs-keyword">if</span>(intervals.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">//预处理 排序</span><br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(),intervals.<span class="hljs-built_in">end</span>(),[](vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; a,vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; b)&#123; <br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>        &#125;);<br><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> hi = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>( intervals[i][<span class="hljs-number">0</span>] &lt; hi) <span class="hljs-comment">//重叠</span><br>                &#123;count+=<span class="hljs-number">1</span>;&#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                hi = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> count;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>思路：题目的意思其实就是让区间的数量最大。那么可以通过右边界排序，每次迭代让最小的右边界尽量靠左边，在右侧最大可能的腾出位置。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>贪心</tag>
      
      <tag>区间</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>437. 路径总和 III</title>
    <link href="/2021/12/09/LeetCode/437.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III/"/>
    <url>/2021/12/09/LeetCode/437.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/path-sum-iii/">本题链接</a></p><h2 id="层次遍历-dfs"><a href="#层次遍历-dfs" class="headerlink" title="层次遍历+dfs"></a>层次遍历+dfs</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    queue&lt;TreeNode*&gt; node_tree;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> count;<br>        node_tree.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!node_tree.<span class="hljs-built_in">empty</span>())&#123;<span class="hljs-comment">//层次遍历</span><br><br>            TreeNode* node = node_tree.<span class="hljs-built_in">front</span>();<br>            <span class="hljs-keyword">if</span>(node-&gt;left) node_tree.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            <span class="hljs-keyword">if</span>(node-&gt;right) node_tree.<span class="hljs-built_in">push</span>(node-&gt;right);<br><br>            <span class="hljs-built_in">dfs</span>(node_tree.<span class="hljs-built_in">front</span>(),targetSum);<br><br>            node_tree.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-comment">//深度优先搜索</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; target)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(target == root-&gt;val) ++count;<br>        <br>        <span class="hljs-built_in">dfs</span>(root-&gt;left,target - root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right,target - root-&gt;val);<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在层次遍历中，将每个节点都视作根节点，然后向下递归找到符合条件的节点。很直观，但是太慢了。</p><h2 id="双重递归"><a href="#双重递归" class="headerlink" title="双重递归"></a>双重递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">//从这里开始的节点视为根节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; targetSum)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pathSum</span>(root-&gt;left,targetSum) + <span class="hljs-comment">//以左孩子开始</span><br>        <span class="hljs-built_in">pathSum</span>(root-&gt;right,targetSum) + <span class="hljs-comment">//以右孩子开始</span><br>        <span class="hljs-built_in">sum</span>(root,targetSum);<span class="hljs-comment">//递归自己</span><br>               <br>    &#125;<br><br>    <span class="hljs-comment">//从这里开始的节点视作参与结果统计的节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; targetSum)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">return</span> (targetSum == root-&gt;val ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>) + <span class="hljs-comment">//判断自己是否符合</span><br>            <span class="hljs-built_in">sum</span>(root-&gt;left,targetSum - root-&gt;val) + <span class="hljs-comment">//将左孩子加入结果统计</span><br>            <span class="hljs-built_in">sum</span>(root-&gt;right,targetSum - root-&gt;val); <span class="hljs-comment">//将右孩子加入结果统计</span><br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>使用双重递归，思路更加的清晰，但是复杂度依旧很高</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>层序遍历</tag>
      
      <tag>二叉树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>双重递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>448. 找到所有数组中消失的数字</title>
    <link href="/2021/12/09/LeetCode/448.%20%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2021/12/09/LeetCode/448.%20%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">本题链接</a></p><h2 id="就地-数组下标"><a href="#就地-数组下标" class="headerlink" title="就地+数组下标"></a>就地+数组下标</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findDisappearedNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>            nums[<span class="hljs-built_in">abs</span>(nums[i]) - <span class="hljs-number">1</span>] = -<span class="hljs-built_in">abs</span>(nums[<span class="hljs-built_in">abs</span>(nums[i]) - <span class="hljs-number">1</span>]);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">1</span>);<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>很简单，就是依靠数组的下标和数组元素的正负值来判断数组下标的这个数有没有出现，算一个小技巧，没有额外空间。也可以直接用哈希表，不过这样有额外空间。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>就地算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>451. 根据字符出现频率排序</title>
    <link href="/2021/12/09/LeetCode/451.%20%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/12/09/LeetCode/451.%20%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">本题链接</a></p><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">frequencySort</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-comment">//计数排序</span><br>        map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; i_map;<br>        <span class="hljs-comment">//先存放字符串中字符出现的次数到map中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">if</span>(i_map.<span class="hljs-built_in">find</span>(s[i]) == i_map.<span class="hljs-built_in">end</span>()) i_map.<span class="hljs-built_in">insert</span>(&#123;s[i],<span class="hljs-number">1</span>&#125;);<br>            <span class="hljs-keyword">else</span> ++i_map[s[i]];<br>        &#125;<br><br>        <span class="hljs-comment">//将i_map的key和value对调放入一个新的multimap</span><br>        multimap&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">char</span>&gt; res_map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; pair:i_map)&#123;<br>            res_map.<span class="hljs-built_in">insert</span>(&#123;pair.second,pair.first&#125;);<br>        &#125;<br><br>        string res_str;<br>        <span class="hljs-comment">//逆向</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i = res_map.<span class="hljs-built_in">rbegin</span>();i != res_map.<span class="hljs-built_in">rend</span>();++i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = (*i).first;k &gt; <span class="hljs-number">0</span>;--k)<br>                res_str.<span class="hljs-built_in">push_back</span>((*i).second);<br>            <br>        <span class="hljs-keyword">return</span> res_str;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先存放字符出现的次数到map中，然后将map的key和value对调存入multimap，利用multimap的性质从multimap的逆迭代器开始遍历构造结果字符串。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>计数排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>452. 用最少数量的箭引爆气球</title>
    <link href="/2021/12/09/LeetCode/452.%20%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/"/>
    <url>/2021/12/09/LeetCode/452.%20%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">本题链接</a></p><h2 id="暴力-贪心"><a href="#暴力-贪心" class="headerlink" title="暴力+贪心"></a>暴力+贪心</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br><br>        <span class="hljs-comment">//异常处理</span><br>        <span class="hljs-keyword">if</span>(points.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//预处理 排序</span><br>    <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(),points.<span class="hljs-built_in">end</span>(),[](vector&lt;<span class="hljs-keyword">int</span>&gt; x,vector&lt;<span class="hljs-keyword">int</span>&gt; y)&#123;<span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>] &lt; y[<span class="hljs-number">1</span>];&#125;);<br><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> hi = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; points.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(points[i][<span class="hljs-number">0</span>] &gt; hi)<br>            &#123;<br>                count +=<span class="hljs-number">1</span>;<br>                hi = points[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>画图得到只要多个气球的左边界集中在某个区域，那么就可以一箭射穿。那么就先按照气球的右边界进行排序，然后每次从最小右边界的气球开始，判断其他气球的左边界是否小于该气球的右边界即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>贪心</tag>
      
      <tag>区间</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>455. 分发饼干</title>
    <link href="/2021/12/09/LeetCode/455.%20%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/"/>
    <url>/2021/12/09/LeetCode/455.%20%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/assign-cookies/">本题链接</a></p><h1 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a>455. 分发饼干</h1><h2 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; g, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; s)</span> </span>&#123;<br><br>        <span class="hljs-comment">//预处理</span><br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">//排序</span><br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(),g.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">int</span>&amp; x,<span class="hljs-keyword">int</span>&amp; y)&#123; <span class="hljs-keyword">return</span> x &lt; y;&#125;);<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">int</span>&amp; x,<span class="hljs-keyword">int</span>&amp; y)&#123; <span class="hljs-keyword">return</span> x &lt; y;&#125;);<br><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> loop_s = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">//让胃口最小的孩子先获得</span><br>        <span class="hljs-keyword">while</span>(loop_s &lt; s.<span class="hljs-built_in">size</span>())&#123;<br>            <br>            <span class="hljs-keyword">if</span>(s[loop_s] &gt;= g[count] &amp;&amp; ++count &gt;= g.<span class="hljs-built_in">size</span>())<br>                <span class="hljs-keyword">break</span>;<br><br>            ++loop_s;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> count;  <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据贪心策略，让胃口最小的孩子去吃最小的饼干，让后面的孩子有更大的几率获得大饼干。不过首先需要先排序。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>456. 132 模式</title>
    <link href="/2021/12/09/LeetCode/456.%20132%20%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/12/09/LeetCode/456.%20132%20%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/132-pattern/">本题链接</a></p><h2 id="使用单调栈"><a href="#使用单调栈" class="headerlink" title="使用单调栈"></a>使用单调栈</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">find132pattern</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        stack&lt;<span class="hljs-keyword">int</span>&gt; tmp_stack;<br>        <span class="hljs-keyword">int</span> last = INT_MIN;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i &gt;= <span class="hljs-number">0</span>;--i)&#123;<br>            <br>            <span class="hljs-keyword">if</span>(tmp_stack.<span class="hljs-built_in">empty</span>()) tmp_stack.<span class="hljs-built_in">push</span>(nums[i]);<span class="hljs-comment">//如果栈空,将元素入栈</span><br>            <span class="hljs-keyword">else</span>&#123;<br><br>                <span class="hljs-keyword">if</span>(tmp_stack.<span class="hljs-built_in">top</span>() &gt; nums[i])&#123;<span class="hljs-comment">//如果栈顶元素大于nums[i]</span><br>                    tmp_stack.<span class="hljs-built_in">push</span>(nums[i]);<span class="hljs-comment">//将元素入栈</span><br>                &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果栈顶元素小于nums[i]</span><br>                    <span class="hljs-keyword">while</span>(!tmp_stack.<span class="hljs-built_in">empty</span>() &amp;&amp; tmp_stack.<span class="hljs-built_in">top</span>() &lt; nums[i])&#123;<br>                        <span class="hljs-keyword">if</span>(tmp_stack.<span class="hljs-built_in">top</span>() &lt; last) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                        last = tmp_stack.<span class="hljs-built_in">top</span>();<br>                        tmp_stack.<span class="hljs-built_in">pop</span>();<br>                    &#125;<span class="hljs-comment">//出栈,直到栈顶元素大于nums[i]或栈变空</span><br>                    tmp_stack.<span class="hljs-built_in">push</span>(nums[i]);<br>                &#125;  <br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> !tmp_stack.<span class="hljs-built_in">empty</span>() &amp;&amp; tmp_stack.<span class="hljs-built_in">top</span>() &lt; last ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>栈混洗是不可能出现<strong>132</strong>这种情况，所以可以模拟栈混洗的反向行为。假设原本的栈为单调栈，使用<code>last</code>这个值代表单调栈的栈顶元素，在单调栈中，从栈顶元素往栈底的方向看去，每个元素都比它下面的元素要大，所以只要当<code>tmp_stack</code>这个栈的栈顶元素小于<code>last</code>的值，就可以确定<strong>132</strong>情况的出现。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>单调栈</tag>
      
      <tag>栈混洗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>46. 全排列</title>
    <link href="/2021/12/09/LeetCode/46.%20%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <url>/2021/12/09/LeetCode/46.%20%E5%85%A8%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/permutations/">本题链接</a></p><h2 id="回溯法-递归"><a href="#回溯法-递归" class="headerlink" title="回溯法+递归"></a>回溯法+递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br><br>        <span class="hljs-built_in">func</span>(nums,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> start)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(start == nums.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(nums);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = start;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-built_in">swap</span>(nums[i],nums[start]);<br>            <span class="hljs-built_in">func</span>(nums,start+<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">swap</span>(nums[i],nums[start]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在每一次递归函数内，当前递归函数所管理的数组区域的第一个元素，都会从起始位置start开始依次往后交换。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>递归</tag>
      
      <tag>回溯法</tag>
      
      <tag>排列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>461. 汉明距离</title>
    <link href="/2021/12/09/LeetCode/461.%20%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/"/>
    <url>/2021/12/09/LeetCode/461.%20%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/hamming-distance/">本题链接</a></p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingDistance</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> dis = x^y;<span class="hljs-comment">//异或</span><br><br>        <span class="hljs-keyword">while</span>(dis)&#123;<span class="hljs-comment">//计算1出现的次数</span><br>            dis &amp;= (dis<span class="hljs-number">-1</span>);<br>            ++cnt;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对x和y进行异或操作，得到的dis中1出现的次数就是汉明距离。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>47. 全排列 II</title>
    <link href="/2021/12/09/LeetCode/47.%20%E5%85%A8%E6%8E%92%E5%88%97%20II/"/>
    <url>/2021/12/09/LeetCode/47.%20%E5%85%A8%E6%8E%92%E5%88%97%20II/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/permutations-ii/">本题链接</a></p><h2 id="回溯-递归-set"><a href="#回溯-递归-set" class="headerlink" title="回溯+递归+set"></a>回溯+递归+set</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>    <br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br><br>        <span class="hljs-built_in">func</span>(nums,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; start)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(start == nums.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(nums);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        set&lt;<span class="hljs-keyword">int</span>&gt; digit_set;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = start;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <br>            <span class="hljs-keyword">if</span>(digit_set.<span class="hljs-built_in">find</span>(nums[i]) == digit_set.<span class="hljs-built_in">end</span>())&#123;<span class="hljs-comment">//如果当前数没有使用过</span><br>                digit_set.<span class="hljs-built_in">insert</span>(nums[i]);<br>                <span class="hljs-built_in">swap</span>(nums[i],nums[start]);<br>                <span class="hljs-built_in">func</span>(nums,start+<span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">swap</span>(nums[i],nums[start]);<br>            &#125;<br>            <br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>只需要在每次递归中跳过使用过的<strong>数</strong>就行</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>数组</tag>
      
      <tag>递归</tag>
      
      <tag>回溯法</tag>
      
      <tag>排列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>48. 旋转图像</title>
    <link href="/2021/12/09/LeetCode/48.%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <url>/2021/12/09/LeetCode/48.%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="本题链接"><a href="#本题链接" class="headerlink" title="本题链接]"></a><a href="https://leetcode-cn.com/problems/rotate-image/">本题链接]</a></h1><h2 id="普通矩阵"><a href="#普通矩阵" class="headerlink" title="普通矩阵"></a>普通矩阵</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;r &lt; (n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;++r)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;c &lt; n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;++c)&#123;<br>                <span class="hljs-built_in">swap</span>(matrix[r][c],matrix[c][n-r]);<br>                <span class="hljs-built_in">swap</span>(matrix[r][c],matrix[n-r][n-c]);<br>                <span class="hljs-built_in">swap</span>(matrix[r][c],matrix[n-c][r]);<br>            &#125;<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>画图后观察发现，对一个矩阵的旋转只需要操作其中的前面四分之一区域(边长为奇数和偶数有细微差别)，每次迭代操作只需要互相交换4个点的值即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>496. 下一个更大元素 I</title>
    <link href="/2021/12/09/LeetCode/496.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20I/"/>
    <url>/2021/12/09/LeetCode/496.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20I/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/next-greater-element-i/">本题链接</a></p><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br><br>        map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; f_map;<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; d_stack;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(nums1.size(),<span class="hljs-number">-1</span>)</span></span>;<br><br>        <span class="hljs-comment">//维护nums2对应的递增单调栈</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = nums2.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span> ;--i)&#123;<br>           <span class="hljs-keyword">while</span>(!d_stack.<span class="hljs-built_in">empty</span>() &amp;&amp; d_stack.<span class="hljs-built_in">top</span>() &lt; nums2[i]) d_stack.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//如果栈非空且栈顶元素小于当前元素:将栈顶元素出栈</span><br>           <span class="hljs-keyword">if</span>(!d_stack.<span class="hljs-built_in">empty</span>()) f_map.<span class="hljs-built_in">insert</span>(&#123;nums2[i],d_stack.<span class="hljs-built_in">top</span>()&#125;);<span class="hljs-comment">//当栈顶元素大于当前元素,就将&#123;key:当前元素,value:栈顶元素&#125;放入map</span><br>           d_stack.<span class="hljs-built_in">push</span>(nums2[i]);<span class="hljs-comment">//将当前元素入栈</span><br>        &#125;<br><br>        <span class="hljs-comment">//对结果进行查找</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>();++i)<br>            <span class="hljs-keyword">if</span>(f_map.<span class="hljs-built_in">find</span>(nums1[i]) != f_map.<span class="hljs-built_in">end</span>())<br>                res[i] = f_map[nums1[i]];<br>            <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>维护一个单调递增栈，从nums2的尾部向前进行遍历：在栈非空的情况下，当前的nums2元素的下一个最大元素为栈顶元素。若栈为空，当前元素没有下一个最大元素。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>504. 七进制数</title>
    <link href="/2021/12/09/LeetCode/504.%20%E4%B8%83%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
    <url>/2021/12/09/LeetCode/504.%20%E4%B8%83%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/base-7/">本题链接</a></p><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">convertToBase7</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br><br>        <span class="hljs-keyword">int</span> dig = <span class="hljs-built_in">abs</span>(num);<br>        string res;<br><br>        <span class="hljs-keyword">while</span>(dig != <span class="hljs-number">0</span>)&#123;<br>            res = <span class="hljs-built_in">to_string</span>(dig % <span class="hljs-number">7</span>) + res;<br>            dig /= <span class="hljs-number">7</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> num &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;-&#x27;</span> + res : res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和二进制的转换过程一样，不断求余即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>进制转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>509. 斐波那契数</title>
    <link href="/2021/12/09/LeetCode/509.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <url>/2021/12/09/LeetCode/509.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/fibonacci-number/">本题链接</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br><br>        <span class="hljs-keyword">int</span> p1 = <span class="hljs-number">0</span>,p2 = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; n;++i)&#123;<br>            p2 = p1 + p2;<br>            p1 = p2 - p1;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p2;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>只要根据斐波那契数列的性质推出状态转移方程</p><script type="math/tex; mode=display">dp[i]=dp[i-1]+dp[i-2]</script>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51. N 皇后</title>
    <link href="/2021/12/09/LeetCode/51.%20N%20%E7%9A%87%E5%90%8E/"/>
    <url>/2021/12/09/LeetCode/51.%20N%20%E7%9A%87%E5%90%8E/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/n-queens/">本题链接</a></p><h2 id="回溯法-栈"><a href="#回溯法-栈" class="headerlink" title="回溯法+栈"></a>回溯法+栈</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">int</span> rac;<span class="hljs-comment">//n</span><br>    stack&lt;vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&gt; cb_stack;<span class="hljs-comment">//栈顶保存着当前合法的棋盘状态. 二维数组状态:0:安全地带 1:攻击范围 2:已有皇后</span><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; cb_tmp;<span class="hljs-comment">//临时棋盘</span><br>    <span class="hljs-keyword">int</span> dirc[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<span class="hljs-comment">//方向</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; queen_pos&#123;vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">9</span>,<span class="hljs-number">-1</span>)&#125;; <span class="hljs-comment">//第n个皇后所处的第n个位置</span><br>    vector&lt;vector&lt;string&gt;&gt; res;<span class="hljs-comment">//最终结果</span><br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-keyword">int</span> n) &#123;<br><br>        <span class="hljs-comment">//初始化:空间换时间</span><br>        rac = n;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; tmp_vec = vector&lt;<span class="hljs-keyword">int</span>&gt;(n,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;n;++i)&#123;<br>            cb_tmp.<span class="hljs-built_in">push_back</span>(tmp_vec);<br>        &#125;<br>        cb_stack.<span class="hljs-built_in">push</span>(cb_tmp);<br>        <span class="hljs-keyword">int</span> loop_col = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> loop_row = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">//逐行逐列遍历</span><br>        <span class="hljs-keyword">for</span>(;loop_row &lt; n;)&#123;<br><br>            <span class="hljs-keyword">int</span> cur_queen_pos = loop_row;<br><br>            <span class="hljs-keyword">for</span>(;loop_col &lt; n;++loop_col)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">setAttack</span>(&#123;loop_row,loop_col&#125;))&#123;<span class="hljs-comment">//如果皇后能待在该处,则移动到下一行</span><br>                    loop_col = <span class="hljs-number">0</span>;<br>                    ++loop_row;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果不行就遍历列,直到一个合适的位置</span><br>            &#125;<br><br>            <span class="hljs-comment">//如果当前遍历完,该行皇后还是找不到合适的位置,那么就更改上一行皇后,或是已经满足一种情况</span><br>            <span class="hljs-keyword">if</span>(queen_pos[cur_queen_pos] == <span class="hljs-number">-1</span> || cb_stack.<span class="hljs-built_in">size</span>() == n + <span class="hljs-number">1</span>)&#123;<br><br>                <span class="hljs-keyword">if</span>(queen_pos[cur_queen_pos] != <span class="hljs-number">-1</span>) <span class="hljs-built_in">saveRes</span>();<span class="hljs-comment">//保存棋盘到结果里</span><br>                <span class="hljs-keyword">if</span>(cur_queen_pos == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//如果第一位皇后遍历结束</span><br>                <span class="hljs-comment">//将上一个皇后的最后状态取出</span><br>                loop_col = queen_pos[--loop_row] + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//将上一个皇后的状态设置为-1</span><br>                queen_pos[loop_row] = <span class="hljs-number">-1</span>;<br>                <span class="hljs-comment">//将上一个皇后的合法棋盘撤销</span><br>                cb_stack.<span class="hljs-built_in">pop</span>();<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">//设置皇后攻击状态 失败情况:攻击到其他皇后</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">setAttack</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; queen)</span></span>&#123;<br><br>        <span class="hljs-comment">//如果该皇后处于其他皇后的攻击范围</span><br>        <span class="hljs-keyword">if</span>(((vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;)cb_stack.<span class="hljs-built_in">top</span>())[queen.first][queen.second] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        cb_tmp = cb_stack.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//备份一份当前的合法棋盘</span><br>        pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; point_tmp;<span class="hljs-comment">//创建一个点备份</span><br>        cb_tmp[queen.first][queen.second] = <span class="hljs-number">2</span>;<span class="hljs-comment">//设置皇后自身</span><br>        <span class="hljs-comment">//设置皇后的八个方向</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> dir = <span class="hljs-number">0</span>;dir &lt; <span class="hljs-number">8</span>;++dir)&#123;<br>            point_tmp = queen;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                point_tmp.first+=dirc[dir];<span class="hljs-comment">//根据方向位移点</span><br>                point_tmp.second+=dirc[dir+<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isLegal</span>(point_tmp)) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//如果不合法,退出</span><br>                <span class="hljs-keyword">if</span>(cb_tmp[point_tmp.first][point_tmp.second] == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果攻击到其他皇后</span><br>                cb_tmp[point_tmp.first][point_tmp.second] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>       cb_stack.<span class="hljs-built_in">push</span>(cb_tmp);<span class="hljs-comment">//保存当前的合法棋盘</span><br>       queen_pos[queen.first] = queen.second;<span class="hljs-comment">//保存皇后的位置</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>    <span class="hljs-comment">//判断点是否合法</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isLegal</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; p)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= p.first &amp;&amp; p.first &lt; rac)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= p.second &amp;&amp; p.second &lt; rac)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//保存结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveRes</span><span class="hljs-params">()</span></span>&#123;<br><br>        vector&lt;string&gt; tmp_res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; vec:(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;)cb_stack.<span class="hljs-built_in">top</span>())&#123;<br>            string s;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; rac;++i)&#123;<br>                <span class="hljs-keyword">if</span>(vec[i] == <span class="hljs-number">2</span>) s.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;Q&#x27;</span>);<br>                <span class="hljs-keyword">else</span> s.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br>            &#125;<br>            tmp_res.<span class="hljs-built_in">push_back</span>(s);<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(tmp_res);<br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>回溯法的重点就是要保存之前的某个状态。后面想到用栈来保存每次合法的棋盘状态，然后根据条件来对之前的合法棋盘进行重新的操作。该方法虽然合理且通俗易懂。但是空间和时间的效率都十分低下……</p><h2 id="回溯法-递归"><a href="#回溯法-递归" class="headerlink" title="回溯法+递归"></a>回溯法+递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">int</span> rac;<span class="hljs-comment">//n</span><br>    <span class="hljs-keyword">int</span> dirc[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<span class="hljs-comment">//对角方向</span><br>    vector&lt;vector&lt;string&gt;&gt; res;<br>    <br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-keyword">int</span> n) &#123;<br><br>        rac = n; <br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">cb</span><span class="hljs-params">(n, string(n, <span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br>        <span class="hljs-built_in">refreshCB</span>(<span class="hljs-number">0</span>,cb);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">refreshCB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row,vector&lt;string&gt;&amp; cb)</span></span>&#123;<br><br>        <span class="hljs-comment">//保存结果</span><br>        <span class="hljs-keyword">if</span>(row == rac)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(cb);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; rac; ++col)&#123;<br><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">setAttack</span>(&#123;row,col&#125;,cb))&#123;<span class="hljs-comment">//如果成功放置皇后</span><br>                <span class="hljs-built_in">refreshCB</span>(row + <span class="hljs-number">1</span>,cb);<span class="hljs-comment">//交给下一行</span><br>            &#125;<br>            cb[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//设置皇后攻击状态 失败情况:攻击到其他皇后</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">setAttack</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; queen,vector&lt;string&gt;&amp; cb)</span></span>&#123;<br><br>        <span class="hljs-comment">//判断列方向</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> loop_rac = <span class="hljs-number">0</span>;loop_rac &lt; queen.first;++loop_rac)&#123;<br>            <span class="hljs-keyword">if</span>(cb[loop_rac][queen.second] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果攻击到其他皇后</span><br>        &#125;<br>        <span class="hljs-comment">//判断对角方向</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> dir = <span class="hljs-number">0</span>;dir &lt; <span class="hljs-number">4</span>;++dir)&#123;<br>            pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; point_tmp = queen;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                point_tmp.first+=dirc[dir];<span class="hljs-comment">//根据方向位移点</span><br>                point_tmp.second+=dirc[dir+<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isLegal</span>(point_tmp)) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//如果不合法,退出</span><br>                <span class="hljs-keyword">if</span>(cb[point_tmp.first][point_tmp.second] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果攻击到其他皇后</span><br>            &#125;<br>        &#125;<br>       cb[queen.first][queen.second] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//判断点是否合法</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isLegal</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; p)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= p.first &amp;&amp; p.first &lt; rac)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= p.second &amp;&amp; p.second &lt; rac)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>在回溯法+栈的版本上进行了优化：</p><ul><li>剪枝操作。只要判断当前皇后是否会攻击到其他皇后就行，无需考虑其他皇后攻击当前皇后的情况。因为两者是等价的</li><li>利用内存栈来代替显式的数据栈</li><li>不再考虑皇后同一行的冲突问题，而皇后同一列的只向上考虑</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>栈</tag>
      
      <tag>回溯法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>524. 通过删除字母匹配到字典里最长单词</title>
    <link href="/2021/12/09/LeetCode/524.%20%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/"/>
    <url>/2021/12/09/LeetCode/524.%20%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">本题链接</a></p><h2 id="双指针-暴力"><a href="#双指针-暴力" class="headerlink" title="双指针+暴力"></a>双指针+暴力</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">findLongestWord</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; dictionary)</span> </span>&#123;<br><br>        <span class="hljs-comment">//异常情况</span><br>        <span class="hljs-keyword">if</span>(dictionary.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-built_in">sort</span>(dictionary.<span class="hljs-built_in">begin</span>(),dictionary.<span class="hljs-built_in">end</span>(),[](string&amp; a,string&amp; b)&#123;<br>               <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>() == b.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">compare</span>(b) &lt; <span class="hljs-number">0</span>;<br>               <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>() &gt; b.<span class="hljs-built_in">size</span>();<br>            &#125;);<br>        &#125;<br><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; str:dictionary)&#123;<br>            <br>            <span class="hljs-keyword">int</span> p_dic = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; p_dic != str.<span class="hljs-built_in">size</span>(); i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(s[i] == str[p_dic]) ++p_dic;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(p_dic == str.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> str;<br><br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> string&#123;<span class="hljs-string">&quot;&quot;</span>&#125;;<br>    &#125;<br><br><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>只要将字典按照字典序和长度排序，然后剩下的事情就是用两个指针，一个指针指向字符串，一个指针指向排序后的字符串就行。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>53. 最大子序和</title>
    <link href="/2021/12/09/LeetCode/53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <url>/2021/12/09/LeetCode/53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-subarray/">本题链接</a></p><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">psum</span><span class="hljs-params">(nums.size() + <span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <br>        <span class="hljs-comment">//构造前缀和</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>            psum[i + <span class="hljs-number">1</span>] = psum[i] + nums[i];<br><br>        <span class="hljs-keyword">int</span> res = psum[<span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">//使用滑动窗口</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; psum.<span class="hljs-built_in">size</span>(); ++i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i;j &lt; psum.<span class="hljs-built_in">size</span>(); ++j)<br>                res = <span class="hljs-built_in">max</span>(res,psum[j] - psum[i<span class="hljs-number">-1</span>]);<br>            <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>记录每个元素的前缀和，然后使用滑动窗口计算每个区域的大小。但是后面发现多此一举…没必要统计前缀和，使用单纯的累计值对比就行。</p><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> res = INT_MIN;<br><br>        <span class="hljs-comment">//使用滑动窗口</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i;j &lt; nums.<span class="hljs-built_in">size</span>(); ++j)&#123;<br>                sum+=nums[j];<br>                res = <span class="hljs-built_in">max</span>(res,sum);<br>            &#125;   <br>        &#125;<br> <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>简单直观，直接暴力遍历每个可能的区间，但是复杂度很高。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>,ans = nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; p : nums)&#123;<br>            <br>            pre = <span class="hljs-built_in">max</span>(p,pre + p);<span class="hljs-comment">//选择是否保留前面的区域</span><br>            ans = <span class="hljs-built_in">max</span>(pre,ans);<span class="hljs-comment">//选择最大的结果</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>根据规律其实可以推出状态转移方程：</p><script type="math/tex; mode=display">dp[i]=max(dp[i-1],dp[i-1]+numsp[i])</script><p>如果前面的区域加上自己还小于自己的话，说明前面的区域可以舍弃了。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>数组</tag>
      
      <tag>动态规划</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>543. 二叉树的直径</title>
    <link href="/2021/12/09/LeetCode/543.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    <url>/2021/12/09/LeetCode/543.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">本题链接</a></p><h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">int</span> max_len = <span class="hljs-number">0</span>;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">getLen</span>(root);<br>        <span class="hljs-keyword">return</span> max_len;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLen</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">int</span> left_len = <span class="hljs-built_in">getLen</span>(root-&gt;left);<span class="hljs-comment">//左子树的最大路径</span><br>        <span class="hljs-keyword">int</span> right_len = <span class="hljs-built_in">getLen</span>(root-&gt;right);<span class="hljs-comment">//右子树的最大路径</span><br><br>        <span class="hljs-comment">//结合自己与已有的结果对比</span><br>        max_len = <span class="hljs-built_in">max</span>(max_len,left_len + right_len);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(left_len,right_len);<span class="hljs-comment">//返回给上层最多的路径</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对每一个节点都求以它自己为准的最大路劲长度。实际上与求树的深度一样</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>540. 有序数组中的单一元素</title>
    <link href="/2021/12/09/LeetCode/540.%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0/"/>
    <url>/2021/12/09/LeetCode/540.%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">本题链接</a></p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNonDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span> , right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> mid;<br><br>        <span class="hljs-comment">//总是保持l和r之间为奇数个元素</span><br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <br>            mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">//如果left和mid之间为偶数个</span><br>            <span class="hljs-keyword">if</span>((mid - left) % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<br><br>                <span class="hljs-keyword">if</span>( nums[mid] ==  nums[mid + <span class="hljs-number">1</span>]) right = mid - <span class="hljs-number">1</span>;<span class="hljs-comment">//说明这个数在left与mid之间</span><br>                <span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//说明这个数在mid与right之间</span><br><br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果left和mid之间为奇数个</span><br><br>                <span class="hljs-keyword">if</span>( nums[mid] ==  nums[mid + <span class="hljs-number">1</span>]) left = mid;<span class="hljs-comment">//说明这个数在mid与right之间</span><br>                <span class="hljs-keyword">else</span>  right = mid;<span class="hljs-comment">//说明这个数在left与mid之间</span><br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums[left];<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>观察题目给的例子发现，只要这个唯一数存在于某个区间内，那么这个区间的元素个数一定为奇数个。那么只要通过二分查找把区间保持在奇数个即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>547. 省份数量</title>
    <link href="/2021/12/09/LeetCode/547.%20%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/"/>
    <url>/2021/12/09/LeetCode/547.%20%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-provinces/">本题链接</a></p><h2 id="DFS-栈"><a href="#DFS-栈" class="headerlink" title="DFS+栈"></a>DFS+栈</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;<br><br>        set&lt;<span class="hljs-keyword">int</span>&gt; city_set;<span class="hljs-comment">//存放已经遍历过的城市</span><br>        stack&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; city_stack;<span class="hljs-comment">//辅助栈 &lt;city,当前遍历的连接&gt;</span><br>        <span class="hljs-keyword">int</span> province = <span class="hljs-number">0</span>;<span class="hljs-comment">//省份数量</span><br>        <span class="hljs-keyword">int</span> city = <span class="hljs-number">0</span>;<span class="hljs-comment">//当前城市</span><br>        <span class="hljs-keyword">while</span>(city_set.<span class="hljs-built_in">size</span>() &lt; isConnected.<span class="hljs-built_in">size</span>())&#123;<br><br>            <span class="hljs-keyword">int</span> conn = <span class="hljs-number">0</span>;<span class="hljs-comment">//连接数</span><br><br>            <span class="hljs-keyword">if</span>(city_set.<span class="hljs-built_in">find</span>(city) != city_set.<span class="hljs-built_in">end</span>())&#123;<span class="hljs-comment">//如果该城市已经属于省份,跳过</span><br>                ++city;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                city_set.<span class="hljs-built_in">insert</span>(city);<span class="hljs-comment">//加入新城市,以该城市为起点</span><br>                ++province;<br>            &#125;<br>            <br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><br>                <span class="hljs-keyword">if</span>(isConnected[city][conn] == <span class="hljs-number">0</span> || city_set.<span class="hljs-built_in">find</span>(conn) != city_set.<span class="hljs-built_in">end</span>())&#123;<span class="hljs-comment">//跳过0,或自己,已连接的城市和有归属的城市</span><br>                    <span class="hljs-keyword">if</span>(++conn == isConnected.<span class="hljs-built_in">size</span>())&#123;<span class="hljs-comment">//到达边界</span><br>                        <span class="hljs-keyword">if</span>(city_stack.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//如果栈为空,退出</span><br>                        <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//状态回归</span><br>                            pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; city_state = city_stack.<span class="hljs-built_in">top</span>();<br>                            city_stack.<span class="hljs-built_in">pop</span>();<br>                            city = city_state.first;<br>                            conn = city_state.second;<br>                        &#125;<br>                    &#125; <br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//否则将当前城市和当前的连接入栈,并保存</span><br>                    city_stack.<span class="hljs-built_in">push</span>(&#123;city,conn&#125;);<br>                    city = conn;<br>                    conn = <span class="hljs-number">0</span>;<br>                    city_set.<span class="hljs-built_in">insert</span>(city);<br>                &#125; <br>            &#125;<br><br>            ++city;<br>        &#125;<br>        <span class="hljs-keyword">return</span> province;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>该题可看作一行为一个节点，然后这个节点中存储着与其他节点之间的连接关系。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度优先搜索</tag>
      
      <tag>栈</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>560. 和为K的子数组</title>
    <link href="/2021/12/09/LeetCode/560.%20%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2021/12/09/LeetCode/560.%20%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">本题链接</a></p><h2 id="前缀和-哈希表"><a href="#前缀和-哈希表" class="headerlink" title="前缀和+哈希表"></a>前缀和+哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        set&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; unique_set;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">pand</span><span class="hljs-params">(nums.size() + <span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">//初始化前缀和 O(n)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; pand.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            pand[i] = nums[i<span class="hljs-number">-1</span>] + pand[i<span class="hljs-number">-1</span>];<br>        &#125;<br><br>        <span class="hljs-comment">//暴力遍历 O(n^2)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>;lo &lt; nums.<span class="hljs-built_in">size</span>();++lo)&#123;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> hi = lo;hi &lt; nums.<span class="hljs-built_in">size</span>();++hi)&#123;<br><br>                <span class="hljs-keyword">if</span>(pand[hi + <span class="hljs-number">1</span>] - pand[lo] == k)&#123;<br><br>                    <span class="hljs-keyword">if</span>(unique_set.<span class="hljs-built_in">find</span>(&#123;lo,hi&#125;)  == unique_set.<span class="hljs-built_in">end</span>())&#123;<br>                        unique_set.<span class="hljs-built_in">insert</span>(&#123;lo,hi&#125;);<br>                        ++res;<br><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>超时，时间主要消耗在亦步亦趋的遍历个个区间和计算，并且有重复区间会被计算</p><h2 id="前缀和-哈希表-1"><a href="#前缀和-哈希表-1" class="headerlink" title="前缀和+哈希表"></a>前缀和+哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; psum_map;<span class="hljs-comment">//第一个int表示前缀和,第二个int表示出现次数</span><br>        psum_map[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>,psum = <span class="hljs-number">0</span>;<br> <br>        <span class="hljs-comment">//初始化前缀和 O(n)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-comment">//累计前缀和</span><br>            psum += nums[i];<br>            res += psum_map[psum - k];<span class="hljs-comment">//当前psum_map[psum - k]存在，表示之前有一个前缀和等于k。若不存在,psum_map[psum - k]的值为0</span><br>            ++psum_map[psum];<span class="hljs-comment">//将当前前缀和保存</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>如果对应的k存在，那么表示某两个前缀和的差值为k。又因为题目要求是连续的子数组，所以在按顺序计算前缀和的同时，计算是否存在与当前前缀和差值为k的之前的前缀和即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>数组</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>605. 种花问题</title>
    <link href="/2021/12/09/LeetCode/605.%20%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/"/>
    <url>/2021/12/09/LeetCode/605.%20%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/can-place-flowers/">本题链接</a></p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canPlaceFlowers</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; flowerbed, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <br>       <span class="hljs-comment">//预处理</span><br>       flowerbed.<span class="hljs-built_in">insert</span>(flowerbed.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">0</span>);<br>       flowerbed.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br><br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; flowerbed.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i++)<br>       &#123;<br>           <span class="hljs-keyword">if</span>(flowerbed[i<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span> &amp;&amp; flowerbed[i] == <span class="hljs-number">0</span> &amp;&amp; flowerbed[i+<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)<br>           &#123;<br>                flowerbed[i] = <span class="hljs-number">1</span>;<br>                n--;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> n &lt;= <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>判断连续三个0，才在中间种花。为了防止在迭代过程中数组越界，在算法开始时进行预处理：在数组头尾两端添加0。</li><li>使用贪心策略，只要有三个0就种花。</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>633. 平方数之和</title>
    <link href="/2021/12/09/LeetCode/633.%20%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2021/12/09/LeetCode/633.%20%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/">本题链接</a></p><h2 id="双指针-暴力"><a href="#双指针-暴力" class="headerlink" title="双指针+暴力"></a>双指针+暴力</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judgeSquareSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123;<br><br>        <span class="hljs-keyword">long</span> l = <span class="hljs-number">0</span>,r = (<span class="hljs-keyword">long</span>)<span class="hljs-built_in">sqrt</span>(c),res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l &lt;= r)<br>        &#123;   <br>            res = l*l + r*r;<br><br>            <span class="hljs-keyword">if</span>(res == c) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res &gt; c) r--;<br>            <span class="hljs-keyword">else</span> l++;<br>            <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res == c;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>前后双指针的边界分别是0和目标值的开方。然后每次迭代两边的指针根据结果和目标值的对比进行移动。</p><h2 id="双平方定理"><a href="#双平方定理" class="headerlink" title="双平方定理"></a>双平方定理</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judgeSquareSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(c &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">//素因数分解</span><br>        <span class="hljs-keyword">while</span>(c % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) c = c/<span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">int</span> p = <span class="hljs-number">3</span>,index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(p*p &lt;= c)<br>        &#123;<br>            index = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(c % p == <span class="hljs-number">0</span>)<br>            &#123;<br>               ++index;<br>               c = c / p; <br>            &#125;<br><br>            <span class="hljs-keyword">if</span>( p % <span class="hljs-number">4</span> == <span class="hljs-number">3</span> &amp;&amp; index % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>            p+=<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c % <span class="hljs-number">4</span> == <span class="hljs-number">1</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>双指针</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>637. 二叉树的层平均值</title>
    <link href="/2021/12/09/LeetCode/637.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/"/>
    <url>/2021/12/09/LeetCode/637.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">本题链接</a></p><h2 id="层序遍历-迭代"><a href="#层序遍历-迭代" class="headerlink" title="层序遍历+迭代"></a>层序遍历+迭代</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">averageOfLevels</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>        queue&lt;TreeNode*&gt; node_queue;<br>        vector&lt;<span class="hljs-keyword">double</span>&gt; res;<br><br>        node_queue.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!node_queue.<span class="hljs-built_in">empty</span>())&#123;<br><br>            <span class="hljs-keyword">double</span> size = node_queue.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//该层大小</span><br>            <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0</span>;<span class="hljs-comment">//该层总数</span><br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; size;++i)&#123;<br>                <br>                <span class="hljs-keyword">if</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;left) node_queue.<span class="hljs-built_in">push</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;left);<br>                <span class="hljs-keyword">if</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;right) node_queue.<span class="hljs-built_in">push</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;right);<br>                sum += node_queue.<span class="hljs-built_in">front</span>()-&gt;val;<br>                <br>                node_queue.<span class="hljs-built_in">pop</span>();<br>            &#125;   <br><br>            res.<span class="hljs-built_in">push_back</span>(sum/size);<span class="hljs-comment">//保存结果</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>与&lt;&lt;<strong>102. 二叉树的层序遍历</strong>&gt;&gt;思路一致</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代</tag>
      
      <tag>层序遍历</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>64. 最小路径和</title>
    <link href="/2021/12/09/LeetCode/64.%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2021/12/09/LeetCode/64.%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-path-sum/">本题链接</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br><br>        <span class="hljs-comment">//对边界进行处理</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">1</span>;r &lt; grid.<span class="hljs-built_in">size</span>();++r)<br>            grid[r][<span class="hljs-number">0</span>] += grid[r<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]; <br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">1</span>;c &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();++c)<br>            grid[<span class="hljs-number">0</span>][c] += grid[<span class="hljs-number">0</span>][c<span class="hljs-number">-1</span>]; <br>        <br>        <span class="hljs-comment">//设置每个位置的最小值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">1</span>;r &lt; grid.<span class="hljs-built_in">size</span>();++r)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">1</span>;c &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();++c)<br>                grid[r][c] += <span class="hljs-built_in">min</span>(grid[r - <span class="hljs-number">1</span>][c],grid[r][c<span class="hljs-number">-1</span>]);<br>            <br>        <span class="hljs-keyword">return</span> grid[grid.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>][grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>依照题目很容易推出状态方程：</p><script type="math/tex; mode=display">dp[r][c]+=min(dp[r - 1][c],dp[r][c-1]);</script><p>其中，$dp[r][c]$​​的值为到达这个点的最短路径，由于在原数组中，每一个值被遍历后的状态一定是固定的，不会回溯，所以可以用原数组<strong>grid</strong>来当作<strong>dp</strong>数组使用。</p><p>所以整体思路就是对每一个位置求出到达该处的最短路径，然后返回所需要的那个位置即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>647. 回文子串</title>
    <link href="/2021/12/09/LeetCode/647.%20%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2021/12/09/LeetCode/647.%20%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/palindromic-substrings/">本题链接</a></p><h2 id="中心扩展"><a href="#中心扩展" class="headerlink" title="中心扩展"></a>中心扩展</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            res+= <span class="hljs-built_in">getMaxSub</span>(i,i+<span class="hljs-number">1</span>,s);<br>            res+= <span class="hljs-built_in">getMaxSub</span>(i,i,s);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMaxSub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lo,<span class="hljs-keyword">int</span> hi,string&amp; s)</span></span>&#123;<br><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">0</span> &lt;= lo &amp;&amp; hi &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[lo] == s[hi])&#123;<br>            ++count;<br>            --lo;<br>            ++hi;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每次遍历选择一个字母为轴心，然后逐步向左向右拓展，直到左右两边不相等。注意要分奇偶情况</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>中心扩展法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>665. 非递减数列</title>
    <link href="/2021/12/09/LeetCode/665.%20%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/"/>
    <url>/2021/12/09/LeetCode/665.%20%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/non-decreasing-array/">本题链接</a></p><h2 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">checkPossibility</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">//异常处理</span><br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt;<span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">//预处理</span><br>        nums.<span class="hljs-built_in">insert</span>(nums.<span class="hljs-built_in">begin</span>(),INT_MIN);<br><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span> &amp;&amp; count &lt; <span class="hljs-number">2</span>;i++)<br>        &#123; <br>            <span class="hljs-keyword">if</span>(nums[i] &gt; nums[i+<span class="hljs-number">1</span>])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[i<span class="hljs-number">-1</span>] &lt;= nums[i+<span class="hljs-number">1</span>] ) &#123; nums[i] = nums[i<span class="hljs-number">-1</span>]; ++count; &#125;<br>                <span class="hljs-keyword">else</span> &#123; nums[i+<span class="hljs-number">1</span>] = nums[i];++count;&#125;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> count &lt; <span class="hljs-number">2</span>;<br><br>       <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>可以通过贪心策略让局部达到最优，让需要更改的值尽可能的小，以便于让后面的值可以满足非递增的要求。分析实际情况，会得出每次下降只会是以下两种情况：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/381a90cae8ea2a09d35c41b43736c8aa-198c4.png" style="zoom:50%;" /></p><p>遍历的前提是：遍历的每个点的左侧都已经是非降状态。为了保证算法正常运行，所以在第一个点的左侧插入一个无限小的值，那么第一个点一定满足。之后从第一个点开始遍历到最后，只需考察每个点的右侧即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>692. 前K个高频单词</title>
    <link href="/2021/12/09/LeetCode/692.%20%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D/"/>
    <url>/2021/12/09/LeetCode/692.%20%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/top-k-frequent-words/">本题链接</a></p><h2 id="哈希表-优先级队列"><a href="#哈希表-优先级队列" class="headerlink" title="哈希表+优先级队列"></a>哈希表+优先级队列</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">using</span> elem = pair&lt;string,<span class="hljs-keyword">int</span>&gt;;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span>&#123;</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> elem&amp; e1,<span class="hljs-keyword">const</span> elem&amp; e2)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(e1.second == e2.second)&#123;<span class="hljs-comment">//如果字符串的出现频率相同</span><br>                <span class="hljs-keyword">return</span> e1.first &lt; e2.first;<span class="hljs-comment">//字符序小的在前</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> e1.second &gt; e2.second;<br>        &#125;<br>    &#125;;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;string&gt;&amp; words, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        unordered_map&lt;string,<span class="hljs-keyword">int</span>&gt; hash;<br>        <span class="hljs-comment">//放入unordered_map中去重</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> string&amp; s : words)&#123;<br>            ++hash[s];<br>        &#125;<br><br>        priority_queue&lt;elem, vector&lt;elem&gt;,cmp&gt; heap;<span class="hljs-comment">//小顶堆</span><br>        <span class="hljs-comment">//放到堆里</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; [str,cnt] : hash)&#123;<br>            heap.<span class="hljs-built_in">emplace</span>(str,cnt);<br>            <span class="hljs-keyword">if</span>(heap.<span class="hljs-built_in">size</span>() &gt; k) heap.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//如果堆中元素大于K,就剔除堆顶元素</span><br>        &#125;<br><br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">res</span><span class="hljs-params">(heap.size(),<span class="hljs-string">&quot;&quot;</span>)</span></span>;<br>        <span class="hljs-comment">//从堆中取出元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = k - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;--i)&#123;<br>            res[i] = heap.<span class="hljs-built_in">top</span>().first;<br>            heap.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>       <br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先让数组中的所有元素放入哈希表统计次数，然后将哈希表的元素按照题目要求的顺序放入小顶堆里，让堆保持每时每刻都是最大的k个元素，最后再将堆中的元素放到结果数组中返回即可。</p><blockquote><ul><li><p>时间复杂度：$O(l \times n + m \times l \log k)$​，其中 n 表示给定字符串序列的长度，m 表示实际字符串种类数，l 表示字符串的平均长度。我们需要 $l×n$​ 的时间将字符串插入到哈希表中，以及每次插入元素到优先队列中都需要 $l*logk$​ 的时间，共需要插入 m 次。</p></li><li><p>空间复杂度：$O(l×(m+k))$，其中 ll表示字符串的平均长度，m 表示实际字符串种类数。哈希表空间占用为 $O(l×m)$，优先队列空间占用为 $O(l×k)$。</p></li></ul><p>来自：LeetCode-Solution</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>优先级队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>693. 交替位二进制数</title>
    <link href="/2021/12/09/LeetCode/693.%20%E4%BA%A4%E6%9B%BF%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
    <url>/2021/12/09/LeetCode/693.%20%E4%BA%A4%E6%9B%BF%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/">本题链接</a></p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasAlternatingBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">while</span>(n)&#123;<br>            <br>            <span class="hljs-keyword">if</span>((n &amp; <span class="hljs-number">1</span>) == (n &gt;&gt; <span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            n&gt;&gt;=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每次拿n的最低位和次低位进行比较。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>696. 计数二进制子串</title>
    <link href="/2021/12/09/LeetCode/696.%20%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/"/>
    <url>/2021/12/09/LeetCode/696.%20%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/count-binary-substrings/">本题链接</a></p><h2 id="双指针-中心扩展法"><a href="#双指针-中心扩展法" class="headerlink" title="双指针+中心扩展法"></a>双指针+中心扩展法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countBinarySubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; s.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            <span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>] == s[i]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果相等就跳过</span><br>            <br>            <span class="hljs-keyword">int</span> left = i<span class="hljs-number">-1</span>,right = i;<span class="hljs-comment">//双指针</span><br>            <span class="hljs-keyword">while</span>(<span class="hljs-number">0</span> &lt;= left &amp;&amp; right &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[left] == s[i<span class="hljs-number">-1</span>] &amp;&amp; s[right] == s[i])&#123;<br>                ++res;<br>                --left;<br>                ++right;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每当遍历到一个元素与它前面的元素不相等的时候，就以这两个元素为中心向左右拓展并计数。</p><h2 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countBinarySubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> arr[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">char</span> tmp = s[<span class="hljs-number">0</span>];<span class="hljs-comment">//对比字符初始化</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            <span class="hljs-keyword">if</span>(s[i] == tmp) ++arr[<span class="hljs-number">1</span>];<span class="hljs-comment">//如果字符相等,就计数</span><br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//否则</span><br>                tmp = s[i];<span class="hljs-comment">//改变对比字符</span><br>                res += <span class="hljs-built_in">min</span>(arr[<span class="hljs-number">0</span>],arr[<span class="hljs-number">1</span>]);<span class="hljs-comment">//选择最小的累加</span><br>                arr[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">1</span>];<span class="hljs-comment">//将此次计数往前置</span><br>                arr[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//设置新的计数值</span><br>            &#125;<br><br>        &#125;<br><br>        res += <span class="hljs-built_in">min</span>(arr[<span class="hljs-number">0</span>],arr[<span class="hljs-number">1</span>]);<span class="hljs-comment">//计算最后一次比较次数</span><br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><blockquote><p>先统计连续的0和1分别有多少个，如：111100011000，得到4323；在4323中的任意相邻两个数字，取小的一个加起来，就是3+2+2 = 7.</p></blockquote><p>来自：<a href="https://leetcode-cn.com/problems/count-binary-substrings/comments/55920">https://leetcode-cn.com/problems/count-binary-substrings/comments/55920</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
      <tag>奇技淫巧</tag>
      
      <tag>中心扩展法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>695. 岛屿的最大面积</title>
    <link href="/2021/12/09/LeetCode/695.%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/"/>
    <url>/2021/12/09/LeetCode/695.%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/max-area-of-island/">本题链接</a></p><h2 id="DFS-递归"><a href="#DFS-递归" class="headerlink" title="DFS+递归"></a>DFS+递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    set&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; yet_set;<span class="hljs-comment">//已经被探寻过的地点</span><br>    pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; border;<span class="hljs-comment">//grid边界</span><br>    vector&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; direction_vec&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;<span class="hljs-comment">//方向 上右下左的顺序</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br><br>        <span class="hljs-keyword">this</span>-&gt;border = pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&#123;grid.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>,grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">int</span> max_land = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">//遍历所有能遍历到的点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;row &lt; grid.<span class="hljs-built_in">size</span>();++row)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>;col &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();++col)&#123;<br>                <br>                <span class="hljs-keyword">if</span>(grid[row][col] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果是0,直接跳过</span><br>                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;yet_set.<span class="hljs-built_in">find</span>(&#123;row,col&#125;) != <span class="hljs-keyword">this</span>-&gt;yet_set.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果已经探寻过,直接跳过</span><br>                <br>                pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; point&#123;row,col&#125;;<span class="hljs-comment">//创建一个点</span><br>                <span class="hljs-keyword">this</span>-&gt;yet_set.<span class="hljs-built_in">insert</span>(point);<span class="hljs-comment">//备份这个点</span><br>                max_land = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">getLand</span>(point,grid),max_land);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max_land;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLand</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; point,vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span></span>&#123;<br>        <br>        <span class="hljs-keyword">int</span> local_max = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;direction : <span class="hljs-keyword">this</span>-&gt;direction_vec)&#123;<span class="hljs-comment">//从上右下左的顺序遍历点</span><br><br>            pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; new_point&#123;point.first + direction.first,point.second + direction.second&#125;;<span class="hljs-comment">//获得新的点位置</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">inGrid</span>(new_point) &amp;&amp; (<span class="hljs-keyword">this</span>-&gt;yet_set.<span class="hljs-built_in">find</span>(new_point) == <span class="hljs-keyword">this</span>-&gt;yet_set.<span class="hljs-built_in">end</span>()) &amp;&amp; grid[new_point.first][new_point.second] == <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//如果这个点合法且没被遍历过而且值为1</span><br>                <span class="hljs-keyword">this</span>-&gt;yet_set.<span class="hljs-built_in">insert</span>(new_point);<br>                local_max += <span class="hljs-built_in">getLand</span>(new_point,grid);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//否则跳过</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> local_max;      <br>    &#125;<br><br>    <span class="hljs-comment">//判断点是否合法</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">inGrid</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; point)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= point.first &amp;&amp; point.first &lt;= <span class="hljs-keyword">this</span>-&gt;border.first)<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= point.second &amp;&amp; point.second &lt;= <span class="hljs-keyword">this</span>-&gt;border.second) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>需要保存被探寻过的地点，以免再次遍历；然后就是定义一个方向数组，用来保存不同方向的行走。注意要避开不存在的点。然后流程就是先遍历每一个点，在每次迭代中对当前符合题意的点进一步深入即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>70. 爬楼梯</title>
    <link href="/2021/12/09/LeetCode/70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <url>/2021/12/09/LeetCode/70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/climbing-stairs/">本题链接</a></p><h2 id="动态规划-剪枝-哈希表"><a href="#动态规划-剪枝-哈希表" class="headerlink" title="动态规划+剪枝+哈希表"></a>动态规划+剪枝+哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br><br>        map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; cs_map&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;&#125;;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>;i &lt;= n + <span class="hljs-number">1</span>;++i)<br>            cs_map.<span class="hljs-built_in">insert</span>(&#123;i,cs_map[i<span class="hljs-number">-1</span>] + cs_map[i<span class="hljs-number">-2</span>]&#125;);<br>            <br>        <span class="hljs-keyword">return</span> cs_map[n+<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题实际上就是斐波那契数列…</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br><br>        <span class="hljs-keyword">int</span> p1 = <span class="hljs-number">1</span>,p2 = <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt; n;++i)&#123;<br>            p2 = p1 + p2;<br>            p1 = p2 - p1;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p2;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这题实际上就是斐波那契数列…</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>动态规划</tag>
      
      <tag>剪枝</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>720. 词典中最长的单词</title>
    <link href="/2021/12/09/LeetCode/720.%20%E8%AF%8D%E5%85%B8%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <url>/2021/12/09/LeetCode/720.%20%E8%AF%8D%E5%85%B8%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/">本题链接</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestWord</span><span class="hljs-params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(words.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-built_in">sort</span>(words.<span class="hljs-built_in">begin</span>(),words.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">const</span> string&amp; s1,<span class="hljs-keyword">const</span> string&amp; s2)&#123;<br>            <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">size</span>() == s2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> s1 &lt; s2;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt; s2.<span class="hljs-built_in">size</span>();<br>        &#125;);<br>    <br>        set&lt;string&gt; hash;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; s:words)&#123;<br>            <span class="hljs-comment">//如果字符串长度等于1或者在哈希表中找到了字符串的前缀</span><br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span> || hash.<span class="hljs-built_in">find</span>(<span class="hljs-built_in">string</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>()<span class="hljs-number">-1</span>)) != hash.<span class="hljs-built_in">end</span>())&#123;<br>                <span class="hljs-comment">//将该字符串加入哈希表中</span><br>                hash.<span class="hljs-built_in">emplace</span>(s);<br>                <span class="hljs-comment">//如果当前字符串长度大于结果，或者长度相等时字符串的字典序小于结果</span><br>                <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() &lt; s.<span class="hljs-built_in">size</span>() || (res.<span class="hljs-built_in">size</span>() == s.<span class="hljs-built_in">size</span>() &amp;&amp; res &gt; s)) res = s;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于结果的选取，长度优先考虑，之后再选择字典序最小的。先将数组排序，让字符串长度越小的越靠前，然后依次放入哈希表中，如果字符串的前缀没有在哈希表里，那么就跳过。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>739. 每日温度</title>
    <link href="/2021/12/09/LeetCode/739.%20%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
    <url>/2021/12/09/LeetCode/739.%20%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/daily-temperatures/">本题链接</a></p><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br><br>        stack&lt;<span class="hljs-keyword">int</span>&gt; d_stack;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(temperatures.size(),<span class="hljs-number">0</span>)</span></span>;<br><br>        <span class="hljs-comment">//维护temperatures对应的递增单调栈(存入下标)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = temperatures.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span> ;--i)&#123;<br>           <span class="hljs-comment">//如果栈非空且temperatures[栈顶元素]小于temperatures[当前元素]:将栈顶元素出栈</span><br>           <span class="hljs-keyword">while</span>(!d_stack.<span class="hljs-built_in">empty</span>() &amp;&amp; temperatures[d_stack.<span class="hljs-built_in">top</span>()] &lt;= temperatures[i]) d_stack.<span class="hljs-built_in">pop</span>();<br>           <span class="hljs-comment">//如果栈非空,计算当前元素到栈顶元素的距离(天数)</span><br>           <span class="hljs-keyword">if</span>(!d_stack.<span class="hljs-built_in">empty</span>()) res[i] = d_stack.<span class="hljs-built_in">top</span>() - i;<br>           <span class="hljs-comment">//将当前元素(下标)入栈</span><br>           d_stack.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>维护一个单调递增栈，其中的栈元素为temperatures数组的下标。其中，在栈非空的情况下需要保证栈顶元素所对应的值大于当前元素的值，就可计算出当前元素还需要多久会升温。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>75. 颜色分类</title>
    <link href="/2021/12/09/LeetCode/75.%20%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/"/>
    <url>/2021/12/09/LeetCode/75.%20%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-colors/">本题链接</a></p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">//退化情况</span><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &gt; nums[<span class="hljs-number">1</span>]) <span class="hljs-built_in">swap</span>(nums[<span class="hljs-number">0</span>] , nums[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <br><br>        <span class="hljs-comment">//使用计数或堆排序或者是快排思想皆可</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,pos = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><br>            <span class="hljs-keyword">while</span>(left &lt;= nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[left] == <span class="hljs-number">0</span>)<span class="hljs-comment">//碰到非0停止</span><br>                ++left;<br>            <br>            <span class="hljs-keyword">while</span>(right &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[right] != <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//碰到0停止</span><br>                <span class="hljs-keyword">if</span>(nums[right] == <span class="hljs-number">2</span>) <span class="hljs-built_in">swap</span>(nums[right--],nums[pos--]);<br>                <span class="hljs-keyword">else</span> --right;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(left &gt;= right) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-built_in">swap</span>(nums[left],nums[right]);<br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>实际上是三指针，但是每次遍历只移动left和right指针。每次遍历需要保证[0,left]区间内的值为0，[right,pos]区间内的值为1，(pos,nums.size()-1]区间内为2。只要right指针表示的值为2，那么就和pos指针的值交换。虽然pos指向的是下次存放2的位置，但是pos此时的值为1，那么跟right交换也不会出错。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>763. 划分字母区间</title>
    <link href="/2021/12/09/LeetCode/763.%20%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/"/>
    <url>/2021/12/09/LeetCode/763.%20%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/partition-labels/">本题链接</a></p><h2 id="哈希表-贪心-暴力"><a href="#哈希表-贪心-暴力" class="headerlink" title="哈希表+贪心+暴力"></a>哈希表+贪心+暴力</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-comment">//异常处理</span><br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;<span class="hljs-number">1</span>&#125;;<br><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; index_vec;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; index_map;  <br>        <span class="hljs-keyword">auto</span> index_it = index_map.<span class="hljs-built_in">end</span>();<br>        <br>        <span class="hljs-comment">//预处理1:整理字符串出现的头尾位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>();i++)<br>        &#123;   <br>            index_it = index_map.<span class="hljs-built_in">find</span>(s[i]);<br>            <span class="hljs-keyword">if</span>(index_it != index_map.<span class="hljs-built_in">end</span>())<span class="hljs-comment">//找到该字符</span><br>            &#123;   <br>                <span class="hljs-comment">//刷新位置</span><br>                index_vec[index_it-&gt;second][<span class="hljs-number">1</span>] = i;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                index_vec.<span class="hljs-built_in">push_back</span>(&#123;i,i&#125;);<span class="hljs-comment">//插入第一次出现的位置</span><br>                index_map.<span class="hljs-built_in">insert</span>(&#123;s[i],index_vec.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>&#125;);<br>            &#125;<br>            <br>        &#125;<br><br>        <span class="hljs-comment">//预处理2:排序</span><br>        <span class="hljs-built_in">sort</span>(index_vec.<span class="hljs-built_in">begin</span>(),index_vec.<span class="hljs-built_in">end</span>(),[](vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; a,vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; b)&#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>        &#125;);<br><br>        <span class="hljs-keyword">int</span> lo = index_vec[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> hi = index_vec[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; index_vec.<span class="hljs-built_in">size</span>(); i++)&#123;<br><br>                <span class="hljs-keyword">if</span>( hi &gt; index_vec[i][<span class="hljs-number">0</span>])<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(hi &lt;index_vec[i][<span class="hljs-number">1</span>])<br>                        hi = index_vec[i][<span class="hljs-number">1</span>];<br>                &#125; <br>                <span class="hljs-keyword">else</span> <br>                &#123;   <br>                    res.<span class="hljs-built_in">push_back</span>(hi-lo+<span class="hljs-number">1</span>);<br>                    lo = index_vec[i][<span class="hljs-number">0</span>];<br>                    hi = index_vec[i][<span class="hljs-number">1</span>];<br>                &#125;<br>        &#125;<br><br>        res.<span class="hljs-built_in">push_back</span>(hi-lo+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>存储每个字符的起始和终止位置，然后根据贪心策略，让字符尽可能的挤在相同的一块区域。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>字符串</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>77. 组合</title>
    <link href="/2021/12/09/LeetCode/77.%20%E7%BB%84%E5%90%88/"/>
    <url>/2021/12/09/LeetCode/77.%20%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/combinations/">本题链接</a></p><h2 id="回溯法-递归"><a href="#回溯法-递归" class="headerlink" title="回溯法+递归"></a>回溯法+递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">int</span> k;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>    <br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k) &#123;<br><br>        <span class="hljs-keyword">this</span>-&gt;n = n;<br>        <span class="hljs-keyword">this</span>-&gt;k = k;<br>        <span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(tmp.<span class="hljs-built_in">size</span>() == k)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = start;tmp.<span class="hljs-built_in">size</span>() &lt; k &amp;&amp; i &lt;= n;++i)&#123;<br><br>            tmp.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">func</span>(i + <span class="hljs-number">1</span>);<br>            tmp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每次取一个数，然后从剩下的数中再取一个数..直至一共取了k个数，就把结果放入数组中。整个过程持续迭代,直到遍历数超过n。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>回溯法</tag>
      
      <tag>组合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>785. 判断二分图</title>
    <link href="/2021/12/09/LeetCode/785.%20%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <url>/2021/12/09/LeetCode/785.%20%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/is-graph-bipartite/">本题链接</a></p><h2 id="染色法"><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br><br>        <span class="hljs-comment">//对每个点进行广度优先遍历</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">color_vec</span><span class="hljs-params">(graph.size(),<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">//染色,0表示未遍历,1表示黑色,2表示白色</span><br><br>        queue&lt;<span class="hljs-keyword">int</span>&gt; node_queue;<br>        <span class="hljs-comment">//预处理</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; graph.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            <span class="hljs-keyword">if</span>(color_vec[i] == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//如果没有被染色</span><br>                <span class="hljs-comment">//统一设成黑色，只要节点之间连通就一定会入队，不连通的无所谓</span><br>                color_vec[i] = <span class="hljs-number">1</span>;<br>                node_queue.<span class="hljs-built_in">push</span>(i);<span class="hljs-comment">//将节点入队</span><br>            &#125;<br><br>            <span class="hljs-keyword">while</span>(!node_queue.<span class="hljs-built_in">empty</span>())&#123;<br>                <br>                <span class="hljs-keyword">int</span> pos = node_queue.<span class="hljs-built_in">front</span>();node_queue.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//获取当前节点</span><br><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; neig : graph[pos])&#123;<span class="hljs-comment">//遍历该节点的所有相邻节点 </span><br><br>                    <span class="hljs-keyword">if</span>(color_vec[neig] == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//如果没有被染色</span><br><br>                        color_vec[neig] = color_vec[pos] == <span class="hljs-number">1</span> ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<span class="hljs-comment">//染成和自己不一样的颜色</span><br>                        node_queue.<span class="hljs-built_in">push</span>(neig);<span class="hljs-comment">//将节点入队</span><br><br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(color_vec[neig] == color_vec[pos]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果和自己的颜色相同 </span><br>                          <br>                &#125;<br><br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>分辨图是否为二分图，使用染色法。详情见<a href="https://leetcode-cn.com/problems/is-graph-bipartite/solution/pan-duan-er-fen-tu-by-leetcode-solution/">官方解析</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>广度优先搜索</tag>
      
      <tag>图</tag>
      
      <tag>染色法</tag>
      
      <tag>二分图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>79. 单词搜索</title>
    <link href="/2021/12/09/LeetCode/79.%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"/>
    <url>/2021/12/09/LeetCode/79.%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/word-search/">本题链接</a></p><h2 id="dfs-递归"><a href="#dfs-递归" class="headerlink" title="dfs+递归"></a>dfs+递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">int</span> dirc[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<span class="hljs-comment">//上 右 下 左</span><br>    <span class="hljs-keyword">int</span> row;<br>    <span class="hljs-keyword">int</span> col;<br>    <span class="hljs-comment">//set&lt;pair&lt;int,int&gt;&gt; re_set;</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;<br><br>        row = board.<span class="hljs-built_in">size</span>();<br>        col = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">state_vec</span>(row,vector&lt;<span class="hljs-keyword">bool</span>&gt;(col,<span class="hljs-literal">false</span>));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;r &lt; row;++r)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;c &lt; col;++c)<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(&#123;r,c&#125;,<span class="hljs-number">0</span>,board,word,state_vec)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&amp; point,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; pos,<span class="hljs-keyword">const</span> vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board,<span class="hljs-keyword">const</span> string&amp; word,vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt;&amp; state_vec)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(pos == word.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//如果找到所有的字符,就返回真</span><br>            <br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isLegal</span>(point) || board[point.first][point.second] != word[pos] || state_vec[point.first][point.second]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果这个点不符合要求</span><br>        state_vec[point.first][point.second] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//if(!isLegal(point) || board[point.first][point.second] != word[pos] || re_set.find(point) != re_set.end()) return false;//如果这个点不符合要求</span><br>        <span class="hljs-comment">//re_set.insert(point);</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> d = <span class="hljs-number">0</span>;d &lt; <span class="hljs-number">4</span>;++d) <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(&#123;point.first+dirc[d],point.second+dirc[d+<span class="hljs-number">1</span>]&#125;,pos + <span class="hljs-number">1</span>,board,word,state_vec)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        state_vec[point.first][point.second] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//re_set.erase(point);</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isLegal</span><span class="hljs-params">(<span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&amp; point)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= point.second &amp;&amp; point.second &lt; col)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= point.first &amp;&amp; point.first &lt; row)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路其实就是对每一个有可能的点进行dfs，然后为了避免回溯，就需要存储每个点是否被访问的状态。我一开始用的是set来保存每个点，后面超时了就更换了一个二维数组。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>852. 山脉数组的峰顶索引</title>
    <link href="/2021/12/09/LeetCode/852.%20%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95/"/>
    <url>/2021/12/09/LeetCode/852.%20%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/">本题链接</a></p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">peakIndexInMountainArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>,r = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>,mid;<br><br>        <span class="hljs-keyword">while</span>((l + <span class="hljs-number">2</span>) != r)&#123;<br>            <br>            mid = (r + l)  / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(arr[mid] &gt; arr[mid - <span class="hljs-number">1</span>] &amp;&amp; arr[mid] &gt; arr[mid + <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid] &gt; arr[mid - <span class="hljs-number">1</span>] &amp;&amp; arr[mid] &lt; arr[mid + <span class="hljs-number">1</span>]) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid;<br>            <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> l + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>只要把峰值限制在左右边界之间即可</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>83. 删除排序链表中的重复元素</title>
    <link href="/2021/12/09/LeetCode/83.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <url>/2021/12/09/LeetCode/83.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">本题链接</a></p><h2 id="迭代版"><a href="#迭代版" class="headerlink" title="迭代版"></a>迭代版</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <br>        ListNode* node = head;<br><br>        <span class="hljs-keyword">while</span>(node)&#123;<br><br>            <span class="hljs-keyword">if</span>(node-&gt;next)&#123;<br>                <span class="hljs-keyword">if</span>(node-&gt;val == node-&gt;next-&gt;val)&#123;<br>                    node-&gt;next = node-&gt;next-&gt;next;<span class="hljs-comment">//可能为空</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125; <br>            &#125;<br>            node = node-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>逐步删除，但是注意若有删除操作，指针不能移动，以避免跳过重复的元素。至于为什么没有delete掉链表中重复的节点，原因是我认为不应该在被调函数中删除调用者的内存。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>88. 合并两个有序数组</title>
    <link href="/2021/12/09/LeetCode/88.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2021/12/09/LeetCode/88.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/merge-sorted-array/">本题链接</a></p><h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-keyword">int</span> m, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> pos = m-- + --n ;<br>        <span class="hljs-keyword">while</span>(n &gt;= <span class="hljs-number">0</span>)<br>        &#123;   <br>            nums1[pos--] = m &gt;= <span class="hljs-number">0</span> &amp;&amp; nums1[m] &gt;= nums2[n] ? nums1[m--] : nums2[n--];<br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据题意使用双指针，同时自后向前遍历即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>912. 排序数组</title>
    <link href="/2021/12/09/LeetCode/912.%20%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2021/12/09/LeetCode/912.%20%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/sort-an-array/">本题链接</a></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <br>        <span class="hljs-comment">//归并排序 </span><br>        <span class="hljs-comment">//创建辅助空间</span><br>        <span class="hljs-keyword">int</span>* buf = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>((nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>));<br>        <span class="hljs-built_in">merge</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>,buf);<br>        <span class="hljs-built_in">free</span>(buf);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> lo,<span class="hljs-keyword">int</span> hi,<span class="hljs-keyword">int</span>* buf)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(hi == lo) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//递归基</span><br>        <span class="hljs-keyword">if</span>(lo + <span class="hljs-number">1</span> == hi)<span class="hljs-comment">//特殊情况:两个元素</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[lo] &gt; nums[hi]) <span class="hljs-built_in">swap</span>(nums[lo],nums[hi]);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//排序左边</span><br>        <span class="hljs-built_in">merge</span>(nums,lo,mid,buf);<br>        <span class="hljs-comment">//排序右边 </span><br>        <span class="hljs-built_in">merge</span>(nums,mid+<span class="hljs-number">1</span>,hi,buf);<br><br>        <span class="hljs-keyword">int</span> pos = hi-mid<span class="hljs-number">-1</span>;<span class="hljs-comment">//指向缓冲区的指针</span><br>        <span class="hljs-comment">//将右边存入缓冲区</span><br>        <span class="hljs-built_in">memcpy</span>((<span class="hljs-keyword">char</span>*)buf,(<span class="hljs-keyword">char</span>*)&amp;nums[mid+<span class="hljs-number">1</span>],(pos+<span class="hljs-number">1</span>)*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>));<br>        <br>        <span class="hljs-keyword">while</span>(mid &gt;= lo &amp;&amp; pos &gt;= <span class="hljs-number">0</span>)&#123;<br><br>            <span class="hljs-keyword">if</span>(*(buf + pos) &lt; nums[mid]) nums[hi--] = nums[mid--];<br>            <span class="hljs-keyword">else</span> nums[hi--] = *(buf + pos--);<br><br>        &#125;<br>        <span class="hljs-comment">//如果缓冲区还有元素</span><br>        <span class="hljs-keyword">while</span>(pos &gt;= <span class="hljs-number">0</span>) nums[hi--] = *(buf + pos--);<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>比较重要的是需要将右边区间的元素放入缓冲区，然后从整个区间的最后开始遍历,逐一覆盖。最后需要判断缓冲区内是否还有剩余元素未判断，若有的话需要将这些元素放入原来的区间内。</p><h2 id="起泡排序跳跃版"><a href="#起泡排序跳跃版" class="headerlink" title="起泡排序跳跃版"></a>起泡排序跳跃版</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">//起泡排序跳跃版</span><br><br>        <span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>,hi = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,last;<br>        <span class="hljs-keyword">while</span>(hi &gt; (lo = <span class="hljs-number">0</span>))&#123;<br>            <br>            <span class="hljs-keyword">while</span>(lo &lt; hi)&#123;<br><br>                <span class="hljs-keyword">if</span>(nums[lo] &gt; nums[lo + <span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-built_in">swap</span>(nums[lo], nums[lo + <span class="hljs-number">1</span>]);<br>                    last = ++lo;<br>                &#125;<span class="hljs-keyword">else</span> ++lo;<br><br>            &#125;<br>            hi = --last;<br>        &#125;<br>       <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>重要的不是思路，重要的是超时了…..</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">//快速排序</span><br>        <span class="hljs-built_in">quickSearch</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> nums; <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSearch</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> lo,<span class="hljs-keyword">int</span> hi)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!(lo &lt; hi)) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">swap</span>(nums[lo], nums[lo + <span class="hljs-built_in">rand</span>() % ( hi - lo )]);<br>        <span class="hljs-keyword">int</span> target = nums[lo];<br>        <span class="hljs-keyword">int</span> len = hi  + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> mi = lo ;<span class="hljs-comment">//边界</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = lo + <span class="hljs-number">1</span>;i &lt; len; ++i)<br>            <span class="hljs-keyword">if</span>(nums[i] &lt;= target) <span class="hljs-built_in">swap</span>(nums[++mi],nums[i]);<br>          <br>        <span class="hljs-comment">//轴点归位</span><br>        <span class="hljs-built_in">swap</span>(nums[mi],nums[lo]);<br>        <span class="hljs-comment">//对L区间进行快速搜索</span><br>        <span class="hljs-built_in">quickSearch</span>(nums,lo,mi - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//对G区间进行快速搜索</span><br>        <span class="hljs-built_in">quickSearch</span>(nums,mi + <span class="hljs-number">1</span>,hi);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>遵循分而治之的策略，先将轴点进行归位，此时的轴点之前是小于等于轴点的元素，轴点之后是大于轴点的元素。</p><p>然后分别对轴点的左边和右边进行快速搜索。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  Parent(i)         ( ( ( i ) - 1 ) &gt;&gt; 1 ) <span class="hljs-comment">//PQ[i]的父节点（floor((i-1)/2)，i无论正负）</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  LChild(i)         ( 1 + ( ( i ) &lt;&lt; 1 ) ) <span class="hljs-comment">//PQ[i]的左孩子</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  RChild(i)         ( ( 1 + ( i ) ) &lt;&lt; 1 ) <span class="hljs-comment">//PQ[i]的右孩子</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  InHeap(n, i)      ( ( ( -1 ) &lt; ( i ) ) &amp;&amp; ( ( i ) &lt; ( n ) ) ) <span class="hljs-comment">//判断PQ[i]是否合法</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  LChildValid(n, i) InHeap( n, LChild( i ) ) <span class="hljs-comment">//判断PQ[i]是否有一个（左）孩子</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  RChildValid(n, i) InHeap( n, RChild( i ) ) <span class="hljs-comment">//判断PQ[i]是否有两个孩子</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  Smaller(PQ, i, j)  ( !lt( PQ[i], PQ[j] ) ? j : i ) <span class="hljs-comment">//取大者（等时前者优先）</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  ProperParent(PQ, n, i) <span class="hljs-comment">/*父子（至多）三者中的大者*/</span> \</span><br><span class="hljs-meta">            ( RChildValid(n, i) ? Smaller( PQ, Smaller( PQ, i, LChild(i) ), RChild(i) ) : \</span><br><span class="hljs-meta">            ( LChildValid(n, i) ? Smaller( PQ, i, LChild(i) ) : i \</span><br><span class="hljs-meta">            ) \</span><br><span class="hljs-meta">            ) <span class="hljs-comment">//相等时父节点优先，如此可避免不必要的交换</span></span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">lt</span> <span class="hljs-params">( T&amp; a, T&amp; b )</span> </span>&#123; <span class="hljs-keyword">return</span> a &lt; b; &#125; <span class="hljs-comment">//less than</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(nums.size(),<span class="hljs-number">0</span>)</span></span>;<br><br>        <span class="hljs-comment">//堆排序</span><br>        <span class="hljs-comment">//先建堆 floyd算法 自下而上的进行下滤 排除叶子节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = nums.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<span class="hljs-number">0</span> &lt;= i;--i)<br>            <span class="hljs-built_in">percolateDown</span>(nums,i,nums.<span class="hljs-built_in">size</span>());<br>        <br>        <span class="hljs-comment">//自上而下的下滤</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; res.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            res[i] = nums[<span class="hljs-number">0</span>];<br>            nums[<span class="hljs-number">0</span>] = nums[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> - i];<br>            <span class="hljs-built_in">percolateDown</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>() - i - <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">//下滤操作 将较大的数进行下滤</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">percolateDown</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; num,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> numSize)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> j; <span class="hljs-comment">//i及其（至多两个）孩子中，堪为父者</span><br>        <span class="hljs-keyword">while</span> ( i != ( j = <span class="hljs-built_in">ProperParent</span> (num,numSize, i)))  <span class="hljs-comment">//只要i非j，则</span><br>            <span class="hljs-built_in">swap</span>(num[i], num[j] ); i = j; <span class="hljs-comment">//二者换位，并继续考查下降后的i</span><br>        <span class="hljs-keyword">return</span> i; <span class="hljs-comment">//返回下滤抵达的位置（亦i亦j）</span><br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>先对原数组从尾巴到头的下滤操作，完成后数组的形式是个小顶堆。然后依次将堆顶元素（最小）取出，将此时的堆的最后一个元素放到堆顶（为了保持堆序性，同样也是从原数组的末尾开始向前遍历），再进行对堆顶的下滤操作。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <br>    <span class="hljs-comment">//选择排序</span><br>        <span class="hljs-keyword">int</span> min;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;nums.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            min = i;<br>            <span class="hljs-comment">//找到最小的</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i;j &lt;nums.<span class="hljs-built_in">size</span>();++j)<br>                <span class="hljs-keyword">if</span>(nums[min] &gt;= nums[j]) min = j;<br><br>            <span class="hljs-built_in">swap</span>(nums[min],nums[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>重要的不是思路，重要的是超时了…..</p><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">//计数排序</span><br>        map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; i_map;<br>        <span class="hljs-comment">//先存放数组到map中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">if</span>(i_map.<span class="hljs-built_in">find</span>(nums[i]) == i_map.<span class="hljs-built_in">end</span>()) i_map.<span class="hljs-built_in">insert</span>(&#123;nums[i],<span class="hljs-number">1</span>&#125;);<br>            <span class="hljs-keyword">else</span> ++i_map[nums[i]];<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;pair:i_map)&#123;<br><br>            <span class="hljs-keyword">while</span>(pair.second != <span class="hljs-number">0</span>)&#123;<br>                nums[pos++] = pair.first;<br>                --pair.second;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>先保存每个数出现的次数到map中，然后再依次从map取出对应数量的每个数到原数组中。</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br><span class="hljs-keyword">typedef</span> multimap&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;::iterator multimapit;<br><span class="hljs-keyword">typedef</span> pair&lt;multimapit,multimapit&gt; pairit;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        multimap&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; p_multimap;<br>        <br>        <span class="hljs-comment">//基数排序</span><br>        <span class="hljs-comment">//获得最大值</span><br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(nums[i]) &gt; max) max = <span class="hljs-built_in">abs</span>(nums[i]);<br>        &#125;<br>        <span class="hljs-comment">//获得最高的位数</span><br>        <span class="hljs-keyword">int</span> max_digit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">do</span>&#123;<br>            max = max/<span class="hljs-number">10</span>;<br>            ++max_digit;<br>        &#125;<span class="hljs-keyword">while</span>(max != <span class="hljs-number">0</span>);<br>       <br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> digit = <span class="hljs-number">1</span>;digit &lt;= max_digit;++digit)&#123;<br><br>            <span class="hljs-keyword">int</span> get_remainder = <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,digit);<span class="hljs-comment">//求余</span><br>            <span class="hljs-keyword">int</span> get_quotient = get_remainder/<span class="hljs-number">10</span>;<span class="hljs-comment">//求商</span><br>            <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<span class="hljs-comment">//数组索引</span><br><br>            <span class="hljs-comment">//遍历整个数组</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;index &lt; nums.<span class="hljs-built_in">size</span>();++index)<br>                p_multimap.<span class="hljs-built_in">insert</span>(&#123;nums[index]%get_remainder/get_quotient,nums[index]&#125;);<br><br>            <span class="hljs-comment">//从multimap取出到nums</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">-9</span>;i &lt;= <span class="hljs-number">9</span>;++i)&#123;<br><br>                <span class="hljs-keyword">if</span>(p_multimap.<span class="hljs-built_in">find</span>(i) == p_multimap.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">continue</span>;<br><br>                <span class="hljs-comment">//获得key</span><br>                pairit pit = p_multimap.<span class="hljs-built_in">equal_range</span>(i);<br>                <span class="hljs-keyword">for</span>(multimapit mit = pit.first;mit!=pit.second;++mit)&#123;<br>                    nums[pos++] = mit-&gt;second;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">//清空</span><br>            p_multimap.<span class="hljs-built_in">clear</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums;   <br>    &#125;   <br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>按照低位到高位的顺序进行排序，可优化的地方很多。</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DIFFERENCE_VALUE 1000 <span class="hljs-comment">//桶中的元素以1000来分隔</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">//桶排序</span><br>        map&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;*&gt; t_map;<br>        <br>        <span class="hljs-comment">//入桶</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">int</span> key = <span class="hljs-built_in">get_key</span>(nums[i]);<br>            <span class="hljs-keyword">if</span>(t_map.<span class="hljs-built_in">find</span>(key) == t_map.<span class="hljs-built_in">end</span>()) t_map.<span class="hljs-built_in">insert</span>(&#123;key,<span class="hljs-keyword">new</span> vector&#123;nums[i]&#125;&#125;);<br>            <span class="hljs-keyword">else</span> ((vector&lt;<span class="hljs-keyword">int</span>&gt;*)t_map[key])-&gt;<span class="hljs-built_in">push_back</span>(nums[i]);<br>        &#125;<br><br>        <span class="hljs-comment">//桶排序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; bucket:t_map)<br>            <span class="hljs-built_in">sort</span>(((vector&lt;<span class="hljs-keyword">int</span>&gt;*)bucket.second)-&gt;<span class="hljs-built_in">begin</span>(),((vector&lt;<span class="hljs-keyword">int</span>&gt;*)bucket.second)-&gt;<span class="hljs-built_in">end</span>());<br>        <br>        <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//出桶</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; bucket:t_map)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; digit:*((vector&lt;<span class="hljs-keyword">int</span>&gt;*)bucket.second))<br>                nums[pos++] = digit;<br><br>            <span class="hljs-built_in"><span class="hljs-keyword">delete</span></span> (vector&lt;<span class="hljs-keyword">int</span>&gt;*)bucket.second;<br>        &#125;<br>            <br>        <span class="hljs-keyword">return</span> nums;   <br>    &#125;   <br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get_key</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; k)</span> <span class="hljs-keyword">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> k?k/DIFFERENCE_VALUE:<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>本想使用hash_map，自定义哈希函数,编译不通过…原因是hash_map不是STL所提供使用的，他只是个底层容器。</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">//希尔排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = <span class="hljs-number">0x3FFFFFFF</span>; <span class="hljs-number">0</span> &lt; d; d &gt;&gt;= <span class="hljs-number">1</span> )&#123;<span class="hljs-comment">//构建素数&#123; 1, 3, 7, 15, ..., 1073741823 &#125;</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = d; j &lt; nums.<span class="hljs-built_in">size</span>(); j++ ) &#123;<br>                <span class="hljs-keyword">int</span> tmp = nums[j],i = j - d;<span class="hljs-comment">//tmp为当前数组值,i为该列的第一个值的下标</span><br>                <span class="hljs-keyword">while</span>(<span class="hljs-number">0</span> &lt;= i &amp;&amp; nums[i]&gt;tmp)&#123;<span class="hljs-comment">//从列的下方开始,若条件满足,则往上交换</span><br>                    nums[i+d] = nums[i];<br>                    i-=d;<br>                &#125; <br>                nums[i+d] = tmp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;   <br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>当步长集合中，其中的各项并非互素，因此每一轮的排序都有大量的精力浪费于对前一轮排序工作的重复之上。所以，步长集合中，相邻项需要尽可能的互素。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>快速排序</tag>
      
      <tag>计数排序</tag>
      
      <tag>归并排序</tag>
      
      <tag>起泡排序</tag>
      
      <tag>堆排序</tag>
      
      <tag>选择排序</tag>
      
      <tag>基数排序</tag>
      
      <tag>桶排序</tag>
      
      <tag>希尔排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>94. 二叉树的中序遍历</title>
    <link href="/2021/12/09/LeetCode/94.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2021/12/09/LeetCode/94.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">本题链接</a></p><h2 id="迭代-栈-哈希表"><a href="#迭代-栈-哈希表" class="headerlink" title="迭代+栈+哈希表"></a>迭代+栈+哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>        unordered_set&lt;TreeNode*&gt; hash;<span class="hljs-comment">//防止左孩子重复入栈</span><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<span class="hljs-comment">//结果数组</span><br>        stack&lt;TreeNode*&gt; node_stack;<span class="hljs-comment">//节点栈</span><br>        TreeNode* cur_node;<br><br>        node_stack.<span class="hljs-built_in">push</span>(root);<span class="hljs-comment">//将第一个节点压栈</span><br>        <span class="hljs-keyword">while</span>(!node_stack.<span class="hljs-built_in">empty</span>())&#123;<br>            <br>            <span class="hljs-comment">//获得当前节点</span><br>            cur_node = node_stack.<span class="hljs-built_in">top</span>();<br><br>            <span class="hljs-keyword">if</span>(cur_node-&gt;left &amp;&amp; hash.<span class="hljs-built_in">find</span>(cur_node-&gt;left) == hash.<span class="hljs-built_in">end</span>())&#123;<span class="hljs-comment">//如果有左孩子</span><br>                node_stack.<span class="hljs-built_in">push</span>(cur_node-&gt;left);<span class="hljs-comment">//将左孩子入栈</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果没有左孩子</span><br>                res.<span class="hljs-built_in">push_back</span>(cur_node-&gt;val);<span class="hljs-comment">//保存结果</span><br>                hash.<span class="hljs-built_in">insert</span>(cur_node);<span class="hljs-comment">//标记自己</span><br>                node_stack.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//将自己出栈</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(cur_node-&gt;right) node_stack.<span class="hljs-built_in">push</span>(cur_node-&gt;right);<span class="hljs-comment">//右孩子入栈 </span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据中序遍历的性质，将每个时刻栈顶的左孩子优先入栈（实际上就是沿着左侧链持续下行），直到当前栈顶没有左孩子，此时就可以把自己的数据保存到结果中，然后将右孩子入栈。为了防止左孩子重复入栈，使用哈希表存储已经被取值的节点。</p><h2 id="迭代-栈1"><a href="#迭代-栈1" class="headerlink" title="迭代+栈1"></a>迭代+栈1</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<span class="hljs-comment">//结果数组</span><br>        stack&lt;TreeNode*&gt; node_stack;<span class="hljs-comment">//节点栈</span><br>        TreeNode* cur_node = root;<br><br>        <br>        <span class="hljs-comment">//先将左侧链入栈</span><br>        <span class="hljs-keyword">while</span>(cur_node)&#123;<br>            node_stack.<span class="hljs-built_in">push</span>(cur_node);<br>            cur_node = cur_node-&gt;left;<br>        &#125;   <br>        <br>        <span class="hljs-keyword">while</span>(!node_stack.<span class="hljs-built_in">empty</span>())&#123;<br><br>            <span class="hljs-comment">//获得当前节点,并将当前节点出栈</span><br>            cur_node = node_stack.<span class="hljs-built_in">top</span>();node_stack.<span class="hljs-built_in">pop</span>();<br><br>            res.<span class="hljs-built_in">push_back</span>(cur_node-&gt;val);<span class="hljs-comment">//保存结果</span><br><br>            cur_node = cur_node-&gt;right;<span class="hljs-comment">//将控制权交给右孩子</span><br><br>            <span class="hljs-comment">//沿着当前节点的左侧链下行</span><br>            <span class="hljs-keyword">while</span>(cur_node)&#123;<br>                node_stack.<span class="hljs-built_in">push</span>(cur_node);<br>                cur_node = cur_node-&gt;left;<br>            &#125;   <br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>既然中序遍历的实质就是沿着左侧链下行，那么每次就把当前节点左侧链放入栈中，栈顶为当前未被遍历的左侧链的最末端。</p><h2 id="迭代-栈2"><a href="#迭代-栈2" class="headerlink" title="迭代+栈2"></a>迭代+栈2</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>  <br>        stack&lt;TreeNode*&gt; node_stack;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        TreeNode* cur_node = root;<span class="hljs-comment">//获取当前节点</span><br><br>        <span class="hljs-keyword">while</span>(!node_stack.<span class="hljs-built_in">empty</span>() || cur_node)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur_node)&#123;<span class="hljs-comment">//沿着左侧链下行</span><br>                node_stack.<span class="hljs-built_in">push</span>(cur_node);<span class="hljs-comment">//将当前节点压栈</span><br>                cur_node = cur_node-&gt;left;<span class="hljs-comment">//将控制权交给左孩子</span><br>            &#125;   <br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//走到某条左侧链的最后,即当前节点为空</span><br>                cur_node = node_stack.<span class="hljs-built_in">top</span>();node_stack.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//将当前节点更新为栈顶节点</span><br>                res.<span class="hljs-built_in">push_back</span>(cur_node-&gt;val);<span class="hljs-comment">//保存结果</span><br>                cur_node = cur_node-&gt;right;<span class="hljs-comment">//将控制权交给右孩子</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>相比第一个版本的<strong>迭代+栈</strong>更加直观</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-built_in">inOrder</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-built_in">inOrder</span>(root-&gt;left);<span class="hljs-comment">//优先深入左孩子</span><br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<span class="hljs-comment">//再保存自己的数据</span><br>        <span class="hljs-built_in">inOrder</span>(root-&gt;right);<span class="hljs-comment">//接着深入右孩子</span><br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>递归思路很简单，而且代码简洁直观。根据中序遍历序列的性质，优先考虑左孩子即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>迭代</tag>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
      <tag>栈</tag>
      
      <tag>中序遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>98. 验证二叉搜索树</title>
    <link href="/2021/12/09/LeetCode/98.%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2021/12/09/LeetCode/98.%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">本题链接</a></p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">bool</span> res = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">long</span> last = LONG_MIN;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">inOrder</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root || !res) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-built_in">inOrder</span>(root-&gt;left);<span class="hljs-comment">//先进入左孩子</span><br><br>        <span class="hljs-keyword">if</span>(last &gt;= root-&gt;val)&#123;<span class="hljs-comment">//如果小于或等于上次的值</span><br>            res = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">else</span> last = root-&gt;val;<span class="hljs-comment">//更新上一次的值</span><br>        <br>        <span class="hljs-built_in">inOrder</span>(root-&gt;right);<span class="hljs-comment">//再进入右孩子</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二叉搜索树的中序遍历序列是递增的，所以可以按照这个递增的性质进行处理。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>中序遍历</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>993. 二叉树的堂兄弟节点</title>
    <link href="/2021/12/09/LeetCode/993.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9/"/>
    <url>/2021/12/09/LeetCode/993.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/">本题链接</a></p><h2 id="哈希表-递归"><a href="#哈希表-递归" class="headerlink" title="哈希表+递归"></a>哈希表+递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br><br>        <span class="hljs-keyword">int</span> depth;<br>        TreeNode* father;<br><br>    &#125;Elem;<br><br>    unordered_map&lt;<span class="hljs-keyword">int</span>,Elem&gt; node_map;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isCousins</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><br>        <span class="hljs-built_in">func</span>(root,<span class="hljs-number">0</span>,<span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-keyword">return</span> node_map[x].depth == node_map[y].depth &amp;&amp; node_map[x].father != node_map[y].father;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(TreeNode* root,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; depth,TreeNode* father)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br><br>        node_map[root-&gt;val] = &#123;depth,father&#125;;<br><br>        <span class="hljs-built_in">func</span>(root-&gt;left,depth+<span class="hljs-number">1</span>,root);<br>        <span class="hljs-built_in">func</span>(root-&gt;right,depth+<span class="hljs-number">1</span>,root);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>比较简单粗暴的方式就是遍历所有的节点，然后保存每个节点的高度和父节点，最后再进行比较。虽然简单直观但是很慢，如果只是对比其中两个节点的话其实没必要遍历所有的节点。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 03. 数组中重复的数字</title>
    <link href="/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2003.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2003.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">本题链接</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        unordered_set&lt;<span class="hljs-keyword">int</span>&gt; hash;<br>        <span class="hljs-keyword">int</span> i;<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt;nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">find</span>(nums[i]) == hash.<span class="hljs-built_in">end</span>()) hash.<span class="hljs-built_in">insert</span>(nums[i]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>; <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums[i];<br>    &#125;   <br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>既然是找到重复的数字，很容易想到使用哈希表来判断元素是否重复出现。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(n)$</li></ul><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//排序</span><br><br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<span class="hljs-comment">//查找</span><br>            <span class="hljs-keyword">if</span>(nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums[i];<br>    &#125;   <br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>先对数组进行排序，然后查找是否有相邻元素相等。</p><ul><li><p>时间复杂度$O(n+nlog_2{n}) = O(nlog_2{n})$</p></li><li><p>空间复杂度$O(1)$</p></li></ul><h2 id="原地哈希"><a href="#原地哈希" class="headerlink" title="原地哈希"></a>原地哈希</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">while</span>(nums[i] != i)&#123;<br>                <span class="hljs-keyword">if</span>(nums[nums[i]] == nums[i]) <span class="hljs-keyword">return</span> nums[i];<br>                <span class="hljs-built_in">swap</span>(nums[nums[i]],nums[i]);<br>            &#125;  <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>每次遍历的时候都让下标对应的元素归位，比如下标0的地方存放0。只要发现当前元素所指向的下标已经存放该元素了，就代表发现了一个重复的元素。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>数组</tag>
      
      <tag>就地算法</tag>
      
      <tag>剑指Offer</tag>
      
      <tag>就地哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 05. 替换空格</title>
    <link href="/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2005.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <url>/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2005.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">本题链接</a></p><h2 id="字符串-双指针"><a href="#字符串-双指针" class="headerlink" title="字符串+双指针"></a>字符串+双指针</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        string res;<br>        res.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>()*<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">int</span> res_index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();++i,++res_index)&#123;<br><br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                res[res_index++] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>                res[res_index++] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                res[res_index] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                res[res_index] = s[i];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题如果用从头到尾的遍历，复杂度会很高，达到$O(n^2)$。原因是string在插入时会将插入后面的元素向后移动，该移动操作的平均复杂度为$O(n)$​。</p><p>如果用一个空的字符串来不停的<code>push_back()</code>也不是最好的办法，因为字符串和向量的行为上类似，当容量不足以存放元素时会发生扩容操作，这也是一笔不小的开销。</p><p>那么就直接将结果字符串设置为固定的大小，结果字符串的大小取值范围与原字符串的空格有关。那么就按照最坏的情况考虑，当原字符串的每个字符都为空格时，结果字符串的大小就是原字符串的三倍。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 06. 从尾到头打印链表</title>
    <link href="/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2006.%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2006.%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        stack&lt;<span class="hljs-keyword">int</span>&gt; tmp_s;<br><br>        <span class="hljs-comment">//加入栈</span><br>        <span class="hljs-keyword">while</span>(head)&#123;<br>            tmp_s.<span class="hljs-built_in">push</span>(head-&gt;val);<br>            head = head-&gt;next;<br>        &#125;<br><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-comment">//从栈取出</span><br>        <span class="hljs-keyword">while</span>(!tmp_s.<span class="hljs-built_in">empty</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(tmp_s.<span class="hljs-built_in">top</span>());<br>            tmp_s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将链表从头遍历到尾，并将过程中经历过的节点的值放入栈中。然后再依次从栈中取出元素放入结果数组。</p><h2 id="获得链表大小"><a href="#获得链表大小" class="headerlink" title="获得链表大小"></a>获得链表大小</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> list_size = <span class="hljs-number">0</span>;<br>        ListNode* node = head;<br><br>        <span class="hljs-comment">//获得链表的大小</span><br>        <span class="hljs-keyword">while</span>(node)&#123;<br>            ++list_size;<br>            node = node-&gt;next;<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(list_size,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">//链表从头到尾开始遍历,对应数组从尾到头填入数据</span><br>        <span class="hljs-keyword">while</span>(head)&#123;<br>            res[--list_size] = head-&gt;val;<br>            head = head-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先获得链表大小，然后根据这个大小开辟数组，接着再遍历一次链表，将值写入数组。这样做少了vector的扩容开销</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        <span class="hljs-built_in">getNext</span>(head);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-built_in">getNext</span>(head-&gt;next);<br>        res.<span class="hljs-built_in">push_back</span>(head-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>递归思路更加直观，当从递归基返回时才会将值加入数组，函数栈的返回正好对应链表的从尾到头。</p><blockquote><p>当链表非常长的时候，这会导致函数调用的层级很深，从而可能导致函数调用栈溢出。显然，基于用栈基于循环的代码鲁棒性比这个好。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>栈</tag>
      
      <tag>链表</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 09. 用两个栈实现队列</title>
    <link href="/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2009.%20%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2009.%20%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">本题链接</a></p><h2 id="栈1"><a href="#栈1" class="headerlink" title="栈1"></a>栈1</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CQueue</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br><br>        <span class="hljs-keyword">while</span>(!tail_s.<span class="hljs-built_in">empty</span>())&#123;<br>            head_s.<span class="hljs-built_in">push</span>(tail_s.<span class="hljs-built_in">top</span>());<br>            tail_s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        head_s.<span class="hljs-built_in">push</span>(value);<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(head_s.<span class="hljs-built_in">empty</span>() &amp;&amp; tail_s.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-built_in">peek</span>();<br>        tail_s.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">while</span>(!head_s.<span class="hljs-built_in">empty</span>())&#123;<br>            tail_s.<span class="hljs-built_in">push</span>(head_s.<span class="hljs-built_in">top</span>());<br>            head_s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> tail_s.<span class="hljs-built_in">top</span>();<br>    &#125;<br><br>    stack&lt;<span class="hljs-keyword">int</span>&gt; head_s;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; tail_s;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your CQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * CQueue* obj = new CQueue();</span><br><span class="hljs-comment"> * obj-&gt;appendTail(value);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;deleteHead();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>分别用两个栈的栈底模拟队列的头和尾即可</p><h2 id="栈2"><a href="#栈2" class="headerlink" title="栈2"></a>栈2</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CQueue</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        s1.<span class="hljs-built_in">push</span>(value);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">empty</span>() &amp;&amp; s2.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//若没有数据</span><br>     <br>        <span class="hljs-keyword">if</span>(s2.<span class="hljs-built_in">empty</span>())&#123;<span class="hljs-comment">//当s2为空时</span><br><br>            <span class="hljs-keyword">while</span>(!s1.<span class="hljs-built_in">empty</span>())&#123;<span class="hljs-comment">//将s1的所有数据放入s2中</span><br>                s2.<span class="hljs-built_in">push</span>(s1.<span class="hljs-built_in">top</span>());<br>                s1.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> res = s2.<span class="hljs-built_in">top</span>();<br>        s2.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    stack&lt;<span class="hljs-keyword">int</span>&gt; s1;<span class="hljs-comment">//优先存放元素</span><br>    stack&lt;<span class="hljs-keyword">int</span>&gt; s2;<span class="hljs-comment">//反转s1的元素</span><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your CQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * CQueue* obj = new CQueue();</span><br><span class="hljs-comment"> * obj-&gt;appendTail(value);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;deleteHead();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>s1存放正常入队顺序的元素，而由于出队时先进来的元素被放在s1的栈底，所以需要借由s2来获取s1的栈底元素。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 10- II. 青蛙跳台阶问题</title>
    <link href="/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2010-%20II.%20%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"/>
    <url>/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2010-%20II.%20%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">本题链接</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">int</span> p1 = <span class="hljs-number">1</span>,p2 = <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt; n;++i)&#123;<br>            p2 = p1 + p2;<br>            p1 = p2 - p1;<br>            p2 %= <span class="hljs-number">1000000007</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p2;<br><br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题实际上就是斐波那契数列…</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>数学</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 11. 旋转数组的最小数字</title>
    <link href="/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2011.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <url>/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2011.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">本题链接</a></p><h2 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;++i)<br>            <span class="hljs-keyword">if</span>(numbers[i] &gt; numbers[i+<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">return</span> numbers[i+<span class="hljs-number">1</span>];<br>            <br>        <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>暴力搜索简单明了，直接一遍搜索即可。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(1)$</li></ul><h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>,hi = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(lo &lt; hi)&#123;<br><br>            <span class="hljs-keyword">int</span> mid = lo + (hi - lo) / <span class="hljs-number">2</span>;<span class="hljs-comment">//避免lo+hi直接溢出</span><br><br>            <span class="hljs-keyword">if</span>(numbers[mid] &lt; numbers[hi])&#123;<span class="hljs-comment">//此时结果位于mid的左侧</span><br>                <br>                hi = mid;<br><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[mid] &gt; numbers[hi])&#123;<span class="hljs-comment">//此时结果位于mid的右侧</span><br><br>                lo = mid + <span class="hljs-number">1</span>;<br><br>            &#125;<span class="hljs-keyword">else</span> --hi;<span class="hljs-comment">//特殊情况</span><br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> numbers[lo];<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>详情见<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-by-leetcode-s/">官方解析</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>数组</tag>
      
      <tag>二分查找</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 12. 矩阵中的路径</title>
    <link href="/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2012.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <url>/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2012.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">本题链接</a></p><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(board.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">//保存节点访问状态</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">state</span>(board.<span class="hljs-built_in">size</span>(),vector&lt;<span class="hljs-keyword">bool</span>&gt;(board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(),<span class="hljs-literal">false</span>));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;r &lt; board.<span class="hljs-built_in">size</span>();++r)<span class="hljs-comment">//每一行</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;c &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();++c)<span class="hljs-comment">//每一列</span><br>                <span class="hljs-keyword">if</span>(board[r][c] == word[<span class="hljs-number">0</span>] &amp;&amp; <span class="hljs-built_in">dfs</span>(r,c,board,state,word,<span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; r,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; c,<span class="hljs-keyword">const</span> vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board,vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt;&amp; state,<span class="hljs-keyword">const</span> string&amp; word,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; str_pos)</span></span>&#123;<br>        <br>        <span class="hljs-keyword">if</span>(!(<span class="hljs-number">0</span> &lt;= r &amp;&amp; r &lt; board.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-number">0</span> &lt;= c &amp;&amp; c &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果点不合法</span><br>        <span class="hljs-keyword">if</span>(state[r][c]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果自己已被遍历过</span><br><br>        <span class="hljs-keyword">bool</span> res;<br>        <span class="hljs-keyword">if</span>(board[r][c] == word[str_pos])&#123;<span class="hljs-comment">//如果自己符合</span><br>        <br>            <span class="hljs-keyword">if</span>(str_pos == word.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//且到达字符串的最后一个</span><br>            state[r][c] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//设置自己已经被遍历过</span><br>            res = <span class="hljs-built_in">dfs</span>(r + <span class="hljs-number">1</span>,c,board,state,word,str_pos + <span class="hljs-number">1</span>) ||<span class="hljs-comment">//上</span><br>                  <span class="hljs-built_in">dfs</span>(r,c + <span class="hljs-number">1</span>,board,state,word,str_pos + <span class="hljs-number">1</span>) ||<span class="hljs-comment">//右</span><br>                  <span class="hljs-built_in">dfs</span>(r - <span class="hljs-number">1</span>,c,board,state,word,str_pos + <span class="hljs-number">1</span>) ||<span class="hljs-comment">//下</span><br>                  <span class="hljs-built_in">dfs</span>(r,c - <span class="hljs-number">1</span>,board,state,word,str_pos + <span class="hljs-number">1</span>) ; <span class="hljs-comment">//左</span><br><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        state[r][c] = <span class="hljs-literal">false</span>;<span class="hljs-comment">//返回前把自己设置为未访问</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>回溯法一般使用递归，因为在递归中函数栈能保存每个时刻的行为和变量。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵</tag>
      
      <tag>回溯法</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 13. 机器人的运动范围</title>
    <link href="/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2013.%20%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <url>/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2013.%20%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">本题链接</a></p><h2 id="回溯-dfs"><a href="#回溯-dfs" class="headerlink" title="回溯+dfs"></a>回溯+dfs</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">int</span> m_bak,n_bak,k_bak;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!m || !n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        m_bak = m;n_bak = n;k_bak = k;<br><br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">state</span>(m,vector&lt;<span class="hljs-keyword">bool</span>&gt;(n,<span class="hljs-literal">false</span>));<span class="hljs-comment">//是否已被遍历</span><br>        <br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,state);<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; r,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; c,vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt;&amp; state)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isLegal</span>(r,c,state)) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//如果不合法</span><br><br>        state[r][c] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//设置自己已被遍历</span><br>        ++res;<br>        <br>        <span class="hljs-comment">//dfs(r - 1,c,state);//上</span><br>        <span class="hljs-built_in">dfs</span>(r + <span class="hljs-number">1</span>,c,state);<span class="hljs-comment">//下</span><br>        <span class="hljs-comment">//dfs(r,c - 1,state);//左</span><br>        <span class="hljs-built_in">dfs</span>(r,c + <span class="hljs-number">1</span>,state);<span class="hljs-comment">//右</span><br>        <br>        <span class="hljs-comment">//state[r][c] = false;//设置自己未被遍历</span><br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isLegal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">const</span> vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt;&amp; state)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= r &amp;&amp; r &lt; m_bak &amp;&amp; <span class="hljs-number">0</span> &lt;= c &amp;&amp; c &lt; n_bak)&#123;<span class="hljs-comment">//如果点在合法范围内</span><br>            <br>            <span class="hljs-keyword">if</span>(state[r][c]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//若该点已经被遍历过</span><br><br>            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(r &gt; <span class="hljs-number">0</span>)&#123;<br>                sum += r % <span class="hljs-number">10</span>;<br>                r = r / <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(c &gt; <span class="hljs-number">0</span>)&#123;<br>                sum += c % <span class="hljs-number">10</span>;<br>                c = c / <span class="hljs-number">10</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//若数位之和小于等于给定的K,返回真</span><br>            <span class="hljs-keyword">return</span> sum &lt;= k_bak ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对每个节点做DFS即可，比较重要的是机器人的行走方向可以优化，具体见<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/ji-qi-ren-de-yun-dong-fan-wei-by-leetcode-solution/">官方解析</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度优先搜索</tag>
      
      <tag>回溯法</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 15. 二进制中1的个数</title>
    <link href="/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2015.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2015.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">本题链接</a></p><h2 id="位运算1"><a href="#位运算1" class="headerlink" title="位运算1"></a>位运算1</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">uint32_t</span> flag = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(flag)&#123;<br><br>            <span class="hljs-keyword">if</span>(n &amp; flag) ++count;<br>            flag = flag &lt;&lt; <span class="hljs-number">1</span>;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>让flag中1的位置逐次向左移，再与n中各位置进行比较。</p><p>其实让n右移也是可以的，因为n为无符号的整型，右移n只会在最左端添加0，并不会造成死循环。</p><p>循环次数固定为32次，循环次数与输入数据的位数相同。</p><h2 id="位运算2"><a href="#位运算2" class="headerlink" title="位运算2"></a>位运算2</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n)&#123;<br>            n = (n - <span class="hljs-number">1</span>) &amp; n;<br>            ++cnt;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>把一个整数减去1，再和原来的整数做与运算，会把该整数最右边的1变成0。一直迭代到n为0即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 16. 数值的整数次方</title>
    <link href="/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2016.%20%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
    <url>/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2016.%20%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">本题链接</a></p><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//任何数的0次方都为1,即使0的0次方没有意义</span><br>        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//1的任何次方都为0</span><br><br>        <span class="hljs-comment">//快速幂</span><br>        <span class="hljs-keyword">long</span> n_tmp = <span class="hljs-built_in">abs</span>(n);<span class="hljs-comment">//设置为long防止n为边界值</span><br>        <span class="hljs-keyword">double</span> res = <span class="hljs-number">1</span>;<br> <br><br>        <span class="hljs-keyword">while</span>(n_tmp)&#123;<span class="hljs-comment">//若n_tmp的比特位还有1</span><br><br>            <span class="hljs-keyword">if</span>(n_tmp &amp; <span class="hljs-number">1</span>)<span class="hljs-comment">//若n_tmp当前位为1</span><br>                res = x * res;<br>          <br>            x *=  x;<span class="hljs-comment">//将自己累计</span><br>            n_tmp &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> ? res : <span class="hljs-number">1</span>/res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用快速幂，能让时间复杂度降低到$log_2(n)$。详见<a href="https://www.youtube.com/watch?v=GbDtCFhq20A">快速幂都能做什么？小小的算法也有大大的梦想</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>剑指Offer</tag>
      
      <tag>快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 18. 删除链表的节点</title>
    <link href="/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2018.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2018.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">本题链接</a></p><h2 id="链表遍历"><a href="#链表遍历" class="headerlink" title="链表遍历"></a>链表遍历</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br><br>        <span class="hljs-function">ListNode <span class="hljs-title">dummy</span><span class="hljs-params">(<span class="hljs-number">0</span>,head)</span></span>;<br>        ListNode* node = &amp;dummy;<br><br>        <span class="hljs-keyword">while</span>(node-&gt;next &amp;&amp; node-&gt;next-&gt;val != val)<span class="hljs-comment">//找到要删除的节点</span><br>            node = node-&gt;next;<br>        <span class="hljs-comment">//将被删除节点的前后节点接起来</span><br>        node-&gt;next = node-&gt;next-&gt;next;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>亦步亦趋的遍历，找到下一个节点为目标的节点，然后将该节点与下一个节点的下一个节点串接即可。即使被删除的节点为链表的最后一个节点也不会有错。注意需要在头节点的前面再添加一个节点，以防止删除头节点的情况出现。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</title>
    <link href="/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2021.%20%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
    <url>/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2021.%20%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">本题链接</a></p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">exchange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums;<br><br>        <span class="hljs-keyword">int</span> odd_index = <span class="hljs-number">0</span>;<span class="hljs-comment">//指向下一个奇数存放的地方</span><br>  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>();++i)<br>            <span class="hljs-keyword">if</span>(nums[i] &amp; <span class="hljs-number">0x1</span>)&#123;<span class="hljs-comment">//当前为奇数</span><br>                <span class="hljs-built_in">swap</span>(nums[odd_index++],nums[i]);<br>            <br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>只需要维护一根指向下一个奇数存放的地方的指针，然后每当遍历到奇数，就把当前的奇数放到这个指针指向的位置就行，接着这个指针再前进到下一次存放奇数的地方。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(1)$</li></ul><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">exchange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left  &lt; right)&#123;<br><br>            <span class="hljs-keyword">while</span>(left &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[left] &amp; <span class="hljs-number">0x1</span>) ++left;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-number">0</span> &lt;= right &amp;&amp; !(nums[right] &amp; <span class="hljs-number">0x1</span>)) --right;<br><br>            <span class="hljs-keyword">if</span>(left  &lt; right) <span class="hljs-built_in">swap</span>(nums[left],nums[right]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>维护两根指针，左指针从数组第一个元素开始，右指针从数组最后一个元素开始。左指针遇到偶数就停下，右指针遇到奇数就停下，然后两者交换即可。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(1)$</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>迭代</tag>
      
      <tag>双指针</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 22. 链表中倒数第k个节点</title>
    <link href="/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2022.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <url>/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2022.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">本题链接</a></p><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span>(k &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-comment">//快慢指针</span><br>        ListNode* p1 = head;<br>        ListNode* p2 = head;<br><br>        <span class="hljs-comment">//让p1先走k步</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; k &amp;&amp; p1;++i)&#123;<span class="hljs-comment">//i &lt; k &amp;&amp; p1为了避免k超过链表的长度</span><br>            p1 = p1-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(!p1) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//避免k超过链表的长度</span><br><br>        <span class="hljs-comment">//两个指针一起走</span><br>        <span class="hljs-keyword">while</span>(p1-&gt;next)&#123;<br>            p1 = p1-&gt;next;<br>            p2 = p2-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> p2;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义两个节点指针p1和p2，两个指针一开始都指向头。先让p1走k-1步，然后p1和p2再一起走。直到p1到达链表的最后一个，那么p2指向的就是倒数第k个节点。实际上就是保持p1和p2之间的节点数量为k-1。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>快慢指针</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 26. 树的子结构</title>
    <link href="/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2026.%20%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <url>/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2026.%20%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">本题链接</a></p><h2 id="迭代-递归"><a href="#迭代-递归" class="headerlink" title="迭代+递归"></a>迭代+递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!A || !B) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        vector&lt;TreeNode*&gt; imp_vec;<span class="hljs-comment">//存放可能的A树子树根节点</span><br>        queue&lt;TreeNode*&gt; node_queue;<span class="hljs-comment">//用于层序遍历</span><br>        TreeNode* cur_node;<span class="hljs-comment">//临时节点</span><br><br>        node_queue.<span class="hljs-built_in">push</span>(A);<span class="hljs-comment">//将A树入队</span><br>        <span class="hljs-keyword">while</span>(!node_queue.<span class="hljs-built_in">empty</span>())&#123;<br><br>            cur_node = node_queue.<span class="hljs-built_in">front</span>();node_queue.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//获取队头的节点</span><br>            <span class="hljs-keyword">if</span>(cur_node-&gt;val == B-&gt;val) imp_vec.<span class="hljs-built_in">push_back</span>(cur_node);<span class="hljs-comment">//找到一个可能的节点</span><br><br>            <span class="hljs-keyword">if</span>(cur_node-&gt;left) node_queue.<span class="hljs-built_in">push</span>(cur_node-&gt;left);<span class="hljs-comment">//放入左孩子</span><br>            <span class="hljs-keyword">if</span>(cur_node-&gt;right) node_queue.<span class="hljs-built_in">push</span>(cur_node-&gt;right);<span class="hljs-comment">//放入右孩子</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(imp_vec.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果没有可能的节点,直接返回</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p : imp_vec)&#123;<span class="hljs-comment">//遍历每一个可能的节点</span><br>            TreeNode* B_node = B;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(p,B_node)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//A的子树和B树同时递归</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!B) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(!A) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(A-&gt;val != B-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(A-&gt;left,B-&gt;left) &amp;&amp; <span class="hljs-built_in">dfs</span>(A-&gt;right,B-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先找到A树中所有可能的节点，判断依据就是当这个节点和B树的根节点的值相同时，那么这个节点就是一个可能的节点。之后再遍历所有的可能节点，让可能的节点和B树根节点同时深入，只要发现某一时刻两个节点的值不相同就返回<code>false</code>。</p><h2 id="双重递归"><a href="#双重递归" class="headerlink" title="双重递归"></a>双重递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!A || !B) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSubStructure</span>(A-&gt;left,B) || <span class="hljs-built_in">isSubStructure</span>(A-&gt;right,B) || <span class="hljs-built_in">dfs</span>(A,B);<br>    &#125;<br><br>    <span class="hljs-comment">//A的子树和B树同时递归</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!B) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(!A) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(A-&gt;val != B-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(A-&gt;left,B-&gt;left) &amp;&amp; <span class="hljs-built_in">dfs</span>(A-&gt;right,B-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>在<code>isSubStructure</code>函数中，可以同时对它的左右孩子进行<code>isSubStructure</code>，即在双重递归的思路下，A树中所有的节点都可能成为与B树相对应的那个子结构的根节点。虽然双重递归简洁明了，但是时间复杂度显而易见的高。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代</tag>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
      <tag>双重递归</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 27. 二叉树的镜像</title>
    <link href="/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2027.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
    <url>/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2027.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">本题链接</a></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-built_in">inOrder</span>(root);<br>        <span class="hljs-keyword">return</span> root;<br>        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">//将左右孩子交换</span><br>        TreeNode* tmp = root-&gt;left;<br>        root-&gt;left = root-&gt;right;<br>        root-&gt;right = tmp;<br><br>        <span class="hljs-built_in">inOrder</span>(root-&gt;left);<br>        <span class="hljs-built_in">inOrder</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一棵二叉树的镜像实际上就是对每个节点交换左右孩子的引用。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 29. 顺时针打印矩阵</title>
    <link href="/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2029.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <url>/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2029.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">本题链接</a></p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">int</span> r_dirc = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> c_dirc = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> dirc[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//右 下 左 上</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>        <span class="hljs-comment">//存放节点是否被遍历</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">statue</span>(matrix.<span class="hljs-built_in">size</span>(),vector&lt;<span class="hljs-keyword">bool</span>&gt;(matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(),<span class="hljs-literal">false</span>));<br>        <span class="hljs-comment">//结果</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(matrix.size() * matrix[<span class="hljs-number">0</span>].size(),<span class="hljs-number">0</span>)</span></span>;<br><br>        <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> c = <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">//从[0,-1]开始</span><br>        <span class="hljs-comment">//遍历方向从右开始</span><br>        <span class="hljs-keyword">while</span>(pos &lt; res.<span class="hljs-built_in">size</span>())&#123;<br><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isLegal</span>(r + dirc[r_dirc],c + dirc[c_dirc],matrix,statue))&#123;<span class="hljs-comment">//如果下一个合法</span><br><br>                <span class="hljs-comment">//走到下一个</span><br>                r += dirc[r_dirc];<br>                c += dirc[c_dirc];<br>                res[pos++] = matrix[r][c];<span class="hljs-comment">//放入结果</span><br>                statue[r][c] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//标记自己不能再被访问</span><br><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">changeDirc</span>();<span class="hljs-comment">//改变方向</span><br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">//改变方向</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">changeDirc</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(r_dirc == <span class="hljs-number">3</span>)&#123;<br>            r_dirc = <span class="hljs-number">0</span>;<br>            c_dirc = <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            ++r_dirc;<br>            ++c_dirc;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">//判断能不能走</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isLegal</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; r,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; c,<span class="hljs-keyword">const</span> vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix,<span class="hljs-keyword">const</span> vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt;&amp; statue)</span> <span class="hljs-keyword">const</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= r &amp;&amp; r &lt; matrix.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-number">0</span> &lt;= c &amp;&amp; c &lt; matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp; !statue[r][c]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>想象遍历方向类似贪吃蛇的运动，贪吃蛇如果下一步碰到边界或者碰到自己就会改变方向，而方向只有<strong>右下左上</strong>这四种，且不停的重复。所以可以判断下一步能不能走，不能走的话就改变贪吃蛇的方向。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(n)$</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二维数组</tag>
      
      <tag>矩阵</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 32 - I. 从上到下打印二叉树</title>
    <link href="/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2032%20-%20I.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2032%20-%20I.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">本题链接</a></p><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>        queue&lt;TreeNode*&gt; node_queue;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br><br>        node_queue.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!node_queue.<span class="hljs-built_in">empty</span>())&#123;<br><br>            <span class="hljs-keyword">if</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;left) node_queue.<span class="hljs-built_in">push</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;left);<br>            <span class="hljs-keyword">if</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;right) node_queue.<span class="hljs-built_in">push</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;right);<br>            res.<span class="hljs-built_in">emplace_back</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;val);<br>                <br>            node_queue.<span class="hljs-built_in">pop</span>();<br>            <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>就是简单的层序遍历…</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>层序遍历</tag>
      
      <tag>二叉树</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 35. 复杂链表的复制</title>
    <link href="/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2035.%20%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
    <url>/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2035.%20%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">本题链接</a></p><h2 id="就地算法"><a href="#就地算法" class="headerlink" title="就地算法"></a>就地算法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* random;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">        random = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> head;<br>        <br>        <span class="hljs-comment">//就地算法</span><br><br>        <span class="hljs-comment">//在每个节点后面添加一份它自己的复制</span><br>        Node* cur_node = head;<br>        <span class="hljs-keyword">while</span>(cur_node)&#123;<br>            <br>            <span class="hljs-comment">//创建复制</span><br>            Node* cur_node_cpy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(cur_node-&gt;val);<br>            <span class="hljs-comment">//串接新节点</span><br>            cur_node_cpy-&gt;next = cur_node-&gt;next;<br>            cur_node-&gt;next = cur_node_cpy;<br>            <span class="hljs-comment">//cur_node前进</span><br>            cur_node = cur_node_cpy-&gt;next;<br>        &#125;<br><br>        <span class="hljs-comment">//遍历每个新创建的节点</span><br>        cur_node = head;<br>        Node* new_node;<br>        <span class="hljs-keyword">while</span>(cur_node)&#123;<br><br>            <span class="hljs-comment">//新节点等于原节点的下一个</span><br>            new_node = cur_node-&gt;next;<br>            <span class="hljs-comment">//新节点的random等于它原节点的random的复制</span><br>            new_node-&gt;random = cur_node-&gt;random ? cur_node-&gt;random-&gt;next : cur_node-&gt;random;<br>            <span class="hljs-comment">//前进</span><br>            cur_node = new_node-&gt;next;<br>        &#125;<br><br>        <span class="hljs-comment">//将新节点从原节点分离</span><br>        cur_node = head;<br>        <span class="hljs-function">Node <span class="hljs-title">dummy</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>        Node* res_node = &amp;dummy;<br><br>        <span class="hljs-keyword">while</span>(cur_node)&#123;<br>            <br>            <span class="hljs-comment">//提取新链表</span><br>            res_node-&gt;next = cur_node-&gt;next;<br>            res_node = res_node-&gt;next;<br>            <span class="hljs-comment">//还原旧链表</span><br>            cur_node-&gt;next = res_node-&gt;next;<br>            cur_node = cur_node-&gt;next;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>先遍历一次原链表，每遍历到一个原节点，就在原节点后面添加一个原节点的复制</li><li>第二次遍历链表，将所有新节点的random指针指向它对应原节点的random的复制</li><li>第三次遍历链表，将新的节点和旧的节点分离，返回新的链表，并同时将旧链表恢复原样</li></ol>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>就地算法</tag>
      
      <tag>链表</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 36. 二叉搜索树与双向链表</title>
    <link href="/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2036.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2036.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">本题链接</a></p><h2 id="中序遍历1"><a href="#中序遍历1" class="headerlink" title="中序遍历1"></a>中序遍历1</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* left;</span><br><span class="hljs-comment">    Node* right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node() &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        left = NULL;</span><br><span class="hljs-comment">        right = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val, Node* _left, Node* _right) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        left = _left;</span><br><span class="hljs-comment">        right = _right;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    vector&lt;Node*&gt; node_vec;<span class="hljs-comment">//保存所有节点</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br><br>        <span class="hljs-comment">//中序遍历序列</span><br>        <span class="hljs-built_in">inOrder</span>(root);<br>        <span class="hljs-keyword">if</span>(node_vec.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-comment">//逐一串接相邻两个节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; node_vec.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;++i)&#123;<br>            node_vec[i]-&gt;right = node_vec[i+<span class="hljs-number">1</span>];<br>            node_vec[i+<span class="hljs-number">1</span>]-&gt;left = node_vec[i];<br>        &#125;<br><br>        <span class="hljs-comment">//将头尾节点串接</span><br>        node_vec[<span class="hljs-number">0</span>]-&gt;left = node_vec[node_vec.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>        node_vec[node_vec.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]-&gt;right = node_vec[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">return</span> node_vec[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(Node* root)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-built_in">inOrder</span>(root-&gt;left);<br>        node_vec.<span class="hljs-built_in">emplace_back</span>(root);<span class="hljs-comment">//保存当前节点</span><br>        <span class="hljs-built_in">inOrder</span>(root-&gt;right);<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先将二叉搜索树的节点按照中序遍历保存起来，然后再依次串接即可。借助了一个数组作为辅助空间，存放中序遍历的结果。</p><h2 id="中序遍历2"><a href="#中序遍历2" class="headerlink" title="中序遍历2"></a>中序遍历2</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* left;</span><br><span class="hljs-comment">    Node* right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node() &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        left = NULL;</span><br><span class="hljs-comment">        right = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val, Node* _left, Node* _right) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        left = _left;</span><br><span class="hljs-comment">        right = _right;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    Node* pre = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//代表中序遍历中的上次被操作的节点,在递归结束后指向最后一个节点</span><br>    Node* head = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//双向链表的第一个点</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-comment">//中序遍历</span><br>        <span class="hljs-built_in">inOrder</span>(root);<br><br>        <span class="hljs-comment">//头尾相连</span><br>        head-&gt;left = pre;<br>        pre-&gt;right = head;<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(Node* cur_node)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!cur_node) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-built_in">inOrder</span>(cur_node-&gt;left);<span class="hljs-comment">//转向左孩子</span><br><br>        <span class="hljs-keyword">if</span>(!head) head = cur_node;<span class="hljs-comment">//设置第一个点</span><br>        <span class="hljs-comment">//和上次的点串接</span><br>        cur_node-&gt;left = pre;<span class="hljs-comment">//设置当前节点的左边节点为上次的节点</span><br>        <span class="hljs-keyword">if</span>(pre) pre-&gt;right = cur_node;<span class="hljs-comment">//如果pre存在的话(pre初始化为nullptr)</span><br>        pre = cur_node;<span class="hljs-comment">//将pre设置为当前的节点</span><br><br>        <span class="hljs-built_in">inOrder</span>(cur_node-&gt;right);<span class="hljs-comment">//转向右孩子</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>相比<strong>中序遍历1</strong>少了辅助数组，直接就地解决。在中序遍历的过程中，当前节点和上次遍历的节点串接起来即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>中序遍历</tag>
      
      <tag>二叉搜索树</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 38. 字符串的排列</title>
    <link href="/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2038.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <url>/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2038.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">本题链接</a></p><h2 id="哈希表-递归-回溯"><a href="#哈希表-递归-回溯" class="headerlink" title="哈希表+递归+回溯"></a>哈希表+递归+回溯</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    unordered_set&lt;string&gt; res_hash;<span class="hljs-comment">//借哈希表去重</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">permutation</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-built_in">func</span>(s,<span class="hljs-number">0</span>,s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<span class="hljs-comment">//全排列</span><br><br>        <span class="hljs-comment">//创建结果数组</span><br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">res</span><span class="hljs-params">(res_hash.size(),<span class="hljs-string">&quot;&quot;</span>)</span></span>;<br>        <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; p:res_hash)&#123;<span class="hljs-comment">//将哈希表中的值写入结果数组</span><br>            res[pos++] = p;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(string&amp; s,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; lo,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; hi)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(lo &gt;= hi)&#123;<br>            res_hash.<span class="hljs-built_in">insert</span>(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//确定一个字符</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = lo;i &lt;= hi;++i)&#123;<br><br>            <span class="hljs-built_in">swap</span>(s[lo],s[i]);<span class="hljs-comment">//交换</span><br>            <span class="hljs-built_in">func</span>(s,lo + <span class="hljs-number">1</span>,hi);<br>            <span class="hljs-built_in">swap</span>(s[lo],s[i]);<span class="hljs-comment">//复原</span><br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>把字符串看成区间，然后每次迭代都把区间的第一个字符与剩下的字符逐一交换，并不停的缩小区间，且继续将缩小的区间的第一个字符与剩下的字符逐一的交换…直到最后一个区间的大小为1，就保存结果。</p><p>使用递归模仿回溯的流程。当字符串中有重复的字母时，排列也会出现重复的情况。此时使用哈希表去重即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>递归</tag>
      
      <tag>字符串</tag>
      
      <tag>回溯法</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 39. 数组中出现次数超过一半的数字</title>
    <link href="/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2039.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2039.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">本题链接</a></p><h2 id="摩尔投票法-栈"><a href="#摩尔投票法-栈" class="headerlink" title="摩尔投票法+栈"></a>摩尔投票法+栈</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        stack&lt;<span class="hljs-keyword">int</span>&gt; istack;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            <span class="hljs-keyword">if</span>(istack.<span class="hljs-built_in">empty</span>() || istack.<span class="hljs-built_in">top</span>() == nums[i])<span class="hljs-comment">//如果当前元素与栈顶的元素相等</span><br>                istack.<span class="hljs-built_in">push</span>(nums[i]);<span class="hljs-comment">//放入栈中</span><br>            <span class="hljs-keyword">else</span> istack.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//将栈顶元素出栈</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> istack.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用摩尔投票法，极限一换一</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(n)$</li></ul><h2 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            <span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//说明已经抵消了</span><br>                res = nums[i];<br>                ++cnt;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果res没被抵消</span><br>                res == nums[i] ? ++cnt : --cnt;<br>            &#125;<br>            <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>使用摩尔投票法，极限一换一</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(1)$</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>该题还可以使用快速排序的思路，如果一个数是众数，那么这个数同时也是中位数，并经过快排后处于数组中间。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>栈</tag>
      
      <tag>剑指Offer</tag>
      
      <tag>摩尔投票法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 40. 最小的k个数</title>
    <link href="/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2040.%20%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
    <url>/2021/12/09/LeetCode/%E5%89%91%E6%8C%87%20Offer%2040.%20%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">本题链接</a></p><h2 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-comment">//快速选择</span><br>        <span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> hi = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> target = k - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(lo &lt; hi)&#123;<br><br>            <span class="hljs-keyword">int</span> pviot = <span class="hljs-built_in">partition</span>(arr,lo,hi);<span class="hljs-comment">//获取轴点</span><br>            <span class="hljs-keyword">if</span>(target == pviot)&#123;<br>                <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt;(arr.<span class="hljs-built_in">begin</span>(),arr.<span class="hljs-built_in">begin</span>() + k);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &lt; pviot)&#123;<br>                hi = pviot - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pviot &lt; target)&#123;<br>                lo = pviot + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt;(arr.<span class="hljs-built_in">begin</span>(),arr.<span class="hljs-built_in">begin</span>() + k);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> lo,<span class="hljs-keyword">int</span> hi)</span></span>&#123;<br><br>        <span class="hljs-keyword">int</span> left = lo,right = hi;<br>        <span class="hljs-built_in">swap</span>(nums[lo],nums[lo + <span class="hljs-built_in">rand</span>() % (hi - lo)]);<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br><br>            <span class="hljs-keyword">while</span>(left &lt;= hi &amp;&amp; nums[left] &lt;= nums[lo]) ++left;<br><br>            <span class="hljs-keyword">while</span>(lo &lt; right &amp;&amp; nums[lo] &lt; nums[right]) --right;<br><br>            <span class="hljs-keyword">if</span>(left &lt; right) <span class="hljs-built_in">swap</span>(nums[left],nums[right]);<br><br>        &#125;<br>        <span class="hljs-built_in">swap</span>(nums[lo],nums[left - <span class="hljs-number">1</span>]);<span class="hljs-comment">//轴点归位</span><br>        <span class="hljs-keyword">return</span> left - <span class="hljs-number">1</span>;<br>    &#125;   <br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>借用快排思想，每次对一个区域排序。然后根据快排返回的轴点，与k进行比较，缩小轴点可能的范围，直到轴点刚好是k-1，此时就可以返回前k个元素。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>剑指Offer</tag>
      
      <tag>快速选择</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题 17.14. 最小K个数</title>
    <link href="/2021/12/09/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98%2017.14.%20%E6%9C%80%E5%B0%8FK%E4%B8%AA%E6%95%B0/"/>
    <url>/2021/12/09/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98%2017.14.%20%E6%9C%80%E5%B0%8FK%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="面试题-17-14-最小K个数"><a href="#面试题-17-14-最小K个数" class="headerlink" title="面试题 17.14. 最小K个数"></a><a href="https://leetcode-cn.com/problems/smallest-k-lcci/">面试题 17.14. 最小K个数</a></h1><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">smallestK</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(k,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-keyword">int</span>&amp; a,<span class="hljs-keyword">int</span>&amp; b)&#123;<span class="hljs-keyword">return</span> a &gt; b;&#125;;<br>        priority_queue&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;,<span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">p_q</span>(cmp);<span class="hljs-comment">//优先级队列:小顶</span><br><br>        <span class="hljs-comment">//将原数组的元素放入小顶堆排序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>();++i)&#123;<br>            p_q.<span class="hljs-built_in">push</span>(arr[i]);<br>        &#125;<br><br>        <span class="hljs-comment">//从小顶堆堆顶取出K个元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k;++i)&#123;<br>            res[i] = p_q.<span class="hljs-built_in">top</span>();<br>            p_q.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将原数组的元素放入小顶堆排序，然后再从小顶堆堆顶取出K个元素即可。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">smallestK</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(),arr.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt;(arr.<span class="hljs-built_in">begin</span>(),arr.<span class="hljs-built_in">begin</span>()+k);<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>直接使用STL排序算法，然后返回前K个就行…</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">smallestK</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>,hi = arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">quick</span>(lo,hi,arr,k);<br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt;(arr.<span class="hljs-built_in">begin</span>(),arr.<span class="hljs-built_in">begin</span>()+k);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">quick</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; lo,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; hi,vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; k)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(lo &gt;= hi) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-built_in">swap</span>(arr[lo],arr[lo+<span class="hljs-built_in">rand</span>()%(hi - lo)]);<span class="hljs-comment">//交换点</span><br>        <span class="hljs-keyword">int</span> target = arr[lo];<span class="hljs-comment">//目标</span><br>        <span class="hljs-keyword">int</span> left = lo,right = hi;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br><br>            <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt;= target)&#123;<br>                ++left;<br>            &#125;<br><br>            <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; target &lt; arr[right])&#123;<br>                --right;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(left &lt; right) <span class="hljs-built_in">swap</span>(arr[left],arr[right]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">swap</span>(arr[--left],arr[lo]);<br><br>        <span class="hljs-keyword">if</span>(left == k)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">quick</span>(lo,left,arr,k) || <span class="hljs-built_in">quick</span>(left+<span class="hljs-number">1</span>,hi,arr,k)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>只要确定第k个轴点就可以退出，并确保数组中前k个元素最小。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>优先级队列</tag>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级开发</title>
    <link href="/2021/05/11/C++/%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91/"/>
    <url>/2021/05/11/C++/%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="类体里的内联函数"><a href="#类体里的内联函数" class="headerlink" title="类体里的内联函数"></a>类体里的内联函数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br><span class="hljs-built_in">complex</span> (T r = <span class="hljs-number">0</span>, T i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i)&#123;&#125; <br>complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp;); <br><span class="hljs-function">T <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125; <span class="hljs-comment">//内联函数的候选人</span><br><span class="hljs-function">T <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125; <span class="hljs-comment">//内联函数的候选人</span><br><span class="hljs-keyword">private</span>: <br>T re, im; <span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-keyword">const</span> complex&amp;);  <br>&#125;;<br></code></pre></div></td></tr></table></figure><p>在类体里定义的函数会成为内联函数的<strong>候选人</strong>，最终是否为内联函数由编译器决定。</p><h3 id="构造函数的重载"><a href="#构造函数的重载" class="headerlink" title="构造函数的重载"></a>构造函数的重载</h3><p>构造函数重载的情况很常见，但是比如</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br><span class="hljs-built_in">complex</span> (<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i) &#123;&#125; <span class="hljs-comment">//构造函数1</span><br><span class="hljs-built_in">complex</span> () : <span class="hljs-built_in">re</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">im</span>(<span class="hljs-number">0</span>) &#123;&#125; <span class="hljs-comment">//构造函数2</span><br>complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp;); <br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125; <br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125; <br><span class="hljs-keyword">private</span>: <br><span class="hljs-keyword">double</span> re, im; <br><br><span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-keyword">const</span> complex&amp;);  <br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>构造函数1</strong>和<strong>构造函数2</strong>是不能同时存在的，原因是<strong>构造函数1</strong>的形参设置了默认值，编译器无法分辨它和<strong>构造函数2</strong>的区别</p><h2 id="参数传递与返回值"><a href="#参数传递与返回值" class="headerlink" title="参数传递与返回值"></a>参数传递与返回值</h2><h3 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h3><p>const关键字用于成员函数（如下面代码段中的<strong>一号const</strong>和<strong>二号const</strong>），表示该成员函数所执行的内容不会改变类里面的数据。</p><p>另外，const用于变量（如下面代码段中的<strong>三号const</strong>），表示该变量的值无法被修改。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/*xxx.h*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">complex</span> (<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i)  &#123; &#125; <br>    complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp;); <br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125; <span class="hljs-comment">//一号const</span><br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125; <span class="hljs-comment">//二号const</span><br><span class="hljs-keyword">private</span>: <br>    <span class="hljs-keyword">double</span> re, im; <br>    <span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-keyword">const</span> complex&amp;);  <br>&#125;;<br><br><span class="hljs-comment">/*mian.cc*/</span><br><span class="hljs-comment">//...</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">const</span> complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//三号const</span><br>cout &lt;&lt; c1.<span class="hljs-built_in">real</span>();<span class="hljs-comment">//代码1</span><br>cout &lt;&lt; c1.<span class="hljs-built_in">imag</span>();<span class="hljs-comment">//代码2</span><br>&#125;<br><span class="hljs-comment">//...</span><br></code></pre></div></td></tr></table></figure><p>假设有两种情况：</p><ol><li>一号const和二号const存在</li><li>一号const和二号const不存在</li></ol><p>第一种情况是正确的。c1为const，故无法更改c1的内容。又因为<strong>real()</strong>方法为const，所以<strong>代码1</strong>和<strong>代码2</strong>不会报错。</p><p>第二种情况是错误的。此时<strong>real()</strong>和<strong>imag()</strong>这两个成员函数不是const，而c1变量又是const，当执行<code>cout&lt;&lt;c1.real();</code>时，编译器认为<strong>real()</strong>这个方法可能会改变c1变量的内容，故会报错。这种情况下把<strong>三号const</strong>也去掉，编译器就不会报错了。</p><p>不过为了程序的健壮性与开发规范，没有改变类数据的成员函数加上const是必不可少的。</p><h3 id="参数传递和返回值传递"><a href="#参数传递和返回值传递" class="headerlink" title="参数传递和返回值传递"></a>参数传递和返回值传递</h3><ol><li>值传递：值有多大就传多大</li><li>指针：传地址</li><li>引用：引用的底层就是指针，传引用就是传指针</li></ol><p><strong>参数和返回值传递尽量使用引用</strong>。不过有些情况可以用值，比如值的大小&lt;4字节时，速度会更快点。</p><p>引用速度很快，但是它和指针一样，内容会被修改。当我们只想追求参数传递速度而不想改变引用的内容时，可以使用const来修饰引用。如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br><span class="hljs-built_in">complex</span> (<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i)  &#123; &#125; <br>complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp;); <span class="hljs-comment">//const引用修饰的形参</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125; <br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125; <br><span class="hljs-keyword">private</span>: <br><span class="hljs-keyword">double</span> re, im; <br><span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-keyword">const</span> complex&amp;);<span class="hljs-comment">//const引用修饰的返回值</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>当函数返回值为函数的<strong>局部变量</strong>时，禁止使用引用。</p><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>在一个类里声明一个友元函数，表示这个友元函数可以随意访问这个类的内容，比如private修饰的类成员数据。即类对于友元函数失去了封装性。</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br><span class="hljs-built_in">complex</span> (<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i)  &#123; &#125; <br>complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp;); <br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125; <br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125; <br><span class="hljs-keyword">private</span>: <br><span class="hljs-keyword">double</span> re, im ; <br><span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-keyword">const</span> complex&amp;);  <br>&#125;;<br><br><span class="hljs-keyword">inline</span> complex&amp; __doapl (complex* ths, <span class="hljs-keyword">const</span> complex&amp; r) &#123; <br>    ths - &gt;re += r.re ; <br>    ths - &gt;im += r.im ; <br>    <span class="hljs-keyword">return</span> *ths ; <br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于友元函数还有个特例：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br><span class="hljs-built_in">complex</span> (<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i)  &#123; &#125; <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> complex&amp; param)</span> </span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> param.re + param.im; &#125; <br><span class="hljs-keyword">private</span>: <br><span class="hljs-keyword">double</span> re, im; <br>&#125;;<br><span class="hljs-comment">//...</span><br>&#123; <br><span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>; <br>complex c2; <br>c2.<span class="hljs-built_in">func</span>(c1); <br>&#125;<br><span class="hljs-comment">//...</span><br></code></pre></div></td></tr></table></figure><p>上面的例子是正确。虽然re和im这两个类成员数据是私有的，但是c2却能访问c1的私有变量。这个隐藏属性用一句话就能解释：</p><p><strong>相同 class 的各个 objects 互为 friends (友元)</strong>。</p><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><h3 id="成员函数的隐藏参数"><a href="#成员函数的隐藏参数" class="headerlink" title="成员函数的隐藏参数"></a>成员函数的隐藏参数</h3><p>所有成员函数都自带一个隐藏的<strong>this</strong>指针</p><h3 id="返回值引用的语法分析"><a href="#返回值引用的语法分析" class="headerlink" title="返回值引用的语法分析"></a>返回值引用的语法分析</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//XXX.h</span><br><span class="hljs-comment">//方法1</span><br><span class="hljs-keyword">inline</span> complex&amp;<span class="hljs-comment">//返回值是引用类型，速度更快</span><br>__doapl(complex* ths, <span class="hljs-keyword">const</span> complex&amp; r) &#123; <br>    ... <br>    <span class="hljs-keyword">return</span> *ths; <span class="hljs-comment">//这里的*表示取ths这个指针的内容</span><br>&#125; <br><br><span class="hljs-comment">//方法2</span><br><span class="hljs-keyword">inline</span> complex&amp; <span class="hljs-comment">//这里返回值改成“值”类型也是没问题的</span><br>complex::<span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp; r) &#123; <span class="hljs-comment">//这里的参数列表只有一个r,这个r指的是右值。而左值是隐藏的this</span><br>    <span class="hljs-keyword">return</span> __doapl(<span class="hljs-keyword">this</span>,r); <span class="hljs-comment">//调用__doapl</span><br>&#125;<br><br><span class="hljs-comment">//main.c</span><br>&#123;<br><span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-function">complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>c2 += c1;<span class="hljs-comment">//上面代码的返回值类型的改动不会影响到这行代码的结果</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>__doapl</strong>这个函数的返回值为引用，所以调用该函数者，无论是以值的类型接收还是以引用的类型接收都可以，与<strong>__doapl</strong>无关。</p><p>我们设计<strong>方法2</strong>的时候，如果只考虑使用者只会编写出<code>c2 += c1</code>这种情况，那么方法2的返回值类型改成void的也是可以的。但是当使用者编写出<code>c3 += c2 += c1</code>这样的连续赋值的代码时，方法2为void返回值类型就会出错。</p><p>一个好的函数设计应该做到：</p><p><strong>传递者无需知道接收者是以引用形式接收</strong></p><p>那么如何判断一个函数的返回值类型能不能为引用呢？其实很简单，只要判断返回值在函数内是不是该函数的临时变量，如果是，就老老实实的用值类型；如果不是，即该返回值是事先存在的（还没调用到该函数时就已经存在了），那么就可以用引用类型的返回值。</p><h3 id="操作符重载的非成员函数与临时对象"><a href="#操作符重载的非成员函数与临时对象" class="headerlink" title="操作符重载的非成员函数与临时对象"></a>操作符重载的非成员函数与临时对象</h3><p>例1：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//函数1</span><br><span class="hljs-keyword">inline</span> complex <br><span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">const</span> complex&amp; x, <span class="hljs-keyword">const</span> complex&amp; y) <br>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>(<span class="hljs-built_in">real</span> (x) + <span class="hljs-built_in">real</span> (y), <span class="hljs-built_in">imag</span> (x) + <span class="hljs-built_in">imag</span> (y)); <br>&#125; <br><br><span class="hljs-comment">//函数2</span><br><span class="hljs-keyword">inline</span> complex <br><span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">const</span> complex&amp; x, <span class="hljs-keyword">double</span> y) <br>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>(<span class="hljs-built_in">real</span> (x) + y, <span class="hljs-built_in">imag</span> (x)); <br>&#125; <br><br><span class="hljs-comment">//函数3</span><br><span class="hljs-keyword">inline</span> complex <br><span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">const</span> complex&amp; y) <br>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>(x + <span class="hljs-built_in">real</span> (y), <span class="hljs-built_in">imag</span> (y)); <br>&#125;<br><br><span class="hljs-comment">//函数4</span><br><span class="hljs-keyword">inline</span> complex<br><span class="hljs-keyword">operator</span> - (<span class="hljs-keyword">const</span> complex&amp; x)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span> (-<span class="hljs-built_in">real</span> (x), -<span class="hljs-built_in">imag</span> (x));<br>&#125;<br><br><span class="hljs-comment">//函数5</span><br><span class="hljs-keyword">inline</span> complex<br><span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">const</span> complex&amp; x)<br>&#123;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-comment">//main.c</span><br>&#123;<br><span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br>complex c2;<br>c2 = c1 + c2;<span class="hljs-comment">//对应函数1</span><br>c2 = c1 + <span class="hljs-number">5</span>;<span class="hljs-comment">//对应函数2</span><br>c2 = <span class="hljs-number">7</span> + c1;<span class="hljs-comment">//对应函数3</span><br>    cout &lt;&lt; -c1;<span class="hljs-comment">//对应函数4</span><br>    cout &lt;&lt; +c1;<span class="hljs-comment">//对应函数5</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面的函数1~4的返回值类型都是值，而不是引用。原因是这几个函数最后返回的complex都是<strong>临时对象</strong>，所以不能用引用，否则会出错。函数5应该可以把返回值类型改成引用，由于代码源自标准库，所以设计者有他的道理或者说该函数不够完美。</p><p>例2：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//函数1</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> complex</span><br><span class="hljs-function"><span class="hljs-title">conj</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> complex&amp; x)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span> (<span class="hljs-built_in">real</span> (x), -<span class="hljs-built_in">imag</span> (x));<br>&#125;<br><br><span class="hljs-comment">//函数2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream.h&gt;</span></span><br>ostream&amp;<span class="hljs-comment">//函数2的返回值类型</span><br><span class="hljs-keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="hljs-keyword">const</span> complex&amp; x)<br>&#123;<br><span class="hljs-keyword">return</span> os &lt;&lt; <span class="hljs-string">&#x27;(&#x27;</span> &lt;&lt; <span class="hljs-built_in">real</span> (x) &lt;&lt; <span class="hljs-string">&#x27;,&#x27;</span> &lt;&lt; <span class="hljs-built_in">imag</span> (x) &lt;&lt; <span class="hljs-string">&#x27;)&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">//main.c</span><br>&#123;<br><span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-built_in">conj</span>(c1);<span class="hljs-comment">//代码1</span><br>cout &lt;&lt; c1 &lt;&lt; <span class="hljs-built_in">conj</span>(c1);<span class="hljs-comment">//代码2</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于函数2，返回值类型可以为void，但是只有代码1才能正确执行。当返回值类型为引用时，代码1和代码2都能正确执行。</p><p>另外，我们也可以写出<code>c1&lt;&lt;cout;</code>这样的代码，将<strong>函数2</strong>写为成员函数就会出现这种情况，不过一般不这么做，因为不符合规范。</p><h2 id="拷贝构造，拷贝复制，析构（Big-Three）"><a href="#拷贝构造，拷贝复制，析构（Big-Three）" class="headerlink" title="拷贝构造，拷贝复制，析构（Big Three）"></a>拷贝构造，拷贝复制，析构（Big Three）</h2><h3 id="默认的Big-Three"><a href="#默认的Big-Three" class="headerlink" title="默认的Big Three"></a>默认的Big Three</h3><p>编译器都会给类默认生成Big Three，当然我们也可以自己写。但是当一个类里面有指针类型的成员变量时，我们最好要自定义Big Three。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">String</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr = <span class="hljs-number">0</span>); <span class="hljs-comment">//构造函数</span><br><span class="hljs-built_in">String</span>(<span class="hljs-keyword">const</span> String&amp; str); <span class="hljs-comment">//拷贝构造</span><br>String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> String&amp; str);<span class="hljs-comment">//拷贝复制 </span><br>~<span class="hljs-built_in">String</span>(); <span class="hljs-comment">//析构函数</span><br><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">get_c_str</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_data; &#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">char</span>* m_data;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-title">String::String</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr = <span class="hljs-number">0</span>)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (cstr) &#123;<br>m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-built_in">strlen</span>(cstr)+<span class="hljs-number">1</span>];<br><span class="hljs-built_in">strcpy</span>(m_data, cstr);<br>&#125;<br><span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 未指定初值</span><br>m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1</span>]; *m_data = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">inline</span><br>String::~<span class="hljs-built_in">String</span>() &#123;<br><span class="hljs-keyword">delete</span>[] m_data;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="对象拥有指针时的拷贝构造"><a href="#对象拥有指针时的拷贝构造" class="headerlink" title="对象拥有指针时的拷贝构造"></a>对象拥有指针时的拷贝构造</h3><p>编译器自带的拷贝构造有缺点，比如当一个对象1中有一个指针指向内存的地址，而通过编译器给的拷贝构造进行拷贝时，对象2也会拥有这个指针，同时也指向同一块内存，所以这并不是真正意义上的拷贝。所以<strong>当类含有指针，我们一定不能使用默认的拷贝构造</strong>。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416173442.png" alt="拷贝构造示例"></p><h3 id="拷贝复制中的检测自我赋值"><a href="#拷贝复制中的检测自我赋值" class="headerlink" title="拷贝复制中的检测自我赋值"></a>拷贝复制中的检测自我赋值</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">inline</span><br>String&amp; String::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> String&amp; str)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;str)<span class="hljs-comment">//检测自我赋值</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><br><span class="hljs-keyword">delete</span>[] m_data;<span class="hljs-comment">//第一步，删除自己的空间</span><br>m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-built_in">strlen</span>(str.m_data) + <span class="hljs-number">1</span>];<span class="hljs-comment">//第二步，创建空间，空间大小参考复制的对象</span><br><span class="hljs-built_in">strcpy</span>(m_data, str.m_data);<span class="hljs-comment">//第三步，将复制的对象的内容复制到自己的空间里</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416173919.png" alt="检测自我复制"></p><p>假设我们执行<code>a=a;</code>,此时若没有<strong>检测自我赋值</strong>，直接执行第一步，那么执行当第二步的时候，由于<code>str.m_data</code>这个指针已经被第一步删除了，所以会出错。</p><h2 id="堆、栈与内存管理"><a href="#堆、栈与内存管理" class="headerlink" title="堆、栈与内存管理"></a>堆、栈与内存管理</h2><h3 id="new和delete的详解"><a href="#new和delete的详解" class="headerlink" title="new和delete的详解"></a>new和delete的详解</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417172347.png" alt="new"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417172442.png" alt="delete"></p><h3 id="动态分配所得到的内存块以及array"><a href="#动态分配所得到的内存块以及array" class="headerlink" title="动态分配所得到的内存块以及array"></a>动态分配所得到的内存块以及array</h3><p>一块由动态分配得到的内存如下所示：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417175419.png" alt="内存"></p><p>须知：分配出来内存的大小必须为16的倍数。</p><p>绿色的内存区域是我们为类型分配空间时，该类型占用的存储空间。</p><p>头尾两块红色的内存，称为cookie，它的作用是表示这块内存的大小和状态。比如一块内存大小为64的内存，转换为16进制为0x40，但是我们看最左边的那片内存，头尾的cookie却是0x41，原因是当这片内存处于释放状态时，cookie的最后一位为0；而当这片内存处于使用状态时，cookie的最后一位为1。所以0x41实际上代表着：这块内存的大小为64且正在被使用。</p><p>灰色的内存区域表示处于debug模式下需要用到的空间，具体名称见下图。</p><p>浅绿色的内存区域表示当这块内存区域的大小不是16的倍数时，需要多余的内存区域。这块内存区域纯粹是起到了填充的作用，让整片内存区域变成16的倍数。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417181042.png" alt="动态分配array"></p><p>上图中String这边对应着下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">String</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr = <span class="hljs-number">0</span>);<br><span class="hljs-built_in">String</span>(<span class="hljs-keyword">const</span> String&amp; str);<br>String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> String&amp; str);<br>~<span class="hljs-built_in">String</span>();<br><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">get_c_str</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_data; &#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">char</span>* m_data;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-title">String::String</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr = <span class="hljs-number">0</span>)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (cstr) &#123;<br>m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-built_in">strlen</span>(cstr)+<span class="hljs-number">1</span>];<span class="hljs-comment">//这里的new使用中括号，会导致下面析构函数的delete使用中括号</span><br><span class="hljs-built_in">strcpy</span>(m_data, cstr);<br>&#125;<br><span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 未指定初值</span><br>m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1</span>]; *m_data = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">inline</span><br>String::~<span class="hljs-built_in">String</span>() &#123;<br><span class="hljs-keyword">delete</span>[] m_data;<span class="hljs-comment">//这里的delete使用中括号，是因为上面构造函数的new使用了中括号</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>array new、array delete这两者需要互相搭配</strong>，不然像下图的情况，会导致内存泄露：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417174307.png" alt="示意图"></p><h3 id="new和delete的重载"><a href="#new和delete的重载" class="headerlink" title="new和delete的重载"></a>new和delete的重载</h3><p>对于new和delete的重载比较特殊，对于<strong>全局</strong>的重载只能改变<code>new</code>内部的<code>operator new</code>。比如</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Complex* pc = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">//此处的new并不能被重载</span><br><br><span class="hljs-comment">//**********</span><br><span class="hljs-keyword">void</span>* mem = <span class="hljs-keyword">operator</span> <span class="hljs-built_in"><span class="hljs-keyword">new</span></span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Complex));<span class="hljs-comment">//只有这里的new会被重载</span><br>pc = <span class="hljs-keyword">static_cast</span>&lt;Complex*&gt;(mem);<br>pc-&gt;Complex::<span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br><span class="hljs-comment">//**********</span><br></code></pre></div></td></tr></table></figure><p>实际上，类里对于<code>operator new</code>的重载必须是<code>static</code>静态方法，因为<code>operator new</code>无法通过对象来调用。但是又因为<strong>必须</strong>是<code>static</code>，所以我们可以省略不写，编译器会自动转成静态方法。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/66788b8ddbd5222fc1305edc2eb807b9-291fd.png" alt="new和delete的重载"></p><p>成员的重载和全局的重载类似，但是成员的重载只会影响具体的对象，并不会影响到全局。比如：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/802ea01e86c5f33027bb662e7cb8f6eb-fe55d.png" alt="成员的重载"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f93c6a1d0fbc45623c36504b87fc7ff7-9832f.png" alt="成员的重载"></p><p>内存池经常使用这种重载的写法。</p><h4 id="new和delete重载例子"><a href="#new和delete重载例子" class="headerlink" title="new和delete重载例子"></a>new和delete重载例子</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6d9b9f2bcaea735bfe0440039666101e-2c912.png" alt="new和delete重载例子"></p><p>注意：若使用者想绕过成员重载的new和delete，那么可以使用域运算符强制使用全局的new和delete：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">Foo* pf = ::<span class="hljs-keyword">new</span> Foo;<span class="hljs-comment">//强制使用全局的new</span><br>::<span class="hljs-keyword">delete</span> pf;<span class="hljs-comment">//强制使用全局的delete</span><br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8d373471aa84c1428828b9fbc2b7a43b-483b9.png" alt="new和delete重载例子"></p><p>本例中的<code>Foo</code>大小为$int(4)+long(4)+string(4) = 12$，五个<code>Foo</code>就是$12<em>5=60$。但是上图中，大小为5的<code>Foo</code>指针数组的<em>*size</em></em>却为64。这多出来的4个字节实际上是计数器，记录了该数组的元素个数，不然当<code>array delete</code>的时候，无法正常释放。</p><p>还有一点，上图右边的内存示意图，表示当<code>array new</code>时，对象的构造是自上而下，即从下标为0开始的元素构造到最后一个；而<code>array delete</code>的顺序正好相反。</p><h4 id="placement-operator-new-delete"><a href="#placement-operator-new-delete" class="headerlink" title="placement operator new/delete"></a>placement operator new/delete</h4><p>因为new操作符是先分配内存，再执行构造函数，所以当构造函数发生异常后，需要及时的归还内存，否则会造成内存泄漏。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/711308668153592ca45c4aada96ad2bc-c4497.png" alt="placement operator new/delete"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/d85663e5f18393030570a21bb364de79-d3e5d.png" alt="placement operator new/delete"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/427d96d859f4c379c07aeb0c363f03fc-c443a.png" alt="placement operator new/delete"></p><h4 id="c-库例子：basic-string使用new-extra-扩充申请量"><a href="#c-库例子：basic-string使用new-extra-扩充申请量" class="headerlink" title="c++库例子：basic_string使用new(extra)扩充申请量"></a>c++库例子：basic_string使用new(extra)扩充申请量</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f40ea2a9e53c950064695b344070ea3f-68f51.png" alt="c++库例子：basic_string使用new(extra)扩充申请量"></p><h2 id="拓展补充：类模板、函数模板及其他"><a href="#拓展补充：类模板、函数模板及其他" class="headerlink" title="拓展补充：类模板、函数模板及其他"></a>拓展补充：类模板、函数模板及其他</h2><h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><p><strong>每个类成员函数都有一个指向自己所处对象的this指针</strong>，通过对象调用成员函数时，会把对象的地址放到成员函数里变成this指针</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417194726.png" alt="示意图"></p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ol><li>静态数据、静态函数与对象脱离，它不属于对象。它只有一份，存储在内存的某片区域</li><li>静态函数没有this指针，所以它只能处理静态的数据</li><li>静态函数可以通过类名调用，也可以通过对象名调用</li><li>只有调用或执行到含有静态数据的函数或代码块，该静态数据才会被创建</li></ol><h3 id="模板简介"><a href="#模板简介" class="headerlink" title="模板简介"></a>模板简介</h3><p>类模板：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">complex</span> (T r = <span class="hljs-number">0</span>, T i = <span class="hljs-number">0</span>): <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i) &#123; &#125;<br>complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp;);<br><span class="hljs-function">T <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125;<br><span class="hljs-function">T <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125;<br><span class="hljs-keyword">private</span>:<br>T re, im;<br><span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-keyword">const</span> complex&amp;); <br>&#125;;<br><br>&#123;<br><span class="hljs-function">complex&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2.5</span>,<span class="hljs-number">1.5</span>)</span></span>;<span class="hljs-comment">//代码1</span><br><span class="hljs-function">complex&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">6</span>)</span></span>;<span class="hljs-comment">//代码2</span><br>...<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>当执行到<strong>代码1</strong>和<strong>代码</strong>2时，类模板会根据<code>double</code>和<code>int</code>生成相应的代码。这种行为会造成代码的膨胀，但是这是必要的。</p><p>函数模板：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417201643.png" alt="函数模板"></p><p>类模板的类型用<strong>typename</strong>来代替，而函数模板用<strong>class</strong>来代替，虽然看起来两者不同，但是意思上是一样的。</p><p>类模板和函数模板的不同点在于<strong>引数推导</strong>，即编译器会根据实参的类型来推导，比如上图<code>r3 = min(r1,r2)</code>中的<strong>r1</strong>和<strong>r2</strong>。</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417212750.png" alt="命名空间"></p><h2 id="组合与继承"><a href="#组合与继承" class="headerlink" title="组合与继承"></a>组合与继承</h2><h3 id="组合-has-a"><a href="#组合-has-a" class="headerlink" title="组合 has-a"></a>组合 has-a</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417212913.png" alt="复合例子1"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417212933.png" alt="复合例子2"></p><h3 id="组合关系下的构造与析构"><a href="#组合关系下的构造与析构" class="headerlink" title="组合关系下的构造与析构"></a>组合关系下的构造与析构</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417213018.png" alt="复合的析构"></p><h3 id="委托-Composition-by-reference"><a href="#委托-Composition-by-reference" class="headerlink" title="委托 Composition by reference"></a>委托 Composition by reference</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417213157.png" alt="委托"></p><p>这样的做法很好，因为这样做可以保持左边不变右边变，即提供给客户端的接口不变，但是实现接口的功能可以改变。这样又称为编译防火墙，因为左边不变，所以左边无需再编译。</p><p>委托和组合的区别：</p><ol><li>组合中，两者的生命周期是同时的。而在委托里，两者的生命周期可以分先后。</li></ol><h3 id="继承关系下的构造与析构"><a href="#继承关系下的构造与析构" class="headerlink" title="继承关系下的构造与析构"></a>继承关系下的构造与析构</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417221702.png" alt="继承"></p><h3 id="继承-组合关系下的构造与析构"><a href="#继承-组合关系下的构造与析构" class="headerlink" title="继承+组合关系下的构造与析构"></a>继承+组合关系下的构造与析构</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/d47977674578fa527e49b603340f0e60-d4e93.png" alt="继承+组合关系下的构造与析构"></p><h2 id="虚函数与多态"><a href="#虚函数与多态" class="headerlink" title="虚函数与多态"></a>虚函数与多态</h2><h3 id="内存中的继承"><a href="#内存中的继承" class="headerlink" title="内存中的继承"></a>内存中的继承</h3><p>函数继承：子类继承了父类的函数调用权</p><h3 id="继承与模板方法"><a href="#继承与模板方法" class="headerlink" title="继承与模板方法"></a>继承与模板方法</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210418075133.png" alt="模板方法"></p><h3 id="委托-继承与观察者模式"><a href="#委托-继承与观察者模式" class="headerlink" title="委托+继承与观察者模式"></a>委托+继承与观察者模式</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210418080207.png" alt="观察者模式"></p><h4 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/25e2643d8ad391fd2a7ee50d3e4ac2a9-375551.png" alt="委托+继承"></p><ol><li>add()函数不能为纯虚函数的原因：如果是纯虚函数，那么Primitive这个类就必须实现。</li><li>Composite是个容器，可以同时存放Primitive和自身。这种情况下可以抽象出两者的父类，并以父类的指针作为容器的元素。</li><li>应用场景：可以把Primitive看成文件，Composite看成目录。</li></ol><h4 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h4><p>若有如下需求：在一个树状继承体系中，创建出一个未来才会实现的类。即在代码中对未来的类进行提前的封装，然后进行相关的操作？</p><p>设想：派生出来的子类创建完自己后，将自己的位置告诉给父类，让父类存储。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/cd0bd4e2038edfe0b32e67c780956a79-737a8.png" alt="Prototype"></p><p>父类：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">imageType</span> &#123;</span> LSAT, SPOT &#125;; <span class="hljs-comment">//子类类型的枚举变量</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Image</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <br>    <span class="hljs-function"><span class="hljs-keyword">static</span> Image *<span class="hljs-title">findAndClone</span><span class="hljs-params">(imageType)</span></span>; <br>    <br>    <span class="hljs-keyword">protected</span>: <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> imageType <span class="hljs-title">returnType</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//由子类实现，让子类返回自己的类型</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Image *<span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//由子类实现clone过程</span><br>    <span class="hljs-built_in">addPrototype</span>(Image *image) &#123; <span class="hljs-comment">// 当 Image 的每个子类被声明时，它会注册它的static void原型</span><br>                _prototypes[_nextSlot++] = image;<br>            &#125; <br>    <br>    <span class="hljs-keyword">private</span>: <br>    <span class="hljs-keyword">static</span> Image *_prototypes[<span class="hljs-number">10</span>]; <span class="hljs-comment">// addPrototype() 在这里保存每个注册的原型</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _nextSlot; <br>&#125;; <br>Image *Image::_prototypes[]; <br><span class="hljs-keyword">int</span> Image::_nextSlot;<br><span class="hljs-comment">// 客户需要实例时调用这个公共静态成员函数</span><br><span class="hljs-comment">// 返回一个 Image子类</span><br><span class="hljs-function">Image *<span class="hljs-title">Image::findAndClone</span><span class="hljs-params">(imageType type)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; _nextSlot; i++)<br><span class="hljs-keyword">if</span> (_prototypes[i]-&gt;<span class="hljs-built_in">returnType</span>() == type)<br><span class="hljs-keyword">return</span> _prototypes[i]-&gt;<span class="hljs-built_in">clone</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>子类：<br><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LandSatImage</span>:</span> <span class="hljs-keyword">public</span> Image &#123; <br>    <span class="hljs-keyword">public</span>: <br>    <span class="hljs-function">imageType <span class="hljs-title">returnType</span><span class="hljs-params">()</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> LSAT; <br>    &#125; <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;  <br>        cout &lt;&lt; <span class="hljs-string">&quot;LandSatImage::draw &quot;</span> &lt;&lt; _id &lt;&lt; endl; <br>    &#125; <br>    <span class="hljs-comment">// 当clone被调用时, 调用带了一个假参数(dummy)的构造函数：LandSatImage(int dummy)</span><br>    <span class="hljs-function">Image *<span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">LandSatImage</span>(<span class="hljs-number">1</span>); <br>    &#125; <br>    <span class="hljs-keyword">protected</span>: <br>    <span class="hljs-comment">// 只会被clone()函数调用 </span><br>    <span class="hljs-built_in">LandSatImage</span>(<span class="hljs-keyword">int</span> dummy) &#123;<br>                _id = _count++; <br>            &#125; <br>    <span class="hljs-keyword">private</span>: <br>    <span class="hljs-comment">// 始化 Image 子类 - 这会导致调用默认的构造函数，它注册子类的原型 </span><br>    <span class="hljs-keyword">static</span> LandSatImage _landSatImage; <br>    <span class="hljs-comment">// 这仅在初始化私有静态数据成员时调用 </span><br>    <span class="hljs-built_in">LandSatImage</span>() &#123; <span class="hljs-built_in">addPrototype</span>(<span class="hljs-keyword">this</span>); &#125; <br>    <span class="hljs-comment">// 区分每个实例所需 </span><br>    <span class="hljs-keyword">int</span> _id; <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _count; <br>&#125;; <br><span class="hljs-comment">// 注册子类的原型</span><br>LandSatImage LandSatImage::_landSatImage; <br><span class="hljs-comment">// 区分每个实例所需</span><br><span class="hljs-keyword">int</span> LandSatImage::_count = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//略</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpotImage</span>:</span> <span class="hljs-keyword">public</span> Image<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">imageType <span class="hljs-title">returnType</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> SPOT;<br>&#125;<br>    <span class="hljs-comment">//....与class LandSatImage相似，略</span><br>&#125;<br></code></pre></div></td></tr></table></figure></p><p>main:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 模拟创建请求</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> NUM_IMAGES = <span class="hljs-number">8</span>; <br>imageType input[NUM_IMAGES] = &#123; LSAT, LSAT, LSAT, SPOT, LSAT, SPOT, SPOT, LSAT &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>Image* images[NUM_IMAGES];<br><span class="hljs-comment">// 给定一个图像类型，找到正确的原型，并返回一个克隆</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_IMAGES; i++)<br>images[i] = Image::<span class="hljs-built_in">findAndClone</span>(input[i]);<br><span class="hljs-comment">// 证明已克隆正确的图像对象</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NUM_IMAGES; i++)<br>images[i]-&gt;<span class="hljs-built_in">draw</span>();<br><span class="hljs-comment">// 释放动态内存</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NUM_IMAGES; i++)<br><span class="hljs-keyword">delete</span> images[i];<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="conversion-function（转换函数）"><a href="#conversion-function（转换函数）" class="headerlink" title="conversion function（转换函数）"></a>conversion function（转换函数）</h2><ul><li>转换函数没有返回类型</li><li>为了程序的健壮性，转换函数需要加const</li><li>转换类型不一定得是基本类型，自定义类型也行，只要编译器认得转换的类型就可以。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Fraction</span>(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> den=<span class="hljs-number">1</span>) <br>  : <span class="hljs-built_in">m_numerator</span>(num), <span class="hljs-built_in">m_denominator</span>(den)<br>&#123;&#125;<br><br>    <span class="hljs-comment">//转换函数</span><br> <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <br>      <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)m_numerator / m_denominator; <br> &#125;<br> <br><span class="hljs-keyword">private</span>:   <br>   <span class="hljs-keyword">int</span> m_numerator;    <span class="hljs-comment">//分子</span><br>   <span class="hljs-keyword">int</span> m_denominator;  <span class="hljs-comment">//分母</span><br>&#125;;<br><br><span class="hljs-comment">//main.cpp...</span><br><span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-keyword">double</span> d = <span class="hljs-number">4</span> + f;<span class="hljs-comment">//f将会被转换为0.6</span><br></code></pre></div></td></tr></table></figure><p>若没有转换函数，重载运算符<code>+</code>，也能运行</p><h3 id="STL中的转换函数"><a href="#STL中的转换函数" class="headerlink" title="STL中的转换函数"></a>STL中的转换函数</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/e131cbce529c3873f473dd3a802fbfb5-21f79b.png" alt="STL中的转换函数"></p><h2 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h2><h3 id="non-explicit-one-argument-ctor"><a href="#non-explicit-one-argument-ctor" class="headerlink" title="non-explicit-one-argument ctor"></a>non-explicit-one-argument ctor</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Fraction</span>(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> den=<span class="hljs-number">1</span>) <br>  : <span class="hljs-built_in">m_numerator</span>(num), <span class="hljs-built_in">m_denominator</span>(den)&#123;&#125;<br><br> Fraction <span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">const</span> Fraction&amp; f) &#123;  <br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fraction</span>(......);<br>&#125;<br>    <br><span class="hljs-keyword">private</span>:   <br>   <span class="hljs-keyword">int</span> m_numerator;    <span class="hljs-comment">//分子</span><br>   <span class="hljs-keyword">int</span> m_denominator;  <span class="hljs-comment">//分母</span><br>&#125;<br><br><span class="hljs-comment">//main.cpp...</span><br><span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;<br>Fraction d2 = f + <span class="hljs-number">4</span>;<span class="hljs-comment">//调用 non-explicit 构造函数，将4转换为Fraction(4,1)，然后调用operator+</span><br></code></pre></div></td></tr></table></figure><p>本例中：</p><ul><li>Fraction的构造函数，虽然说有两个形式参数，但是由于其中有一个默认值，所以实际上这个构造函数可以看成<strong>单实参</strong>构造函数。（单实参并不是单形参）</li><li>在编译器编译到<code>Fraction d2 = f + 4;</code>这条语句的时候，找到了Fraction类中operator+重载函数，但是该重载函数的参数为<code>Fraction&amp;</code>类型，所以编译器接下来会<strong>尝试</strong>将<code>4</code>转换为Fraction类型。在此例中，有了<strong>“单实参构造函数“</strong>的前提条件，编译器将会调用<code>Fraction</code>的构造函数，将<code>4</code>传入，即执行<code>Fraction(4,1)</code>。</li></ul><h3 id="conversion-function-vs-non-explicit-one-argument-ctor"><a href="#conversion-function-vs-non-explicit-one-argument-ctor" class="headerlink" title="conversion function vs. non-explicit-one-argument ctor"></a>conversion function vs. non-explicit-one-argument ctor</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Fraction</span>(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> den=<span class="hljs-number">1</span>) <br>  : <span class="hljs-built_in">m_numerator</span>(num), <span class="hljs-built_in">m_denominator</span>(den)&#123;&#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <br>      <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)m_numerator / m_denominator; <br> &#125;<br> <br> Fraction <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Fraction&amp; f) &#123;  <br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fraction</span>(......);<br>&#125; <br><br><span class="hljs-keyword">private</span>:   <br>   <span class="hljs-keyword">int</span> m_numerator;    <span class="hljs-comment">//分子</span><br>   <span class="hljs-keyword">int</span> m_denominator;  <span class="hljs-comment">//分母</span><br>&#125;;<br><br><span class="hljs-comment">//main.cpp</span><br><span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>; <br>Fraction d2 = f + <span class="hljs-number">4</span>;<span class="hljs-comment">//[Error]ambiguous  </span><br></code></pre></div></td></tr></table></figure><p>在本例中，由于同时重载了<code>double()</code>和<code>operator+</code>，所以当编译器编译<code>double d2 = f + 4;</code>时，会遇到问题，即二义性问题。编译器接来下处理<code>f + 4</code>会面临两种抉择：</p><ol><li>将<code>f</code>通过<code>double()</code>转化<code>0.6</code>，即<code>0.6+4</code></li><li>将<code>4</code>通过构造函数转化为<code>Fraction(4,1)</code>，即<code>f+Fraction(4,1)</code></li></ol><p>编译器不知道该怎么选择，所以会报错：<strong>ambiguous</strong>  </p><h3 id="explicit-one-argument-ctor"><a href="#explicit-one-argument-ctor" class="headerlink" title="explicit-one-argument ctor"></a>explicit-one-argument ctor</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Fraction</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> den=<span class="hljs-number">1</span>)</span> <span class="hljs-comment">//加入explicit关键字</span></span><br><span class="hljs-function">  : m_numerator(num), m_denominator(den)&#123;</span>&#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <br>      <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)m_numerator / m_denominator; <br> &#125;<br> <br> Fraction <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Fraction&amp; f) &#123;  <br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fraction</span>(......);<br>&#125; <br>    <br><span class="hljs-keyword">private</span>:   <br>   <span class="hljs-keyword">int</span> m_numerator;    <span class="hljs-comment">//分子</span><br>   <span class="hljs-keyword">int</span> m_denominator;  <span class="hljs-comment">//分母</span><br>&#125;;<br><br><span class="hljs-comment">//main.cpp</span><br><span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;<br>Fraction d2 = f + <span class="hljs-number">4</span>;<span class="hljs-comment">//[Error]conversion from &#x27;double&#x27; to &#x27;Fraction&#x27; requested</span><br></code></pre></div></td></tr></table></figure><p>本例中，在构造函数的前面添加了<code>explicit</code>关键字。这个关键字的作用就是告诉编译器：</p><p><strong>只有当构造函数被显式的调用，编译器才可以调用构造函数</strong></p><p>所以当编译器编译<code>Fraction d2 = f + 4;</code>时，已经不会再尝试地将<code>4</code>转化为<code>Fraction(4,1)</code>了，只会将<code>f</code>通过<code>double()</code>进行转换，所以<code>f+4</code>会变成<code>0.6+4</code>。又因为<code>d2</code>是Fraction类型，所以编译器报错是正常的。</p><h2 id="pointer-like-classes"><a href="#pointer-like-classes" class="headerlink" title="pointer-like classes"></a>pointer-like classes</h2><p>也可以对类进行分类：比如像指针的类，像函数的类</p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><h4 id="关于operator-和operator-gt"><a href="#关于operator-和operator-gt" class="headerlink" title="关于operator*和operator-&gt;"></a>关于operator*和operator-&gt;</h4><p>智能指针中都会带有一个一般的指针。</p><p>在智能指针中，重载操作符<code>*</code>和<code>-&gt;</code>一般都是固定写法。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/34dc5fe416e326ad1ec2a555b1c1fed6-c414f2.png" alt="关于operator*和operator-&gt;"></p><p>对于图中三个已经编号的语句：</p><ul><li>语句1看起来很正常，因为重载操作符<code>*</code>，返回的同样是解引用。所以<code>Foo f(*sp)</code>实际上就是<code>Foo f(*px)</code>。</li><li>而对于语句2，如果通过重载操作符<code>-&gt;</code>返回值为<code>px</code>的话，按照正常的思路，<code>sp-&gt;method()</code>就会变成<code>pxmethod()</code>，少了<code>-&gt;</code>。但是实际上，语句2会变成语句3。原因是是C++的语法规定：<strong>-&gt;符号有个特殊的行为，在-&gt;符号作用的结果上，-&gt;符号会继续作用下去。</strong></li></ul><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>迭代器其实也是智能指针</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/58ff59423d173f39de7f3c07a6639191-a6f205.png" alt="迭代器"></p><h2 id="function-like-classes：仿函数"><a href="#function-like-classes：仿函数" class="headerlink" title="function-like classes：仿函数"></a>function-like classes：仿函数</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/bcbb678ba6becab283407c1b358ca181-f3318a.png" alt="仿函数"></p><p>调用方法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">select1st&lt;Pair&gt;()()<br>select2nd&lt;Pair&gt;()()<br></code></pre></div></td></tr></table></figure><p>在一个class里重载<code>()</code>，说明用意就是想让<strong>class</strong>变成一个<strong>function</strong>。对于这种模仿函数行为的对象，称之为函数对象。（stl里面有很多的仿函数）</p><h2 id="namespace经验谈"><a href="#namespace经验谈" class="headerlink" title="namespace经验谈"></a>namespace经验谈</h2><p>对于测试程序，可以使用<code>namespace</code>。比如：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8d4c799728c33e47f9ea6b6385880545-b66f52.png" alt="namespace经验谈"></p><h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><h3 id="class-template"><a href="#class-template" class="headerlink" title="class template"></a>class template</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/af7e08d3ba53835799e99215f45aa80c-d1a5b2.png" alt="类模板"></p><h3 id="member-template：成员模板"><a href="#member-template：成员模板" class="headerlink" title="member template：成员模板"></a>member template：成员模板</h3><p>这种成员模板的应用在STL标准库中大量出现：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b8270b8b0d56bd28cc0c9e01e8008574-ae6359.png" alt="member template 1"></p><p>智能指针中模仿向上转型的做法：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/51f2f90ada34ecd33f6f6380f26ca958-a29028.png" alt="member template 2"></p><h3 id="specialization：模板特化"><a href="#specialization：模板特化" class="headerlink" title="specialization：模板特化"></a>specialization：模板特化</h3><ul><li>特化可以写任意版本</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8bed3c001f2f63d2ceddcf13ad43eb0d-151429.png" alt="模板特化"></p><h4 id="partial-specialization：模板偏特化"><a href="#partial-specialization：模板偏特化" class="headerlink" title="partial specialization：模板偏特化"></a>partial specialization：模板偏特化</h4><ul><li>模板绑定参数需要从左边到右边进行绑定，比如形参次序为1，2，3，4，5，那么绑定参数不能挑选出1，3，5进行绑定，只能1，2，3这样绑定。</li></ul><h5 id="个体偏特化"><a href="#个体偏特化" class="headerlink" title="个体偏特化"></a>个体偏特化</h5><p>对某种具体类型的特殊处理，比如对bool类型偏特化：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/cecfd818959022054a9923abcb3d8698-2ddbe1.png" alt="单个偏特化"></p><h5 id="范围偏特化"><a href="#范围偏特化" class="headerlink" title="范围偏特化"></a>范围偏特化</h5><p>对某个范围的类型进行特殊处理，比如对<strong>所有</strong>指针类型进行偏特化：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/ccf5547367e4a7c109b8db153d0582a4-2cea76.png" alt="范围偏特化"></p><h3 id="template-template-parameter：模板模板参数"><a href="#template-template-parameter：模板模板参数" class="headerlink" title="template template parameter：模板模板参数"></a>template template parameter：模板模板参数</h3><h4 id="对于list的例子"><a href="#对于list的例子" class="headerlink" title="对于list的例子"></a>对于list的例子</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/33c4d4e3c79a9f39707e67c21c688199-f878bf.png" alt="模板模板参数"></p><p>现在的需求是：动态的指定<code>list</code>的类型，就相当于<code>list&lt;string&gt;</code>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">XCls&lt;string,list&gt; mylist1;<span class="hljs-comment">//错误</span><br></code></pre></div></td></tr></table></figure><p>虽然说结合上面的模板模板参数，看起来语法正确，但是由于<code>list</code>不止有一个模板参数，所以编译<code>XCls&lt;string,list&gt; mylist1;</code>编译器会报错。为了实现需求，可以使用：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> Lst = list&lt;T,allocator&lt;T&gt;&gt;;<br></code></pre></div></td></tr></table></figure><p>然后再：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">XCls&lt;string,Lst&gt; mylist1;<span class="hljs-comment">//正确</span><br></code></pre></div></td></tr></table></figure><h4 id="对于智能指针的例子"><a href="#对于智能指针的例子" class="headerlink" title="对于智能指针的例子"></a>对于智能指针的例子</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/60f943f55fb92522b88c79061ece7635-a17588.png" alt="对于智能指针的例子"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">XCls&lt;string,shared_ptr&gt; p1;<span class="hljs-comment">//正确</span><br>XCls&lt;<span class="hljs-keyword">double</span>,unique_ptr&gt; p2;<span class="hljs-comment">//错误</span><br>XCls&lt;<span class="hljs-keyword">int</span>,weak_ptr&gt; p3;<span class="hljs-comment">//错误</span><br>XCls&lt;<span class="hljs-keyword">long</span>,auto_ptr&gt; p4;<span class="hljs-comment">//正确</span><br></code></pre></div></td></tr></table></figure><p>同样的，参考对于list的例子，p2和p3错误的原因也是因为模板的参数不是唯一的。</p><h4 id="一个不是模板模板参数的例子"><a href="#一个不是模板模板参数的例子" class="headerlink" title="一个不是模板模板参数的例子"></a>一个不是模板模板参数的例子</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b1dd9c5d60a6f8e2197052c8dd45178e-34bb35.png" alt="一个不是模板模板参数的例子"></p><p>虽然说<code>Sequence</code>的默认参数是<code>deque&lt;T&gt;</code>，这个默认参数是一个模板类型的参数。但是他作为参数的时候已经不算是模板了，而是由模板初始化而来的一个参数。也就是说它已经被确定了。</p><h3 id="variadic-templates：数量不定的模板参数（C-11）"><a href="#variadic-templates：数量不定的模板参数（C-11）" class="headerlink" title="variadic templates：数量不定的模板参数（C++11）"></a>variadic templates：数量不定的模板参数（C++11）</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b6f56c4064300c100f3b179589d66b96-c7d814.png" alt="variadic templates：数量不定的模板参数"></p><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>可以在指定模板参数后，在模板后面加()直接生成临时的对象。比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span>*p allocator&lt;<span class="hljs-keyword">int</span>&gt;().<span class="hljs-built_in">allocate</span>(<span class="hljs-number">512</span>,(<span class="hljs-keyword">int</span>*)<span class="hljs-number">0</span>);<br></code></pre></div></td></tr></table></figure><h2 id="auto（C-11）"><a href="#auto（C-11）" class="headerlink" title="auto（C++11）"></a>auto（C++11）</h2><p>auto关键字可以让编译器自动推导类型</p><ul><li>所有变量都用auto可取吗？不行：<ul><li>对于变量的类型需要很熟悉，且auto的可读性不高</li><li>不可能每一次在声明对象的时候都赋值</li></ul></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/28998a55f89820c73ef91e0c3fcd8581-7889b2.png" alt="auto"></p><h2 id="ranged-base-for-：for新写法（C-11）"><a href="#ranged-base-for-：for新写法（C-11）" class="headerlink" title="ranged-base for ：for新写法（C++11）"></a>ranged-base for ：for新写法（C++11）</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8e75a572eebe3e248f33caa6cd148262-ebcb46.png" alt="ranged-base for ：for新写法（C++11）"></p><ul><li>pass by value：实际上是值传递，<strong>vec</strong>拷贝了一份赋值给<strong>elem</strong>，传值无法修改原来的值</li><li>pass by reference：<strong>vec</strong>将当前迭代元素的引用赋值给<strong>elem</strong>，传引用可以修改原来的值</li></ul><h2 id="reference：引用"><a href="#reference：引用" class="headerlink" title="reference：引用"></a>reference：引用</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/28e8af9de3f3e70f82cd704c38b65447-b2cca6.png" alt="reference：引用"></p><ul><li><p>虽然说引用的底层是指针，指针大小在32位上是4个字节。但是引用代表的东西sizeof多大，引用sizeof就多大</p></li><li><p>引用代表的东西的地址在哪里，引用的地址就在哪里</p></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/56041a3b3f0c57e698c49ed766c64dca-f12e4d.png" alt=""></p><h3 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h3><blockquote><p>引用就是一个漂亮的指针</p></blockquote><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f49b1cb39974da549e0c65f5d904b80e-4c0f1c.png" alt=""></p><p>Q：const是不是函数签名的一部分？</p><p>A：是</p><p><strong>注意：函数签名不含返回值</strong></p><h2 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h2><h3 id="关于vptr和vtbl"><a href="#关于vptr和vtbl" class="headerlink" title="关于vptr和vtbl"></a>关于vptr和vtbl</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b4a9e8f6e13e6d20e65eda01095ce90e-d9e28.png" alt="关于vptr和vtbl"></p><ul><li>只要类里面有一个以上的虚函数，那么这个类以及它的派生类在内存里就会多一根指针，这个指针就是虚表指针</li><li>继承函数是继承调用权，而不是继承函数的内存大小。所以父类若有虚函数，子类一定也有虚函数</li><li>动态绑定的三个条件<ul><li>通过指针调用</li><li>指针为up-cast，向上转型</li><li>调用的是虚函数</li></ul></li><li>静态绑定：编译时直接指定某个地址</li></ul><h3 id="关于this指针"><a href="#关于this指针" class="headerlink" title="关于this指针"></a>关于this指针</h3><ul><li>在C++的成员函数里面，一定有一个隐藏的this作为参数。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a9d134fab38b6f37fc66b43f2e205b77-abf79.png" alt="关于this指针"></p><h4 id="汇编层面的函数调用"><a href="#汇编层面的函数调用" class="headerlink" title="汇编层面的函数调用"></a>汇编层面的函数调用</h4><h5 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/dc0e09af8263a41969ed8ab2396e9ecc-0f736.png" alt="汇编层面的多态"></p><h5 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7f59aad8017b1fe873dec0b1da9cf192-43f3b.png" alt="动态绑定"></p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h3 id="const-member-functions：常量成员函数"><a href="#const-member-functions：常量成员函数" class="headerlink" title="const member functions：常量成员函数"></a>const member functions：常量成员函数</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/52c2717bc969b0b16180cc37360601b1-4963e.png" alt="const member functions：常量成员函数 "></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新特性</tag>
      
      <tag>对象模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>域名解析教程</title>
    <link href="/2021/04/10/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Godaddy%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2021/04/10/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Godaddy%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在开始之前，需要一个域名和VPS。一开始我选择的是狗爹域名和腾讯云VPS。结果到后面网站需要备案的时候麻烦来了：国外域名注册商提供的域名无法在国内进行备案(将域名从狗爹转入到国内的域名注册商后就可以备案了)…一开始我买狗爹的域名是想绑定在搬瓦工VPS上，后面感觉在大多数的使用情况下使用国内的VPS，响应会比较快，就用了腾讯云。然后配置的时候一路通行，到备案的时候给卡住了…所以个人建议：</p><ol><li>如果你是做类似于外贸的网站，或是用的国外VPS，建议在国外域名注册商那儿注册域名。而且听说国外建站无需备案</li><li>如果只是做个人网站，而且在国内访问比较频繁的话，直接选择国内VPS+国内域名注册商，方便省心。</li></ol><p>本文也是写到备案这块发现了这个问题，所以后面干脆在腾讯云又买了个域名。感觉腾讯云会比狗爹便宜许多，墙裂推荐</p><p>虽然本文具体写的是<strong>Godaddy域名绑定到腾讯云服务器</strong>，但是除了Godaddy官网操作的那部分不一样之外，其他注册商购买的域名(比如腾讯云、阿里云)绑定到腾讯云的操作其实是一样的，直接看”<strong>2.2 添加解析</strong>“就好</p><hr><hr><h2 id="2-Godaddy域名绑定到腾讯云服务器"><a href="#2-Godaddy域名绑定到腾讯云服务器" class="headerlink" title="2. Godaddy域名绑定到腾讯云服务器"></a>2. Godaddy域名绑定到腾讯云服务器</h2><h3 id="2-1-DNS地址设置"><a href="#2-1-DNS地址设置" class="headerlink" title="2.1 DNS地址设置"></a>2.1 DNS地址设置</h3><p>进入腾讯云的DNS解析页面</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410170812.png" alt="进入设置页面"></p><p>进入DNSPod控制台</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410171019.png" alt="进入DNSPod控制台"></p><p>添加域名</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410171154.png" alt="添加域名"></p><p>此时会显示DNS不正确</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410171303.png" alt="DNS不正确"></p><p>鼠标移动到状态上面，此时会显示</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410171449.png" alt="查看详情1"></p><p>点击查看详情</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410171616.png" alt="查看详情2"></p><p>记住腾讯云提供的两个DNS服务器地址，然后打开<a href="https://dcc.godaddy.com/">Godaddy</a>，登录后点击需要修改DNS的域名，进入该域名的管理界面</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410171918.png" alt="点击域名"></p><p>进入页面后，拉至网页的最下方，找到<strong>Manage DNS</strong>，并点击进入下一个界面</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410172049.png" alt="点击Manage DNS"></p><p>进入页面后，找到<strong>Nameservers</strong>的<em>*Changes</em>，并点击进入下一个界面</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410172522.png" alt="Change"></p><p>接着点击<strong>Enter my own nameservers (advanced)</strong>进入下一个界面</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410172707.png" alt="Enter my own nameservers (advanced)"></p><p>在输入框输入刚才腾讯云提供的两个DNS地址，然后点击Save</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410173004.png" alt="输入地址并保存"></p><p>此时会跳出一个提示框，要是没什么问题直接勾选并继续即可</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410173117.png" alt="勾选并继续"></p><p>此时会发一个密码到你注册狗爹时使用的邮箱，点击发送密码</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410173326.png" alt="发送密码"></p><p>输入邮箱收到的密码，点击验证</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410173439.png" alt="输入密码并验证"></p><p>等待一会，在出现的页面中找到Nmaeservers，看看两个Nameserver是不是我们刚才更改的地址，如果是的话就可以</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410173614.png" alt="修改成功"></p><p>返回腾讯云，等待一段时间后点击重新验证。我这里是修改完DNS地址后直接重新验证就可以了</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410173839.png" alt="重新验证"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410173932.png" alt="验证结果"></p><hr><h3 id="2-2-添加解析"><a href="#2-2-添加解析" class="headerlink" title="2.2 添加解析"></a>2.2 添加解析</h3><p>在<strong>DNSPOD</strong>点击待解析的域名</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410194832.png" alt="待解析域名"></p><p>点击<strong>添加第一条记录</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410200036.png" alt="添加第一条记录"></p><p>根据自己的需要，按照提示填写，然后点击<strong>确认</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410200129.png" alt="按照提示填写"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410200321.png" alt=""></p><p>至此已经完成了，在浏览器中输入域名也可顺利的访问。但是由于我们的网站还未备案，所以没过一会就会出现让你备案的网页。想要好好的用，就老老实实的备案吧(备案之前需要先将域名从狗爹转入国内域名注册商)</p><hr><hr><h2 id="错误及问题记录"><a href="#错误及问题记录" class="headerlink" title="错误及问题记录"></a>错误及问题记录</h2><h3 id="1-DNS-PROBE-FINISHED-NXDOMAIN"><a href="#1-DNS-PROBE-FINISHED-NXDOMAIN" class="headerlink" title="1. DNS_PROBE_FINISHED_NXDOMAIN"></a>1. DNS_PROBE_FINISHED_NXDOMAIN</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410200903.png" alt="DNS_PROBE_FINISHED_NXDOMAIN"></p><p>这个问题是在我刚在宝塔面板给网站添加域名后访问出现的，然后等了大概两三分钟再打开就没问题了。</p><h3 id="2-This-Web-page-is-parked-FREE-courtesy-of-GoDaddy-未解决"><a href="#2-This-Web-page-is-parked-FREE-courtesy-of-GoDaddy-未解决" class="headerlink" title="2. This Web page is parked FREE, courtesy of GoDaddy.(未解决)"></a>2. This Web page is parked FREE, courtesy of GoDaddy.(未解决)</h3><p>当我满怀期待地在地址栏输入我的域名并回车后，结果眼前出现了一个神秘男子</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410201653.png" alt="神秘男子"></p><p>但是我从宝塔面板点击我的域名，网页却正常的显示</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410210330.png" alt="正常显示"></p><p>而我用另一台设备打开这个网页的时候，也是能正常的显示原本的内容。</p><p>后面猜想了一下，应该跟DNS服务器有关</p><p>这个是没法正常打开网页的设备的DNS服务器地址</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410210543.png" alt="DNS服务器"></p><p>这个是能够正常打开的设备的DNS服务器地址</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410210833.png" alt="另一台设备"></p><p>个人认为，可能因为是我刚在腾讯云添加了DNS解析，而一些DNS服务器的解析记录还没有更新，所以才会导致出现这种情况。</p><p>至于为什么在同一台机子上，直接用浏览器打开和用宝塔面板进入会出现两种情况，我想了一下，应该是因为宝塔面板是安装在我域名解析的那台服务器上。也就是说当我从宝塔面板进入时，宝塔面板把”<strong>自己</strong>“返回给了我让我进入，而没有经过域名解析…怪我才疏学浅，目前能想到的原因只有这个</p><hr><h3 id="3-该网站未根据工信部相关法律规则进行备案"><a href="#3-该网站未根据工信部相关法律规则进行备案" class="headerlink" title="3. 该网站未根据工信部相关法律规则进行备案"></a>3. 该网站未根据工信部相关法律规则进行备案</h3><p>网站多访问几次以后，出现了以下页面</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410202119.png" alt="网站未备案"></p><p>没有解决方法，在国内还是老老实实备案吧</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410202344.png" alt="开始备案"></p><p>注意，Godaddy购买的域名在国内是无法进行备案的。如果一定要备案，需要把域名从狗爹转到国内的域名注册商。</p><hr><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://segmentfault.com/q/1010000002309400#">一个注册域名能分配多少子域名?</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>建站</category>
      
    </categories>
    
    
    <tags>
      
      <tag>godaddy</tag>
      
      <tag>腾讯云</tag>
      
      <tag>vps</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建wordpress</title>
    <link href="/2021/03/26/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BAWordPress/"/>
    <url>/2021/03/26/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BAWordPress/</url>
    
    <content type="html"><![CDATA[<h2 id="1-VPS"><a href="#1-VPS" class="headerlink" title="1.VPS"></a>1.VPS</h2><p>搭建WordPress需要一个VPS，对于VPS这部分就不详细描述了，毕竟作为程序员都会有一两个vps吧。</p><h2 id="2-宝塔面板"><a href="#2-宝塔面板" class="headerlink" title="2.宝塔面板"></a>2.宝塔面板</h2><p>使用宝塔面板会比较方便管理VPS</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323115100.png" alt="宝塔面板"></p><p>Linux下安装宝塔面板只需要一句话</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh<br></code></pre></div></td></tr></table></figure><p>如果是国内云服务商提供的VPS（腾讯云、阿里云、华为云等），需要先开端口：<a href="https://www.bt.cn/bbs/thread-19376-1-1.html">https://www.bt.cn/bbs/thread-19376-1-1.html</a></p><p>安装完成后，使用<code>bt</code>命令查看登录方式</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323125207.png" alt="查看宝塔信息"></p><p>在浏览器地址栏输入<strong>外网面板地址</strong>，然后在登录页面输入<strong>username</strong>和<strong>password</strong>即可进入宝塔面板</p><p>这里先讲一下宝塔面板的两个功能：</p><ol><li>安全</li><li>软件商店</li></ol><p>安全用来放行端口，只有在这里把端口放行了，外网才能使用这个端口</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323130008.png" alt="端口放心"></p><p>软件商店用来安装一些环境，这边推荐安装以下内容：</p><ul><li>Nginx 1.18.0</li><li>MySQL 5.7.33</li><li>PHP-7.4</li><li>Pure-Ftpd 1.0.49</li><li>phpMyAdmin 4.4</li></ul><p>其中包括<strong>wordpress</strong>需要用到的环境，还有一些方便管理的工具，安装步骤如下：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323125634.png" alt="软件商店"></p><p>选择编译安装</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323130341.png" alt="选择编译安装"></p><h2 id="3-wordpress"><a href="#3-wordpress" class="headerlink" title="3.wordpress"></a>3.wordpress</h2><h3 id="3-1-wordpress下载"><a href="#3-1-wordpress下载" class="headerlink" title="3.1 wordpress下载"></a>3.1 wordpress下载</h3><ul><li>中文版：<a href="https://cn.wordpress.org/latest-zh_CN.zip">https://cn.wordpress.org/latest-zh_CN.zip</a></li><li>英文版：<a href="https://wordpress.org/latest.zip">https://wordpress.org/latest.zip</a></li></ul><p>复制上面的连接，然后打开宝塔面板中的<strong>文件</strong>，进入<strong>/www/wwwroot</strong>目录，选择<strong>远程下载</strong>，把刚才复制的链接填到<strong>URL地址</strong>中并确认</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323131605.png" alt="远程下载"></p><p>等待下载</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323131742.png" alt="等待下载"></p><p>下载完成后解压文件</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323131900.png" alt="解压1"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323131938.png" alt="解压2"></p><p>解压完成</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323132025.png" alt="解压完成"></p><h3 id="3-2-wordpress数据库创建"><a href="#3-2-wordpress数据库创建" class="headerlink" title="3.2 wordpress数据库创建"></a>3.2 wordpress数据库创建</h3><p>打开宝塔面板的<strong>网站</strong>，点击添加站点，输入域名(如果没有域名，可以用VPS的外网IP代替)，然后根目录选择我们刚才解压的文件，接着提交即可。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323132906.png" alt="添加网站"></p><p>接下来配置数据库，打开宝塔面板的<strong>数据库</strong>，点击<strong>添加数据库</strong>，输入<strong>数据库名</strong>、<strong>用户名</strong>、<strong>密码</strong>，这三条信息需要记住，后面会用到。然后提交即可</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323133242.png" alt="创建数据库"></p><h3 id="3-3-wordpress数据库配置"><a href="#3-3-wordpress数据库配置" class="headerlink" title="3.3 wordpress数据库配置"></a>3.3 wordpress数据库配置</h3><p>进入宝塔面板的网站，点击刚才我们创建网站的根目录</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323141336.png" alt="点击根目录"></p><p>找到<strong>wp-config-sample.php</strong>这个文件，点击<strong>编辑</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323141443.png" alt="编辑文件"></p><p>找到图中所示，填入刚才我们数据库创建时的<strong>数据库名</strong>、<strong>用户名</strong>、<strong>密码</strong>，并保存</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323141638.png" alt="编辑前"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323141757.png" alt="编辑后"></p><p>然后重命名<strong>wp-config-sample.php</strong>为<strong>wp-config.php</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323141914.png" alt="重命名1"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323141937.png" alt="重命名2"></p><h3 id="3-4-wordpress的安装"><a href="#3-4-wordpress的安装" class="headerlink" title="3.4 wordpress的安装"></a>3.4 wordpress的安装</h3><p>在浏览器地址栏中输入：<strong><a href="http://域名/wp-admin">http://域名/wp-admin</a></strong>，如果前面配置成功的话，会出现以下页面：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323142211.png" alt="wordpress安装页面"></p><p>填入信息后点击安装，安装成功如下：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323142326.png" alt="安装成功"></p><p>点击登录</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323142415.png" alt="登录"></p><p>登录成功后进入wordpress的后台管理界面</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323142518.png" alt="后台管理界面"></p><p>至此，wordpress安装成功</p>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wordpress</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web版SSH搭建</title>
    <link href="/2021/03/23/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/web%E7%89%88SSH%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/03/23/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/web%E7%89%88SSH%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>目前web版的SSH很多，但是走的都是别人的服务器，会比较不安全。正好最近看到了<strong>Sshwifty</strong>，可以部署到自己的服务器并用外网访问</p><p><a href="https://github.com/nirui/sshwifty">Sshwifty项目地址</a></p><hr><h2 id="2-Sshwifty"><a href="#2-Sshwifty" class="headerlink" title="2. Sshwifty"></a>2. Sshwifty</h2><h3 id="2-1-安装Sshwifty"><a href="#2-1-安装Sshwifty" class="headerlink" title="2.1 安装Sshwifty"></a>2.1 安装Sshwifty</h3><p>使用docker安装（没安装docker的先安装docker）：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker run --detach \<br>  --restart always \<br>  --publish 8182:8182 \<br>  --name sshwifty \<br>  niruix/sshwifty:latest<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323162439.png" alt="安装成功"></p><hr><h3 id="2-2-安装证书"><a href="#2-2-安装证书" class="headerlink" title="2.2 安装证书"></a>2.2 安装证书</h3><p>先<code>docker ps</code>查看一下Sshwifty有没有在运行，如果出现下图说明有在运行，我们需要先停止Sshwifty</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323165435.png" alt="在运行"></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker stop CONTAINER ID<br>docker rm CONTAINER ID<br></code></pre></div></td></tr></table></figure><p>然后再安装证书<br><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">openssl req -newkey rsa:4096 -nodes -keyout domain.key -x509 -days 90 -out domain.crt<br></code></pre></div></td></tr></table></figure></p><p>输入信息，随便填写即可</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323163708.png" alt="ssl"></p><p>接着执行</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker run --detach \<br>  --restart always \<br>  --publish 8182:8182 \<br>  --env SSHWIFTY_DOCKER_TLSCERT=&quot;$(cat domain.crt)&quot; \<br>  --env SSHWIFTY_DOCKER_TLSCERTKEY=&quot;$(cat domain.key)&quot; \<br>  --name sshwifty \<br>  niruix/sshwifty:latest<br></code></pre></div></td></tr></table></figure><h3 id="2-3-使用Sshwifty"><a href="#2-3-使用Sshwifty" class="headerlink" title="2.3 使用Sshwifty"></a>2.3 使用Sshwifty</h3><p>浏览器地址栏输入：<strong>服务器IP地址:8182</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-03-23_16-57-04.png" alt="等待"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323170246.png" alt="使用1"></p><p>点击左上角的加号添加</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323170449.png" alt="添加"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323170535.png" alt="IDO"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323170559.png" alt="输入密码"></p><h2 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h2><h3 id="1-Unable-to-initialize-client-application-TypeError-Cannot-read-property-‘importKey’-of-undefined"><a href="#1-Unable-to-initialize-client-application-TypeError-Cannot-read-property-‘importKey’-of-undefined" class="headerlink" title="1.  Unable to initialize client application: TypeError: Cannot read property ‘importKey’ of undefined"></a>1.  Unable to initialize client application: TypeError: Cannot read property ‘importKey’ of undefined</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323163039.png" alt="错误1"></p><p>在访问地址前加上<strong>https</strong>即可</p><h3 id="2-ssh-handshake-failed-ssh-unable-to-authenticate-attempted-methods-none-password-no-supported-methods-remain"><a href="#2-ssh-handshake-failed-ssh-unable-to-authenticate-attempted-methods-none-password-no-supported-methods-remain" class="headerlink" title="2. ssh: handshake failed: ssh: unable to authenticate, attempted methods [none password], no supported methods remain"></a>2. ssh: handshake failed: ssh: unable to authenticate, attempted methods [none password], no supported methods remain</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323171046.png" alt="错误2"></p>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用搬瓦工实现科学上网</title>
    <link href="/2021/03/17/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E5%88%A9%E7%94%A8%E6%90%AC%E7%93%A6%E5%B7%A5%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <url>/2021/03/17/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E5%88%A9%E7%94%A8%E6%90%AC%E7%93%A6%E5%B7%A5%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="0edb3962be7b006f1f3c914240551e94f6d4ae59856200ba95446b17a4077243">3872edc3adb321ce81613cfb0f45e5317a00ac516192b838b000f255eb50223bb71904fd047b071edebc693852d7f6208ac6f6f55da8149a4a77b5917a90a846ab482031ff2f00dd3661535a33fbdf418ede4c92abe5923a143b3f6c3bfacaed6376c7dee280e3a3962ce087162e2bcf988ac2191fd322c6771a2c8d4e96cedc7030ec20bd11eda6e847d2be657535433a6cd19596384a477252946d29d35bae7eb929822583c07b4924c67e9654c00624e2e3810e9f0bedc6175f2fe102f8b3e66ee4267b623cd9debebc4e89605e48847d5d9380349a4e2f12e52faa87d30b9a70b6837d841fb8927234a09d5db2629dc60d21e215d6b3679b286679e76afc798393036b2c81fd2394635c9e26dda40a346c4762cbd3bad55748b1b8c338a93b757b0cb87c0795e91061e33b59337fa1e95faec43abdbdbeccbaf5e82ad526dcf30b971c5e6fb07a9dd4c6361c998ab94d167eecf0552e348de0a28a921b59a9d84a69ec68b09006c77ccd20766058a2b3dfe889a5e91bc44ff22f468a2ad097723ac6b8f8e04cdb4742eaaffd8b50ec442f8d384a269bccd9cd976f01c7c16c0e611b5b31a3d43a6f4eb9c90494bdcb10301c722ce97076782bcb939bc6fbdffc020f7b5c37dfe7cfd1a62c276bf0838a21f751c3d77ed3ffeb390285fae6e7b2a7ca59c51cef5e9cda7be1df5abd844cffa2ad6b60e4b6448ace23bc8c97126a969ff2e6ea7ee861cb4afea4177d674be43d1c8525b76572b747115b025979b38be7d0e5fc7995e6553b1f3fd524cf2955b0818bcf11b96a896cad142383c3b7842ff9665e1d8c2b2389e6eaf8c3369bf00e8ad7048b33f81b26044f21a3a0c4ab15e4b38ea0540beeb3f2decd30fc3e830802373eefc08bdf8470bffb924f4999fa327d38d5a85df2ccdda2239ecb406c9d4662c043e6018f3532496e9bfa6ef2a1b4bb594720de597d5ee9650d05ec3d027e1941bf42ab6ea4a7c5598e9f00d6b56e81748de8bb5332ee9a6639c611d02de24ad4faf0bb24b2e90cf28f682d3000737858b3ced8493ba70a8f9af045bfd149559f39581c78c25213aaace9fc410f13f2d79a4f60ca4c46fff1bb10708a2943eab237412d6466c9ea3c27355972c406d805341062f0d3afd15dad02bd12f14080970e6224c44f4e2a3aff64aa8f146c0415e738f3ba04353c227c3e49923c2f08e1aa35dd4080b0ea0aca2456242add9ec4d73de97eda0c36acadf37d1f0e1ad32ea3297c8a71208c3e5214f8ae7e01228064d50e8d698415c2c0a9f19790fda6e80151854945bd075bcf5350e8f1be628974034f9d6fdeb293161c05e95051aa635fd132e8b9e2717399eca5c4e126e6862f82e2e88cdd3ddb806d663a245a6cee9ca860d5536b7c5aced8158adfd1edcc53d639869db5a7d443e09f6ea59671b3a6097ab69d3c25ebb890a19bebf3dc42ebade39de49a70b89cc730749b48a5540db1cf20cc7981037f57699cd8212098b606bc842b9793faf7d4921fbf195b13d1a76ad6c509394e84be67e629dfc97c85ffc9f65fa41c4409bc072ae1ee1df190dd5ad4a6391018b99bf5ac299f001b355cf023f02dadfc2adcb7d648d50d07d48358f5da0f2973c44bc78657debcdd0ca711d20f39fe1b88c0bf98d8d0e6be9b4a372adda0833b8055e01e8e58c95504fc08ff4edd9269d275afb4eb006ab896acfdc6e66fd80f0f96bf436f8e4707b47fa88b62547c116f6d3a833776eb281797ff8a86ac5111eef59668039814bafb34dba684376c04726fc06c5da620bb82ab12d168f3849c3a3c82ab7558588215856b1da7ed4cd68ee9cda18454d48dc1c2fecca0402a4b32b69a2585021061d53fd0f2e4b6d3fa5c814e5e4fdef802c3636fa1c2d5406352a6bb429f3eebbf1662caa1d52302cde0c8981dd1950053fa71835f35b30903875e5594832692dea3b5a8eede9232dc06a095482ee00eba40010e91c0ea37304d2f9006822f77c05e7482c49160c22ed5e5c2b6a817d5125784c57427572a9d3e1bde475b6dfb8d487a31a449a97a8d8730d2e5abfefb40b52016e2e15e6af86294fb2df68349fd4f88b3e3dd19d7c5d6c06cbe754b25daafdef51a897b27591f8630764afee7219475c687e5e9cc467e9a07baee308dad215ab9bc82321672cdd1eab40c7c3912281e3f9df0a9e689585ae5789caf697850ab70f28df03e35310fd2aec7ba1a1e9be3cdeeac5f60eb5beb75e7690fa720ee346618e5e1aa77f295e70506dabe1fe042faae8590e1979e8e0a6772f5c17482898d7f671dd16e29ff85dfdd4cc2cf292d559638d0c0d2bf1ea4839d35750fe9ef097e79f93892502064a796197c056a9b5edd7956a913495a5dd2562ea7875e7b52eefdd9ff95cabd70f00f4e3f442d8ce65292e52ef761e8f39ad6cf65c5ced5fc43fe1f785bc6cbc668de23aa763a7e3046c9eb3577c0e2bfe40a000aaa878e99d63b42796af7873e4c25f04af92f68c14b2a2d7b169828439331f1ff535292ad6e6dbb18253c343d7fa647de723ad1baaf34811c9d57fa8859bbeb6b02ec5db2faabae8b778f8c1e36052ba07c358b9dac66217df00946861f92df22769afe3757b165c109b20a84faf3954dec8746dc23216c55cecf34a6858b7fac78897b97198d7c034ce0b1d9d431b226b8c031a315bc479bd601ae5fd33b387c2277a444c89193e9e4b46b676612e474f299a97c154e6d6c5c4cbd2bca211a2d7799ad97772036c8c931bed3181b37a5ea7ec1ca177d857ecad0bceea331e1ac56c48f906993f1edc3c2e99340af47f4b794e6948c0e4b396c32040f8178c7774320f813498b90c4a6919001a7d094adb113c0d1bab0a46c6a75b43b9329ccef962e055386d0b2331e3866325802476fa0cb26fa204b932926f647f96576a49a73ed66d4a5077a66c707e4ec2ee80520322a7fac20f8bd68e14d98541d18265919ca93ae3499b954739cd0dd48f6b7380119457918dbd9b3d407649bc7583c008444d9cc6b0b76ef0e72301d8935ca7cb4fa57a128c98863bc2dece33d5c8c5ae1c695b9132b3c294140a547b613fe74bd67984347c3c51172ce3ab0fce1c75059cba6cc9e1d5268038349d1c19ef8c8f65ae13ae23bfcd9d26229375aeb5d392b5ac89c3a0b340aa560a16832fff4e6c0e6edb675b07432eb5e8867600f06f227ed84f9b61f0ab6926d1f801ee83c9e377a4f0a8981c359264e1d205a9b8ad84169d69c8c12df9bfc4959ae7c7fa665fa25991b7855f408863de06987e3f494fe440351371069ea216e351699cd4266467e1057b21fe417a0c7f6fd0f8d3de3dc7c834746741f4c02f4548cae49e2fd6289a6614803d5e9e6c2f2c2284f9929c79e9982f0412fc7f5aa7ca8581da2b62812e44df719bfa9da9c3d46328933f580eb1ea3e4052859ae49a11bc49f10364dd9b90b1b1f3a7194f725a28ef0d8808524f22708dea8739c5db24e46ce35a8250b3a86a220c7e73939717962ee4e41d6c1d88cba9e537c06228fd04f7acc8daecb155c9e19e6de1a621b781e66b763597bde86c7cd4c2c910e35928bd710d5d71c12134f6fa6b9e2f59025ea5d9b98374ee4c5356f980a22e29882590b83ea693ba887b79940cfbe6bee1e05b2a4b20c7039305a85c406cd48c5595cf54f108eeb3b216b47a4d6895dda344e6764b351dcdfe8006f4bf1140fd16f2c288b0a0b2dbe1b45870b3b6dd86cd1175dfff588eff08044884c6bcde75ad21022592896d04ea22dac3764cde807e65afc8eec1e7190ecc42f7d856da622e0aee7706fec197f52d9b6dc9e250b132038a407bf7f92bffd3f6a708ac218999f507beed3596143a3ccae08ca52370f2a61256c3ab99819623a3c38360be94af26fe289184f74c80055a50a64d639554cda2b47b08370c9f2b8864c803651daec990c8960139da94694dd0f6f3022ae8912b26e19b3b0f4a7011752886a0b8af55aa8532884f28bdb44b7fac32c8dd7cb254a3d585fa8b1247f114ef94a78943f16ff5df5ad68823e70cee6df538cbb0921f77b300e918477b630852fea3447f2b4c8a53be64724300e5cfc6e677701efdbdd26042791c3d075a81f21dee6bf4f5e5413fe5634e64ae48961aecf90bcd5bafc8d613882bdc57133d7161fbe8ad8dede313c339d4d044edda147ee6f6f61eeab29ce4c61b2bdcef789f1b228504127586a2994401b20c8684464113de6e4b714d503c4f6f2dc77ae7fba912c0568f1ffe7e76f29871689ed60eac89da50d73d622dd1d27d23afd1c3ab0ca281c70f08f1fa46234f1229744d573d023dba407c54f598a0fb526ac50e1593a13397b241f86fba8a5ad18b16c367338bb86d41ceabad3f0a2830ee58d9e1d03c9903e07559b90c621f8376ccee94b9e5796fe461085af84a052f0cdc010df93166f7ff0547f0532778703f15ece65e542c241e1e6aa37426ff7e423dc6535b9f8dc4a3c5a6229ac57d921b774841bb87eb5d096429d3e80859b1f92ac97e68fe3cf8afcb9da2386d329fd30d124cf5080ed5afaa179855d92bc76e12049d8a69c12bb237d045a83ff5bd2beaaa33dcc33661f5ef6f4ee0da28c4e78023be19a431674714731cbb90d9fc5056a931dc894265fe81761b7213725d2cdfce57f554bea27f349c42018998215cc2d9b4c6ed061d8b2ba63cd2251b26a4ee3535285964a70d9b89976084b012d337268592f4c8cb038ebcff4e1b5de3b88b197a5b5504b3cd769fa38eb9c7e663c7da37048a83a992b8c904ed311c0e325d600586972474e5249df8a7eab3bac3ad691590f61d47b0d3fce6e5069fbacf71a00980945b11cf80f78d51e9ed3ec22596339e5db4a25549dd730f4053a0a15cf0e5d8dbacf0325b5d240a55b678b8e7afce13fc2e647883e4b7ebeb47a44f8d52b3b56480276006f8eaa8b282f95cecb7230bb6d76b3b0264241393b777d1a202653a6411c97e27de1837c2128b51df9bcf2deaa46f4d1ed7974d6fac3104fdb8ea9aba132edfa444bc5682383f7fe438493c948147f312c4c7b21f16c1d0bb09bbf3ca4c73f5566e7cdbdafe81f8e3e380d6c727bdf6c257a2b941bdc5c1463d42dbd84d05952440b01880775fd37cc954cad5f792bdad7fef384b3a222f4ba1e84f28a5997b24b25e759e2a3910f5326a516c5add36325d09ff18b1fbc629792e107327d85c88bac2e6a7debfc25ad3cf901d0bb819fc3d6558c494ff0052c6f97056adc64b0168a7b8f9a4c7d1929d31ada0d56a89724afb1de79d85b41b7edbee8fde7db41d72a947e2579469693ac22411d32f64504e624e319606aa8dfc7db84e86b62ad235842a04ce108c4aa57061f519d821cdbd74e4e06518ad689a81e51b823228b4d33908d053e41e7c15e7d0acddc41dcc3769590575cedecc243d19bfaee6d9fd60bf080ef6b2aaa56501a9e8e7496181b51aaf76ea44b640e2111bc34dbc5df43ccf8928d8e8199b56a1961ad24e511f9aba7fb2af98493e0da29aa5864112e868e815a8e515bab4a224d5af0e2a80a102b5024b66f047f50fd3ec0546900e932b142a31265beb25298ca3cbf23921460b157a1515a2dfea0a2b2d1719f15f131b5cc89484a193776f76ccfe68a2613ff4d3b4b867e76af88c508c0a326727854ee1540884e8d916ca9d1b6267d58e201011c7cd5c5eef57d6387ece8bb66840a9adbbaff6a2908b1f74e778c35ed7b232458f8405d4013cb201ec6b50e82df371905fef4fae43caa895587a9a536cb797e12623c0f68dbce6f3889e0477d10ef9a8b8c0155f2b8169b2445f9c953d67ec21c0c77006732bc271b9108d17026c87314753148ac227214a71f4e86539fc0c492a8c7b07dad2abcc004d84aa590d0cded0a75e07988b418cb889cc5990286d44e11366a5e3aebfac9b0dd5f3f5fd03d10905cf123a248906860116226396ab766572253c605ce347e7d1779b8b59388fcf968c2c1d0b6ce28589a22166aba5326cf7a8cab308cc27bb773b81303c01891eb4bd962967334bb70f2870c7d1f14d2666eeb908d2c636fd938d06c5173b391515c27b07048168652d62ac86c68708dd1c476ac376dc0d8d4d69b48e9f73f4c9dc447fbb765f6ba48e761fb69f27196db3bede26c95e69b1f97ddb01f2bc11e9e0a69a076b234971b5447cefe42e17b4dc47e76d99fecf27bd77c7abbf37c01044238b3aaf07d6366b4bfc3128c8968eb41634b1392e8a7cf018cda3881dbc0adb813d0a6b08705be21f4ced47fc99a4ca1c55357ab67e82fc34c0397fad495e247d6b81fb5e5d0ff1a58ca541c4ff9f40375ac5b8620b4d768957d12b8c5b6cef63f7793eb9b931dab4207a1e1c18c226416ac076cc6b224b3037bc8ba01feef2a7a64ece3c99303f34f716aba93e224bdb698b453f46d46c60329bbc8efa2f407a471be96e3baca326e20e21ead5abf298170d309ee1462a37515179a135f6778e5a85b5a9f3555a905662c4027937d2c94ce519c6153f633ac74820d21587c6d33ed36f5620a1b3dea71b4ae9acd44842bbc1f702dcca9d6ffb550964acc96bafadb5cf20684136c8cab80c01d58804dddd2b0eb666d4e59560b4c8f6670d384811ef2d699811ee4795cf997bd55d6da11c62b8ae81cafa374e737e2833be89a67305cb0a0f59b79afb2acda737f8b1280acbba2cde0797ed5b81c0b6cd46b7bef91fb55fc58a5573e7fd76002f99c3f722b82a65bb35561a928e21b9481eaaf2880458a0edd46074441b8d035d6eeff5901c7ce85fa5145db6c8627470daf14363c4aa0b5ccd3bb7d8194339af9811d519e4888415758d92dffd2d83f467158135ceb78bfd9dd10fe4fce436c463e9e9dcab30888dcad1694618e2a2eac162845d65f02ab45d1f70737bbdeb3dd963b7ec6d36402f7a5a360f5c68fcfea4b24ea856ff9221f98a98a76eadcaa1294f00c7e4e8ab2251dd7b5350a2d97d358e8d450e8ec78965f98e3f58725561646e56076cfcffb6e4df0118a2059daa43ae14f6f5a03fb654c8b42aa9446b6ed5d0741c72c1f1430c3e7e7aa0fbf94970b6a77304d7d3d164456dfa9721be33451622d4526007137455d8042f6f7a8eba70efd5ac7b7eac9c6b42c0742d2c1acf9b70ce56abd8cea17842284a8334377d1995c2eab60340778494d30181f86d4e5ce6e4d1510c7cb86f95cef2feecfbc2a2cd8a32a9cf63732ebcea8932eb65227d83999d104d992144264d74c15f7aa4df97cfe6a9641b2282b49d8a05f605fb6311433427c6d9946e99e28afa190f964730fa41551cbc740ccaa0a97dfca7920a8deefe75e6ce9b61347b436935b5b222156d4011eba71c82e315fdb200b7b399a0e84e88f9e5c8ae833dbd04558d75a6412ddbcc4ec7f9288da8e8a0e1a1635dd1fffe202b37fc385ceecca5aa0643283585631118f5caf6c343cd97c197d036b9ea7a939a25a0b2ec958e46d3dbb384794eab3678d5ff837b2e2db0ea08a55dcd450c94ac29e3cc5b2b0fec9d35beab161c19dcdd2d512bc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码以阅读这篇私密文章。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VPN</tag>
      
      <tag>搬瓦工</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git常见用法</title>
    <link href="/2021/03/09/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Git/"/>
    <url>/2021/03/09/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Git/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Git在本地环境的使用"><a href="#1-Git在本地环境的使用" class="headerlink" title="1. Git在本地环境的使用"></a>1. Git在本地环境的使用</h2><h3 id="1-1-在本地初始化一个Git仓库"><a href="#1-1-在本地初始化一个Git仓库" class="headerlink" title="1.1 在本地初始化一个Git仓库"></a>1.1 在本地初始化一个Git仓库</h3><p>在本地新建一个文件夹，用于做Git的仓库。并在该目录下创建新文件</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304170419.png" alt="新建文件夹"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304170551.png" alt="新建文件"></p><p>接着<strong>初始化</strong>这个新建的目录。在该目录下打开命令行，键入</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git init<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304170804.png" alt="初始化新建文件夹"></p><hr><h3 id="1-2-查看本地仓库的状态"><a href="#1-2-查看本地仓库的状态" class="headerlink" title="1.2 查看本地仓库的状态"></a>1.2 查看本地仓库的状态</h3><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git status<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304174055.png" alt="查看状态"></p><p>其中，”<strong>On branch master</strong>“表示本地仓库默认在<strong>master</strong>分支，”<strong>Untracked files</strong>“表示”<strong>test.markdown</strong>“这个文件还没有被跟踪，还没有提交在git仓库里。并且下面会提示你可以使用”<strong>git add</strong>“去操作你想要提交的文件。</p><p>如果该目录没有被初始化，将会出现以下结果</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304200343.png" alt="没有初始化"></p><hr><h3 id="1-3-添加文件到Git暂存区"><a href="#1-3-添加文件到Git暂存区" class="headerlink" title="1.3 添加文件到Git暂存区"></a>1.3 添加文件到Git暂存区</h3><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git add 文件名<br></code></pre></div></td></tr></table></figure><p>添加文件后可以查看一下仓库此时的状态</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304174623.png" alt="提交Git到暂存区"></p><p>“<strong>Changes to be committed</strong>“表示”<strong>test.markdown</strong>“这个文件等待被提交，当然你可以使用</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git <span class="hljs-built_in">rm</span> -<span class="hljs-literal">-cached</span><br></code></pre></div></td></tr></table></figure><p>这个命令去移除这个缓存</p><hr><h3 id="1-4-提交暂存区里的文件"><a href="#1-4-提交暂存区里的文件" class="headerlink" title="1.4 提交暂存区里的文件"></a>1.4 提交暂存区里的文件</h3><p>在我们提交之前，需要先设置自己的用户名和邮箱。这些信息会出现在所有的commit记录里。</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git config -<span class="hljs-literal">-global</span> user.name <span class="hljs-string">&quot;你的名字&quot;</span><br>git config -<span class="hljs-literal">-global</span> user.email <span class="hljs-string">&quot;你的邮箱&quot;</span><br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309213610.png" alt="设置信息"></p><p>设置完后，就可以进行提交了</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git commit <span class="hljs-literal">-m</span> <span class="hljs-string">&#x27;first commit&#x27;</span><br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304204937.png" alt="提交"></p><p>其中，” <strong>-m ‘first commit’ </strong> “表示提交的时候附加信息，跟备注类似。此时再查看一下Git的状态</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304205137.png" alt="查看状态"></p><p>为什么要先”<strong>add</strong>“再”<strong>commit</strong>“呢？首先，”<strong>git add</strong>“是先把改动添加到一个”暂存区“，可以理解为是一个缓存区域，临时保存你的改动，而”<strong>git commit</strong>“才是最后真正的提交。这样做的好处就是防止误提交。</p><hr><h3 id="1-5-查看log"><a href="#1-5-查看log" class="headerlink" title="1.5 查看log"></a>1.5 查看log</h3><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git log<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304205500.png" alt="查看log"></p><p>“<strong>git log</strong>“命令可以查看所有产生的commit记录，其中，”<strong>first commit</strong>“为1.4步骤中我们提交时添加的附加信息，我们1.4节添加的用户名和邮箱也出现在里面</p><hr><h3 id="1-6-分支的查看、添加与切换"><a href="#1-6-分支的查看、添加与切换" class="headerlink" title="1.6 分支的查看、添加与切换"></a>1.6 分支的查看、添加与切换</h3><p>branch即分支的意思。在一个项目里，两个人负责不同的模块，就创建两个分支。两个人分别在各自的分支里对代码进行的改动，互相独立，互不影响。等到最后两个人的模块都完成了，再统一把分支合并起来。</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch</span><br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304205806.png" alt="查看分支"></p><p>我们有一个默认的master分支，前面的”*”号表示master是我们当前使用的分支。注意，当我们的Git仓库没有任何提交的话，直接查看分支情况会出现什么都没有的情况。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304210053.png" alt="空branch"></p><p>添加一个分支也很简单，只需要</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git branch 分支名<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304210244.png" alt="添加分支"></p><p>新建分支的命令是基于当前所在分支的基础上进行的，即以上是基于<strong>master</strong>分支新建了一个叫做<strong>_zhong</strong>的分支，此时<strong>_zhong</strong>分支跟<strong>master</strong>分支的内容完全一 样。如果你有 A、B、C三个分支，三个分支是三位同学的，各分支内容不一样，如果你当前 是在 B 分支，如果执行新建分支命令，则新建的分支内容跟 B 分支是一样的，同理如果当前 所在是 C 分支，那就是基于 C 分支基础上新建的分支。</p><p>但是当前分支并不是新建的”_zhong”分支，所以还需要通过一条命令切换当前分支</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git checkout 分支名<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304210451.png" alt="切换分支"></p><p>还有一条命令更方便，可以直接新建分支并直接切换</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git checkout <span class="hljs-literal">-b</span> 分支名<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304210652.png" alt="直接切换"></p><hr><h3 id="1-7-分支合并与删除"><a href="#1-7-分支合并与删除" class="headerlink" title="1.7 分支合并与删除"></a>1.7 分支合并与删除</h3><p>分支合并就是字面意思，当项目需要模块集成时就需要把各个分支合并到<strong>master</strong>这个主分支里面来。</p><p>合并分支前，要确保当前的分支是<strong>master</strong>，所以第一步就是切换到<strong>master</strong>这个主分支</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git checkout master<br>git merge 分支名<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304224904.png" alt="分支合并"></p><p>既然”<strong>_zhong</strong>“这个分支已经被我们合并到主分支里面去了，此时他已经没用了，就可以把他删除掉</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git branch <span class="hljs-literal">-d</span> 分支名<br>git branch <span class="hljs-literal">-D</span> 分支名<br></code></pre></div></td></tr></table></figure><p>上面两个命令选一个就可以，区别在于”<strong>-D</strong>“为强制删除。有些时候会删除失败，因为”<strong>_zhong</strong>“分支里面的代码可能还没有合并到master，使用”<strong>-d</strong>“是删除不了的，Git会提示你”<strong>_zhong</strong>“分支里还有未合并的代码，此时使用”<strong>-D</strong>“就可以强制删除</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304230029.png" alt="删除与强制删除"></p><hr><h3 id="1-8-添加版本"><a href="#1-8-添加版本" class="headerlink" title="1.8 添加版本"></a>1.8 添加版本</h3><p>我们在客户端开发的时候经常有版本的概念，比如v1.0、v1.1之类的，不同的版本肯定对应不 同的代码，所以我一般要给我们的代码加上标签，这样假设v1.1版本出了一个新bug，但是又 不晓得v1.0是不是有这个bug，有了标签就可以顺利切换到v1.0的代码，重新打个包测试了。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210313175008.png" alt="添加版本"></p><hr><hr><h2 id="2-向Github提交代码"><a href="#2-向Github提交代码" class="headerlink" title="2. 向Github提交代码"></a>2. 向Github提交代码</h2><h3 id="2-1-基本条件"><a href="#2-1-基本条件" class="headerlink" title="2.1 基本条件"></a>2.1 基本条件</h3><ol><li>Github账号</li><li>SSH及使用SSH连接到Github</li></ol><p>这些都是最基础的东西，就不再赘述</p><hr><h3 id="2-2-关联Github仓库"><a href="#2-2-关联Github仓库" class="headerlink" title="2.2 关联Github仓库"></a>2.2 关联Github仓库</h3><p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作。</p><p>在Github创建完仓库后，记住这个仓库名。然后进入你要关联的本地仓库，打开powershell</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git remote add origin git@github.com:你的Github名称/仓库名.git<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309171818.png" alt="关联"></p><p>也可以使用以下命令，查看我们当前项目有哪些远程仓库</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git remote <span class="hljs-literal">-v</span><br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309213054.png" alt="查看仓库"></p><hr><h3 id="2-3-将本地资源更新到Github"><a href="#2-3-将本地资源更新到Github" class="headerlink" title="2.3 将本地资源更新到Github"></a>2.3 将本地资源更新到Github</h3><p>现在我要将我本地仓库的文件更新到Github上的<strong>HelloWorld</strong>这个仓库</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git push origin master<br></code></pre></div></td></tr></table></figure><p>其中，远程库的名字就是<strong>origin</strong>，这是Git默认的也是大家公认的叫法，当然你也可以自己取个名字。<strong>master</strong>指的是在本地的master分支。</p><p>所以这条命令的意思就是把<strong>本地Git仓库</strong>的<strong>master</strong>分支，推送到<strong>Github</strong>中与本地<strong>Git仓库</strong>关联的<strong>Github仓库</strong>中。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309180525.png" alt="仓库"></p><p>推送完成，这时候可以打开Github仓库查看我们推送的内容。注意，需要选择<strong>master分支</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309182850.png" alt="查看推送情况"></p><hr><h3 id="2-4-从Github更新资源到本地"><a href="#2-4-从Github更新资源到本地" class="headerlink" title="2.4 从Github更新资源到本地"></a>2.4 从Github更新资源到本地</h3><p>如果别人提交代码到远程仓库，这个时候你需要把远程仓库的最新代码拉下来，然后保证两端代码的同步</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git pull origin master<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309205925.png" alt="pull"></p><p>一般我们在<strong>push</strong>之前都会先<strong>pull</strong> ，这样不容易冲突。</p><hr><h3 id="2-5-克隆"><a href="#2-5-克隆" class="headerlink" title="2.5 克隆"></a>2.5 克隆</h3><p>克隆可以理解为高级点的复制。将一个项目从Github克隆到本地，那么该项目在本地就已经是一个Git仓库了，不需要使用<code>git init</code>进行初始化，而且都已经关联好了远程仓库，我们只需要在本地的项目目录下任意修改或者添加文件，然后进行commit，之后就可以执行<code>git pull origin master</code>等相关操作。</p><p>在克隆之前，需要获取仓库地址</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309214931.png" alt="获取仓库地址"></p><p>然后打开本地项目所在的父目录，执行</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git clone git@github.com:你的Github/仓库名.git<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309215251.png" alt="仓库克隆"></p><p>进入本地项目，我们会发现目录中有个”<strong>.git</strong>“文件，有这个文件就说明这已经是个本地的Git仓库了。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309215354.png" alt="本地项目"></p><hr><hr><h2 id="3-Git进阶与技巧"><a href="#3-Git进阶与技巧" class="headerlink" title="3. Git进阶与技巧"></a>3. Git进阶与技巧</h2><h3 id="3-1-给命令起别名"><a href="#3-1-给命令起别名" class="headerlink" title="3.1 给命令起别名"></a>3.1 给命令起别名</h3><p>“<strong>alias</strong>“这个命令类似于Python里面的<code>import tensorflow as tf</code>，作用是给命令起个别名。我们每次都输入<code>git push origin master</code>就很繁琐，要是我们给这条命令起个别名，比如<code>git psm</code>，那我们就可以直接使用<code>git psm</code>来代替<code>git push origin master</code>。</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git config -<span class="hljs-literal">-global</span> alias.别名 <span class="hljs-string">&#x27;命令&#x27;</span><br></code></pre></div></td></tr></table></figure><p>当然，别名可以根据自己的习惯来取</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210310162622.png" alt="别名"></p><p>下面是一些比较好用的命令：</p><h4 id="3-1-1-高级日志"><a href="#3-1-1-高级日志" class="headerlink" title="3.1.1 高级日志"></a>3.1.1 高级日志</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git config -<span class="hljs-literal">-global</span> alias.lg <span class="hljs-string">&quot;log --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%</span><br><span class="hljs-string">d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit --date=relative&quot;</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="3-2-给终端设置颜色"><a href="#3-2-给终端设置颜色" class="headerlink" title="3.2 给终端设置颜色"></a>3.2 给终端设置颜色</h3><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git config -<span class="hljs-literal">-global</span> color.ui true<br></code></pre></div></td></tr></table></figure><hr><h3 id="3-3-设置Git编辑器"><a href="#3-3-设置Git编辑器" class="headerlink" title="3.3 设置Git编辑器"></a>3.3 设置Git编辑器</h3><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git config -<span class="hljs-literal">-global</span> core.editor <span class="hljs-string">&quot;vim&quot;</span> <br></code></pre></div></td></tr></table></figure><p>将编辑器设置为<strong>vim</strong>，当然也可以设置为其他的，但是前提是本机有安装。</p><hr><h3 id="3-4-对比文件差异"><a href="#3-4-对比文件差异" class="headerlink" title="3.4 对比文件差异"></a>3.4 对比文件差异</h3><p>我们经常在做代码改动，但是有的时候2天前的代码了，做了哪些改动都忘记了，在提交之前需要确认下，这个时候就可以用diff来查看你到底做了哪些改动。直接输入<code>git diff</code>只能比较当前文件和暂存区文件差异。</p><p>此时往<strong>test.markdown</strong>这个文件添加一行字”<strong>fefe</strong>“，然后执行<code>git diff</code>。我们会发现终端给出的信息是<strong>绿色</strong>的”<strong>+</strong>“号，然后后面跟着”<strong>fefe</strong>“，由此我们可知绿色加号表示的是增加的内容。</p><p>接着我们继续修改这个文件。我们先删除第一次添加的”<strong>fefe</strong>“，然后敲入”<strong>新增加的行</strong>“，并再次执行<code>git diff</code>。我们会发现增加的”<strong>新增加的行</strong>“显示出来了，但是我们删除的”<strong>fefe</strong>“并没有显示。这是因为我们并没有执行<code>git add</code>将文件放入暂存区。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210313171234.png" alt="还未进入暂存区"></p><p>我们先将文件加入暂存区，然后将里面的”<strong>新增加的行</strong>“删除，接着添加”<strong>第二次新增加的行</strong>“。这次我们再<code>git diff</code>就会发现，添加和删除的改动同时给了我们提示。没错，相对应地，绿色”<strong>+</strong>“号为增加，红色”<strong>-</strong>“号为删除。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210313172009.png" alt="放入暂存区"></p><h4 id="3-4-1-比较两次提交之间的差异"><a href="#3-4-1-比较两次提交之间的差异" class="headerlink" title="3.4.1 比较两次提交之间的差异"></a>3.4.1 比较两次提交之间的差异</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git <span class="hljs-built_in">diff</span> &lt;<span class="hljs-variable">$id1</span>&gt; &lt;<span class="hljs-variable">$id2</span>&gt;<br></code></pre></div></td></tr></table></figure><h4 id="3-4-2-在两个分支之间比较"><a href="#3-4-2-在两个分支之间比较" class="headerlink" title="3.4.2 在两个分支之间比较"></a>3.4.2 在两个分支之间比较</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git <span class="hljs-built_in">diff</span> &lt;branch1&gt;..&lt;branch2&gt;<br></code></pre></div></td></tr></table></figure><h4 id="3-4-3-比较暂存区和版本库差异"><a href="#3-4-3-比较暂存区和版本库差异" class="headerlink" title="3.4.3 比较暂存区和版本库差异"></a>3.4.3 比较暂存区和版本库差异</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git <span class="hljs-built_in">diff</span> -<span class="hljs-literal">-staged</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="3-5-checkout命令的拓展"><a href="#3-5-checkout命令的拓展" class="headerlink" title="3.5 checkout命令的拓展"></a>3.5 checkout命令的拓展</h3><p>“<strong>checkout</strong>“一般用作切换分支使用，比如切换到develop分支，可以执行：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git checkout develop<br></code></pre></div></td></tr></table></figure><h4 id="3-5-1-切换tag"><a href="#3-5-1-切换tag" class="headerlink" title="3.5.1 切换tag"></a>3.5.1 切换tag</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git checkout v1.<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h4 id="3-5-2-切换到某次commit"><a href="#3-5-2-切换到某次commit" class="headerlink" title="3.5.2 切换到某次commit"></a>3.5.2 切换到某次commit</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git checkout  ffd9f2dd68f1eb21d36cee50dbdd504e95d9c8f7<br></code></pre></div></td></tr></table></figure><p>后面的一长串是<strong>commit_id</strong>，是每次<strong>commit</strong>的SHA1值，可以根据<code>git log</code>看到。</p><h4 id="3-5-3-撤销文件"><a href="#3-5-3-撤销文件" class="headerlink" title="3.5.3 撤销文件"></a>3.5.3 撤销文件</h4><p>假设我们在一个分支开发 一个小功能，刚写完一半，这时候需求变了，而且是大变化，之前写的代码完全用不了了，好在你刚写，甚至都没有 git add 进暂存区，这个时候很简单的一个操作就直接把原文件还原</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git checkout a.md<br></code></pre></div></td></tr></table></figure><p>注意：只能撤销还没有<strong>add</strong>进暂存区的文件。</p><hr><h3 id="3-6-代码的临时保存"><a href="#3-6-代码的临时保存" class="headerlink" title="3.6 代码的临时保存"></a>3.6 代码的临时保存</h3><p>设想一个场景，假设我们正在一个新的分支做新的功能，这个时候突然有一个紧急的bug需要 修复，而且修复完之后需要立即发布。当然你说我先把刚写的一点代码进行提交不就行了 么？这样理论上当然是ok的，但是这会产品垃圾<strong>commit</strong>，原则上我们每次的<strong>commit</strong>都要有<strong>实际的意义</strong>，你的代码只是刚写了一半，还没有什么实际的意义是不建议就这样commit的，那 么有没有一种比较好的办法，可以让我暂时切到别的分支，修复完bug再切回来，而且代码也 能保留的呢？</p><p>这个时候 stash 命令就大有用处了，前提是我们的代码<strong>没有</strong>进行<strong>commit</strong> ，哪怕你执行了<strong>add</strong>也没关系</p><h4 id="3-6-1-保存代码"><a href="#3-6-1-保存代码" class="headerlink" title="3.6.1 保存代码"></a>3.6.1 保存代码</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git stash<br></code></pre></div></td></tr></table></figure><p>意思就是把当前分支所有没有<strong>commit</strong>的代码先暂存起来，这个时候你再执行<code>git status</code>你会发现当前分支很干净，几乎看不到任何改动，你的代码改动也看不见了，但其实是暂存起来了。</p><h4 id="3-6-3-查询保存记录"><a href="#3-6-3-查询保存记录" class="headerlink" title="3.6.3 查询保存记录"></a>3.6.3 查询保存记录</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git stash list<br></code></pre></div></td></tr></table></figure><h4 id="3-6-4-还原代码"><a href="#3-6-4-还原代码" class="headerlink" title="3.6.4 还原代码"></a>3.6.4 还原代码</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git stash apply<br></code></pre></div></td></tr></table></figure><p>之前的代码全部又回来了，就好像一切都没发生过一样</p><h4 id="3-6-5-删除记录"><a href="#3-6-5-删除记录" class="headerlink" title="3.6.5 删除记录"></a>3.6.5 删除记录</h4><p>紧接着你最好需要把暂存区的这次<strong>stash</strong>记录删除</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git stash drop<br></code></pre></div></td></tr></table></figure><p>当然后面可以跟<strong>stash_id</strong>参数来删除指定的某条记录，不跟参数就是删除最近的</p><h4 id="3-6-6-还原并删除记录"><a href="#3-6-6-还原并删除记录" class="headerlink" title="3.6.6 还原并删除记录"></a>3.6.6 还原并删除记录</h4><p>其实还有更方便的指令</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git stash pop<br></code></pre></div></td></tr></table></figure><p>来代替<strong>apply</strong>命令，<strong>pop</strong>跟<strong>apply</strong>的唯一区别就是<strong>pop</strong>不但会帮你把代码还原，还自动帮你把这条<strong>stash</strong>记录删除，省的自己再<strong>drop</strong>一次了</p><h4 id="3-6-7-清空记录"><a href="#3-6-7-清空记录" class="headerlink" title="3.6.7 清空记录"></a>3.6.7 清空记录</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git stash <span class="hljs-built_in">clear</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="3-7-另一种合并"><a href="#3-7-另一种合并" class="headerlink" title="3.7 另一种合并"></a>3.7 另一种合并</h3><p>我们知道<strong>merge</strong>是用来合并分支的命令，同时，<strong>rebase</strong>命令也是合并的意思，操作起来也和<strong>merge</strong>命令一样</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git checkout master <br>git rebase featureA<br></code></pre></div></td></tr></table></figure><p><strong>rebase</strong>跟<strong>merge</strong>的区别可以理解成有两个书架，你需要把两个书架的书整理到一起 去，第一种做法是<strong>merge</strong> ，比较粗鲁暴力，就直接腾出一块地方把另一个书架的书全部放进去，虽然暴力，但是这种做法你可以知道哪些书是来自另一个书架的；第二种做法就是<strong>rebase</strong> ，他会把两个书架的书先进行比较，按照购书的时间来给他重新排序，然后重新放置好，这样做的好处就是合并之后的书架看起来很有逻辑，但是你很难清晰的知道哪些书来自哪个书架的。 </p><p>只能说各有好处的，不同的团队根据不同的需要以及不同的习惯来选择就好。</p><hr><h3 id="3-8-解决冲突"><a href="#3-8-解决冲突" class="headerlink" title="3.8 解决冲突"></a>3.8 解决冲突</h3><p>假设这样一个场景，A和B两位同学各自开了两个分支来开发不同的功能，大部分情况下都会 尽量互不干扰的，但是有一个需求A需要改动一个基础库中的一个类的方法，不巧B这个时候 由于业务需要也改动了基础库的这个方法，因为这种情况比较特殊，A和B都认为不会对地方 造成影响，等两人各自把功能做完了，需要合并的到主分支<strong>master</strong>的时候，我们假设先合并A的分支，这个时候没问题的，之后再继续合并B的分支，这个时候想想也知道就有冲突了， 因为A和B两个人同时更改了同一个地方，Git 本身他没法判断你们两个谁更改的对，但是这个时候他会智能的提示有<strong>conflicts</strong> ，需要手动解决这个冲突之后再重新进行一次<strong>commit</strong>提交。以下是一个例子：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210313183311.png" alt="冲突例子"></p><p>以上截图里就是冲突的示例，冲突的地方由 == == 分出了上下两个部分，上部分一个叫<strong>HEAD</strong>的字样代表是我当前所在分支的代码，下半部分是一个叫<strong>baidu_activity</strong>分支的代 码，可以看到HEAD对gradle插件进行了升级，同时新增了一个插件，所以我们很容易判断哪些代码该保留，哪些代码该删除，我们只需要移除掉那些老旧代码，而且同也要把那些 &lt;&lt;&lt; HEAD、==== 以及 &gt;&gt;&gt;&gt;&gt;&gt;baidu_activity 这些标记符号也一并删除，最后进行一次 commit 就ok了。</p><p>我们在开发的过程中一般都会约定尽量大家写的代码不要彼此影响，以减少出现冲突的可 能，但是冲突总归无法避免的，我们需要了解并掌握解决冲突的方法。</p><hr><hr><h2 id="4-Git-Flow"><a href="#4-Git-Flow" class="headerlink" title="4.Git Flow"></a>4.Git Flow</h2><p><strong>Git Flow</strong>是一种比较成熟的分支管理流程，我们先看一张能清晰的描述他整个工作流程的图</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210316151643.png" alt="Git Flow"></p><p>一般开发来说，大部分情况下都会拥有两个分支<strong>master</strong>和<strong>develop</strong>，他们的职责分别是：</p><ul><li>master：永远处在即将发布(production-ready)状态</li><li>develop：最新的开发状态</li></ul><p>确切的说<strong>master</strong>、<strong>develop</strong>分支大部分情况下都会保持一致，只有在上线前的测试阶段<strong>develop</strong>比<strong>master</strong>的代码要多，一旦测试没问题，准备发布了，这时候会将<strong>develop</strong>合并到<strong>master</strong>上。 但是我们发布之后又会进行下一版本的功能开发，开发中间可能又会遇到需要紧急修复 bug ，一个功能开发完成之后突然需求变动了等情况，所以<strong>Git Flow</strong>除了以上<strong>master</strong>和<strong>develop</strong>两个主要分支以外，还提出了以下三个辅助分支：</p><ul><li>feature: 开发新功能的分支, 基于develop, 完成后merge回develop</li><li>release: 准备要发布版本的分支, 用来修复bug，基于develop，完成后merge回develop和master</li><li>hotfix: 修复master上的问题, 等不及 release 版本就必须马上上线. 基于 master, 完成后 merge 回 master 和 develop</li></ul><p>举个例子，假设我们已经有 master 和 develop 两个分支了，这个时候我们准备做一个功能 A，第一步我们要做的，就是基于 develop 分支新建个分支：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git branch feature/A<br></code></pre></div></td></tr></table></figure><p>看到了吧，其实就是一个规范，规定了所有开发的功能分支都以 feature 为前缀。 但是这个时候做着做着发现线上有一个紧急的 bug 需要修复，那赶紧停下手头的工作，立刻切换master 分支，然后再此基础上新建一个分支：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git branch hotfix/B<br></code></pre></div></td></tr></table></figure><p>代表新建了一个紧急修复分支，修复完成之后直接合并到develop和master ，然后发布。</p><p>然后再切回我们的 feature/A 分支继续着我们的开发，如果开发完了，那么合并回develop分 支，然后在develop分支属于测试环境，跟后端对接并且测试的差不多了，感觉可以发布到正式环境了，这个时候再新建一个 release 分支：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git branch release/<span class="hljs-number">1.0</span><br></code></pre></div></td></tr></table></figure><p>这个时候所有的 api、数据等都是正式环境，然后在这个分支上进行最后的测试，发现 bug 直 接进行修改，直到测试 ok 达到了发布的标准，最后把该分支合并到 develop 和 master 然后 进行发布。</p><hr><hr><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h3 id="1-Enter-passphrase-for-key"><a href="#1-Enter-passphrase-for-key" class="headerlink" title="1. Enter passphrase for key"></a>1. Enter passphrase for key</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309182939.png" alt="需要密码"></p><p>这个问题出现在每次使用ssh连接Github都需要输入密码，所以删除掉之前的密码即可</p><figure class="highlight cmd"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmd">ssh-keygen -p<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309183534.png" alt="删除密码"></p><p>注意，”<strong>Enter file in which the key is (C:\Users\15606/.ssh/id_rsa):</strong>“这条语句后面只需按回车键。</p><p>这时候再push一下就不需要再次输入密码了</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309183847.png" alt="再次push"></p><hr><h3 id="2-“仓库名”-does-not-appear-to-be-a-git-repository"><a href="#2-“仓库名”-does-not-appear-to-be-a-git-repository" class="headerlink" title="2. “仓库名” does not appear to be a git repository"></a>2. “仓库名” does not appear to be a git repository</h3><p>这个问题是由于本地仓库和远程仓库没有进行关联，只需按照本文的2.2节进行处理。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309171953.png" alt="失败"></p><hr><h3 id="3-Access-has-been-restricted"><a href="#3-Access-has-been-restricted" class="headerlink" title="3. Access has been restricted"></a>3. Access has been restricted</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309172509.png" alt="滥用检测机制"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309172547.png" alt="滥用2"></p><p>这个问题….不知道怎么解决</p><hr><h3 id="4-不同目录下的同名文件的提交（未解决）"><a href="#4-不同目录下的同名文件的提交（未解决）" class="headerlink" title="4.不同目录下的同名文件的提交（未解决）"></a>4.不同目录下的同名文件的提交（未解决）</h3><p>在使用CLion的Git模块时发生的错误，父目录为Learn，而子目录分别是A和B，A和B中分别有main.c这个文件。我先提交的A，后面再提交B，结果B的提交说明会覆盖掉A中main.c的提交说明。</p><p>参考：<a href="https://www.cnblogs.com/kevingrace/p/5690241.html">[Git忽略提交规则 - .gitignore配置运维总结]</a></p><hr><hr><h2 id="心得或经验"><a href="#心得或经验" class="headerlink" title="心得或经验"></a>心得或经验</h2><ol><li>每次的commit必须要有实际的意义</li></ol><h2 id="参考及引用说明"><a href="#参考及引用说明" class="headerlink" title="参考及引用说明"></a>参考及引用说明</h2><ol><li>《learn-github-from-zero》-作者：stormzhang，个人网站：<a href="http://stormzhang.com/">http://stormzhang.com/</a></li><li>“廖雪峰的官方网站”-作者：廖雪峰，个人网站：<a href="https://www.liaoxuefeng.com/sha">https://www.liaoxuefeng.com/sha</a></li><li>“菜鸟教程”：网站：<a href="https://www.runoob.com/git/git-tutorial.html">https://www.runoob.com/git/git-tutorial.html</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标准归纳</title>
    <link href="/2021/03/03/C++/%E6%96%B0%E6%A0%87%E5%87%86%E5%BD%92%E7%BA%B3/"/>
    <url>/2021/03/03/C++/%E6%96%B0%E6%A0%87%E5%87%86%E5%BD%92%E7%BA%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="Variadic-Templates"><a href="#Variadic-Templates" class="headerlink" title="Variadic Templates"></a>Variadic Templates</h2><ul><li>可以有任意多个参数数量，同时参数类型也可以是任意多个</li><li>可变参数模板可以用于递归操作。所以需要同时写一个处理最后情况，即没有参数的函数。否则编译出错。</li></ul><p>比如常见的操作有：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span>... Types&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printX</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; firstArg,<span class="hljs-keyword">const</span> Type&amp;... args)</span></span>&#123;<span class="hljs-comment">//将会被递归调用</span><br>    cout&lt;&lt;firstArg&lt;&lt;endl;<br>    <span class="hljs-keyword">sizeof</span>...(args);<span class="hljs-comment">//可以获得args的数量</span><br>    <span class="hljs-built_in">printX</span>(args...);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printX</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//这个函数必须写，否则当args的个数为0时会报错</span><br><br><span class="hljs-comment">//使用</span><br><span class="hljs-built_in">printX</span>(<span class="hljs-number">7.5</span>,<span class="hljs-string">&quot;hello&quot;</span>,bitset&lt;<span class="hljs-number">16</span>&gt;(<span class="hljs-number">377</span>),<span class="hljs-number">42</span>);<br></code></pre></div></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>tuple：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/2e28effd572df93c0a3d7d35ce0f9f9b-3954c.png"  /></p><h2 id="Initializer-list"><a href="#Initializer-list" class="headerlink" title="Initializer-list"></a>Initializer-list</h2><p>C++新标准的语法糖之一，可以接受个数不定的参数。</p><p>基本用法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i&#123;&#125;;<span class="hljs-comment">//i被初始化为0</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; vec&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-comment">//动态数组vec中有两个值0和1</span><br><span class="hljs-comment">//...</span><br></code></pre></div></td></tr></table></figure><p>它的背后支撑是 <code>initializer_list&lt;T&gt;</code>，而 <code>initializer_list&lt;T&gt;</code>里面其实就是<code>array</code>。</p><p>所以也可以使用它来作为函数的形参：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(initializer_list&lt;<span class="hljs-keyword">int</span>&gt; initlist)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : initlist)&#123;<br>        <span class="hljs-comment">//....</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="for-loop"><a href="#for-loop" class="headerlink" title="for-loop"></a>for-loop</h2><p>新标准的<strong>for-loop</strong>会被编译器解释为如下的代码：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/70b905fedc4141555829534729444a7e-7a7fd.png"  /></p><p>其中，<code>begin()</code>和 <code>end()</code>成为新标准的全局函数。</p><h3 id="错误使用"><a href="#错误使用" class="headerlink" title="错误使用"></a>错误使用</h3><p>对于以下情况，<strong>for-loop</strong>无法正常编译：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp; s)</span></span>;<span class="hljs-comment">//禁止隐式转换</span><br><span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">//...</span><br>vectot&lt;string&gt; vec;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> C&amp; elem : vec)&#123;<span class="hljs-comment">//错误！因为没有定义string转C类型的类型转换函数</span><br>cout&lt;&lt;elem&lt;&lt;endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="delete和-default"><a href="#delete和-default" class="headerlink" title="=delete和=default"></a>=delete和=default</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7b2b1face664b066dc6d68ae9abd9eee-58f42.png"  /></p><h3 id="big-five"><a href="#big-five" class="headerlink" title="big-five"></a>big-five</h3><ul><li>默认的<strong>big-five</strong>只有在需要的时候（被调用）才会被编译器合成</li><li>所有的<strong>big-five</strong>都是<code>public</code>且<code>inline</code>的</li><li>如果class没有pointer member，用默认的<strong>big-five</strong>就够了。反例：比如C++中的<code>string</code>，由于它里面的成员变量有指针，所以使用默认的big-five容易出错。另外，对于<code>string</code>类，里面有引用计数，感觉应该是为了实现写时复制读时共享。</li><li>如果一个类只允许让友元类或家族成员拷贝，那么可以把拷贝控制放到<code>private</code>里，且不能定义。在<strong>boost</strong>库中有一个类<code>noncopyable</code>，这个类就是把拷贝控制放到<code>private</code>里，而且从它派生的子类也会继承它的性质。</li></ul><h3 id="delete"><a href="#delete" class="headerlink" title="=delete"></a>=delete</h3><ul><li><code>=delete</code>可用于任何函数身上</li><li>一个比较典型的例子：为了让某类型的对象只有一份，可以把该类的拷贝构造和拷贝赋值设置为<code>=delete</code>，让使用者禁止调用拷贝构造和拷贝赋值。</li></ul><h3 id="default"><a href="#default" class="headerlink" title="=default"></a>=default</h3><ul><li><code>=default</code>只能用于<strong>big-five</strong></li></ul><h2 id="Alias-Template"><a href="#Alias-Template" class="headerlink" title="Alias Template"></a>Alias Template</h2><p>化名可以带参数，比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> Vec = std:vector&lt;T,MyAlloc&lt;T&gt;&gt;;<span class="hljs-comment">//使用自己的内存分配器代替标准库的内存分配器</span><br><br>Vec&lt;<span class="hljs-keyword">int</span>&gt; coll;<span class="hljs-comment">//别名可以含参，等同于下面</span><br>std:vector&lt;T,MyAlloc&lt;T&gt;&gt; coll;<br></code></pre></div></td></tr></table></figure><p>注意：虽然说别名可以带参数，但是无法对别名进行特化，只能对它代替的本体进行特化。</p><p>但是使用<strong>macro</strong>无法达到同样的效果：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Vec<span class="hljs-meta-string">&lt;T&gt;</span> template<span class="hljs-meta-string">&lt;typename T&gt;</span> std:vector<span class="hljs-meta-string">&lt;T,MyAlloc&lt;T&gt;</span>&gt;;<span class="hljs-comment">//如果使用宏定义</span></span><br><br><span class="hljs-comment">//对于Vec&lt;int&gt; coll;会变成如下的样子</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">int</span>&gt; std:vector&lt;<span class="hljs-keyword">int</span>,MyAlloc&lt;<span class="hljs-keyword">int</span>&gt;&gt;;<span class="hljs-comment">//不是我们想要的效果</span><br></code></pre></div></td></tr></table></figure><p>而且，使用 <code>typedef</code>也无法达到相同的效果，因为 <code>typedef</code>是不接受参数的。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>若想实现一个函数，这个函数的实参是容器+数据类型，比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">func</span>(list,string);<span class="hljs-comment">//希望该函数在内部组装成list&lt;string&gt;</span><br></code></pre></div></td></tr></table></figure><p>如果使用以下的方法不可取：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/0e3e4da418ba56a8d09599e81084e714-2c4e3.png" alt=""></p><p>解决方法1：使用模板+迭代器+萃取机制。</p><p>可以使用萃取机取出元素类型，比如：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9b118fa0855d9281180f42badcfabda8-bb430.png"  /></p><p>解决方法2：使用模板别名和模板模板参数。如下：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/269cad0f9f8e281a3c0a082393cc68c3-c4a7c.png"  /></p><h3 id="别名的其他用法"><a href="#别名的其他用法" class="headerlink" title="别名的其他用法"></a>别名的其他用法</h3><p>除了用于模板的<strong>别名</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">charT</span>&gt;</span> <br><span class="hljs-keyword">using</span> mystring = std::basic_string&lt;CharT,std::char_traits&lt;CharT&gt;&gt;;<br><span class="hljs-comment">//...</span><br>mystring&lt;<span class="hljs-keyword">char</span>&gt; str;<br></code></pre></div></td></tr></table></figure><p>还能用于模板的参数：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Container</span>&#123;</span><br><span class="hljs-keyword">using</span> value_type = T;<br>&#125;;<br><span class="hljs-comment">//上下代码等同效果</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Cntr&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fn2</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Cntr&amp; c)</span></span>&#123;<br>    <span class="hljs-keyword">typename</span> Cntr::value_type n;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>也能用于函数：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> func = <span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(*)(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>);<span class="hljs-comment">//等效于typedef void(*func)(int,int);</span><br><span class="hljs-comment">//...</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">example</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span></span>&#123;&#125;<br>func fn = example;<br></code></pre></div></td></tr></table></figure><p><code>typedef</code>和<strong>别名</strong>实际上的差别并不大，但是<strong>别名</strong>的灵活性更胜一筹。</p><h2 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h2><p>在函数后头添加这个关键字，表示这个函数保证不会发生异常。比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></div></td></tr></table></figure><p>也可以对 <code>noexcept</code>添加条件，比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span></span>;<span class="hljs-comment">//可以添加条件，表示符合这个条件就不会发生异常</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Type&amp; x,Type&amp; y)</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-keyword">noexcept</span>(x.swap(y)))</span></span>&#123;<br>    x.<span class="hljs-built_in">swap</span>(y);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意：如果发生异常，没有及时处理，那么这个异常就会进入 <code>std::terminate()</code>，并且调用 <code>std::abort()</code>结束程序。</p><p>另外，对于用户自定义类的移动函数，也需要在后面添加 <code>noexcept</code>关键字。如果没有添加，特别是使用容器 <code>vector</code>时，<code>vector</code>只会调用开销更大的拷贝函数，而不会去调用移动函数。（能够生长的容器只有 <code>vector</code>和 <code>deque</code>）</p><p>使用 <code>noexcept</code>可以让编译器对代码进行优化。</p><h2 id="override"><a href="#override" class="headerlink" title="override"></a>override</h2><p>这个关键字只是为了让编译器帮助检查，避免重写过程中的错误，不一定需要使用。但是感觉写了也增加了程序的可读性。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Base</span>&#123;</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfunc</span><span class="hljs-params">(<span class="hljs-keyword">float</span>)</span></span>&#123;&#125;  <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test1</span>:</span>Base&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>&#123;&#125;  <span class="hljs-comment">//本意是重写Base的vfunc函数，但是由于失误更改了形参类型</span><br>     <span class="hljs-comment">//编译器会认为定义了一个新函数</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test2</span>:</span>Base&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-keyword">override</span></span>&#123;&#125;  <span class="hljs-comment">//本意是重写Base的vfunc函数，但是由于失误更改了形参类型</span><br>       <span class="hljs-comment">//不过有override关键字的存在，编译器发现了错误</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>这个关键字和 <code>override</code>一样，也是为了让编译器帮助检查。</p><p>这个关键字可用于类身上，它的作用就是告诉编译器：我是这个继承体系之下的最后一个，不能再有类继承我了。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Base</span> <span class="hljs-keyword">final</span>&#123;</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test</span>:</span>Base&#123;&#125;;<span class="hljs-comment">//错误！不能继承一个final类</span><br></code></pre></div></td></tr></table></figure><p>也可以用于虚函数身上，作用同上。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">strcuct Base&#123;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span></span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test</span>:</span>Base&#123;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//错误！不能重写一个final虚函数</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p>使用 <code>decltype</code>关键字可以找到一个表达式的类型，相当于 <code>typeof</code>。比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">map&lt;string,<span class="hljs-keyword">float</span>&gt; coll;<br><span class="hljs-keyword">decltype</span>(coll)::value_type elem;<span class="hljs-comment">//可以使用decltype获得容器的类型</span><br><span class="hljs-comment">//等同于以下</span><br><span class="hljs-comment">//before C++11</span><br>map&lt;string,<span class="hljs-keyword">float</span>&gt;::value_type elem;<br></code></pre></div></td></tr></table></figure><p>它可以用来声明一个 <code>return type</code>：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T1 x,T2 y)</span>-&gt;<span class="hljs-title">decltype</span><span class="hljs-params">(x+y)</span></span>&#123;&#125;;<br></code></pre></div></td></tr></table></figure><p>也可以用于模板元编程：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T obj)</span></span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> <span class="hljs-title">decltype</span><span class="hljs-params">(obj)</span>::iterator iType</span>;<span class="hljs-comment">//取迭代器，当然前提是T有迭代器</span><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>还可以用于 <code>lambda</code>：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-keyword">const</span> Person&amp; p1,<span class="hljs-keyword">const</span> Person&amp; p2)&#123;<br>    <span class="hljs-comment">//....</span><br>&#125;;<br><span class="hljs-function">std::set&lt;Person,<span class="hljs-title">decltype</span><span class="hljs-params">(cmp)</span>&gt; <span class="hljs-title">coll</span><span class="hljs-params">(cmp)</span></span>;<span class="hljs-comment">//常用于对容器的排序</span><br></code></pre></div></td></tr></table></figure><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p><code>lambda</code>有点像<strong>inline function</strong>，它可以被当作函数参数或一个局部object。</p><p>它有很多形式：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">[]&#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;hello&quot;</span>&lt;&lt;std::endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">[]&#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;hello&quot;</span>&lt;&lt;std::endl;<br>&#125;();<span class="hljs-comment">//注意这个括号，表示直接调用，输出hello</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> func = []&#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;hello&quot;</span>&lt;&lt;std::endl;<br>&#125;;<br><span class="hljs-built_in">func</span>();<span class="hljs-comment">//输出hello</span><br></code></pre></div></td></tr></table></figure><p>它的语法如下：</p><script type="math/tex; mode=display">[\ \ ]\ ()\ mutable_{opt}\ throwSpec_{opt}->retType_{opt}\{...\}</script><ul><li><p><strong>[ ]</strong>为捕获列表，可以为空，也可以写入变量。捕获方式可以是值传递，也可以是引用传递。</p><ul><li>[=]：全部都是值传递</li><li>[&amp;a]：a变量引用传递</li><li>[a]：a变量值传递</li><li>[&amp;a,=]：a变量引用传递，其他变量值传递</li></ul></li><li><strong>( )</strong>为形参列表</li><li>$mutable_{opt}$表示是否可以改动捕获列表中的变量。</li><li>$throwSpec_{opt}$表示是否丢出异常</li><li>$retType_{opt}$表示返回类型。</li><li>$mutable<em>{opt}$​、$throwSpec</em>{opt}$​、$retType_{opt}$可有可无。若三者都不存在，可以不写<strong>( )</strong>。但是若三者有一个出现，那么<strong>( )</strong>必须存在。</li><li><strong>{ }</strong>为函数本体</li></ul><h2 id="Rvalue-references"><a href="#Rvalue-references" class="headerlink" title="Rvalue references"></a>Rvalue references</h2><ul><li>左值：可以出现在等号的左侧</li><li>右值：只能出现在等号的右侧<ul><li>右值引用可以避免不必要的拷贝</li><li>临时对象也是右值</li><li>右值没有名称</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用SSR实现局域网代理</title>
    <link href="/2021/03/01/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8SSR%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BB%A3%E7%90%86/"/>
    <url>/2021/03/01/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8SSR%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><h3 id="1-设置路由器"><a href="#1-设置路由器" class="headerlink" title="1. 设置路由器"></a>1. 设置路由器</h3><p>既然要实现局域网代理，那么首先，需要给作为代理服务器的设备设置静态IP地址。</p><p>我的代理服务器静态IP地址设置为192.168.3.9，在此举出以便于下文编写。</p><h4 id="1-1-从路由器关闭DHCP-不推荐"><a href="#1-1-从路由器关闭DHCP-不推荐" class="headerlink" title="1.1 从路由器关闭DHCP(不推荐)"></a>1.1 从路由器关闭DHCP(不推荐)</h4><p>打开路由器的设置页面，以华为路由器为例，找到DHCP相关设置，并关闭DHCP。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301091942.png" alt="关闭DHCP"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301091909.png" alt="提示"></p><p>该方法不推荐使用，原因如上图</p><h4 id="1-2-从路由器添加静态IP地址"><a href="#1-2-从路由器添加静态IP地址" class="headerlink" title="1.2 从路由器添加静态IP地址"></a>1.2 从路由器添加静态IP地址</h4><p>在路由器的DHCP页面找到添加静态IP地址的选项</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301092234.png" alt="添加"></p><p>选择需要作为代理服务器的设备即可</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301092321.png" alt="静态IP地址绑定"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301092447.png" alt="完成"></p><h4 id="1-3-直接在代理服务器上设置静态IP地址"><a href="#1-3-直接在代理服务器上设置静态IP地址" class="headerlink" title="1.3 直接在代理服务器上设置静态IP地址"></a>1.3 直接在代理服务器上设置静态IP地址</h4><p>打开代理服务器上的”<strong>网络连接</strong>“，找到连接到路由器的网卡，右键点击呼出上下文，选择属性并进入，IP地址相关不再赘述。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301092813.png" alt="设置静态IP"></p><h3 id="2-设置SSR"><a href="#2-设置SSR" class="headerlink" title="2. 设置SSR"></a>2. 设置SSR</h3><p>在Surface上右键小飞机-&gt;更多-&gt;选项设置</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301080311.png" alt="设置SSR"></p><p>勾选”<strong>允许来自局域网的连接</strong>“即可</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301080602.png" alt="选项设置"></p><h2 id="Windows客户端"><a href="#Windows客户端" class="headerlink" title="Windows客户端"></a>Windows客户端</h2><h4 id="1-PAC文件"><a href="#1-PAC文件" class="headerlink" title="1. PAC文件"></a>1. PAC文件</h4><p>右键小飞机找到PAC文件地址并复制</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210303210609.png" alt="PAC文件地址"></p><h4 id="2-设置windows代理"><a href="#2-设置windows代理" class="headerlink" title="2. 设置windows代理"></a>2. 设置windows代理</h4><p>在<strong>客户端</strong>，依次打开控制面板-&gt;网络和Internet-&gt;代理，在自动设置代理里面的脚本地址中填入刚才复制的PAC地址，其中，IP地址需要更换成代理服务器的地址</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210303211509.png" alt=""></p><h2 id="随记"><a href="#随记" class="headerlink" title="随记"></a>随记</h2><h3 id="1-自动代理和手动代理的区别"><a href="#1-自动代理和手动代理的区别" class="headerlink" title="1. 自动代理和手动代理的区别"></a>1. 自动代理和手动代理的区别</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301091636.png" alt="自动代理和手动代理"></p><ol><li>自动代理：需要配置PAC(proxy auto-config)脚本文件，根据PAC文件流量会自动选择走代理还是直连。<a href="https://www.barretlee.com/blog/2016/08/25/pac-file/">详解代理自动配置 PAC</a></li><li>手动代理：除了指定的地址不走代理，流量会经代理访问剩余地址</li></ol>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>局域网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows10环境使用Jekyll+github page搭建个人博客</title>
    <link href="/2021/02/05/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Windows10%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8Jekyll+github%20page%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/02/05/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Windows10%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8Jekyll+github%20page%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="1-搭建Jekyll"><a href="#1-搭建Jekyll" class="headerlink" title="1.搭建Jekyll"></a>1.搭建Jekyll</h2><h3 id="1-1-安装Ruby"><a href="#1-1-安装Ruby" class="headerlink" title="1.1 安装Ruby"></a>1.1 安装Ruby</h3><p>Ruby是一种类似于Python的面向对象的语言。</p><p><a href="https://rubyinstaller.org/downloads/">Ruby下载网址</a></p><p>根据自己的开发环境选择对应版本。注意，需要选择<strong>Ruby+Devkit</strong>。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205111003.png" alt="Ruby下载"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205114122.png" alt="License"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205114157.png" alt="Destination"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205114232.png" alt="Components"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205114344.png" alt="等待安装完成"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205114601.png" alt="安装完成"></p><p>等待一会，会跳出命令行界面。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-04-58.png" alt="RubyInstaller2"></p><p>直接按ENTER执行。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205114946.png" alt="正在安装"></p><p>安装完成后关闭窗口即可</p><hr><h3 id="1-2-安装Jekyll"><a href="#1-2-安装Jekyll" class="headerlink" title="1.2 安装Jekyll"></a>1.2 安装Jekyll</h3><p>打开CMD，输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">gem install jekyll bundler<br></code></pre></div></td></tr></table></figure><p>执行，然后等待安装完成。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205115635.png" alt="CMD安装"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205115733.png" alt="CMD安装完成"></p><p>现在验证Jekyll安装是否完成，只需在CMD中输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">jekyll -v<br></code></pre></div></td></tr></table></figure><p>若出现下图结果，表示Jekyll安装成功。若安装失败，重新启动系统，然后<strong>jekyll -v</strong>再次运行。如果错误仍然存在，请打开<a href="https://github.com/oneclick/rubyinstaller2/issues/new">RubyInstaller问题</a>。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205115903.png" alt="Jekyll安装完成" style="zoom:200%;" /></p><hr><h3 id="1-3-使用Jekyll创建网站"><a href="#1-3-使用Jekyll创建网站" class="headerlink" title="1.3 使用Jekyll创建网站"></a>1.3 使用Jekyll创建网站</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">jekyll new blog<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-12-25.png" alt="jekyll new blog"></p><p>完成后在C:\Users\你的用户名下会有个blog的文件夹，内容如下</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210206092035.png" alt="网站创建成功"></p><p><a id='target'>关键</a>:接着安装一些依赖</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">gem <span class="hljs-keyword">install</span> sdbm<br>gem <span class="hljs-keyword">install</span> webrick<br>gem <span class="hljs-keyword">install</span> net-telnet<br>gem <span class="hljs-keyword">install</span> xmlrpc<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-31-34.png" alt="安装依赖"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210206093914.png" alt="安装依赖"></p><p>然后进入blog目录，<strong>shift+鼠标右键</strong>呼出上下文菜单，打开<strong>Powershell窗口</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210206094145.png" alt="上下文菜单"></p><p>在Powershell中输入</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">bundle add webrick<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-36-13.png" alt="bundle add webrick"></p><p>最后运行Jekyll服务</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">jekyll server<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-36-43.png" alt="Jekyll服务"></p><p>打开本地浏览器，输入网址</p><figure class="highlight http"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs http">http://localhost:4000<br></code></pre></div></td></tr></table></figure><p>成功运行<img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-37-34.png" alt=""></p><h3 id="1-4-发布博客"><a href="#1-4-发布博客" class="headerlink" title="1.4 发布博客"></a>1.4 发布博客</h3><p>发布博客很简单，只需要根据Jekyll指定的格式发布即可</p><p>在blog目录下有个_posts文件夹，这个文件夹专门存放markdown文件。里面自带了一个标准的markdown</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304155824.png" alt="默认文件"></p><p>里面内容如下：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">---<br>layout: post    <br>title:  &quot;Welcome to Jekyll!&quot;<br>date:   2021-02-06 09:10:43 +0800<br>categories: jekyll update<br><br>---<br><br>您可以在“ <span class="hljs-emphasis">_posts”目录中找到此信息。继续进行编辑，然后重新构建站点以查看您的更改。您可以用许多不同的方法重建站点，但是最常见的方法是运行“ jekyll serve”，它会启动Web服务器并在文件更新时自动重新生成站点。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">Jekyll要求按照以下格式命名博客文章文件：</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">`YEAR-MONTH-DAY-title.MARKUP`</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">其中“YEAR”是四位数，“MONTH”和“DAY”都是两位数，“ MARKUP”是表示文件中使用的格式的文件扩展名。在那之后，包括必要的前题。查看这篇文章的来源，以了解其工作原理。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">Jekyll还为代码段提供了强大的支持：</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">&#123;% highlight ruby %&#125;</span><br><span class="hljs-emphasis">def print_</span>hi(name)<br>  puts &quot;Hi, #&#123;name&#125;&quot;<br>end<br>print<span class="hljs-emphasis">_hi(&#x27;Tom&#x27;)</span><br><span class="hljs-emphasis">#=&gt; prints &#x27;Hi, Tom&#x27; to STDOUT.</span><br><span class="hljs-emphasis">&#123;% endhighlight %&#125;</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">查看[Jekyll docs] [jekyll-docs]，以获取有关如何充分利用Jekyll的更多信息。在[Jekyll的GitHub存储库] [jekyll-gh]中提交所有错误/功能请求。如有疑问，可以在[Jekyll Talk] [jekyll-talk]上提问。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">[jekyll-docs]: https://jekyllrb.com/docs/home</span><br><span class="hljs-emphasis">[jekyll-gh]:   https://github.com/jekyll/jekyll</span><br><span class="hljs-emphasis">[jekyll-talk]: https://talk.jekyllrb.com/</span><br></code></pre></div></td></tr></table></figure><p>总结一下，就是发布博客最简单的方法就是在_posts目录下，按照它给定的格式创建一个markdown文件，然后在markdown文件的头部，添加一个<strong>front matter</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304160530.png" alt="创建markdown文件"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304160709.png" alt="编写markdown"></p><p>重新运行jekyll服务，然后进入主页</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304160815.png" alt="主页显示"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304161001.png" alt="进入博客"></p><h2 id="2-创建github-page"><a href="#2-创建github-page" class="headerlink" title="2. 创建github page"></a>2. 创建github page</h2><h3 id="2-1-创建仓库"><a href="#2-1-创建仓库" class="headerlink" title="2.1 创建仓库"></a>2.1 创建仓库</h3><p>首先需要一个Github账号，相信大家都有了吧</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210212191956.png" alt="创建仓库1"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210212193329.png" alt="创建仓库2"></p><p>仓库创建成功效果如下图</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210212193101.png" alt="创建成功"></p><h3 id="2-2-设置github-page"><a href="#2-2-设置github-page" class="headerlink" title="2.2 设置github page"></a>2.2 设置github page</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210212193442.png" alt="点击setting"></p><p>下拉找到github page，并点击<strong>Choose a theme</strong>选择一个主题</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210212193555.png" alt="github page选项"></p><h2 id="错误记录"><a href="#错误记录" class="headerlink" title="错误记录"></a>错误记录</h2><h3 id="1-jekyll-创建网站时卡住"><a href="#1-jekyll-创建网站时卡住" class="headerlink" title="1. jekyll 创建网站时卡住"></a>1. jekyll 创建网站时卡住</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205154036.png" alt="jekyll 创建网站时卡住"></p><p>先卸载掉Jekyll</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">gem unistall jekyll <br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-00-22.png" alt="卸载Jekyll"></p><p>然后打开之前下载的rubyinstaller-devkit-xxx.exe可执行文件，按照之前的步骤安装，最重要的是到了这一步</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-04-58.png" alt="RubyInstaller2"></p><p>直接ENTER键安装全部，不需要选择1~3之间的任意选项。然后剩下的步骤照常即可。</p><h3 id="2-servlet-rb-3-in-require’-cannot-load-such-file-—-webrick-LoadError"><a href="#2-servlet-rb-3-in-require’-cannot-load-such-file-—-webrick-LoadError" class="headerlink" title="2. servlet.rb:3:in `require’: cannot load such file — webrick (LoadError)"></a>2. servlet.rb:3:in `require’: cannot load such file — webrick (LoadError)</h3><p>启动Jekyll服务时出错</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-29-39.png" alt="报错"></p><p>原因是启动服务前没有安装相应的依赖，并加入到bundle里面。<a href='#target'>解决方法</a>及<a href="https://github.com/jekyll/jekyll/issues/8523">参考</a></p><h2 id="随记"><a href="#随记" class="headerlink" title="随记"></a>随记</h2><h3 id="1-Jeklly"><a href="#1-Jeklly" class="headerlink" title="1. Jeklly"></a>1. Jeklly</h3><h4 id="1-1-config-yml文件"><a href="#1-1-config-yml文件" class="headerlink" title="1.1  _config.yml文件"></a>1.1  _config.yml文件</h4><p><strong>原始网页：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304115655.png" alt="原始网页"></p><p><strong>原始文件：</strong></p><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-comment"># 欢迎来到 Jekyll!</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 此配置文件用于影响整个博客的设置和值</span><br><span class="hljs-comment"># 应该设置一次，以后很少编辑。如果你发现自己经常编辑此文件，请考虑使用Jekyll的数据文件功能用于您需要经常更新的数据。</span><br><span class="hljs-comment">#由于技术原因，当您使用&#x27;bundle exec jekyll serve&#x27;，不会自动重新加载该文件</span><br><span class="hljs-comment"># 如果更改此文件，请重新启动服务器进程。</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 如果您需要有关YAML语法的帮助，以下是一些快速参考: </span><br><span class="hljs-comment"># https://learn-the-web.algonquindesign.ca/topics/markdown-yaml-cheat-sheet/#yaml</span><br><span class="hljs-comment"># https://learnxinyminutes.com/docs/yaml/</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 网站设置</span><br><span class="hljs-comment"># 这些用于个性化您的新站点。如果您查看HTML文件，您将看到它们通过&#123;&#123;site.title&#125;&#125;，&#123;&#123;site.email&#125;&#125;等访问。</span><br><span class="hljs-comment"># 在模板中通过&#123;&#123;site.myvariable&#125;&#125;可以创建任何想要的自定义变量，并且可以访问它们</span><br><br><span class="hljs-attr">title:</span> <span class="hljs-string">Your</span> <span class="hljs-string">awesome</span> <span class="hljs-string">title</span> <span class="hljs-comment"># 此处修改网页标题</span><br><span class="hljs-attr">email:</span> <span class="hljs-string">your-email@example.com</span> <span class="hljs-comment"># 此处修改个人邮箱</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">&gt;-</span> <span class="hljs-comment"># 此处添加网页描述。这意味着忽略换行符，直到“baseurl：”为止</span><br>  <span class="hljs-string">Write</span> <span class="hljs-string">an</span> <span class="hljs-string">awesome</span> <span class="hljs-string">description</span> <span class="hljs-string">for</span> <span class="hljs-string">your</span> <span class="hljs-string">new</span> <span class="hljs-string">site</span> <span class="hljs-string">here.</span> <span class="hljs-string">You</span> <span class="hljs-string">can</span> <span class="hljs-string">edit</span> <span class="hljs-string">this</span><br>  <span class="hljs-string">line</span> <span class="hljs-string">in</span> <span class="hljs-string">_config.yml.</span> <span class="hljs-string">It</span> <span class="hljs-string">will</span> <span class="hljs-string">appear</span> <span class="hljs-string">in</span> <span class="hljs-string">your</span> <span class="hljs-string">document</span> <span class="hljs-string">head</span> <span class="hljs-string">meta</span> <span class="hljs-string">(for</span><br>  <span class="hljs-string">Google</span> <span class="hljs-string">search</span> <span class="hljs-string">results)</span> <span class="hljs-string">and</span> <span class="hljs-string">in</span> <span class="hljs-string">your</span> <span class="hljs-string">feed.xml</span> <span class="hljs-string">site</span> <span class="hljs-string">description.</span><br><span class="hljs-attr">baseurl:</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># 您网站的子路径，例如/blog</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># 您网站的基本主机名和协议，例如http://example.com</span><br><span class="hljs-attr">twitter_username:</span> <span class="hljs-string">jekyllrb</span><br><span class="hljs-attr">github_username:</span>  <span class="hljs-string">jekyll</span><br><br><span class="hljs-comment"># 构建设置</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">minima</span> <span class="hljs-comment"># 主题</span><br><span class="hljs-attr">plugins:</span> <span class="hljs-comment"># 插件</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">jekyll-feed</span><br><br><span class="hljs-comment"># 从进程中排除</span><br><span class="hljs-comment"># 默认情况下不会处理以下项目</span><br><span class="hljs-comment"># 此处“exclude：”下列出的任何项目都会自动添加到内部的“默认列表”。</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 排除的项目可以通过显式列出目录或在“ include：”列表中输入其条目的文件路径。</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># exclude:</span><br><span class="hljs-comment">#   - .sass-cache/</span><br><span class="hljs-comment">#   - .jekyll-cache/</span><br><span class="hljs-comment">#   - gemfiles/</span><br><span class="hljs-comment">#   - Gemfile</span><br><span class="hljs-comment">#   - Gemfile.lock</span><br><span class="hljs-comment">#   - node_modules/</span><br><span class="hljs-comment">#   - vendor/bundle/</span><br><span class="hljs-comment">#   - vendor/cache/</span><br><span class="hljs-comment">#   - vendor/gems/</span><br><span class="hljs-comment">#   - vendor/ruby/</span><br><br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://sspai.com/post/54608">GitHub Pages 搭建教程</a></li><li><a href="https://segmentfault.com/a/1190000011337349">Windows环境下Jekyll+Github搭建个人博客</a></li><li><a href="https://www.bilibili.com/video/BV1rC4y1878Y/?spm_id_from=333.788.recommend_more_video.0">十分钟搭建个人博客：Jekyll+GitHub Pages</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github page</tag>
      
      <tag>jekyll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xxx atribute should be defined</title>
    <link href="/2020/12/29/Android/%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/xxx_atribute_should_be_defined/"/>
    <url>/2020/12/29/Android/%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/xxx_atribute_should_be_defined/</url>
    
    <content type="html"><![CDATA[<h2 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h2><h3 id="1-’xxx’-atribute-should-be-defined"><a href="#1-’xxx’-atribute-should-be-defined" class="headerlink" title="1.’xxx’ atribute should be defined"></a>1.’xxx’ atribute should be defined</h3><p>在一开始自定义shape和selector的时候，会有 <strong>‘xxx’ attribute should be defined</strong>的问题。主要原因是xml文件存放的文件夹有错，应该放在drawable文件夹下。<br><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201228171559.png" alt=""><br><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201228171732.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>错误记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Startup</title>
    <link href="/2020/12/27/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Startup/"/>
    <url>/2020/12/27/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Startup/</url>
    
    <content type="html"><![CDATA[<ul><li>StartupCode的重要功能：让静态对象的构造函数正确的被调用</li><li>main()是由启动码函数调用</li></ul><h2 id="mainCRTStartup"><a href="#mainCRTStartup" class="headerlink" title="mainCRTStartup()"></a>mainCRTStartup()</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/54dc87706cafbf193f1a014a2af24970-5ee36.png" alt="C++程序的运行调用栈" style="zoom:100%;" /></p><ol><li><code>_heap_init()</code>：初始化堆内存</li><li><code>_ioinit()</code>：IO初始化<ul><li>任何一个C++程序第一次分配内存的大小都是256</li></ul></li><li><code>GetCommandLineA()</code>：命令行参数初始化。</li><li><code>_crtGetEnvironmentStringsA()</code>：环境变量初始化。从操作系统获取环境变量，并申请空间来存放这些环境变量。</li><li><code>_setargv()</code>：设置命令行参数。<img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/05dad4c0dbed55a7e04b9da98315d795-c474a.png" alt="设置命令行参数。"></li><li><code>_setenvp()</code>：分配<code>_crtGetEnvironmentStringsA()</code>刚才保存的环境变量，将它们存放在一个表中。其中，<code>_environ</code>指向这个表。<ul><li><code>_setenvp()</code>一共执行了n次内存分配操作，n等于一次表的内存分配+k个环境变量的内存分配，其中表的内存分配大小等于k个环境变量的指针大小再加上一个末尾的0。即$sizeof(表)=(k+1)*4$。（效果同<code>_setargv()</code>）<img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b37fc061c3c963ffd880c6e723d93471-dba61.png" style="zoom: 100%;" /></li><li>归还之前<code>_crtGetEnvironmentStringsA()</code>临时保存环境变量的内存。</li></ul></li></ol><p>3，4，5，6都在处理字符串</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/3d90aa9de9a2d03fe3386692e2c88316-1894d.png" alt=""></p><h2 id="WindowsXP-sp2-Heap"><a href="#WindowsXP-sp2-Heap" class="headerlink" title="WindowsXP-sp2 Heap"></a>WindowsXP-sp2 Heap</h2><ul><li>win上采用<strong>前区块</strong>来取代<strong>下cookie</strong></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6c367818cbe928e82625201a7ab44cb7-c6411.png" style="zoom:100%;" /></p><ul><li>debug信息是附加在内存块的尾部</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/98f2c9918d2fee82b83d8ae8b50ac89f-ff0a8.png" style="zoom: 100%;" /></p><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><ul><li>I/O泛指程序与外界的各种交互作用，包括file，pipe，network，console，semaphore等等，或泛指能被OS理解为file的任何事务，file在此是一个广义概念。</li><li>C通过一个pointer to FILE来进行file操作。在OS层面，Linux对应FILE的是File Descriptor（fd）,Windows对应的则是file handle，二者都用来映射kernel file object。</li><li>fd具体是个index of opened file table，一个进程拥有的的这个table是个array of pointers，每个pointer指向一个kernel opened object。当client开启一个file，OS会建立一个（kernel）opened file object并找到上述table中的一个idle entry指向之，然后以该entry的index作为fd。此table位于kernel mode，因此client即使拥有fd<strong>亦无法</strong>获得table address。Linux的fd中，0，1，2分别代表stdin、stdout、stderr。</li><li>C的File与Linux的fd必有一对一的关系。只要有table address p（kernel mode中才可得），p+fd就只想opened file table的某个entry，从而可得kernel file object。</li><li>Windows的file handle和Linux的fd大同小异，但handle不是index，而是index经某种变换后的结果。</li><li>ioinit就是要在client space中建立起stdin，stdout，stderr及其对应的FILEs，使程序进入main()之后立即可用printf()，scanf()等函数。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a72dd579fe9d4a3b0e7a7ec0afb459a8-ff92f.png" style="zoom: 100%;" /></p><ul><li>ioinfo对应了我们写的程序中的FILE（一对一）</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9d38b8e139329e440bd76a40bd36105d-db095.png" style="zoom:100%;" /></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/d9dd37a8490234a9b7eb62a00de58928-c1840.png" style="zoom:100%;" /></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
      <tag>CRT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL：allocator</title>
    <link href="/2020/12/24/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/STL%EF%BC%9Aallocator/"/>
    <url>/2020/12/24/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/STL%EF%BC%9Aallocator/</url>
    
    <content type="html"><![CDATA[<h2 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9f392e29eaa3de0bce406431de47678e-57e69.png" alt="运行模式"></p><ul><li>STL：allocator的客户是STL的容器，如果在容器以外用的话会很麻烦，因为要记录使用的内存大小，以便于销毁的时候需要将大小告诉<code>deallocator</code>，让<code>deallocator</code>找到<code>free_list</code>的对应节点。</li><li><code>free_list</code>管理了16个节点，这16个节点从下标0到下标15，依次管理着8bytes、16bytes、24bytes、32bytes…128bytes的内存区域（按照8bytes增长）。</li><li>通过分配器分配的内存大小，在分配器内部会被设置为某个数的倍数，也就是类似内存对齐。原因是只有对象的size大于等于指针的大小（比如四字节），才能在未分配的内存块里使用指针。<code>vector&lt;bool&gt;</code>可能是个不好的用法，因为浪费了很多内存。</li><li><code>allocator</code>内存分配链表中的不同节点，指向的一大块内存区域都被等分为<strong>20</strong>块相同的内存块。就比如负责32bytes的节点，指向一共有20块大小为32bytes的内存区域，这块内存区域的大小即为20*32bytes。</li><li>如果内存区域用光了，如果有备用空间的话，就拿备用空间的内存，没有的话就向malloc申请一块2*20*(所需空间大小)的内存区域。比如这时候假设需要96bytes的空间，且没有备用空间，那么分配器会向malloc申请2<em>20个96btyes大小的空间，然后用前面的20个来给96bytes用，剩下的20\</em>96bytes的空间将成为备用空间。此时再要申请128bytes的内存块，又因为内存分配链表中，管理128bytes的节点中没有内容，那么就会将备用空间拿来用，划分内存块的流程是20*96bytes/128bytes，即划分为10*128bytes。（这个只是简单流程，更具体的流程看PDF）</li><li><code>start_free</code>和<code>end_free</code>指向备用区域（内存池）的头尾两端。</li><li>每次向<code>malloc</code>申请内存时都会有个追加量。</li><li><code>allocate</code>和<code>deallocate</code>都会先判断元素大小是否合法，如果不合法将调用第一级别的<code>allocate</code>和<code>deallocate</code>。</li><li>如果传入<code>deallocate</code>的对象指针p并非当初从<code>allocate</code>所得，在size参数合法的情况下，p依然会被并入到<code>free_list</code>中去。如果p所指的大小不是8的倍数，甚至会带来灾难。</li><li><code>chunk_alloc</code>中对碎片的处理：将碎片插入到合适的#号free-list中，一般情况是将节点接入链表的中间区域，而不一定是链表的最末尾。</li><li><code>deallocate</code>完全没有调用<code>free</code>和<code>delete</code>，源于其设计上的先天缺陷。</li></ul><h3 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h3><h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/e58fed98c2c7536e2576006a55cd8f90-f4728.png"  /></p><h4 id="将C-allocator转移到C"><a href="#将C-allocator转移到C" class="headerlink" title="将C++ allocator转移到C"></a>将C++ allocator转移到C</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/e8a2e33a35b2a1c866eee7bf827676fe-e9261.png" alt="C++"  /></p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><h5 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">obj* *p1,*p2;<span class="hljs-comment">//等效于下面代码</span><br>obj **p1,*p2;<span class="hljs-comment">//等效于下面代码</span><br>obj** p1;obj* p2;<br></code></pre></div></td></tr></table></figure><h5 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">void</span><span class="hljs-params">(*set_malloc_handler(<span class="hljs-keyword">void</span> (*f)()))</span><span class="hljs-params">()</span></span><br></code></pre></div></td></tr></table></figure><p>等效于</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*new_handler)</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(new_handler p)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br></code></pre></div></td></tr></table></figure><p>也等效于</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*H)</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> H <span class="hljs-title">set_malloc_handler</span><span class="hljs-params">(H f)</span></span>;<br></code></pre></div></td></tr></table></figure><h2 id="allocator源码"><a href="#allocator源码" class="headerlink" title="allocator源码"></a>allocator源码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span>  <span class="hljs-comment">//for malloc(),realloc()</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;</span>  <span class="hljs-comment">//for size_t</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory.h&gt;</span>  <span class="hljs-comment">//for memcpy()</span></span><br><br><span class="hljs-comment">//#define __THROW_BAD_ALLOC   cerr &lt;&lt; &quot;out of memory&quot; &lt;&lt; endl; exit(1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __THROW_BAD_ALLOC   exit(1)</span><br><br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">// 第1級配置器。</span><br><span class="hljs-comment">//----------------------------------------------</span><br><br><span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*oom_handler)() = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">oom_malloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*my_malloc_handler)();<br>  <span class="hljs-keyword">void</span>* result;<br><br>  <span class="hljs-keyword">for</span> (;;) &#123;    <span class="hljs-comment">//不斷嘗試釋放、配置、再釋放、再配置…</span><br>    my_malloc_handler = oom_handler;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;<br>    (*my_malloc_handler)();    <span class="hljs-comment">//呼叫處理常式，企圖釋放記憶體</span><br>    result = <span class="hljs-built_in">malloc</span>(n);        <span class="hljs-comment">//再次嘗試配置記憶體</span><br>    <span class="hljs-keyword">if</span> (result) <span class="hljs-keyword">return</span>(result);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">oom_realloc</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *p, <span class="hljs-keyword">size_t</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*my_malloc_handler)();<br>  <span class="hljs-keyword">void</span>* result;<br><br>  <span class="hljs-keyword">for</span> (;;) &#123;    <span class="hljs-comment">//不斷嘗試釋放、配置、再釋放、再配置…</span><br>    my_malloc_handler = oom_handler;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;<br>    (*my_malloc_handler)();    <span class="hljs-comment">//呼叫處理常式，企圖釋放記憶體。</span><br>    result = <span class="hljs-built_in">realloc</span>(p, n);    <span class="hljs-comment">//再次嘗試配置記憶體。</span><br>    <span class="hljs-keyword">if</span> (result) <span class="hljs-keyword">return</span>(result);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">malloc_allocate</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">void</span> *result = <span class="hljs-built_in">malloc</span>(n);   <span class="hljs-comment">//直接使用 malloc()</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == result) result = <span class="hljs-built_in">oom_malloc</span>(n);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">malloc_deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-keyword">size_t</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">free</span>(p);  <span class="hljs-comment">//直接使用 free()</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">malloc_reallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *p, <span class="hljs-keyword">size_t</span> old_sz, <span class="hljs-keyword">size_t</span> new_sz)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">void</span>* result = <span class="hljs-built_in">realloc</span>(p, new_sz); <span class="hljs-comment">//直接使用 realloc()</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == result) result = <span class="hljs-built_in">oom_realloc</span>(p, new_sz);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*<span class="hljs-built_in">set_malloc_handler</span>(<span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*f)()))()<br>&#123; <span class="hljs-comment">//類似 C++ 的 set_new_handler().</span><br>  <span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*old)() = oom_handler;<br>  oom_handler = f;<br>  <span class="hljs-keyword">return</span>(old);<br>&#125;<br><br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">//第二級配置器</span><br><span class="hljs-comment">//----------------------------------------------</span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span>__ALIGN = <span class="hljs-number">8</span>&#125;;                        <span class="hljs-comment">//小區塊的上調邊界</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span>__MAX_BYTES = <span class="hljs-number">128</span>&#125;;                  <span class="hljs-comment">//小區塊的上限</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span>__NFREELISTS = __MAX_BYTES/__ALIGN&#125;; <span class="hljs-comment">//free-lists 個數</span><br><br><span class="hljs-comment">// union obj &#123;                   //G291[o],CB5[x],VC6[x]</span><br><span class="hljs-comment">//   union obj* free_list_link;  //這麼寫在 VC6 和 CB5 中也可以，</span><br><span class="hljs-comment">// &#125;;                            //但以後就得使用 &quot;union obj&quot; 而不能只寫 &quot;obj&quot;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">obj</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">obj</span>* <span class="hljs-title">free_list_link</span>;</span><br>&#125; obj;<br><br><span class="hljs-keyword">char</span>*   start_free = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span>*   end_free = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">size_t</span>  heap_size = <span class="hljs-number">0</span>;<br>obj* free_list[__NFREELISTS]<br>     = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">ROUND_UP</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> bytes)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (((bytes) + __ALIGN<span class="hljs-number">-1</span>) &amp; ~(__ALIGN - <span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">FREELIST_INDEX</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> bytes)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (((bytes) + __ALIGN<span class="hljs-number">-1</span>)/__ALIGN - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">// We allocate memory in large chunks in order to</span><br><span class="hljs-comment">// avoid fragmentingthe malloc heap too much.</span><br><span class="hljs-comment">// We assume that size is properly aligned.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Allocates a chunk for nobjs of size &quot;size&quot;.</span><br><span class="hljs-comment">// nobjs may be reduced if it is inconvenient to</span><br><span class="hljs-comment">// allocate the requested number.</span><br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">//char* chunk_alloc(size_t size, int&amp; nobjs)  //G291[o],VC6[x],CB5[x]</span><br><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">chunk_alloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span>* nobjs)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span>* result;<br>  <span class="hljs-keyword">size_t</span> total_bytes = size * (*nobjs);   <span class="hljs-comment">//原 nobjs 改為 (*nobjs)</span><br>  <span class="hljs-keyword">size_t</span> bytes_left = end_free - start_free;<br><br>  <span class="hljs-keyword">if</span> (bytes_left &gt;= total_bytes) &#123;<br>      result = start_free;<br>      start_free += total_bytes;<br>      <span class="hljs-keyword">return</span>(result);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bytes_left &gt;= size) &#123;<br>      *nobjs = bytes_left / size;         <span class="hljs-comment">//原 nobjs 改為 (*nobjs)</span><br>      total_bytes = size * (*nobjs);      <span class="hljs-comment">//原 nobjs 改為 (*nobjs)</span><br>      result = start_free;<br>      start_free += total_bytes;<br>      <span class="hljs-keyword">return</span>(result);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">size_t</span> bytes_to_get =<br>                 <span class="hljs-number">2</span> * total_bytes + <span class="hljs-built_in">ROUND_UP</span>(heap_size &gt;&gt; <span class="hljs-number">4</span>);<br>      <span class="hljs-comment">// Try to make use of the left-over piece.</span><br>      <span class="hljs-keyword">if</span> (bytes_left &gt; <span class="hljs-number">0</span>) &#123;<br>          obj* <span class="hljs-keyword">volatile</span> *my_free_list =<br>                 free_list + <span class="hljs-built_in">FREELIST_INDEX</span>(bytes_left);<br><br>          ((obj*)start_free)-&gt;free_list_link = *my_free_list;<br>          *my_free_list = (obj*)start_free;<br>      &#125;<br>      start_free = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(bytes_to_get);<br>      <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == start_free) &#123;<br>          <span class="hljs-keyword">int</span> i;<br>          obj* <span class="hljs-keyword">volatile</span> *my_free_list, *p;<br><br>          <span class="hljs-comment">//Try to make do with what we have. That can&#x27;t</span><br>          <span class="hljs-comment">//hurt. We do not try smaller requests, since that tends</span><br>          <span class="hljs-comment">//to result in disaster on multi-process machines.</span><br>          <span class="hljs-keyword">for</span> (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;<br>              my_free_list = free_list + <span class="hljs-built_in">FREELIST_INDEX</span>(i);<br>              p = *my_free_list;<br>              <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != p) &#123;<br>                  *my_free_list = p -&gt; free_list_link;<br>                  start_free = (<span class="hljs-keyword">char</span>*)p;<br>                  end_free = start_free + i;<br>                  <span class="hljs-keyword">return</span>(<span class="hljs-built_in">chunk_alloc</span>(size, nobjs));<br>                  <span class="hljs-comment">//Any leftover piece will eventually make it to the</span><br>                  <span class="hljs-comment">//right free list.</span><br>              &#125;<br>          &#125;<br>          end_free = <span class="hljs-number">0</span>;       <span class="hljs-comment">//In case of exception.</span><br>          start_free = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc_allocate</span>(bytes_to_get);<br>          <span class="hljs-comment">//This should either throw an exception or</span><br>          <span class="hljs-comment">//remedy the situation. Thus we assume it</span><br>          <span class="hljs-comment">//succeeded.</span><br>      &#125;<br>      heap_size += bytes_to_get;<br>      end_free = start_free + bytes_to_get;<br>      <span class="hljs-keyword">return</span>(<span class="hljs-built_in">chunk_alloc</span>(size, nobjs));<br>  &#125;<br>&#125;<br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">// Returns an object of size n, and optionally adds</span><br><span class="hljs-comment">// to size n free list. We assume that n is properly aligned.</span><br><span class="hljs-comment">// We hold the allocation lock.</span><br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">refill</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> nobjs = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">char</span>* chunk = <span class="hljs-built_in">chunk_alloc</span>(n,&amp;nobjs);<br>    obj* <span class="hljs-keyword">volatile</span> *my_free_list;   <span class="hljs-comment">//obj** my_free_list;</span><br>    obj* result;<br>    obj* current_obj;<br>    obj* next_obj;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == nobjs) <span class="hljs-keyword">return</span>(chunk);<br>    my_free_list = free_list + <span class="hljs-built_in">FREELIST_INDEX</span>(n);<br><br>    <span class="hljs-comment">//Build free list in chunk</span><br>    result = (obj*)chunk;<br>    *my_free_list = next_obj = (obj*)(chunk + n);<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;  ; ++i) &#123;<br>      current_obj = next_obj;<br>      next_obj = (obj*)((<span class="hljs-keyword">char</span>*)next_obj + n);<br>      <span class="hljs-keyword">if</span> (nobjs<span class="hljs-number">-1</span> == i) &#123;<br>          current_obj-&gt;free_list_link = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">break</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          current_obj-&gt;free_list_link = next_obj;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>(result);<br>&#125;<br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> n)</span>  <span class="hljs-comment">//n must be &gt; 0</span></span><br><span class="hljs-function"></span>&#123;<br>  obj* <span class="hljs-keyword">volatile</span> *my_free_list;    <span class="hljs-comment">//obj** my_free_list;</span><br>  obj* result;<br><br>  <span class="hljs-keyword">if</span> (n &gt; (<span class="hljs-keyword">size_t</span>)__MAX_BYTES) &#123;<br>      <span class="hljs-keyword">return</span>(<span class="hljs-built_in">malloc_allocate</span>(n));<br>  &#125;<br><br>  my_free_list = free_list + <span class="hljs-built_in">FREELIST_INDEX</span>(n);<br>  result = *my_free_list;<br>  <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">void</span>* r = <span class="hljs-built_in">refill</span>(<span class="hljs-built_in">ROUND_UP</span>(n));<br>      <span class="hljs-keyword">return</span> r;<br>  &#125;<br><br>  *my_free_list = result-&gt;free_list_link;<br>  <span class="hljs-keyword">return</span> (result);<br>&#125;<br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *p, <span class="hljs-keyword">size_t</span> n)</span>  <span class="hljs-comment">//p may not be 0</span></span><br><span class="hljs-function"></span>&#123;<br>  obj* q = (obj*)p;<br>  obj* <span class="hljs-keyword">volatile</span> *my_free_list;   <span class="hljs-comment">//obj** my_free_list;</span><br><br>  <span class="hljs-keyword">if</span> (n &gt; (<span class="hljs-keyword">size_t</span>) __MAX_BYTES) &#123;<br>      <span class="hljs-built_in">malloc_deallocate</span>(p, n);<br>      <span class="hljs-keyword">return</span>;<br>  &#125;<br>  my_free_list = free_list + <span class="hljs-built_in">FREELIST_INDEX</span>(n);<br>  q-&gt;free_list_link = *my_free_list;<br>  *my_free_list = q;<br>&#125;<br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">reallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *p, <span class="hljs-keyword">size_t</span> old_sz, <span class="hljs-keyword">size_t</span> new_sz)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">void</span> * result;<br>  <span class="hljs-keyword">size_t</span> copy_sz;<br><br>  <span class="hljs-keyword">if</span> (old_sz &gt; (<span class="hljs-keyword">size_t</span>) __MAX_BYTES &amp;&amp; new_sz &gt; (<span class="hljs-keyword">size_t</span>) __MAX_BYTES) &#123;<br>      <span class="hljs-keyword">return</span>(<span class="hljs-built_in">realloc</span>(p, new_sz));<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ROUND_UP</span>(old_sz) == <span class="hljs-built_in">ROUND_UP</span>(new_sz)) <span class="hljs-keyword">return</span>(p);<br>  result = <span class="hljs-built_in">allocate</span>(new_sz);<br>  copy_sz = new_sz &gt; old_sz? old_sz : new_sz;<br>  <span class="hljs-built_in">memcpy</span>(result, p, copy_sz);<br>  <span class="hljs-built_in">deallocate</span>(p, old_sz);<br>  <span class="hljs-keyword">return</span>(result);<br>&#125;<br><span class="hljs-comment">//----------------------------------------------</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>上拉加载和下拉刷新</title>
    <link href="/2020/12/21/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0/"/>
    <url>/2020/12/21/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="SmartRefreshLayout结合RecyclerView"><a href="#SmartRefreshLayout结合RecyclerView" class="headerlink" title="SmartRefreshLayout结合RecyclerView"></a>SmartRefreshLayout结合RecyclerView</h2><h3 id="1-创建错误布局（空数据布局）"><a href="#1-创建错误布局（空数据布局）" class="headerlink" title="1.创建错误布局（空数据布局）"></a>1.创建错误布局（空数据布局）</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201220162105.png" alt="空数据布局"></p><h4 id="EmptyView-java"><a href="#EmptyView-java" class="headerlink" title="EmptyView.java"></a>EmptyView.java</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><br><span class="hljs-comment">//import ...</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmptyView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinearLayout</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ImageView icon;<br>    <span class="hljs-keyword">private</span> TextView title;<br>    <span class="hljs-keyword">private</span> Button action;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EmptyView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(context, <span class="hljs-keyword">null</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EmptyView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(context, attrs, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EmptyView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs, <span class="hljs-keyword">int</span> defStyleAttr)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(context, attrs, defStyleAttr, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EmptyView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs, <span class="hljs-keyword">int</span> defStyleAttr, <span class="hljs-keyword">int</span> style)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context, attrs, defStyleAttr, style);<br>        setOrientation(VERTICAL);<br>        setGravity(Gravity.CENTER);<br>        <span class="hljs-comment">//加载布局文件</span><br>        LayoutInflater.from(context).inflate(R.layout.layout_empty_view, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">true</span>);<br><br>        icon = findViewById(R.id.empty_icon);<br>        title = findViewById(R.id.empty_text);<br>        action = findViewById(R.id.empty_action);<br>    &#125;<br><br>    <span class="hljs-comment">//设置图片</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEmptyIcon</span><span class="hljs-params">(<span class="hljs-meta">@DrawableRes</span> <span class="hljs-keyword">int</span> iconRes)</span> </span>&#123;<br>        icon.setImageResource(iconRes);<br>    &#125;<br><br>    <span class="hljs-comment">//设置标题</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTitle</span><span class="hljs-params">(String text)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (TextUtils.isEmpty(text)) &#123;<br>            <span class="hljs-comment">//如果文本为空，设置text隐藏</span><br>            title.setVisibility(GONE);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            title.setText(text);<br>            title.setVisibility(VISIBLE);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">//设置按钮</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setButton</span><span class="hljs-params">(String text, View.OnClickListener listener)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (TextUtils.isEmpty(text)) &#123;<br>            action.setVisibility(GONE);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            action.setText(text);<br>            action.setVisibility(VISIBLE);<br>            action.setOnClickListener(listener);<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="layout-empty-view-xml"><a href="#layout-empty-view-xml" class="headerlink" title="layout_empty_view.xml"></a>layout_empty_view.xml</h4><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><br>    <span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;center&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center_horizontal&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/empty_icon&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@drawable/icon_empty_no_data&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/empty_text&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;16dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;虽然什么也没有,要不下拉刷新试试&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#999999&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;16sp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:visibility</span>=<span class="hljs-string">&quot;visible&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:text</span>=<span class="hljs-string">&quot;虽然什么也没有,要不下拉刷新看看&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TextView</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.button.MaterialButton</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/empty_action&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;16dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:paddingLeft</span>=<span class="hljs-string">&quot;16dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:paddingRight</span>=<span class="hljs-string">&quot;16dp&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#ffffff&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;14sp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:visibility</span>=<span class="hljs-string">&quot;gone&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:backgroundTint</span>=<span class="hljs-string">&quot;#ff678f&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:cornerRadius</span>=<span class="hljs-string">&quot;20dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:text</span>=<span class="hljs-string">&quot;朕知道了&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">com.google.android.material.button.MaterialButton</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br><br><br></code></pre></div></td></tr></table></figure><h3 id="2-编写总布局"><a href="#2-编写总布局" class="headerlink" title="2.编写总布局"></a>2.编写总布局</h3><h4 id="layout-refresh-view-xml"><a href="#layout-refresh-view-xml" class="headerlink" title="layout_refresh_view.xml"></a>layout_refresh_view.xml</h4><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">FrameLayout</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span><br><br>        <br>        <span class="hljs-tag">&lt;<span class="hljs-name">com.scwang.smartrefresh.layout.SmartRefreshLayout</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/refresh_layout&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><br><br>            <span class="hljs-comment">&lt;!-- 头 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">com.scwang.smartrefresh.layout.header.ClassicsHeader</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com.scwang.smartrefresh.layout.header.ClassicsHeader</span>&gt;</span><br><br>            <span class="hljs-comment">&lt;!-- 内容展示 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">androidx.recyclerview.widget.RecyclerView</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/recycler_view&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.recyclerview.widget.RecyclerView</span>&gt;</span><br><br>            <span class="hljs-comment">&lt;!-- 尾 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">com.scwang.smartrefresh.layout.footer.ClassicsFooter</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com.scwang.smartrefresh.layout.footer.ClassicsFooter</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">com.scwang.smartrefresh.layout.SmartRefreshLayout</span>&gt;</span><br><br><br><span class="hljs-comment">&lt;!--       错误布局 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">com.mooc.libcommon.view.EmptyView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/empty_view&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;100dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com.mooc.libcommon.view.EmptyView</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">FrameLayout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><p>注：需转化为dataBinding布局</p><h3 id="3-编写基础的ListFragment"><a href="#3-编写基础的ListFragment" class="headerlink" title="3.编写基础的ListFragment"></a>3.编写基础的ListFragment</h3><h4 id="AbsListFragment-class"><a href="#AbsListFragment-class" class="headerlink" title="AbsListFragment.class"></a>AbsListFragment.class</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><br><span class="hljs-comment">//import androidx.fragment.app.Fragment;</span><br><span class="hljs-comment">//import ...</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbsListFragment</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">M</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbsViewModel</span>&lt;<span class="hljs-title">T</span>&gt;&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Fragment</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OnRefreshListener</span>, <span class="hljs-title">OnLoadMoreListener</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> LayoutRefreshViewBinding binding;<br>    <span class="hljs-keyword">protected</span> RecyclerView mRecyclerView;<br>    <span class="hljs-keyword">protected</span> SmartRefreshLayout mRefreshLayout;<br>    <span class="hljs-keyword">protected</span> EmptyView mEmptyView;<br>    <span class="hljs-keyword">protected</span> PagedListAdapter&lt;T, RecyclerView.ViewHolder&gt; adapter;<br>    <span class="hljs-keyword">protected</span> M mViewModel;<br>    <span class="hljs-keyword">protected</span> DividerItemDecoration decoration;<br><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LayoutInflater inflater, <span class="hljs-meta">@Nullable</span> ViewGroup container, <span class="hljs-meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-comment">//获取databinding布局</span><br>        binding = LayoutRefreshViewBinding.inflate(inflater, container, <span class="hljs-keyword">false</span>);<br>        binding.getRoot().setFitsSystemWindows(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//获得view</span><br>        mRecyclerView = binding.recyclerView;<br>        mRefreshLayout = binding.refreshLayout;<br>        mEmptyView = binding.emptyView;<br><br>        <span class="hljs-comment">//打开上拉刷新</span><br>        mRefreshLayout.setEnableRefresh(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//打开下拉加载</span><br>        mRefreshLayout.setEnableLoadMore(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//设置上拉刷新监听事件</span><br>        mRefreshLayout.setOnRefreshListener(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-comment">//设置下拉加载监听事件</span><br>        mRefreshLayout.setOnLoadMoreListener(<span class="hljs-keyword">this</span>);<br><br>        <span class="hljs-comment">//设置适配器</span><br>        adapter = getAdapter();<br>        mRecyclerView.setAdapter(adapter);<br>        <span class="hljs-comment">//设置垂直线性布局</span><br>        mRecyclerView.setLayoutManager(<span class="hljs-keyword">new</span> LinearLayoutManager(getContext(), LinearLayoutManager.VERTICAL, <span class="hljs-keyword">false</span>));<br>        <span class="hljs-comment">//设置列表动画为空</span><br>        mRecyclerView.setItemAnimator(<span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//默认给列表中的Item 一个 10dp的ItemDecoration</span><br>        decoration = <span class="hljs-keyword">new</span> DividerItemDecoration(getContext(), LinearLayoutManager.VERTICAL);<br>        decoration.setDrawable(ContextCompat.getDrawable(getContext(), R.drawable.list_divider));<br>        mRecyclerView.addItemDecoration(decoration);<br><br>        genericViewModel();<br>        <span class="hljs-keyword">return</span> binding.getRoot();<br><br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">genericViewModel</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//利用 子类传递的 泛型参数实例化出absViewModel 对象。</span><br>        ParameterizedType type = (ParameterizedType) getClass().getGenericSuperclass();<br>        Type[] arguments = type.getActualTypeArguments();<br>        <span class="hljs-keyword">if</span> (arguments.length &gt; <span class="hljs-number">1</span>) &#123;<br>            Type argument = arguments[<span class="hljs-number">1</span>];<br>            Class modelClaz = ((Class) argument).asSubclass(AbsViewModel.class);<br>            mViewModel = (M) ViewModelProviders.of(<span class="hljs-keyword">this</span>).get(modelClaz);<br><br>            <span class="hljs-comment">//触发页面初始化数据加载的逻辑</span><br>            mViewModel.getPageData().observe(<span class="hljs-keyword">this</span>, pagedList -&gt; submitList(pagedList));<br><br>            <span class="hljs-comment">//监听分页时有无更多数据,以决定是否关闭上拉加载的动画</span><br>            mViewModel.getBoundaryPageData().observe(<span class="hljs-keyword">this</span>, hasData -&gt; finishRefresh(hasData));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//加载数据到界面</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">submitList</span><span class="hljs-params">(PagedList&lt;T&gt; result)</span> </span>&#123;<br>        <span class="hljs-comment">//只有当新数据集合大于0 的时候，才调用adapter.submitList</span><br>        <span class="hljs-comment">//否则可能会出现 页面----有数据-----&gt;被清空-----空布局</span><br>        <span class="hljs-keyword">if</span> (result.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            adapter.submitList(result);<br>        &#125;<br>        <span class="hljs-comment">//结束刷新</span><br>        finishRefresh(result.size() &gt; <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finishRefresh</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> hasData)</span> </span>&#123;<br><br>        <span class="hljs-comment">//获得adapter当前的数据集合</span><br>        PagedList&lt;T&gt; currentList = adapter.getCurrentList();<br>        <span class="hljs-comment">//判断是否有数据</span><br>        hasData = hasData || currentList != <span class="hljs-keyword">null</span> &amp;&amp; currentList.size() &gt; <span class="hljs-number">0</span>;<br>        RefreshState state = mRefreshLayout.getState();<br>        <br>        <span class="hljs-comment">//isOpening等同isLoading || isRefreshing</span><br>        <span class="hljs-keyword">if</span> (state.isFooter &amp;&amp; state.isOpening) &#123;<span class="hljs-comment">//当前于Footer一系列状态中</span><br>            <span class="hljs-comment">//上拉加载完成</span><br>            mRefreshLayout.finishLoadMore();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state.isHeader &amp;&amp; state.isOpening) &#123;<span class="hljs-comment">//当前于Header一系列状态中</span><br>            <span class="hljs-comment">//下拉刷新完成</span><br>            mRefreshLayout.finishRefresh();<br>        &#125;<br><br>        <span class="hljs-comment">//如果有数据，隐藏错误布局</span><br>        <span class="hljs-keyword">if</span> (hasData) &#123;<br>            mEmptyView.setVisibility(View.GONE);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mEmptyView.setVisibility(View.VISIBLE);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 因而 我们在 onCreateView的时候 创建了 PagedListAdapter</span><br><span class="hljs-comment">     * 所以，如果arguments 有参数需要传递到Adapter 中，那么需要在getAdapter()方法中取出参数。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>     <span class="hljs-comment">//设置虚方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> PagedListAdapter <span class="hljs-title">getAdapter</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><br></code></pre></div></td></tr></table></figure><h3 id="4-编写适配器"><a href="#4-编写适配器" class="headerlink" title="4.编写适配器"></a>4.编写适配器</h3><h4 id="AbsPagedListAdapter-class"><a href="#AbsPagedListAdapter-class" class="headerlink" title="AbsPagedListAdapter.class"></a>AbsPagedListAdapter.class</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><br><span class="hljs-comment">//import ...</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一个能够添加HeaderView,FooterView的PagedListAdapter。</span><br><span class="hljs-comment"> * 解决了添加HeaderView和FooterView时 RecyclerView定位不准确的问题</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt;  Java Bean</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;VH&gt;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbsPagedListAdapter</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">VH</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ViewHolder</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">PagedListAdapter</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">VH</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> SparseArray&lt;View&gt; mHeaders = <span class="hljs-keyword">new</span> SparseArray&lt;&gt;();<br>    <span class="hljs-keyword">private</span> SparseArray&lt;View&gt; mFooters = <span class="hljs-keyword">new</span> SparseArray&lt;&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> BASE_ITEM_TYPE_HEADER = <span class="hljs-number">100000</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> BASE_ITEM_TYPE_FOOTER = <span class="hljs-number">200000</span>;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">AbsPagedListAdapter</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> DiffUtil.ItemCallback&lt;T&gt; diffCallback)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(diffCallback);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addHeaderView</span><span class="hljs-params">(View view)</span> </span>&#123;<br>        <span class="hljs-comment">//判断给View对象是否还没有处在mHeaders数组里面</span><br>        <span class="hljs-keyword">if</span> (mHeaders.indexOfValue(view) &lt; <span class="hljs-number">0</span>) &#123;<br>            mHeaders.put(BASE_ITEM_TYPE_HEADER++, view);<br>            notifyDataSetChanged();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFooterView</span><span class="hljs-params">(View view)</span> </span>&#123;<br>        <span class="hljs-comment">//判断给View对象是否还没有处在mFooters数组里面</span><br>        <span class="hljs-keyword">if</span> (mFooters.indexOfValue(view) &lt; <span class="hljs-number">0</span>) &#123;<br>            mFooters.put(BASE_ITEM_TYPE_FOOTER++, view);<br>            notifyDataSetChanged();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 移除头部</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeHeaderView</span><span class="hljs-params">(View view)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> index = mHeaders.indexOfValue(view);<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        mHeaders.removeAt(index);<br>        notifyDataSetChanged();<br>    &#125;<br><br>    <span class="hljs-comment">// 移除底部</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeFooterView</span><span class="hljs-params">(View view)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> index = mFooters.indexOfValue(view);<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        mFooters.removeAt(index);<br>        notifyDataSetChanged();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHeaderCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mHeaders.size();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFooterCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mFooters.size();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> itemCount = <span class="hljs-keyword">super</span>.getItemCount();<br>        <span class="hljs-keyword">return</span> itemCount + mHeaders.size() + mFooters.size();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOriginalItemCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getItemCount() - mHeaders.size() - mFooters.size();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemViewType</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (isHeaderPosition(position)) &#123;<br>            <span class="hljs-comment">//返回该position对应的headerview的  viewType</span><br>            <span class="hljs-keyword">return</span> mHeaders.keyAt(position);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (isFooterPosition(position)) &#123;<br>            <span class="hljs-comment">//footer类型的，需要计算一下它的position实际大小</span><br>            position = position - getOriginalItemCount() - mHeaders.size();<br>            <span class="hljs-keyword">return</span> mFooters.keyAt(position);<br>        &#125;<br>        position = position - mHeaders.size();<br>        <span class="hljs-keyword">return</span> getItemViewType2(position);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemViewType2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFooterPosition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> position &gt;= getOriginalItemCount() + mHeaders.size();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeaderPosition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> position &lt; mHeaders.size();<br>    &#125;<br><br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> VH <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ViewGroup parent, <span class="hljs-keyword">int</span> viewType)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (mHeaders.indexOfKey(viewType) &gt;= <span class="hljs-number">0</span>) &#123;<br>            View view = mHeaders.get(viewType);<br>            <span class="hljs-keyword">return</span> (VH) <span class="hljs-keyword">new</span> RecyclerView.ViewHolder(view) &#123;<br>            &#125;;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (mFooters.indexOfKey(viewType) &gt;= <span class="hljs-number">0</span>) &#123;<br>            View view = mFooters.get(viewType);<br>            <span class="hljs-keyword">return</span> (VH) <span class="hljs-keyword">new</span> RecyclerView.ViewHolder(view) &#123;<br>            &#125;;<br>        &#125;<br><br><br>        <span class="hljs-keyword">return</span> onCreateViewHolder2(parent, viewType);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> VH <span class="hljs-title">onCreateViewHolder2</span><span class="hljs-params">(ViewGroup parent, <span class="hljs-keyword">int</span> viewType)</span></span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> VH holder, <span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (isHeaderPosition(position) || isFooterPosition(position))<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//列表中正常类型的itemView的 position 咱们需要减去添加headerView的个数</span><br>        position = position - mHeaders.size();<br>        onBindViewHolder2(holder, position);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder2</span><span class="hljs-params">(VH holder, <span class="hljs-keyword">int</span> position)</span></span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewAttachedToWindow</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> RecyclerView.ViewHolder holder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!isHeaderPosition(holder.getAdapterPosition()) &amp;&amp; !isFooterPosition(holder.getAdapterPosition())) &#123;<br>            <span class="hljs-keyword">this</span>.onViewAttachedToWindow2((VH) holder);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewAttachedToWindow2</span><span class="hljs-params">(VH holder)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewDetachedFromWindow</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> RecyclerView.ViewHolder holder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!isHeaderPosition(holder.getAdapterPosition()) &amp;&amp; !isFooterPosition(holder.getAdapterPosition())) &#123;<br>            <span class="hljs-keyword">this</span>.onViewDetachedFromWindow2((VH) holder);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewDetachedFromWindow2</span><span class="hljs-params">(VH holder)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerAdapterDataObserver</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> RecyclerView.AdapterDataObserver observer)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.registerAdapterDataObserver(<span class="hljs-keyword">new</span> AdapterDataObserverProxy(observer));<br>    &#125;<br><br>    <span class="hljs-comment">//如果我们先添加了headerView,而后网络数据回来了再更新到列表上</span><br>    <span class="hljs-comment">//由于Paging在计算列表上item的位置时 并不会顾及我们有没有添加headerView，就会出现列表定位的问题</span><br>    <span class="hljs-comment">//实际上 RecyclerView#setAdapter方法，它会给Adapter注册了一个AdapterDataObserver</span><br>    <span class="hljs-comment">//咱么可以代理registerAdapterDataObserver()传递进来的observer。在各个方法的实现中，把headerView的个数算上，再中转出去即可</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdapterDataObserverProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">AdapterDataObserver</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> RecyclerView.AdapterDataObserver mObserver;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AdapterDataObserverProxy</span><span class="hljs-params">(RecyclerView.AdapterDataObserver observer)</span> </span>&#123;<br>            mObserver = observer;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onChanged</span><span class="hljs-params">()</span> </span>&#123;<br>            mObserver.onChanged();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemRangeChanged</span><span class="hljs-params">(<span class="hljs-keyword">int</span> positionStart, <span class="hljs-keyword">int</span> itemCount)</span> </span>&#123;<br>            mObserver.onItemRangeChanged(positionStart + mHeaders.size(), itemCount);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemRangeChanged</span><span class="hljs-params">(<span class="hljs-keyword">int</span> positionStart, <span class="hljs-keyword">int</span> itemCount, <span class="hljs-meta">@Nullable</span> Object payload)</span> </span>&#123;<br>            mObserver.onItemRangeChanged(positionStart + mHeaders.size(), itemCount, payload);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemRangeInserted</span><span class="hljs-params">(<span class="hljs-keyword">int</span> positionStart, <span class="hljs-keyword">int</span> itemCount)</span> </span>&#123;<br>            mObserver.onItemRangeInserted(positionStart + mHeaders.size(), itemCount);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemRangeRemoved</span><span class="hljs-params">(<span class="hljs-keyword">int</span> positionStart, <span class="hljs-keyword">int</span> itemCount)</span> </span>&#123;<br>            mObserver.onItemRangeRemoved(positionStart + mHeaders.size(), itemCount);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemRangeMoved</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fromPosition, <span class="hljs-keyword">int</span> toPosition, <span class="hljs-keyword">int</span> itemCount)</span> </span>&#123;<br>            mObserver.onItemRangeMoved(fromPosition + mHeaders.size(), toPosition + mHeaders.size(), itemCount);<br>        &#125;<br><br><br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>每个继承于PagedListAdapter的RecyclerViewAdatpter，都必须在构造方法里面复写下图中的某个方法。<br><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201220172145.png" alt="PagedListAdapter"></p><ul><li>PagedListAdapter(@NonNull DiffUtil.ItemCallback<T> diffCallback)：这个是给新旧数据集做拆分页，做比对的时候，需要使用的一个回调</li><li>PagedListAdapter(@NonNull AsyncDifferConfig<T> config)：做拆分页时的一个配置。AsyncDifferConfig的设置如下表：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">private final Executor mMainThreadExecutor;</td><td style="text-align:left">主线程线程池</td></tr><tr><td style="text-align:left">private final Executor mBackgroundThreadExecutor;</td><td style="text-align:left">子线程线程池</td></tr><tr><td style="text-align:left">private final DiffUtil.ItemCallback<T> mDiffCallback;</td><td style="text-align:left">做拆分页的回调</td></tr></tbody></table></div><h4 id="FeedAdapter-class"><a href="#FeedAdapter-class" class="headerlink" title="FeedAdapter.class"></a>FeedAdapter.class</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//import ...</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeedAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbsPagedListAdapter</span>&lt;<span class="hljs-title">Feed</span>, <span class="hljs-title">FeedAdapter</span>.<span class="hljs-title">ViewHolder</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LayoutInflater inflater;<br>    <span class="hljs-keyword">protected</span> Context mContext;<br>    <span class="hljs-keyword">protected</span> String mCategory;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FeedAdapter</span><span class="hljs-params">(Context context, String category)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> DiffUtil.ItemCallback&lt;Feed&gt;() &#123;<br>            <span class="hljs-comment">//判断两个Item是否相等</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">areItemsTheSame</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Feed oldItem, <span class="hljs-meta">@NonNull</span> Feed newItem)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> oldItem.id == newItem.id;<br>            &#125;<br>            <span class="hljs-comment">//比较两个Item里面的内容是否相同</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">areContentsTheSame</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Feed oldItem, <span class="hljs-meta">@NonNull</span> Feed newItem)</span> </span>&#123;<br>                <span class="hljs-comment">//Feed中的equals方法被复写</span><br>                <span class="hljs-keyword">return</span> oldItem.equals(newItem);<br>            &#125;<br>        &#125;);<br><br>        inflater = LayoutInflater.from(context);<br>        mContext = context;<br>        mCategory = category;<br>    &#125;<br><br>    <span class="hljs-comment">//返回Feed是图片类型还是视频类型</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemViewType2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        Feed feed = getItem(position);<br>        <span class="hljs-keyword">if</span> (feed.itemType == Feed.TYPE_IMAGE_TEXT) &#123;<br>            <span class="hljs-keyword">return</span> R.layout.layout_feed_type_image;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (feed.itemType == Feed.TYPE_VIDEO) &#123;<br>            <span class="hljs-keyword">return</span> R.layout.layout_feed_type_video;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> ViewHolder <span class="hljs-title">onCreateViewHolder2</span><span class="hljs-params">(ViewGroup parent, <span class="hljs-keyword">int</span> viewType)</span> </span>&#123;<br>        ViewDataBinding binding = DataBindingUtil.inflate(inflater, viewType, parent, <span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ViewHolder(binding.getRoot(), binding);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder2</span><span class="hljs-params">(ViewHolder holder, <span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Feed feed = getItem(position);<br><br>        holder.bindData(feed);<br><br>        holder.itemView.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>                FeedDetailActivity.startFeedDetailActivity(mContext, feed, mCategory);<br>                onStartFeedDetailActivity(feed);<br>                <span class="hljs-keyword">if</span> (mFeedObserver == <span class="hljs-keyword">null</span>) &#123;<br>                    mFeedObserver = <span class="hljs-keyword">new</span> FeedObserver();<br>                    LiveDataBus.get()<br>                            .with(InteractionPresenter.DATA_FROM_INTERACTION)<br>                            .observe((LifecycleOwner) mContext, mFeedObserver);<br>                &#125;<br>                mFeedObserver.setFeed(feed);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartFeedDetailActivity</span><span class="hljs-params">(Feed feed)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> FeedObserver mFeedObserver;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeedObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span>&lt;<span class="hljs-title">Feed</span>&gt; </span>&#123;<br><br>        <span class="hljs-keyword">private</span> Feed mFeed;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onChanged</span><span class="hljs-params">(Feed newOne)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (mFeed.id != newOne.id)<br>                <span class="hljs-keyword">return</span>;<br>            mFeed.author = newOne.author;<br>            mFeed.ugc = newOne.ugc;<br>            mFeed.notifyChange();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFeed</span><span class="hljs-params">(Feed feed)</span> </span>&#123;<br><br>            mFeed = feed;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewHolder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ViewHolder</span> </span>&#123;<br><br>        <span class="hljs-keyword">public</span> ViewDataBinding mBinding;<br>        <span class="hljs-keyword">public</span> ListPlayerView listPlayerView;<br>        <span class="hljs-keyword">public</span> ImageView feedImage;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View itemView, ViewDataBinding binding)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(itemView);<br>            mBinding = binding;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bindData</span><span class="hljs-params">(Feed item)</span> </span>&#123;<br>            <span class="hljs-comment">//这里之所以手动绑定数据的原因是 图片 和视频区域都是需要计算的</span><br>            <span class="hljs-comment">//而dataBinding的执行默认是延迟一帧的。</span><br>            <span class="hljs-comment">//当列表上下滑动的时候 ，会明显的看到宽高尺寸不对称的问题</span><br><br>            mBinding.setVariable(com.mooc.ppjoke.BR.feed, item);<br>            mBinding.setVariable(BR.lifeCycleOwner, mContext);<br>            <span class="hljs-keyword">if</span> (mBinding <span class="hljs-keyword">instanceof</span> LayoutFeedTypeImageBinding) &#123;<span class="hljs-comment">//图片类型</span><br>                LayoutFeedTypeImageBinding imageBinding = (LayoutFeedTypeImageBinding) mBinding;<br>                feedImage = imageBinding.feedImage;<br>                imageBinding.feedImage.bindData(item.width, item.height, <span class="hljs-number">16</span>, item.cover);<br>                <span class="hljs-comment">//imageBinding.setFeed(item);</span><br>                <span class="hljs-comment">//imageBinding.interactionBinding.setLifeCycleOwner((LifecycleOwner) mContext);</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mBinding <span class="hljs-keyword">instanceof</span> LayoutFeedTypeVideoBinding) &#123;<span class="hljs-comment">//视频类型</span><br>                LayoutFeedTypeVideoBinding videoBinding = (LayoutFeedTypeVideoBinding) mBinding;<br>                videoBinding.listPlayerView.bindData(mCategory, item.width, item.height, item.cover, item.url);<br>                listPlayerView = videoBinding.listPlayerView;<br>                <span class="hljs-comment">//videoBinding.setFeed(item);</span><br>                <span class="hljs-comment">//videoBinding.interactionBinding.setLifeCycleOwner((LifecycleOwner) mContext);</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isVideoItem</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> mBinding <span class="hljs-keyword">instanceof</span> LayoutFeedTypeVideoBinding;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> ListPlayerView <span class="hljs-title">getListPlayerView</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> listPlayerView;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br></code></pre></div></td></tr></table></figure><h3 id="5-编写下拉刷新的通用配置"><a href="#5-编写下拉刷新的通用配置" class="headerlink" title="5.编写下拉刷新的通用配置"></a>5.编写下拉刷新的通用配置</h3><h4 id="AbsViewModel-class"><a href="#AbsViewModel-class" class="headerlink" title="AbsViewModel.class"></a>AbsViewModel.class</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//import ...</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbsViewModel</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewModel</span> </span>&#123;<br><br><br>    <span class="hljs-keyword">protected</span> PagedList.Config config;<br>    <span class="hljs-keyword">private</span> DataSource dataSource;<br>    <span class="hljs-keyword">private</span> LiveData&lt;PagedList&lt;T&gt;&gt; pageData;<br><br>    <span class="hljs-keyword">private</span> MutableLiveData&lt;Boolean&gt; boundaryPageData = <span class="hljs-keyword">new</span> MutableLiveData&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbsViewModel</span><span class="hljs-params">()</span> </span>&#123;<br><br>        config = <span class="hljs-keyword">new</span> PagedList.Config.Builder()<br>                .setPageSize(<span class="hljs-number">10</span>)<span class="hljs-comment">//每次分页加载的数量</span><br>                .setInitialLoadSizeHint(<span class="hljs-number">12</span>)<span class="hljs-comment">//初始化加载时的数量</span><br>                <span class="hljs-comment">// .setMaxSize(100)；</span><br>                <span class="hljs-comment">// .setEnablePlaceholders(false)//设置数据未满的占位符</span><br>                <span class="hljs-comment">// .setPrefetchDistance()//设置根据距离屏幕底部几个item时，加载下一页</span><br>                .build();<br><br>        pageData = <span class="hljs-keyword">new</span> LivePagedListBuilder(factory, config)<br>                .setInitialLoadKey(<span class="hljs-number">0</span>)<span class="hljs-comment">//加载初始化区域的时候，需要传递的参数。如果是多个参数，需要组装成javabean对象</span><br>                <span class="hljs-comment">//.setFetchExecutor()</span><br>                .setBoundaryCallback(callback)<span class="hljs-comment">//监听Pagedlist数据加载的状态</span><br>                .build();<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> LiveData&lt;PagedList&lt;T&gt;&gt; getPageData() &#123;<br>        <span class="hljs-keyword">return</span> pageData;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">getDataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LiveData&lt;Boolean&gt; <span class="hljs-title">getBoundaryPageData</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> boundaryPageData;<br>    &#125;<br><br>    <span class="hljs-comment">//PagedList数据被加载情况的边界回调callback</span><br>    <span class="hljs-comment">//但 不是每一次分页 都会回调这里，具体请看 ContiguousPagedList#mReceiver#onPageResult</span><br>    <span class="hljs-comment">//deferBoundaryCallbacks</span><br>    PagedList.BoundaryCallback&lt;T&gt; callback = <span class="hljs-keyword">new</span> PagedList.BoundaryCallback&lt;T&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onZeroItemsLoaded</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">//新提交的PagedList中没有数据</span><br>            boundaryPageData.postValue(<span class="hljs-keyword">false</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemAtFrontLoaded</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> T itemAtFront)</span> </span>&#123;<br>            <span class="hljs-comment">//新提交的PagedList中第一条数据被加载到列表上</span><br>            boundaryPageData.postValue(<span class="hljs-keyword">true</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemAtEndLoaded</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> T itemAtEnd)</span> </span>&#123;<br>            <span class="hljs-comment">//新提交的PagedList中最后一条数据被加载到列表上</span><br>        &#125;<br>    &#125;;<br><br>    DataSource.Factory factory = <span class="hljs-keyword">new</span> DataSource.Factory() &#123;<br>        <span class="hljs-meta">@NonNull</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">//如果dataSource为空或者无效</span><br>            <span class="hljs-keyword">if</span> (dataSource == <span class="hljs-keyword">null</span> || dataSource.isInvalid()) &#123;<br>                dataSource = createDataSource();<br>            &#125;<br>            <span class="hljs-keyword">return</span> dataSource;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">//该方法推迟到子类实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> DataSource <span class="hljs-title">createDataSource</span><span class="hljs-params">()</span></span>;<br><br><br>    <span class="hljs-comment">//可以在这个方法里 做一些清理 的工作</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCleared</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br><br><br></code></pre></div></td></tr></table></figure><h4 id="AbsViewModel的实现类HomeViewModel-class"><a href="#AbsViewModel的实现类HomeViewModel-class" class="headerlink" title="AbsViewModel的实现类HomeViewModel.class"></a>AbsViewModel的实现类HomeViewModel.class</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//import ...</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeViewModel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbsViewModel</span>&lt;<span class="hljs-title">Feed</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> witchCache = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">private</span> MutableLiveData&lt;PagedList&lt;Feed&gt;&gt; cacheLiveData = <span class="hljs-keyword">new</span> MutableLiveData&lt;&gt;();<br>    <span class="hljs-keyword">private</span> AtomicBoolean loadAfter = <span class="hljs-keyword">new</span> AtomicBoolean(<span class="hljs-keyword">false</span>);<br>    <span class="hljs-keyword">private</span> String mFeedType;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">createDataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FeedDataSource();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> MutableLiveData&lt;PagedList&lt;Feed&gt;&gt; getCacheLiveData() &#123;<br>        <span class="hljs-keyword">return</span> cacheLiveData;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFeedType</span><span class="hljs-params">(String feedType)</span> </span>&#123;<br><br>        mFeedType = feedType;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeedDataSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ItemKeyedDataSource</span>&lt;<span class="hljs-title">Integer</span>, <span class="hljs-title">Feed</span>&gt; </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadInitial</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LoadInitialParams&lt;Integer&gt; params, <span class="hljs-meta">@NonNull</span> LoadInitialCallback&lt;Feed&gt; callback)</span> </span>&#123;<br>            <span class="hljs-comment">//加载初始化数据的</span><br>            Log.e(<span class="hljs-string">&quot;homeviewmodel&quot;</span>, <span class="hljs-string">&quot;loadInitial: &quot;</span>);<br>            <span class="hljs-comment">//先加载缓存</span><br>            loadData(<span class="hljs-number">0</span>, params.requestedLoadSize, callback);<br>            witchCache = <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadAfter</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LoadParams&lt;Integer&gt; params, <span class="hljs-meta">@NonNull</span> LoadCallback&lt;Feed&gt; callback)</span> </span>&#123;<br>            <span class="hljs-comment">//向后加载分页数据的</span><br>            Log.e(<span class="hljs-string">&quot;homeviewmodel&quot;</span>, <span class="hljs-string">&quot;loadAfter: &quot;</span>);<br>            loadData(params.key, params.requestedLoadSize, callback);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBefore</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LoadParams&lt;Integer&gt; params, <span class="hljs-meta">@NonNull</span> LoadCallback&lt;Feed&gt; callback)</span> </span>&#123;<br>            callback.onResult(Collections.emptyList());<br>            <span class="hljs-comment">//能够向前加载数据的</span><br>            <span class="hljs-comment">//比如进入首页时在第三页，但是想往前加载第一第二页</span><br>        &#125;<br><br><br>        <span class="hljs-comment">//通过最后一条Item的信息，来返回id</span><br>        <span class="hljs-meta">@NonNull</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getKey</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Feed item)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> item.id;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> count, ItemKeyedDataSource.LoadCallback&lt;Feed&gt; callback)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (key &gt; <span class="hljs-number">0</span>) &#123;<br>            loadAfter.set(<span class="hljs-keyword">true</span>);<br>        &#125;<br>        <span class="hljs-comment">//feeds/queryHotFeedsList</span><br>        Request request = ApiService.get(<span class="hljs-string">&quot;/feeds/queryHotFeedsList&quot;</span>)<br>                .addParam(<span class="hljs-string">&quot;feedType&quot;</span>, mFeedType)<br>                .addParam(<span class="hljs-string">&quot;userId&quot;</span>, UserManager.get().getUserId())<br>                .addParam(<span class="hljs-string">&quot;feedId&quot;</span>, key)<br>                .addParam(<span class="hljs-string">&quot;pageCount&quot;</span>, count)<br>                .responseType(<span class="hljs-keyword">new</span> TypeReference&lt;ArrayList&lt;Feed&gt;&gt;() &#123;<br>                &#125;.getType());<br><br>        <span class="hljs-keyword">if</span> (witchCache) &#123;<br>            request.cacheStrategy(Request.CACHE_ONLY);<br>            request.execute(<span class="hljs-keyword">new</span> JsonCallback&lt;List&lt;Feed&gt;&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCacheSuccess</span><span class="hljs-params">(ApiResponse&lt;List&lt;Feed&gt;&gt; response)</span> </span>&#123;<br>                    Log.e(<span class="hljs-string">&quot;loadData&quot;</span>, <span class="hljs-string">&quot;onCacheSuccess: &quot;</span>);<br>                    MutablePageKeyedDataSource dataSource = <span class="hljs-keyword">new</span> MutablePageKeyedDataSource&lt;Feed&gt;();<br>                    dataSource.data.addAll(response.body);<br><br>                    PagedList pagedList = dataSource.buildNewPagedList(config);<br>                    cacheLiveData.postValue(pagedList);<br><br>                    <span class="hljs-comment">//下面的不可取，否则会报</span><br>                    <span class="hljs-comment">// java.lang.IllegalStateException: callback.onResult already called, cannot call again.</span><br>                    <span class="hljs-comment">//if (response.body != null) &#123;</span><br>                    <span class="hljs-comment">//  callback.onResult(response.body);</span><br>                    <span class="hljs-comment">// &#125;</span><br>                &#125;<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Request netRequest = witchCache ? request.clone() : request;<br>            netRequest.cacheStrategy(key == <span class="hljs-number">0</span> ? Request.NET_CACHE : Request.NET_ONLY);<br>            ApiResponse&lt;List&lt;Feed&gt;&gt; response = netRequest.execute();<br>            List&lt;Feed&gt; data = response.body == <span class="hljs-keyword">null</span> ? Collections.emptyList() : response.body;<br><br>            callback.onResult(data);<br><br>            <span class="hljs-keyword">if</span> (key &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">//通过BoundaryPageData发送数据 告诉UI层 是否应该主动关闭上拉加载分页的动画</span><br>                ((MutableLiveData) getBoundaryPageData()).postValue(data.size() &gt; <span class="hljs-number">0</span>);<br>                loadAfter.set(<span class="hljs-keyword">false</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        Log.e(<span class="hljs-string">&quot;loadData&quot;</span>, <span class="hljs-string">&quot;loadData: key:&quot;</span> + key);<br><br>    &#125;<br><br>    <span class="hljs-meta">@SuppressLint(&quot;RestrictedApi&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadAfter</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, ItemKeyedDataSource.LoadCallback&lt;Feed&gt; callback)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (loadAfter.get()) &#123;<br>            callback.onResult(Collections.emptyList());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ArchTaskExecutor.getIOThreadExecutor().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                loadData(id, config.pageSize, callback);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p><a href="https://blog.csdn.net/zsp_android_com/article/details/86235067">刷新加载（SmartRefreshLayout）</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RecyclerView</tag>
      
      <tag>SmartRefreshLayout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>点赞实现</title>
    <link href="/2020/12/19/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E7%82%B9%E8%B5%9E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/12/19/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E7%82%B9%E8%B5%9E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>利用dataBinding实现点赞颜色更改和点赞图片更改</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">variable</span></span><br><span class="hljs-tag">        <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;comment&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.mooc.ppjoke.model.Comment&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.mooc.ppjoke.ui.InteractionPresenter&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;android.text.TextUtils&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;android.view.View&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.mooc.ppjoke.utils.StringConvert&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center_vertical&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@&#123;comment.ugc.likeCount&gt;0?StringConvert.convertFeedUgc(comment.ugc.likeCount):null&#125;&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@&#123;comment.ugc.hasLiked?@color/color_theme:@color/color_3d3&#125;&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;@dimen/sp_12&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:text</span>=<span class="hljs-string">&quot;1000&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TextView</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_marginLeft</span>=<span class="hljs-string">&quot;@dimen/dp_2&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:onClick</span>=<span class="hljs-string">&quot;@&#123;()-&gt;InteractionPresenter.toggleCommentLike(lifeCycleOwner,comment)&#125;&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@&#123;comment.ugc.hasLiked?@drawable/icon_cell_liked:@drawable/icon_cell_like&#125;&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:src</span>=<span class="hljs-string">&quot;@drawable/icon_cell_liked&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">ImageView</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dataBinding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataSource</title>
    <link href="/2020/12/17/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/DataSource/"/>
    <url>/2020/12/17/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/DataSource/</url>
    
    <content type="html"><![CDATA[<ul><li><p>DataSource<Key,Value>数据源：</p><ol><li>Key对应加载数据的条件信息</li><li>Value对应数据实体类</li></ol></li><li><p>内置三种对象<br>  |对象|描述|场景<br>  |:——————————————-|:—————————————————|:—————————————————|<br>  |PageKeyedDataSource<Key,Value>|适用于目标数据根据页信息请求数据的场景|初始化的时候加载第一页信息，上拉加载第二页…根据页码来请求数据|<br>  |ItemKeyedDataSource<Key,Value>|适用于目标数据的加载依赖特定item的信息|当页面滑动到最底下的时候，根据最后一个item的信息，来请求下一页的数据|<br>  |PositionalDataSource<T>|适用于目标数据总数固定，通过特定的位置加载数据|规定有一百条数据，指定要这些数据中的哪条数据|</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DataSource</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标签实现</title>
    <link href="/2020/12/17/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E6%A0%87%E7%AD%BE%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/12/17/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E6%A0%87%E7%AD%BE%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="MaterialButton"><a href="#MaterialButton" class="headerlink" title="MaterialButton"></a>MaterialButton</h2><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201217213919.png" alt="MaterialButton效果图"></p><ol><li>修改xml文档</li></ol><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.button.MaterialButton</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;20dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@color/color_2f2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;@dimen/sp_10&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:backgroundTint</span>=<span class="hljs-string">&quot;@color/color_gray&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:icon</span>=<span class="hljs-string">&quot;@drawable/icon_tag&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:cornerRadius</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:iconGravity</span>=<span class="hljs-string">&quot;textStart&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:iconPadding</span>=<span class="hljs-string">&quot;@dimen/dp_4&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:iconSize</span>=<span class="hljs-string">&quot;@dimen/dp_12&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:iconTintMode</span>=<span class="hljs-string">&quot;multiply&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:text</span>=<span class="hljs-string">&quot;神秘皮皮虾&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">com.google.android.material.button.MaterialButton</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><ol><li>修改style.xml文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;AppTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.MaterialComponents.Light.NoActionBar&quot;</span>&gt;</span><span class="xml"></span><br><span class="xml">        <span class="hljs-comment">&lt;!-- Customize your theme here. --&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimary&quot;</span>&gt;</span>@color/colorPrimary<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimaryDark&quot;</span>&gt;</span>@color/colorPrimaryDark<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorAccent&quot;</span>&gt;</span>@color/colorAccent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;materialButtonStyle&quot;</span>&gt;</span>@style/materialButton<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;materialButton&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Widget.MaterialComponents.Button&quot;</span>&gt;</span><span class="xml"></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:paddingLeft&quot;</span>&gt;</span>8dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:paddingRight&quot;</span>&gt;</span>8dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:paddingTop&quot;</span>&gt;</span>4dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:paddingBottom&quot;</span>&gt;</span>4dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:inset&quot;</span>&gt;</span>0dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:insetLeft&quot;</span>&gt;</span>0dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:insetRight&quot;</span>&gt;</span>0dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:insetBottom&quot;</span>&gt;</span>0dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:insetTop&quot;</span>&gt;</span>0dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:minWidth&quot;</span>&gt;</span>0dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:minHeight&quot;</span>&gt;</span>0dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:elevation&quot;</span>&gt;</span>0dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MaterialButton</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小型内存分配器</title>
    <link href="/2020/12/13/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%B0%8F%E5%9E%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/"/>
    <url>/2020/12/13/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%B0%8F%E5%9E%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>起因：</p><ul><li>提升速度</li><li>降低浪费率（cookie），或者说减少cookie的用量</li></ul><h2 id="per-class-allocator-1"><a href="#per-class-allocator-1" class="headerlink" title="per-class allocator 1"></a>per-class allocator 1</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Screen</span>(<span class="hljs-keyword">int</span> x):<span class="hljs-built_in">i</span>(x)&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> i;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">size_t</span>)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    Screen* next;<span class="hljs-comment">//用来指向申请的内存池</span><br>    <span class="hljs-keyword">static</span> Screen* freeStore;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> screenChunk;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> i;<span class="hljs-comment">//该类数据</span><br>&#125;;<br><br>Screen* Screen::freeStore = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Screen::screenChunk = <span class="hljs-number">24</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* Screen::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    Screen* p;<br>    <span class="hljs-keyword">if</span>(!freeStore)<br>    &#123;<br>        <span class="hljs-keyword">size_t</span> chunk = screenChunk * size;<span class="hljs-comment">//申请内存的大小</span><br>        freeStore = p = <span class="hljs-keyword">reinterpret_cast</span>&lt;Screen*&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[chunk]);<br>        <span class="hljs-comment">//将一大块分割片片，当作linked list串接起来</span><br>        <span class="hljs-keyword">for</span>(;p!=&amp;freeStore[screenChunk<span class="hljs-number">-1</span>];++p)<br>            p-&gt;next = p+<span class="hljs-number">1</span>;<br>        p-&gt;next = <span class="hljs-number">0</span>;<br>    &#125;<br>    p = freeStore;<br>    freeStore = freeStore-&gt;next;<span class="hljs-comment">//指向链表首位</span><br>    <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//把链表传回去</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> Screen::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *p, <span class="hljs-keyword">size_t</span>)</span></span><br><span class="hljs-function"></span>&#123;        <span class="hljs-comment">//将指针回收到单向链表之中，放回前端</span><br>    (<span class="hljs-keyword">static_cast</span>&lt;Screen*&gt;(p))-&gt;next = freeStore;<br>    freeStore = <span class="hljs-keyword">static_cast</span>&lt;Screen*&gt;(p);    <br>&#125; <br></code></pre></div></td></tr></table></figure><ul><li>这种设计虽然降低了cookie的数量，但是会引发多耗用一个next的问题，即多了个指针的大小。</li><li><code>operator delete</code>并不算是释放，而是将p归还到链表中，可以让下一个创建者继续使用，而原先p指向的那个区域的旧东西将被新创建者覆盖。</li></ul><h2 id="per-class-allocator-2"><a href="#per-class-allocator-2" class="headerlink" title="per-class allocator 2"></a>per-class allocator 2</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Airplane</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AirplaneRep</span> &#123;</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> miles;<br><span class="hljs-keyword">char</span> type;<br>&#125;;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>AirplaneRep rep;<span class="hljs-comment">//此指针指向使用中的对象</span><br>Airplane* next;<span class="hljs-comment">//此指针指向free list上的对象</span><br>&#125;;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getMiles</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> rep.miles;&#125;<br><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> rep.type;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> m, <span class="hljs-keyword">char</span> t)</span> </span>&#123;<br>rep.miles = m;<br>rep.type = t;<br>&#125;<br><span class="hljs-comment">//重载new和delete</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* deadObject, <span class="hljs-keyword">size_t</span> size)</span></span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> BLOCK_SIZE;<br><span class="hljs-keyword">static</span> Airplane* headOfFreeList;<br>&#125;;<br>Airplane* Airplane::headOfFreeList;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Airplane::BLOCK_SIZE = <span class="hljs-number">512</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* Airplane::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//在继承发生时可能size大小有误</span><br><span class="hljs-keyword">if</span>(size != <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Airplane))<br><span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in"><span class="hljs-keyword">new</span></span>(size);<br>Airplane* p = headOfFreeList;<br><span class="hljs-keyword">if</span>(p)<span class="hljs-comment">//如果p有效就把链表头部向下移</span><br>headOfFreeList = p-&gt;next;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//如果链表已空，申请一大块内存</span><br>Airplane* newBlock = <span class="hljs-keyword">static_cast</span>&lt;Airplane*&gt;<br>            (::<span class="hljs-keyword">operator</span> <span class="hljs-built_in"><span class="hljs-keyword">new</span></span>(BLOCK_SIZE * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Airplane)));<br><br><span class="hljs-comment">//将小块穿成一个freelist</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; BLOCK_SIZE - <span class="hljs-number">1</span>; ++i)<br>newBlock[i].next = &amp;newBlock[i+<span class="hljs-number">1</span>];<br>newBlock[BLOCK_SIZE - <span class="hljs-number">1</span>].next = <span class="hljs-number">0</span>;<br>p = newBlock;<br>headOfFreeList = &amp;newBlock[<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//operator delete截获一个内存块</span><br><span class="hljs-comment">//如果大小正确，就把它加到freelist前端</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> Airplane::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* deadObject, <span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(deadObject == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(size != <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Airplane)) &#123;<br>::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(deadObject)</span></span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>Airplane* carcass = <span class="hljs-keyword">static_cast</span>&lt;Airplane*&gt;(deadObject);<br>carcass-&gt;next = headOfFreeList;<br>headOfFreeList = carcass;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>这种设计很巧妙的运用了联合体。当该内存块在单元中未使用，就让<code>next</code>指针指向下一个未分配的内存块，当这个块被实例化后，next所占用的4个字节就是真正的数据了。若该内存块被创建者使用，创建者就可以使用<code>AirplaneRep</code>的数据覆盖掉<code>next</code>指针。这样做相比<strong>per-class allocator 1</strong>的方法少了额外放成员变量的空间，也就是说将指针和数据合二为一了，根据使用场景不同使用不同的变量。</li><li><code>operator new</code>中<code>for(int i = 1; i &lt; BLOCK_SIZE - 1; ++i)&#123;...&#125;</code>的迭代值<code>i</code>是从<strong>1</strong>开始的，原因是只有当内存中没有这个链表内存空间才会走到当前for循环，也就是说<strong>第一次</strong>有创建者需要一个<code>Airplane</code>。所以直接返回一个第一个对象的空间就可以了，并不需要将该对象的<code>next</code>指向下一个链表内存块，因为对于使用者来说，<code>next</code>指针对他没用处。</li><li>而至于<code>operator delete</code>中为什么要多创建一个<code>Airplane* carcass</code>的原因，有点摸不着头脑。感觉只能这么解释：因为传进来的<code>deadObject</code>使用的是联合体中的<code>AirplaneRep</code>，而<code>AirplaneRep</code>中并没有<code>next</code>指针，所以不能用<code>deadObject</code>去获得<code>next</code>指针，只能通过创建一个新的指针<code>carcass</code>通过显式转换指向<code>deadObject</code>，然后根据这个<code>carcass</code>去修改<code>next</code>的值。</li></ul><h2 id="static-allocator-3"><a href="#static-allocator-3" class="headerlink" title="static allocator 3"></a>static allocator 3</h2><p>之前的两个版本<strong>per-class allocator 1</strong>和<strong>per-class allocator 2</strong>都是在类里重载<code>new</code>和<code>delete</code>，实际上都是完成同样的任务，所以可以将这部分的内存分配抽出来成为一个<code>allocator</code>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">allocator</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">obj</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">obj</span>* <span class="hljs-title">next</span>;</span><br>&#125;;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*,<span class="hljs-keyword">size_t</span>)</span></span>;<br><span class="hljs-keyword">private</span>:<br>obj* freeStore = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> CHUNK = <span class="hljs-number">5</span>;<span class="hljs-comment">//这里小一些以便观察</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">allocator::deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p,<span class="hljs-keyword">size_t</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//将*p收回插入free list 前端</span><br>((obj*)p)-&gt;next = freeStore;<br>freeStore = (obj*)p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">allocator::allocate</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>obj* p;<br><span class="hljs-keyword">if</span>(!freeStore) &#123;<br><span class="hljs-comment">//linked list为空，于是申请一大块</span><br><span class="hljs-keyword">size_t</span> chunk = CHUNK * size;<br>freeStore = p = (obj*)<span class="hljs-built_in">malloc</span>(chunk);<br><br><span class="hljs-comment">//将分配得来的一大块当作linked list</span><br><span class="hljs-comment">//串接起来</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (CHUNK - <span class="hljs-number">1</span>); ++i) &#123;<br>p-&gt;next = (obj*)((<span class="hljs-keyword">char</span>*)p + size);<br>p = p-&gt;next;<br>&#125;<br>p-&gt;next = <span class="hljs-literal">nullptr</span>;<br>&#125;<br>p = freeStore;<br>freeStore = freeStore-&gt;next;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">long</span> L;<br>string str;<br><span class="hljs-keyword">static</span> allocator myAlloc;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Foo</span>(<span class="hljs-keyword">long</span> l):<span class="hljs-built_in">L</span>(<span class="hljs-number">1</span>)&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> </span>&#123;<br><span class="hljs-keyword">return</span> myAlloc.<span class="hljs-built_in">allocate</span>(size);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* pdead,<span class="hljs-keyword">size_t</span> size)</span> </span>&#123;<br><span class="hljs-keyword">return</span> myAlloc.<span class="hljs-built_in">deallocate</span>(pdead,size);<br>&#125;<br>&#125;;<br>allocator Foo::myAlloc;<br></code></pre></div></td></tr></table></figure><ul><li><p>这个版本由于allocator的提取，所以增加了代码的复用性。</p></li><li><p>因为<code>const int CHUNK = 5</code>，所以在内存里面分配的容量会比较小，便于管理。例如创建了<strong>23</strong>个<code>Foo</code>，在下图中可以看到地址是不连续的：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/0cdb64f500e17561171414bbe163980f-ed140.png" style="zoom: 50%;" /></p></li><li><p>因为在<code>Foo</code>中的<code>allocator</code>为<code>static</code>类型，所以<code>Foo</code>独自拥有一个静态的<code>allocator</code>变量。推而广之，可以针对不同的类维护<code>allocator</code>里的<code>freeStore</code>和<code>next</code>，即每个类都有单独的区域，不互相影响。</p></li></ul><h3 id="macro-for-static-allocator"><a href="#macro-for-static-allocator" class="headerlink" title="macro for static allocator"></a>macro for static allocator</h3><p>由偷懒而引发的小技巧：<strong>static allocator</strong>中的<code>allocator</code>可以进一步写成以下形式，然后在类里的使用会非常方便。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECLARE_POOL_ALLOC() \</span><br><span class="hljs-meta">public: \</span><br><span class="hljs-meta">    void* operator new(size_t size) &#123; return myAlloc.allocate(size); &#125; \</span><br><span class="hljs-meta">    void operator delete(void* p) &#123; myAlloc.deallocate(p, 0); &#125; \</span><br><span class="hljs-meta">protected: \</span><br><span class="hljs-meta">    static allocator myAlloc; </span><br><br><span class="hljs-comment">// IMPLEMENT_POOL_ALLOC -- used in class implementation file</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMPLEMENT_POOL_ALLOC(class_name) \</span><br><span class="hljs-meta">allocator class_name::myAlloc; </span><br><br><br><span class="hljs-comment">// in class definition file</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span><br>   <span class="hljs-built_in">DECLARE_POOL_ALLOC</span>()<br><span class="hljs-keyword">public</span>: <br><span class="hljs-keyword">long</span> L;<br>string str;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Foo</span>(<span class="hljs-keyword">long</span> l) : <span class="hljs-built_in">L</span>(l) &#123;  &#125;   <br>&#125;;<br><span class="hljs-comment">//in class implementation file</span><br><span class="hljs-built_in">IMPLEMENT_POOL_ALLOC</span>(Foo) <br></code></pre></div></td></tr></table></figure><h2 id="new-handler"><a href="#new-handler" class="headerlink" title="new handler"></a>new handler</h2><p>当<code>operator new</code>没有能力分配我们所申请的内存，会抛出一个<code>std::bad_alloc</code> exception。某些老旧编译器则是返回0，但是我们依然可以让我们的编译器返回0，做法是：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">new</span>(nothrow) Foo;<span class="hljs-comment">//此称为nothrow形式</span><br></code></pre></div></td></tr></table></figure><p>当我们不按照上面的写法，而是想让我们的内存分配失败时执行我们想要的行为可以吗？可以，C++提供了一个机制<strong>new handler</strong>，我们首先需实现一个形为如下的函数：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*new_handler)</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(new_handler p)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br></code></pre></div></td></tr></table></figure><p>使用方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;new&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cassert&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//我们写的new_handler函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">noMoreMemory</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//在此写上我们希望的行为</span><br>cerr &lt;&lt; <span class="hljs-string">&quot;out of memory&quot;</span>;<br><span class="hljs-built_in">abort</span>();<span class="hljs-comment">//此处若没有这条，那么内存分配失败将一直输出&quot;out of memory&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//设置new_handler</span><br><span class="hljs-built_in">set_new_handler</span>(noMoreMemory);<br><br><span class="hljs-keyword">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100000000000000000</span>];<br><span class="hljs-built_in">assert</span>(p);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意：<strong>new handler</strong>的设计只有两种选择</p><ul><li>让更多的内存可用</li><li>调用<code>abort()</code>或<code>exit()</code></li></ul><p><strong>operator new源码：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7142b5769c270e56124913e1a424b890-1c387.png" style="zoom:50%;" /></p><p><strong>new handler源码：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/c93305fadc36ed14255c47a1efdb058a-8b3c7.png" style="zoom: 67%;" /></p><h2 id="delete-和-default"><a href="#delete-和-default" class="headerlink" title="= delete 和 = default"></a>= delete 和 = default</h2><p><code>= default</code>的作用是：该函数使用默认版本。比如使用默认的构造、拷贝构造等。</p><p><code>= delete</code>的作用是：让该函数无效。</p><p>参考：<a href="https://blog.csdn.net/qq_41453285/article/details/100606913">C++:73—-C++11标准（类的删除函数：=delete关键字、阻止构造、阻止拷贝、private阻止拷贝控制）</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dataBinding</title>
    <link href="/2020/12/09/Android/Jetpack/dataBinding/"/>
    <url>/2020/12/09/Android/Jetpack/dataBinding/</url>
    
    <content type="html"><![CDATA[<h2 id="1-在build-gradle文件中配置"><a href="#1-在build-gradle文件中配置" class="headerlink" title="1.在build.gradle文件中配置"></a>1.在build.gradle文件中配置</h2><p>配置dataBinging无需引用任何的依赖，只需要在build.gradle中配置即可</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">android &#123;<br>    <br>    <span class="hljs-comment">//....</span><br><br>    dataBinding&#123;<br>        enabled=<span class="hljs-keyword">true</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-修改xml布局文件"><a href="#2-修改xml布局文件" class="headerlink" title="2.修改xml布局文件"></a>2.修改xml布局文件</h2><ol><li><p>先将原有布局转换成dataBinging布局<br><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201216234512.png" alt="转换布局"></p></li><li><p>修改xml文件</p></li></ol><h3 id="2-1-在TextView里面使用"><a href="#2-1-在TextView里面使用" class="headerlink" title="2.1 在TextView里面使用"></a>2.1 在TextView里面使用</h3><h4 id="2-1-1-例一"><a href="#2-1-1-例一" class="headerlink" title="2.1.1 例一"></a>2.1.1 例一</h4><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- a.xml --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">variable</span></span><br><span class="hljs-tag">            <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;User&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.mooc.ppjoke.model.User&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/author_name&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@&#123;user.name&#125;&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">tools:text</span>=<span class="hljs-string">&quot;use_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TextView</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- b.xml --&gt;</span><br>    <span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">variable</span></span><br><span class="hljs-tag">            <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;feed&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Feed&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.mooc.ppjoke.model.Feed&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span></span><br><span class="hljs-tag">        <span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;@layout/layout_feed_author&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:user</span>=<span class="hljs-string">&quot;@&#123;feed.author&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><p>在data标签里声明变量：在import标签里引入变量所在的类，variable标签里的type为变量类型，name为变量的名称。在例一中，b.xml包含了a.xml。a.xml中的user，是由b.xml中include标签里的app:user传入的。<br>注：即使user.name为空也不会报错，因为dataBinding是空安全的</p><h4 id="2-1-2-例二"><a href="#2-1-2-例二" class="headerlink" title="2.1.2 例二"></a>2.1.2 例二</h4><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">variable</span></span><br><span class="hljs-tag">            <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;feedText&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> /&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;android.text.TextUtils&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;android.view.View&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@&#123;feedText&#125;&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:visibility</span>=<span class="hljs-string">&quot;@&#123;TextUtils.isEmpty(feedText)?View.GONE:View.VISIBLE&#125;&quot;</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><p>判断feedText是否为空。若为空，则设置android:visibility属性为不显示；若有值，则设置android:visibility属性为显示。</p><h3 id="2-2-在ImageView里面使用"><a href="#2-2-在ImageView里面使用" class="headerlink" title="2.2 在ImageView里面使用"></a>2.2 在ImageView里面使用</h3><ol><li>写一个继承自AppCompatImageView的类</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PPImageView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatImageView</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-comment">//image_url：图片的url；isCircle：图片是否有圆角</span><br>    <span class="hljs-comment">//requireAll：若为true，表示配置的时候只有把参数全都设置了，才能调用该方法</span><br>    <span class="hljs-comment">//这个方法的第一个参数一定是类自身</span><br>    <span class="hljs-meta">@BindingAdapter(value = &#123;&quot;image_url&quot;, &quot;isCircle&quot;&#125;, requireAll = false)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setImageUrl</span><span class="hljs-params">(PPImageView view, String imageUrl, <span class="hljs-keyword">boolean</span> isCircle, <span class="hljs-keyword">int</span> radius)</span> </span>&#123;<br><br>        RequestBuilder&lt;Drawable&gt; builder = Glide.with(view).load(imageUrl);<br>        <span class="hljs-comment">//是否圆角</span><br>        <span class="hljs-keyword">if</span> (isCircle) &#123;<br>            builder.transform(<span class="hljs-keyword">new</span> CircleCrop());<br>        &#125;<br>        <span class="hljs-comment">//设置图片的尺寸</span><br>        ViewGroup.LayoutParams layoutParams = view.getLayoutParams();<br>        <span class="hljs-keyword">if</span> (layoutParams != <span class="hljs-keyword">null</span> &amp;&amp; layoutParams.width &gt; <span class="hljs-number">0</span> &amp;&amp; layoutParams.height &gt; <span class="hljs-number">0</span>) &#123;<br>            builder.override(layoutParams.width, layoutParams.height);<br>        &#125;<br>        builder.into(view);<br>    &#125;<br></code></pre></div></td></tr></table></figure><ol><li>在xml文件中配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">com.mooc.ppjoke.view.PPImageView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/avatar&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;@dimen/dp_40&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;@dimen/dp_40&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:image_url</span>=<span class="hljs-string">&quot;@&#123;user.avatar&#125;&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:isCircle</span>=<span class="hljs-string">&quot;@&#123;true&#125;&quot;</span></span><br><span class="hljs-tag">            &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com.mooc.ppjoke.view.PPImageView</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>注：<strong>@BindingAdapter</strong>注解中的requireAll参数设置为true时，只有配置了<strong>app:image_url</strong>和<strong>app:isCircle</strong>，才能调用PPImageView中的setImageUrl方法。</p><h2 id="dataBinding特殊性"><a href="#dataBinding特殊性" class="headerlink" title="dataBinding特殊性"></a>dataBinding特殊性</h2><ol><li>强校验</li><li>空安全</li><li>根据经验，dataBinding在布局文件里绑定视频资源的时候，会延迟一帧。扩展：如果需要绑定的数据需要计算宽和高，建议使用原生方法</li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jetpack</tag>
      
      <tag>dataBinding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>malloc与free</title>
    <link href="/2020/12/08/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/malloc%E4%B8%8Efree/"/>
    <url>/2020/12/08/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/malloc%E4%B8%8Efree/</url>
    
    <content type="html"><![CDATA[<h2 id="SBH（VC6）"><a href="#SBH（VC6）" class="headerlink" title="SBH（VC6）"></a>SBH（VC6）</h2><ul><li><p><strong>SBH = Small Block Heap</strong></p></li><li><p><code>HeapAlloc()</code>：windows内存分配函数</p></li></ul><p>在新版本如VC10，已经不做小块的内存管理了，统统将操作丢给<code>HeapAlloc()</code>，因为<code>HeapAlloc()</code>也开始做小块内存管理了。</p><p>下图为C++程序的运行调用栈（VC6）：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/54dc87706cafbf193f1a014a2af24970-5ee36.png" alt="C++程序的运行调用栈"  /></p><p>上图中的常量<code>_sbh_threshold</code>的值为<strong>1016</strong>，和<strong>1024</strong>差了<strong>8</strong>个字节，这8个字节就是内存块上下的<strong>cookie</strong>。当我们需要的内存块加上<strong>cookie</strong>一共超过了<strong>1024</strong>，那么<strong>SBH</strong>将会把内存分配的操作<strong>转交给操作系统处理</strong>。由此可见小区块定义的大小就是1024。</p><p>自下而上，首先进入操作系统内核部分，由操作调用<code>mainCRTStartup()</code>，即CRT的动作。</p><h3 id="heap-init"><a href="#heap-init" class="headerlink" title="_heap_init()"></a>_heap_init()</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6ae13a524af0ecd498241c14b290e7d4-c5fe0.png" alt=" _heap_init()"  /></p><ul><li><code>_heap_init()</code>从操作系统的<strong>CRT Heap</strong>申请空间，来应付CRT的需求，<code>_sbh_pHeaderList</code>指向这个空间。</li><li><code>bitvEntryHi</code>和<code>bitvEntryLo</code>实际上会组合起来，即一共64bit。</li><li><code>_heap_init()</code>做的事实际上就是分配了16个<strong>Header</strong>。</li><li>一个<strong>Header</strong>管理<strong>1MB</strong>。</li></ul><p><strong>Header</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> BITVEC;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagHeader</span></span><br><span class="hljs-class">&#123;</span><br>BITVEC bitvEntryHi;<br>BITVEC bitvEntryLo;<br>BITVEC bitvCommit;<br><span class="hljs-keyword">void</span>* pHeapData;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagRegion</span>* <span class="hljs-title">pRegion</span>;</span><br>&#125;<br>HEADER,*PHEADER;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/d58d5e1aad1b8db3e051fdad0f205cf7-6b918.png" alt="**Header**："></p><h3 id="ioinit-（SBH运行例子：malloc与free）"><a href="#ioinit-（SBH运行例子：malloc与free）" class="headerlink" title="_ioinit()（SBH运行例子：malloc与free）"></a>_ioinit()（SBH运行例子：malloc与free）</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/0f99d7cce6fa99cafeb92ce68548dc1e-99459.png" alt="_ioinit()"  /></p><p><code>_ioinit()</code>是跟io相关的初始化，也是<strong>第一次</strong>内存分配。</p><h4 id="添加DebugHeader"><a href="#添加DebugHeader" class="headerlink" title="添加DebugHeader"></a>添加DebugHeader</h4><p>假设在<strong>DEBUG</strong>模式下，首先要给<strong>IO所需的空间</strong>附着<strong>DebugHeader</strong>：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b79b80c6866320719070b90bfe43ff9f-bab51.png"  /></p><ul><li><code>nSize</code>就是IO需要的空间大小，对于IO来说就是256字节。</li><li><code>_CrtMemBlockHeader</code>为<strong>debug</strong>模式下，附着在我们申请的内存之上的东西，即<strong>DebugHeader</strong>。</li><li><code>szFileName</code>是指针，存放文件名；再结合<code>nLine</code>存放的行数，调试器可以知道这块内存是从哪一个文件的哪一行分配出来的。</li><li><code>nDataSize</code>记录着原本所需分配的内存大小，即<code>nSize</code>。</li><li><code>nBlockUse</code>记录该内存块的用途。<img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7e3c56f6d983475ba91219ef3806bf6b-93c18.png" style="zoom:50%;" /></li><li><code>IRequest</code>为流水号，因为图中的内存块是第一块分配的内存，所以<code>IRequest</code>的内容为1。</li><li><code>gap[nNoMansLandSize]</code>的作用就是，万一我们使用的时候超过<code>nSize</code>的边界，到达<code>nNoMansLandSize</code>区域，调试器就可以检查出来。</li><li>在调试模式下，经过malloc分配的所有内存块，都会被登记起来。即使被我们使用了，也会被登记。所以调试器可以进行追踪内存等动作。</li></ul><p>至此，<code>blockSize</code>的大小已经计算出来了，然后根据计算的大小从<code>malloc</code>获得了内存。接着需要往内存里面写内容：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b4dcea961f8a609d602b7d31d5068c7b-fefe5.png" alt="填充"  /></p><p>可以看到，<code>nNoMansLandSize</code>区域被填充了<code>0xFD</code>，IO真正的区域（大小为<code>nSize</code>）被填充了<code>0xCD</code>。这也就是为什么在调试的时候看内存会出现很多“<strong>烫烫烫….</strong>”。</p><h4 id="添加cookie及RoundUp"><a href="#添加cookie及RoundUp" class="headerlink" title="添加cookie及RoundUp"></a>添加cookie及RoundUp</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9e5757177cd3b04692df36a354577d6f-95be9.png"  /></p><p>有了blockSize以及相应大小的内存区域，接下来：</p><ul><li>在内存块上下添加<strong>cookie</strong>，这个<strong>cookie</strong>的值需要变成<strong>16的倍数</strong>，所以在上图根据计算变成了<code>0x130</code>。</li><li>因为这块内存是正在使用的，所以将<code>0x130</code>变成<code>0x131</code>。</li></ul><h4 id="管理模式"><a href="#管理模式" class="headerlink" title="管理模式"></a>管理模式</h4><ul><li>SBH为了管理1MB，成本是16K。</li><li>SBH通过控制中心分配内存块的行为与STL：allocator的行为几乎相似。</li><li>SBH对区域的粒度划分如此细致，是为了更好的将内存归还给OS。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/64e245b7a20655a9367ed949b23d8149-9775f.png" alt="管理模式"  /></p><h5 id="全回收"><a href="#全回收" class="headerlink" title="全回收"></a>全回收</h5><ul><li>如果没有下cookie的设计，就没办法往上合并。</li><li>SBH手上有两个全回收才会将其中一个Group还给OS。</li><li>每次回收只会往上和往下查看上下区块的cookie<strong>一次</strong>。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/78d00a624e830a518a6e9d2a845063b6-7e63b.png" alt="全回收"  /></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Room数据库</title>
    <link href="/2020/12/06/Android/Jetpack/Room%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2020/12/06/Android/Jetpack/Room%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-meta">@Database(entities = &#123;Cache.class&#125;, version = 1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheDatabase</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RoomDatabase</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用抽象类的原因：RoomDatabase是使用注解来使用相关的功能，在编译时使用annotationprocesser来实现类。在使用abstract声明的时候，运行时会产生一个CacheDatabase的实现类。这样一来就不用复写RoomDatabase的几个默认方法</p><h2 id="数据库的创建"><a href="#数据库的创建" class="headerlink" title="数据库的创建"></a>数据库的创建</h2><ol><li>inMemoryDatabaseBuilder()：创建一个内存数据库</li><li>databaseBuilder()：常规创建</li></ol><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><ol><li>allowMainThreadQueries()：是否允许在主线程进行查询，默认是关闭的。如果关闭情况下在主线程查询数据库，将会抛出异常</li><li>addCallback()：数据库创建和打开后的回调</li><li>setQueryExecutor()：设置查询的线程池</li><li>openHelperFactory()：数据库Heper的工厂类</li><li>setJournalMode()：设置数据库的日志模式</li><li>fallbackToDestructiveMigration()：数据库升级异常之后的回滚，设置后将重新创建数据库。若不设置将会销毁数据库</li><li>fallbackToDestructiveMigrationFrom()：数据库升级异常后根据指定版本进行回滚</li><li>addMigrations()：数据库跨版本升级</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-comment">//跨版本升级举例</span><br><br><span class="hljs-comment">//....</span><br><span class="hljs-comment">//数据库从版本1升级到版本3</span><br><span class="hljs-keyword">static</span> Migration sMigration = <span class="hljs-keyword">new</span> Migration(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">migrate</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> SupportSQLiteDatabase database)</span> </span>&#123;<br>        database.execSQL(<span class="hljs-string">&quot;alter table teacher rename to student&quot;</span>);<br>        database.execSQL(<span class="hljs-string">&quot;alter table teacher add column teacher_age INTEGER NOT NULL default 0&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> CacheDatabase database;<br>database = Room.databaseBuilder(AppGlobals.getApplication(), CacheDatabase.class, <span class="hljs-string">&quot;ppjoke_cache&quot;</span>).  addMigrations(sMigration).build();<br><br></code></pre></div></td></tr></table></figure><h2 id="Database注解"><a href="#Database注解" class="headerlink" title="@Database注解"></a>@Database注解</h2><ol><li>entities：数据库中有哪些表</li><li>version：后续数据库升级可用到</li><li>exportSchema：默认为true。会导出一个JSON文件，内容为数据库在升级或创建数据表的时候的操作。也包含了所有表的字段和字段的描述。需要在包的build.gradle文件中配置</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA">defaultConfig &#123;<br>        ...<br><br>        javaCompileOptions&#123;<br>            annotationProcessorOptions&#123;<br>                arguments=[<span class="hljs-string">&quot;room.schemaLocation&quot;</span>:<span class="hljs-string">&quot;$projectDir/schemas&quot;</span>.toString()]<span class="hljs-comment">//表示文件放在包的根目录下的schemas文件夹下</span><br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><h2 id="Entity相关"><a href="#Entity相关" class="headerlink" title="@Entity相关"></a>@Entity相关</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-meta">@Entity(tableName = &quot;cache&quot;,</span><br><span class="hljs-meta">        foreignKeys = &#123;entity = User.class,parentColumns = &quot;id&quot;,childColumns = &quot;key&quot;,</span><br><span class="hljs-meta">        onDelete = &quot;ForeignKey.RESTRICT&quot;,onUpdate = &quot;ForeignKey.SET_DEFAULT&quot;&#125;</span><br><span class="hljs-meta">        )</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-meta">@PrimaryKey(autoGenerate = false)</span><br>    <span class="hljs-keyword">public</span> String key;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] data;<br><br>    <span class="hljs-meta">@Embedded</span> <br>    <span class="hljs-keyword">public</span> User user<br><br>    <span class="hljs-meta">@Relation(entity = Address.class,parentColumn = &quot;id&quot;,entityColumn = &quot;id&quot;,projection = &#123;&#125;)</span><br>    <span class="hljs-keyword">public</span> Address address;<br><br>    <span class="hljs-meta">@ColumnInfo(name = &quot;name&quot;)</span><br>    <span class="hljs-keyword">public</span> String name;<br><br>    <span class="hljs-meta">@Ignore</span><br>    <span class="hljs-keyword">public</span> String age;<br><br>    <span class="hljs-meta">@TypeConverters(value = &#123;DateConverter.class&#125;)</span><br>    <span class="hljs-keyword">public</span> Date mDate;<br><br>&#125;<br><br># DateConverter.class<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateConverter</span> </span>&#123;<br><br>    <span class="hljs-meta">@TypeConverter</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title">date2Long</span><span class="hljs-params">(Date date)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> date.getTime();<br>    &#125;<br><br>    <span class="hljs-meta">@TypeConverter</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">long2Date</span><span class="hljs-params">(Long data)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Date(data);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><ul><li><strong>@ColumnInfo</strong> ：若不加这条注解，表创建时，name在表中的字段名称不变(name)。而加入 <strong>@ColumnInfo(name = “name_”)</strong>，当表创建时，name在表中映射的列名为name_。</li><li><strong>@Embedded</strong> ：对象嵌套,User对象中所有字段,也都会被映射到cache表中</li><li><strong>@Entity</strong> ：定义表的名称</li><li><strong>@PrimaryKey</strong> ：定义表的主键,其中的autoGenerate为true时表示主键自动生成</li><li><strong>foreignKeys</strong> : 定义表的外键。其中entity表示外键所在的表，parentColumns表示外键在其原表中的列名，而childColumns表示外键关联本表中列的列名。onDelete表示外键删除时本表所需动作，onUpdate同理。具体宏作用如下表。<br>  |宏|描述|<br>  |:————|:—————|<br>  |NO_ACTION|什么都不做|<br>  |RESTRICT|当外键删除时，本表中关联的键也会立即删除|<br>  |SET_NULL|设置为空值|<br>  |SET_DEFAULT|设置为默认值|<br>  |CASCADE|与RESTRICT相似，区别在于RESTRICT会立即发生|</li><li><strong>@Ignore</strong> ：该注解标记的字段将不会出现在表中</li><li><strong>@Relation</strong> ：关联查询。entity表示要关联的表，parentColumn表示关联表中的列名，entityColumn表示本表中的列名，projection是个数组，里面填写关联查询所需要返回的列名。</li><li><strong>@TypeConverters</strong> ：它是TypeConverter的集合。可以标记在方法、参数、类、字段上面。当Date类型存入数据库时转换成Long类型，或者从数据库取出后将Long类型转换成Date类型，使用的是DateConverter.class中用 <strong>@TypeConverter</strong> 标注的方法。<strong>@TypeConverter</strong>所标注的方法，必须有一个参数，还有一个不是void类型的返回值。</li></ul><h2 id="Dao相关"><a href="#Dao相关" class="headerlink" title="@Dao相关"></a>@Dao相关</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-meta">@Dao</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CacheDao</span> </span>&#123;<br><br>    <span class="hljs-meta">@Insert(onConflict = OnConflictStrategy.REPLACE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">save</span><span class="hljs-params">(Cache cache)</span></span>;<br><br>    <span class="hljs-comment">//如果是一对多,这里可以写List&lt;Cache&gt;</span><br>    <span class="hljs-meta">@Query(&quot;select *from cache where `key`=:key&quot;)</span><br>    <span class="hljs-function">Cache <span class="hljs-title">getCache</span><span class="hljs-params">(String key)</span></span>;<br><br>    <span class="hljs-comment">//只能传递对象昂,删除时根据Cache中的主键 来比对的</span><br>    <span class="hljs-meta">@Delete</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">delete</span><span class="hljs-params">(Cache cache)</span></span>;<br><br>    <span class="hljs-comment">//只能传递对象昂,删除时根据Cache中的主键 来比对的</span><br>    <span class="hljs-meta">@Update(onConflict = OnConflictStrategy.REPLACE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(Cache cache)</span></span>;<br><br><br><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>当一个类被 <strong>@Dao</strong> 标记，说明它是一个能操作数据库的一个类。可标注在 <strong>interface</strong> 类或者 <strong>abstract</strong> 类上面</li><li><strong>@Insert</strong> 、<strong>@Query</strong> 、 <strong>@Delete</strong> 、<strong>@Update</strong> 等注解</li><li>@Insert(onConflict = OnConflictStrategy.REPLACE)中的<strong>onConflict</strong>表示当插入时发生冲突的行为( <strong>@Update</strong> 也是一样)。<br>  |宏|描述|<br>  |:————|:—————|<br>  |REPLACE|直接用新的数据替换掉旧的数据|<br>  |ROLLBACK|回滚，保留旧的数据|<br>  |ABORT|终止提交，保留旧的数据|<br>  |FAIL|提交失败|<br>  |IGNORE|忽略本次提交|</li><li><strong>@Delete</strong> 中的参数可以是对象、集合、数组等。</li><li><strong>@Transaction</strong> ：所标记的方法将会被当作事务来提交</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>room数据库</tag>
      
      <tag>jetpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ExecutorService</title>
    <link href="/2020/12/03/JAVA/ExecutorService/"/>
    <url>/2020/12/03/JAVA/ExecutorService/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>ExecutorService是Java中对线程池定义的一个接口，它位于java.util.concurrent包中，在这个接口中定义了和后台任务执行相关的方法：</p><ol><li>ThreadPoolExecutor</li><li>ScheduledThreadPoolExecutor</li></ol><p>除此之外，ExecutorService还继承了Executor接口（注意区分Executor接口和Executors工厂类），这个接口只有一个execute()方法，最后我们看一下整个继承树：<br><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201203213311.png" alt="继承树"></p><h2 id="ExecutorService的创建"><a href="#ExecutorService的创建" class="headerlink" title="ExecutorService的创建"></a>ExecutorService的创建</h2><p>创建一个什么样的ExecutorService的实例（即线程池）需要根据具体应用场景而定，不过Java给我们提供了一个Executors工厂类，它可以帮助我们很方便的创建各种类型ExecutorService线程池，Executors一共可以创建下面这四类线程池：</p><ol><li>newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li><li>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li><li>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</li><li>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ol><p><em>注意</em>：Executors只是一个工厂类，它所有的方法返回的都是ThreadPoolExecutor、ScheduledThreadPoolExecutor这两个类的实例。</p><h2 id="ExecutorService的使用"><a href="#ExecutorService的使用" class="headerlink" title="ExecutorService的使用"></a>ExecutorService的使用</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br>executorService.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Asynchronous task&quot;</span>);<br>    &#125;<br>&#125;);<br><br>executorService.shutdown();<br></code></pre></div></td></tr></table></figure><h2 id="ExecutorService的执行"><a href="#ExecutorService的执行" class="headerlink" title="ExecutorService的执行"></a>ExecutorService的执行</h2><ul><li>execute(Runnable)</li><li>submit(Runnable)</li><li>submit(Callable)</li><li>invokeAny(…)</li><li>invokeAll(…)</li></ul><h3 id="execute-Runnable"><a href="#execute-Runnable" class="headerlink" title="execute(Runnable)"></a>execute(Runnable)</h3><p>这个方法接收一个Runnable实例，并且异步的执行</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ExecutorService executorService = Executors.newSingleThreadExecutor();<br><br>executorService.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Asynchronous task&quot;</span>);<br>    &#125;<br>&#125;);<br><br>executorService.shutdown();<br></code></pre></div></td></tr></table></figure><p>这个方法有个问题，就是没有办法获知task的执行结果。如果我们想获得task的执行结果，我们可以传入一个Callable的实例。</p><h3 id="submit-Runnable"><a href="#submit-Runnable" class="headerlink" title="submit(Runnable)"></a>submit(Runnable)</h3><p>submit(Runnable)和execute(Runnable)区别是前者可以返回一个Future对象，通过返回的Future对象，我们可以检查提交的任务是否执行完毕。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br>Future future = executorService.submit(<span class="hljs-keyword">new</span> Runnable() &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Asynchronous task&quot;</span>);<br>&#125;<br>&#125;);<br><br>future.get(); <span class="hljs-comment">/*该方法会产生阻塞*/</span><br><br></code></pre></div></td></tr></table></figure><p>如果任务执行完成，future.get()方法会返回一个null。</p><h3 id="submit-Callable"><a href="#submit-Callable" class="headerlink" title="submit(Callable)"></a>submit(Callable)</h3><p>submit(Callable)和submit(Runnable)类似，也会返回一个Future对象，但是除此之外，submit(Callable)接收的是一个Callable的实现，Callable接口中的call()方法有一个返回值，可以返回任务的执行结果，而Runnable接口中的run()方法是void的，没有返回值。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br>Future future = executorService.submit(<span class="hljs-keyword">new</span> Callable()&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Asynchronous Callable&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Callable Result&quot;</span>;<br>    &#125;<br>&#125;);<br><br>System.out.println(<span class="hljs-string">&quot;future.get() = &quot;</span> + future.get());<span class="hljs-comment">/*该方法会产生阻塞*/</span><br><br></code></pre></div></td></tr></table></figure><p>如果任务执行完成，future.get()方法会返回Callable任务的执行结果。</p><h3 id="invokeAny-…"><a href="#invokeAny-…" class="headerlink" title="invokeAny(…)"></a>invokeAny(…)</h3><p>invokeAny(…)方法接收的是一个Callable的集合，执行这个方法不会返回Future，但是会返回所有Callable任务中其中一个任务的执行结果。这个方法也无法保证返回的是哪个任务的执行结果，反正是其中的某一个。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ExecutorService executorService = Executors.newSingleThreadExecutor();<br><br>Set&lt;Callable&lt;String&gt;&gt; callables = <span class="hljs-keyword">new</span> HashSet&lt;Callable&lt;String&gt;&gt;();<br><br>callables.add(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Task 1&quot;</span>;<br>    &#125;<br>&#125;);<br>callables.add(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Task 2&quot;</span>;<br>    &#125;<br>&#125;);<br>callables.add(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Task 3&quot;</span>;<br>    &#125;<br>&#125;);<br><br>String result = executorService.invokeAny(callables);<br>System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>executorService.shutdown();<br></code></pre></div></td></tr></table></figure><p>每次执行都会返回一个结果，并且返回的结果是变化的，可能会返回“Task2”也可是“Task1”或者其它。</p><h3 id="invokeAll-…"><a href="#invokeAll-…" class="headerlink" title="invokeAll(…)"></a>invokeAll(…)</h3><p>invokeAll(…)与 invokeAny(…)类似也是接收一个Callable集合，但是前者执行之后会返回一个Future的List，其中对应着每个Callable任务执行后的Future对象。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ExecutorService executorService = Executors.newSingleThreadExecutor();<br><br>Set&lt;Callable&lt;String&gt;&gt; callables = <span class="hljs-keyword">new</span> HashSet&lt;Callable&lt;String&gt;&gt;();<br><br>callables.add(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Task 1&quot;</span>;<br>    &#125;<br>&#125;);<br>callables.add(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Task 2&quot;</span>;<br>    &#125;<br>&#125;);<br>callables.add(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Task 3&quot;</span>;<br>    &#125;<br>&#125;);<br><br>List&lt;Future&lt;String&gt;&gt; futures = executorService.invokeAll(callables);<br><br><span class="hljs-keyword">for</span>(Future&lt;String&gt; future : futures)&#123;<br>    System.out.println(<span class="hljs-string">&quot;future.get = &quot;</span> + future.get());<br>&#125;<br><br>executorService.shutdown();<br><br></code></pre></div></td></tr></table></figure><h2 id="ExecutorService的关闭"><a href="#ExecutorService的关闭" class="headerlink" title="ExecutorService的关闭"></a>ExecutorService的关闭</h2><p>当我们使用完成ExecutorService之后应该关闭它，否则它里面的线程会一直处于运行状态。</p><p>举个例子，如果的应用程序是通过main()方法启动的，在这个main()退出之后，如果应用程序中的ExecutorService没有关闭，这个应用将一直运行。之所以会出现这种情况，是因为ExecutorService中运行的线程会阻止JVM关闭。</p><p>如果要关闭ExecutorService中执行的线程，我们可以调用ExecutorService.shutdown()方法。在调用shutdown()方法之后，ExecutorService不会立即关闭，但是它不再接收新的任务，直到当前所有线程执行完成才会关闭，所有在shutdown()执行之前提交的任务都会被执行。</p><p>如果我们想立即关闭ExecutorService，我们可以调用ExecutorService.shutdownNow()方法。这个动作将跳过所有正在执行的任务和被提交还没有执行的任务。但是它并不对正在执行的任务做任何保证，有可能它们都会停止，也有可能执行完成。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p><a href="https://www.cnblogs.com/Transkai/p/11230734.html">Java 线程池ExecutorService详解</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ExecutorService</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PermissionsDispatcher</title>
    <link href="/2020/12/03/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/PermissionsDispatcher/"/>
    <url>/2020/12/03/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/PermissionsDispatcher/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PermissionsDispatcher是一个基于注解、帮助开发者简单处理Android 6.0系统中的运行时权限的开源库。避免了开发者编写大量繁琐的样板代码。</p><h2 id="注解列表"><a href="#注解列表" class="headerlink" title="注解列表"></a>注解列表</h2><div class="table-container"><table><thead><tr><th style="text-align:left">注解</th><th style="text-align:left">必须</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">@RuntimePermissions</td><td style="text-align:left">是</td><td style="text-align:left">注解在其内部需要使用运行时权限的Activity或Fragment上</td></tr><tr><td style="text-align:left">@NeedsPermission</td><td style="text-align:left">是</td><td style="text-align:left">注解在需要调用运行时权限的方法上，当用户给予权限时会执行该方法</td></tr><tr><td style="text-align:left">@OnShowRationale</td><td style="text-align:left">否</td><td style="text-align:left">注解在用于向用户解释为什么需要调用该权限的方法上，只有当第一次请求权限被用户拒绝，下次请求权限之前会调用</td></tr><tr><td style="text-align:left">@OnPermissionDenied</td><td style="text-align:left">否</td><td style="text-align:left">注解在当用户拒绝了权限请求时需要调用的方法上</td></tr><tr><td style="text-align:left">@OnNeverAskAgain</td><td style="text-align:left">否</td><td style="text-align:left">注解在当用户选中了授权窗口中的不再询问复选框后并拒绝了权限请求时需要调用的方法，一般可以向用户解释为何申请此权限，并根据实际需求决定是否再次弹出权限请求对话框</td></tr></tbody></table></div><p><em>注意：私有方法不能被注解！</em></p><h2 id="简单使用方法（以相机权限为例）"><a href="#简单使用方法（以相机权限为例）" class="headerlink" title="简单使用方法（以相机权限为例）"></a>简单使用方法（以相机权限为例）</h2><ol><li>打开bulid.gradle(Module)添加依赖</li></ol><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">dependencies</span> &#123;<br>  <span class="hljs-attribute">implementation</span> <span class="hljs-string">&quot;org.permissionsdispatcher:permissionsdispatcher:<span class="hljs-variable">$&#123;latest.version&#125;</span>&quot;</span><br>  annotationProcessor <span class="hljs-string">&quot;org.permissionsdispatcher:permissionsdispatcher-processor:<span class="hljs-variable">$&#123;latest.version&#125;</span>&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ol><li><p>AndroidManifest.xml中添加权限<br><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201203123324.png" alt="添加权限">  </p></li><li><p>在需要运行权限的Activity上添加@RuntimePermissions<br><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201203123501.png" alt="@RuntimePermissions"></p></li><li><p>在需要调用运行时权限的方法上添加@NeedsPermission并标注所需权限</p></li></ol><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201203123613.png" alt="@NeedsPermission"></p><ol><li>使用MainActivityPermissionsDispatcher.startCameraWithPermissionCheck(this)来调用第四步中创建的方法。其中，startCameraWithPermissionCheck中的startCamera需与第四步中的方法名一致。即调用XXX方法使用MainActivityPermissionsDispatcher.XXXWithPermissionCheck(this)</li></ol><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201203123840.png" alt="调用"></p><ol><li>重写该Activity的onRequestPermissionsResult()方法，其方法内调用MainActivityPermissionsDispatcher的onRequestPermissionsResult()方法</li></ol><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@Override</span><br>public void onRequestPermissionsResult(int requestCode, <span class="hljs-variable">@NonNull</span> String[] permissions, <span class="hljs-variable">@NonNull</span> int[] grantResults) &#123;<br>    <span class="hljs-selector-tag">super</span><span class="hljs-selector-class">.onRequestPermissionsResult</span>(requestCode, permissions, grantResults);<br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> delegate the permission handling to generated method</span><br>    <span class="hljs-selector-tag">MainActivityPermissionsDispatcher</span><span class="hljs-selector-class">.onRequestPermissionsResult</span>(this, requestCode, grantResults);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h2><p><a href="https://github.com/permissions-dispatcher/PermissionsDispatcher">https://github.com/permissions-dispatcher/PermissionsDispatcher</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PermissionsDispatcher</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存原语</title>
    <link href="/2020/12/01/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%8E%9F%E8%AF%AD/"/>
    <url>/2020/12/01/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%8E%9F%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="C-内存原语"><a href="#C-内存原语" class="headerlink" title="C++内存原语"></a>C++内存原语</h1><h2 id="内存分配操作"><a href="#内存分配操作" class="headerlink" title="内存分配操作"></a>内存分配操作</h2><div class="table-container"><table><thead><tr><th>分配</th><th>释放</th><th>类属</th><th>可否重载</th></tr></thead><tbody><tr><td>malloc()</td><td>free()</td><td>C 函数</td><td>不可</td></tr><tr><td>new</td><td>delete</td><td>C++ 表达式</td><td>不可</td></tr><tr><td>::operator new()</td><td>::operator delete()</td><td>C++ 函数</td><td>可</td></tr><tr><td>allocator::allocate()</td><td>allocator::deallocate</td><td>C++ 标准库</td><td>可自由设计并予以搭配任何容器</td></tr></tbody></table></div><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>new实际上在内部执行了三个步骤：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">Complex *pc;<span class="hljs-comment">//实际上会执行以下三步</span><br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">/* 1 */</span> <span class="hljs-keyword">void</span> mem = <span class="hljs-keyword">operator</span> <span class="hljs-built_in"><span class="hljs-keyword">new</span></span> (<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Complex));  <span class="hljs-comment">// allocate 申请内存空间</span><br>    <span class="hljs-comment">/* 2 */</span> pc = <span class="hljs-built_in"><span class="hljs-keyword">static_cast</span></span>(mem);                      <span class="hljs-comment">// cast 类型转换</span><br>    <span class="hljs-comment">/* 3 */</span> pc-&gt;Complex::<span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);                 <span class="hljs-comment">// construct 调用构造函数</span><br>    <span class="hljs-comment">// 注意：只有编译器才可以像上面那样直接呼叫 ctor</span><br>&#125;<br><span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (std::bad_alloc) &#123;<br>    <span class="hljs-comment">// 若 allocation 失败，就不执行 constructor </span><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>在GCC只能由编译器调用构造函数，而VC6下可以自己调用构造函数。而析构函数没有这种限制。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br>    <span class="hljs-comment">//....</span><br>&#125;<br><br>A* pA = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>);<br>pA-&gt;A::<span class="hljs-built_in">A</span>(<span class="hljs-number">3</span>);                    <span class="hljs-comment">//in VC6 : ctor. this=000307A8 id=3</span><br>  <span class="hljs-comment">//in GCC : [Error] cannot call constructor </span><br><span class="hljs-keyword">delete</span> pA; <br></code></pre></div></td></tr></table></figure></li></ul><p><code>operator new</code> 的操作：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// ...\vc98\crt\src\newop2.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> std::<span class="hljs-keyword">nothrow_t</span> &amp;_THROW0())</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// try to allocate size bytes</span><br>    <span class="hljs-keyword">void</span> *p;<br>    <span class="hljs-keyword">while</span> ((p = <span class="hljs-built_in">malloc</span>(size)) == <span class="hljs-number">0</span>)<span class="hljs-comment">//当分配失败时</span><br>    &#123;<br>        <span class="hljs-comment">// buy more memory or return null pointer</span><br>        <span class="hljs-function">__TRY_BEGIN</span><br><span class="hljs-function">        <span class="hljs-title">if</span> <span class="hljs-params">(_callnewh(size) == <span class="hljs-number">0</span>)</span> <span class="hljs-keyword">break</span></span>;<br>        _CATCH(std::bad_alloc)  <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>        _CATCH_END<br>    &#125;   <br>&#125;<br></code></pre></div></td></tr></table></figure><p>在上面代码段中：</p><ul><li><code>const std::nothrow_t &amp;_THROW0()</code>：指示该函数应返回空指针以报告分配失败，而不是引发异常。</li><li><code>_callnewh()</code>：当分配失败时执行这个函数，这个函数由我们自己编写，让我们可以借此机会释放一些内存。</li></ul><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>delete实际上在内部执行了两个步骤：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">Complex *pc = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">delete</span> pc;<span class="hljs-comment">//实际上会执行以下两条代码</span><br><br>pc-&gt;~<span class="hljs-built_in">Complex</span>();         <span class="hljs-comment">// 调用析构函数</span><br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span> <span class="hljs-params">(pc)</span></span>;   <span class="hljs-comment">// 释放内存</span><br></code></pre></div></td></tr></table></figure><p><code>operator delete</code>：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// ...\vc98\crt\src\delop.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> __cdelc <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *p)</span> __<span class="hljs-title">THROW0</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// free an allocated object</span><br>    <span class="hljs-built_in">free</span>(p);<span class="hljs-comment">//实际上就调用了一个free</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="array-new-和-array-delete"><a href="#array-new-和-array-delete" class="headerlink" title="array new 和 array delete"></a>array new 和 array delete</h2><ul><li>所有编译器的malloc和free都会分配cookie。</li><li>一个类的析构函数<strong>没有意义</strong>的话，<strong>array new</strong>后不使用<strong>array delete</strong>也可以。</li></ul><h2 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h2><p><strong>作用：将对象构建在一个已经分配好的内存中</strong>。</p><p>没有所谓的<strong>placement delete</strong>，因为placement new根本没分配内存。或者说与<strong>placement new</strong>相对应的<strong>operator delete</strong>为<strong>placement delete</strong>。</p><p>用法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;new&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span>;</span><br><span class="hljs-keyword">char</span>* buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Complex)*<span class="hljs-number">3</span>];<br>Complex* pc = <span class="hljs-built_in"><span class="hljs-keyword">new</span></span>(buf) <span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">//placement new在此</span><br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">delete</span>[] buf;<br></code></pre></div></td></tr></table></figure><p>在<code>new(buf)Complex(1,2)</code>内部：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">/* 1 */</span> <span class="hljs-keyword">void</span> mem = <span class="hljs-keyword">operator</span> <span class="hljs-built_in"><span class="hljs-keyword">new</span></span> (<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Complex),buf);<br>    <span class="hljs-comment">/* 2 */</span> pc = <span class="hljs-keyword">static_cast</span>&lt;Complex*&gt;(mem);                  <br>    <span class="hljs-comment">/* 3 */</span> pc-&gt;Complex::<span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);             <br>&#125;<br><span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (std::bad_alloc) &#123;<br>    <span class="hljs-comment">// 若 allocation 失败，就不执行 constructor </span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>而上述代码中的<code>operator new</code> 的操作实际上就返回了一个指针。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span>,<span class="hljs-keyword">void</span>* loc)</span></span>&#123;<span class="hljs-keyword">return</span> loc;&#125;<br></code></pre></div></td></tr></table></figure><p>即<strong>指针pc</strong>和<strong>指针buf</strong>都指向同一个地址。</p><p>注意：<strong>placement new</strong>或指<code>new(p)</code>，或指<code>::operator new(size,void*)</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>不应该直接调用构造和析构函数，而是用<code>new</code>和<code>delete</code></li><li>虽然析构函数可以被直接调用，但是也不应该直接调用。若是析构函数中需要释放系统资源，那么析构函数被调用多次，资源也将被释放多次。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更新UI方法</title>
    <link href="/2020/11/23/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E6%9B%B4%E6%96%B0UI%E6%96%B9%E6%B3%95/"/>
    <url>/2020/11/23/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E6%9B%B4%E6%96%B0UI%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="view-post-Runnable-action"><a href="#view-post-Runnable-action" class="headerlink" title="view.post(Runnable action)"></a>view.post(Runnable action)</h2><p>假如该方法是在子线程中</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br>textView.post(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            textView.setText(<span class="hljs-string">&quot;更新textView&quot;</span>);<br>            <span class="hljs-comment">//还可以更新其他的控件</span><br>            imageView.setBackgroundResource(R.drawable.update);<br>        &#125;<br>    &#125;);<br><br></code></pre></div></td></tr></table></figure><p>这是view自带的方法，比较简单，如果你的子线程里可以得到要更新的view的话，可以用此方法进行更新。</p><p>view还有一个方法view.postDelayed(Runnable action, long delayMillis)用来延迟发送。</p><h2 id="activity-runOnUiThread-Runnable-action"><a href="#activity-runOnUiThread-Runnable-action" class="headerlink" title="activity.runOnUiThread(Runnable action)"></a>activity.runOnUiThread(Runnable action)</h2><p>假如该方法是在子线程中</p><p>注意：context 对象要是 主线程中的MainActivity，这样强转才可以。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateUI</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Context context)</span> </span>&#123;<br>        ((MainActivity) context).runOnUiThread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">//此时已在主线程中，可以更新UI了</span><br>            &#125;<br>        &#125;);<br>    &#125;<br><br></code></pre></div></td></tr></table></figure><p>如果没有上下文（context），试试下面的方法：<br>1.用view.getContext()可以得到上下文。<br>2.跳过context直接用new Activity().runOnUiThread(Runnable action)来切换到主线程。</p><h2 id="Handler机制"><a href="#Handler机制" class="headerlink" title="Handler机制"></a>Handler机制</h2><p>首先在主线程中定义Handler，Handler mainHandler = new Handler();（必须要在主线程中定义才能操作主线程，如果想在其他地方定义声明时要这样写Handler mainHandler = new Handler(Looper.getMainLooper())，来获取主线程的 Looper 和 Queue ）</p><p>获取到 Handler 后就很简单了，用handler.post(Runnable r)方法把消息处理放在该 handler 依附的消息队列中（也就是主线程消息队列）。</p><h3 id="1-假如该方法是在子线程中"><a href="#1-假如该方法是在子线程中" class="headerlink" title="1.假如该方法是在子线程中"></a>1.假如该方法是在子线程中</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br>Handler mainHandler = <span class="hljs-keyword">new</span> Handler(Looper.getMainLooper());<br>mainHandler.post(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//已在主线程中，可以更新UI</span><br>    &#125;<br>&#125;);<br><br></code></pre></div></td></tr></table></figure><p>Handler还有下面的方法：<br>1.postAtTime(Runnable r, long uptimeMillis); //在某一时刻发送消息<br>2.postAtDelayed(Runnable r, long delayMillis); //延迟delayMillis毫秒再发送消息</p><h3 id="2-假设在主线程中"><a href="#2-假设在主线程中" class="headerlink" title="2.假设在主线程中"></a>2.假设在主线程中</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br>Handler myHandler = <span class="hljs-keyword">new</span> Handler() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span>(msg.what) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                <span class="hljs-comment">//更新UI等</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                 <span class="hljs-comment">//更新UI等</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>之后可以把 mainHandler 当做参数传递在各个类之间，当需要更新UI时，可以调用sendMessage一系列方法来执行handleMessage里的操作。</p><p>假设现在在子线程了</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  *获取消息，尽量用obtainMessage()方法，查看源码发现，该方法节省内存。</span><br><span class="hljs-comment">  *不提倡用Messenger msg=new Messenger()这种方法，每次都去创建一个对象，肯定不节省内存啦！</span><br><span class="hljs-comment">  */</span><br>Message msg = myHandler.obtainMessage();<br>msg.what = <span class="hljs-number">0</span>; <span class="hljs-comment">//消息标识</span><br>myHandler.sendMessage(msg); <span class="hljs-comment">//发送消息</span><br></code></pre></div></td></tr></table></figure><p>如上代码，只是发送了个消息标识，并没有传其他参数。<br>如果想传递参数，可以这样：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br>msg.what = <span class="hljs-number">1</span>;  <span class="hljs-comment">//消息标识</span><br>msg.arg1=<span class="hljs-number">2</span>;   <span class="hljs-comment">//存放整形数据，如果携带数据简单，优先使用arg1和arg2，比Bundle更节省内存。</span><br>msg.arg2=<span class="hljs-number">3</span>;   <span class="hljs-comment">//存放整形数据</span><br>Bundle bundle=<span class="hljs-keyword">new</span> Bundle();<br>bundle.putString(<span class="hljs-string">&quot;dd&quot;</span>,<span class="hljs-string">&quot;adfasd&quot;</span>);<br>bundle.putInt(<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-number">5</span>);<br>msg.setData(bundle);<br>msg.obj=bundle;   <span class="hljs-comment">//用来存放Object类型的任意对象</span><br>myHandler.sendMessage(msg); <span class="hljs-comment">//发送消息</span><br><br></code></pre></div></td></tr></table></figure><p>总结： msg.obj它的功能比较强大一下，至于它和利用Bundle传递数据，那个会效率高一些，更节省内存一些。个人认为：从传递数据的复杂程度看，由简单到复杂依次使用，arg1， setData(), obj。会比较好一些。</p><p>当然可以用简化方法sendEmptyMessage(int what)来减少不必要的代码，这样写：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">myHandler.sendEmptyMessage(<span class="hljs-number">0</span>); <span class="hljs-comment">//其实内部实现还是和上面一样</span><br></code></pre></div></td></tr></table></figure><p>发送消息的其他方法有：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br>endEmptyMessageAtTime(<span class="hljs-keyword">int</span> what, <span class="hljs-keyword">long</span> uptimeMillis); <span class="hljs-comment">//定时发送空消息</span><br>sendEmptyMessageDelayed(<span class="hljs-keyword">int</span> what, <span class="hljs-keyword">long</span> delayMillis); <span class="hljs-comment">//延时发送空消息</span><br>sendMessageAtTime(Message msg, <span class="hljs-keyword">long</span> uptimeMillis); <span class="hljs-comment">//定时发送消息</span><br>sendMessageDelayed(Message msg, <span class="hljs-keyword">long</span> delayMillis); <span class="hljs-comment">//延时发送消息</span><br>sendMessageAtFrontOfQueue(Message msg); <span class="hljs-comment">//最先处理消息（慎用）</span><br><br></code></pre></div></td></tr></table></figure><h2 id="使用AsyncTask"><a href="#使用AsyncTask" class="headerlink" title="使用AsyncTask"></a>使用AsyncTask</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 该类中方法的执行顺序依次为：onPreExecute, doInBackground, onPostExecute</span><br><span class="hljs-comment">  */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAsyncTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AsyncTask</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">Integer</span>, <span class="hljs-title">String</span>&gt; </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 主线程中执行</span><br><span class="hljs-comment">         * 在execute()被调用后首先执行</span><br><span class="hljs-comment">         * 一般用来在执行后台任务前对UI做一些标记</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPreExecute</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.onPreExecute();<br>            System.out.println(<span class="hljs-string">&quot;MyAsyncTask.onPreExecute&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 子线程中执行，执行一些耗时操作，关键方法</span><br><span class="hljs-comment">         * 在执行过程中可以调用publishProgress(Progress... values)来更新进度信息。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">doInBackground</span><span class="hljs-params">(String... params)</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;MyAsyncTask.doInBackground&quot;</span>);<br>            <span class="hljs-comment">//只是模拟了耗时操作</span><br>            <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    count++;<br>                    publishProgress((count % <span class="hljs-number">100</span>) * <span class="hljs-number">10</span>);<br>                    Thread.sleep(<span class="hljs-number">3000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// publishProgress((int) ((count / (float) total) * 100));</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;耗时操作执行完毕&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 主线程中执行</span><br><span class="hljs-comment">         * 在调用publishProgress(Progress... values)时，此方法被执行，直接将进度信息更新到UI组件中</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onProgressUpdate</span><span class="hljs-params">(Integer... values)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.onProgressUpdate(values);<br>            progressBar.setProgress(values[<span class="hljs-number">0</span>]);<br>            textView.setText(<span class="hljs-string">&quot;loading...&quot;</span> + values[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;%&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;MyAsyncTask.onProgressUpdate&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 在主线程中，当后台操作结束时，此方法将会被调用</span><br><span class="hljs-comment">         * 计算结果将做为参数传递到此方法中，直接将结果显示到UI组件上。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPostExecute</span><span class="hljs-params">(String aVoid)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.onPostExecute(aVoid);<br>            System.out.println(<span class="hljs-string">&quot;MyAsyncTask.onPostExecute aVoid=&quot;</span> + aVoid);<br>            textView.setText(aVoid);<br>        &#125;<br><br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 主线程中执行</span><br><span class="hljs-comment">         * 当异步任务取消后的，会回调该函数。在该方法内可以更新UI</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCancelled</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.onCancelled();<br>            System.out.println(<span class="hljs-string">&quot;MyAsyncTask.onCancelled&quot;</span>);<br>            progressBar.setProgress(<span class="hljs-number">0</span>);<br>            textView.setText(<span class="hljs-string">&quot;0&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCancelled</span><span class="hljs-params">(String s)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.onCancelled(s);<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>注意：doInBackground方法是在子线程中，所以，我们在这个方法里面执行耗时操作。同时，由于其返回结果会传递到onPostExecute方法中，而onPostExecute方法工作在UI线程，这样我们就在这个方法里面更新ui，达到了异步更新ui的目的。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p><a href="https://blog.csdn.net/da_caoyuan/article/details/52931007">【Android】快速切换到主线程更新UI的几种方法</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>STL：其他</title>
    <link href="/2020/11/22/C++/STL/STL%EF%BC%9A%E5%85%B6%E4%BB%96/"/>
    <url>/2020/11/22/C++/STL/STL%EF%BC%9A%E5%85%B6%E4%BB%96/</url>
    
    <content type="html"><![CDATA[<h2 id="一个万用的哈希函数"><a href="#一个万用的哈希函数" class="headerlink" title="一个万用的哈希函数"></a>一个万用的哈希函数</h2><ul><li><p>哈希函数设计不好，哈希冲突的概率会很大</p></li><li><p>哈希函数可以写成下面几种形式：（以<code>class Customer&#123;&#125;;</code>为例）</p><ul><li><p>仿函数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerHash</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">std::<span class="hljs-keyword">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Customer&amp; c)</span> <span class="hljs-keyword">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> ...<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//使用</span><br>unordered_set&lt;Customer,CustomerHash&gt; custset;<br></code></pre></div></td></tr></table></figure></li><li><p>函数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">customer_hash_func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Cunstomer&amp; c)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> ...<br>&#125;;<br><br><span class="hljs-comment">//使用，相较于仿函数会麻烦些</span><br><span class="hljs-function">unordered_set&lt;Customer,<span class="hljs-title">size_t</span><span class="hljs-params">(*)</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Customer&amp;)</span>&gt;</span><br><span class="hljs-function"><span class="hljs-title">custset</span><span class="hljs-params">(<span class="hljs-number">20</span>,customer_hash_func)</span></span>;<br></code></pre></div></td></tr></table></figure></li><li><p>偏特化版本</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std <span class="hljs-comment">//必須放在 std 內 </span><br>&#123;<br><span class="hljs-keyword">template</span>&lt;&gt; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hash</span>&lt;</span>MyString&gt; <span class="hljs-comment">//這是為了 unordered containers </span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">size_t</span> </span><br><span class="hljs-function"><span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MyString&amp; s)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> hash&lt;string&gt;()(<span class="hljs-built_in">string</span>(s.<span class="hljs-built_in">get</span>()));  &#125;  <br>    <span class="hljs-comment">//借用現有的 hash&lt;string&gt; (in ...\include\c++\bits\basic_string.h)</span><br>&#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>一个万用的哈希函数：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f4bffe2eac8d6a071babb44115bb418e-86291.png"  /></p></li></ul><h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><h2 id="type-traits"><a href="#type-traits" class="headerlink" title="type traits"></a>type traits</h2><h2 id="moveable"><a href="#moveable" class="headerlink" title="moveable"></a>moveable</h2><ul><li>差距的多少和内存中的碎片情况息息相关</li><li>move操作是浅拷贝，速度很快，但是很危险。最好是在原来的元素不使用的时候再进行move操作</li><li>对于临时对象，编译器会自动查找move版本的copy。前提是有定义move的方法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL：迭代器</title>
    <link href="/2020/11/18/C++/STL/STL%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2020/11/18/C++/STL/STL%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>在标准库中，算法的形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> iterator&gt;</span><br><span class="hljs-function"><span class="hljs-title">Algorithm</span><span class="hljs-params">(iterator itr1,iterator itr2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> iterator,<span class="hljs-keyword">typename</span> Cmp&gt;</span><br><span class="hljs-function"><span class="hljs-title">Algorithm</span><span class="hljs-params">(iterator itr1,iterator itr2,Cmp comp)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="迭代器的作用"><a href="#迭代器的作用" class="headerlink" title="迭代器的作用"></a>迭代器的作用</h2><ul><li>在标准库中算法是个<strong>function template</strong>，而其他都是<strong>class template</strong><ul><li><strong>function template</strong>没有所谓特化，一般使用重载手法。</li></ul></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/fbd310e5be02fd856bced0cb146cd7c1-1025d.png"  /></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/275f8ff4e3f5caa867c4eb223ba08072-a54af.png"  /></p><ul><li><p>标准库中迭代器的分类不是靠枚举类型，而是靠对象</p><ul><li><p>迭代器的分类也影响到算法的效率</p></li><li><p>可根据继承关系来确定编译期模板参数的具体类型（泛化、特化）</p></li><li>算法内部可以根据具体对象<strong>强化</strong>算法。比如一个类中的成员变量不含指针类型，那么这个对象的Big-tree是不重要的，拷贝类型算法可以根据这个类的特点来强化算法。</li><li>在for循环中使用迭代器来终止循环会比较慢，而类似头尾指针相减的这种（和具体数比较）的方式会比较快</li></ul></li><li><p>由于<strong>output iterator</strong>(例ostream_itreator)是<strong>write-only</strong>，无法像<strong>forward iterator</strong>那般可以<strong>read</strong>，所以不能有类似<em>`result != </em>first`的动作，因此需设计出专属版本。</p></li><li><p>在算法的模板参数中，设计者只能用模板参数的名字来暗示使用者如何使用。</p></li></ul><h3 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9cf1875bf6956855508dcab5d3cdd2c9-8ae89.png"  /></p><ul><li>如果算法结构已经搭建好了，而对于不同的类型有不同的执行需求的话，可以考虑重载操作符。如下图：</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/22e5b15a7cbac739fa25ff314518f672-4f1f7.png"  /></p><p>还有一些特殊的迭代器适配器：<code>ostream_iterator</code>和<code>istream_iterator</code>。具体如下图：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9a6a41624ebdcfc3d59fba9f33bcb901-da2ce.png"  /></p><ul><li>ostream_iterator的迭代器会将值传到控制台</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/bc7706fc2c052df652c65f4f92cb3add-bd53c.png"  /></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/caecc79f3ad9b0120e62c2c2c4117971-c53c4.png"  /></p><ul><li>如果初始化<code>istream_iterator</code>没有参数，那么它就是一个<strong>end-of-stream-iterator</strong>，指向<strong>istream</strong>的最后位置，和容器的<code>end()</code>一个道理。</li><li>当一个含参的<code>istream_iterator</code>被创建时，它会立刻等待输入，即在<code>operator++</code>中阻塞。比如<code>istream_iterator&lt;int&gt; iit(cin);</code>。</li></ul><h2 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h2><p><strong>STL中的仿函数只为算法服务。</strong></p><p>STL中的仿函数分为三大类：</p><ul><li>算术类（x-y）</li><li>逻辑运算类（x&amp;&amp;y）</li><li>相对关系类（x&gt;y）</li></ul><h3 id="可适配条件"><a href="#可适配条件" class="headerlink" title="可适配条件"></a>可适配条件</h3><p>STL规定每个Adaptable Function 都应该挑选适当者继承，因为Function Adapter将会提问。不然<strong>无法融入STL库</strong>。虽然说不继承也能编译成功运行成功，但是一些STL的操作就用不了。比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Arg</span>,<span class="hljs-keyword">class</span> <span class="hljs-title">Result</span>&gt;</span><span class="hljs-comment">//一个操作数</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">unary_function</span>&#123;</span><br><span class="hljs-keyword">typedef</span> Arg argument_type;<br><span class="hljs-keyword">typedef</span> Result result_type;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Arg1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title">Arg2</span>,<span class="hljs-keyword">class</span> <span class="hljs-title">Result</span>&gt;</span><span class="hljs-comment">//两个操作数</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binary_function</span>&#123;</span><br><span class="hljs-keyword">typedef</span> Arg1 first_argument_type;<br><span class="hljs-keyword">typedef</span> Arg2 second_argument_type;<br><span class="hljs-keyword">typedef</span> Result result_type;<br>&#125;<br><br><span class="hljs-comment">//例子（STL中的）</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">less</span>:</span><span class="hljs-keyword">public</span> binary_function&lt;T,T,<span class="hljs-keyword">bool</span>&gt;&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; x,<span class="hljs-keyword">const</span> T&amp; y)</span><span class="hljs-keyword">const</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> x&lt;y;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h3><ul><li>编译器会自动进行类型推导</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a13bd6f63f4103cfe8ba3535abf18a4a-bc003.png" alt="函数适配器"  /></p><ul><li>新版本中，bind已实现规范用法。如下图：</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/605c3141d262b9a9c14dfa75cd440707-f1e39.png"  /></p><ul><li>其中，_1，_2，_3为占位符。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL：容器</title>
    <link href="/2020/11/13/C++/STL/STL%EF%BC%9A%E5%AE%B9%E5%99%A8/"/>
    <url>/2020/11/13/C++/STL/STL%EF%BC%9A%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="STL六大部件"><a href="#STL六大部件" class="headerlink" title="STL六大部件"></a>STL六大部件</h2><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8fc0bded58b81b6d96a516528d6f8c41-af505.png" alt="关系"></p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>$O(1)或O(c)$：常数时间</li><li>$O(n)$：线性时间</li><li>$O(log_2{n})$：次线性时间</li><li>$O(n^2)$：平方时间</li><li>$O(n^3)$：立方时间</li><li>$O(2^n)$：指数时间</li><li>$O(nlog_2{n})$：介于线性及二次方成长的中间之行为模式</li></ul><h3 id="前闭后开区间"><a href="#前闭后开区间" class="headerlink" title="前闭后开区间"></a>前闭后开区间</h3><ul><li><p><code>begin</code>：指向第一个元素</p></li><li><p><code>end</code>：指向最后一个元素的下一个元素</p></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8a140f7be2e3e0c027357761ef6dd359-02bfc.png" alt="前闭后开区间"></p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="结构与分类"><a href="#结构与分类" class="headerlink" title="结构与分类"></a>结构与分类</h4><ul><li>Sequence Containers：循序式容器<ul><li>Array：数组</li><li>Vector：向量</li><li>Deque：双向队列</li><li>List：链表（双向环状链表）</li><li>Forward-List：单向链表</li></ul></li><li>Associative Containers：关联式容器<ul><li>Set/Multiset（底层是红黑树）</li><li>Map/Multimap（底层是红黑树）</li></ul></li><li>Unordered Containers：不定序容器<ul><li>Unordered  Set/Multiset</li><li>Unordered  Map/Multimap</li></ul></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6cfe93a4229328bde82237f6743d260a-a9f92.png" alt="结构与分类"></p><h4 id="使用经验"><a href="#使用经验" class="headerlink" title="使用经验"></a>使用经验</h4><ul><li>array：使用二分查找<code>bsearch()</code>之前需要用<code>qsort()</code>进行排序。</li><li>vector：使用二分查找<code>bsearch()</code>之前需要用<code>sort()</code>进行排序。</li><li>获取容器起始地址用<code>Container.data()</code>。</li><li>所有的算法都是全局的模板函数</li><li>标准库提供的算法如果在容器里也有提供，那么就用容器里的，会更快</li></ul><h3 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h3><p>普通使用不建议用分配器，对于分配和释放内存使用new、delete、malloc、free即可。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/3581061f0c009b1c3a4c3c6b0e58bde5-3c6c8.png" alt="分配器"></p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="OOP-vs-GP"><a href="#OOP-vs-GP" class="headerlink" title="OOP vs. GP"></a>OOP vs. GP</h3><ul><li><p>OOP：企图将datas和methods关联在一起</p></li><li><p>GP：是将datas和methods分开来</p><ul><li>Containers和Algorithms团队可各自闭门造车，其间以Iterator沟通即可。</li><li>Algorithms通过Iterator确定操作范围，并通过Iterator取用Containers元素。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/015e3b07b02f49daaa00064df2cfea0e-2ace9.png" alt="GP"></p></li><li><p>所有Algorithms，其内最终涉及元素本身的操作，无非就是比大小。</p></li><li><p>新版本的STL都遵循了Handle-Body的设计原则。</p></li></ul><h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><h4 id="须知"><a href="#须知" class="headerlink" title="须知"></a>须知</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a260b867c46971748bffeffdc042c0f8-dc287.png" alt="须知"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f674b93cc84802c5a067657e0ed40dc3-7b5dd.png" alt="须知"></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/c11eea35e05921569966c536db823441-a2260.png" alt="例子"></p><h3 id="分配器-1"><a href="#分配器-1" class="headerlink" title="分配器"></a>分配器</h3><ul><li>无论怎样的内存分配操作，最后都是malloc。malloc视环境而定，比如windows\linux。</li><li>调用malloc分配的内存会比我们原本意图中所需要的内存会大。我们要的内存越小，这些额外的内存占比越大。</li><li>VC6+、BC++、GCC2.9的<code>allocator</code>只是以<code>::operator new</code>和<code>::operator delete</code>完成<code>allocate()</code>和<code>deallocate()</code>，没有任何特殊设计。</li></ul><h3 id="容器，结构与分类"><a href="#容器，结构与分类" class="headerlink" title="容器，结构与分类"></a>容器，结构与分类</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8021b54cb711137f50fcf6b5a1a2664c-a318b.png" alt="容器，结构与分类"></p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="成员结构"><a href="#成员结构" class="headerlink" title="成员结构"></a>成员结构</h4><p><strong>G2.9版本：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b715fde3789a0501fdb5d3c9ae46944c-69fb2.png" alt=""></p><ul><li>结构体<code>_list_node</code>的<code>void_pointer</code>实际上指的就是自己这个类型。</li></ul><p><strong>G4.9版本：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/c934a9c4da75f69acb4d7ba487d83d4e-25388.png" alt="G4.9版本"></p><ul><li>List实际上没有大小，因为它继承的父类大小为8，所以List的大小才为8。</li><li><code>end()</code>指向的是<code>_List_impl</code>中的<code>_M_node</code>，<code>begin()</code>指向的是<code>_M_node</code>中的<code>_M_next</code>。</li></ul><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p><strong>G2.9版本：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/73e37be9941993b4030ca243f7274845-a87d0.png" alt="迭代器"></p><ul><li>除了Array和Vector的迭代器，其他容器的迭代器必须是class类型。只有class类型才能设计出”聪明“的动作。</li></ul><p><strong>G4.9版本：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5f7c225801940e0704568741c2a875fa-be049.png" alt="G4.9版本："></p><h4 id="前自增与后自增"><a href="#前自增与后自增" class="headerlink" title="前自增与后自增"></a>前自增与后自增</h4><p><strong>G2.9版本：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/150855421610ef9fbb5b5d7fbe6e1f35-97b34.png" alt="迭代器"></p><ul><li><p><code>*this</code>中的<strong>*</strong>作用的是指针，而迭代器中重载的<code>operator*</code>作用的是迭代器对象。</p></li><li><p>后自增<code>self operator++(int)</code>中的<code>int</code>的作用就是为了给编译器看，符合编译器的语法而已。</p></li><li>后自增一共调用了两次拷贝构造。</li><li>至于后自增返回值、前自增返回引用，是因为参照<code>int</code>类型而设计的规范。（图左下角）</li></ul><h4 id="迭代器的设计原则"><a href="#迭代器的设计原则" class="headerlink" title="迭代器的设计原则"></a>迭代器的设计原则</h4><p><strong>迭代器是容器和算法的桥梁。</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/4d92bd2d2d7a87367f42df3a009d0941-1439b.png" alt="**迭代器是容器和算法的桥梁。**"></p><p>在算法执行的时候，它需要知道迭代器中的：</p><ul><li><strong>分类</strong>（<code>iterator_category()</code>）。它想要知道迭代器的移动性质，比如有些迭代器只能往前走，有些迭代器能往后走。这样它才能采取最佳的移动方式。（图中序号1）</li><li><strong>距离</strong>（<code>difference_type</code>）。就是两个迭代器指针间的距离，应该用什么<strong>type</strong>来表现。（图中序号2）</li><li><strong>类型</strong>（<code>value_type</code>）。即迭代器指向的容器的类型。（图中序号3）</li><li><strong>指针</strong>。从未在C++标准库中被使用。</li><li><strong>引用</strong>。从未在C++标准库中被使用。</li></ul><p>关于这五种的<strong>迭代器关联类型</strong>，具体看下图：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/04d6adf9cc6b1a8ab5807b0356085659-656e3.png" alt="迭代器关联类型"></p><p>以上的方式只有迭代器为class类型时，算法才能获取<strong>迭代器关联类型</strong>。因为标准库的算法是个函数模板，传迭代器和指针都可以，所以当迭代器是指针类型时，以上的处理方式是错误的。为了能应对不同类型的迭代器，算法可以使用萃取机制（<code>iterator_traits</code>），来获取所需信息。</p><h5 id="萃取机制"><a href="#萃取机制" class="headerlink" title="萃取机制"></a>萃取机制</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5255bf7b118a98cb8fbc6e777ffe8c3f-8ffdd.png" alt="萃取机制"></p><p>萃取机中使用了模板偏特化统一了接口：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/fa0e9abfd730734cd7ed183ac9aa76ae-15879.png" alt="萃取机中使用了模板偏特化"></p><p>注意<strong>const指针</strong>的传入，具体看上图右下角。</p><h6 id="萃取机例子"><a href="#萃取机例子" class="headerlink" title="萃取机例子"></a>萃取机例子</h6><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/299e805e56c24b3f39926f39d1fa84a8-1aa6f.png" alt="萃取机例子"></p><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><ul><li><p>TR1是C++过渡版本</p></li><li><p>创建Array时必须指定Array大小 </p></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/0d80554f3f92f6215d591158ced0157b-a0c91.png" alt="必须指定大小"></p><p>和Vector一样，Array的指针也是<code>native pointer</code>。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/43a93960338ab9efbfe3c104646baf22-14cd4.png" alt="Array"></p><h3 id="Forward-List"><a href="#Forward-List" class="headerlink" title="Forward-List"></a>Forward-List</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/cf072de20e41d9542dbd366698ea944e-0bdc6.png" alt="Forward-List"></p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><h4 id="向量结构"><a href="#向量结构" class="headerlink" title="向量结构"></a>向量结构</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f2f9fb58f888ffc9ab8f7f330a6b5bef-40eb7.png" alt="容器"></p><ul><li>向量为倍增式扩容。mscv下是1.5倍扩容,gnu c上是2倍扩容</li><li>向量用三个指针（迭代器）控制整个容器，其中<ul><li><code>start</code>：指向向量起始位置</li><li><code>finish</code>：元素最后一个元素的下一个地址</li><li><code>end_of_storage</code>：指向向量的最后一个位置</li></ul></li><li>向量的一些量化指标：<ul><li><code>size</code>：向量中的元素个数</li><li><code>capacity</code>：向量的最大容量</li></ul></li><li><code>vector</code>需要注意迭代器失效，失效的时机出现在<code>vector</code>在<code>push_back</code>一个新元素后，可能发生的倍增扩容。所以当扩容发生时，由于<code>vector</code>更换了存放位置，指向原来位置的迭代器会失效。比如在更换位置之前，使用某个变量存储了迭代器。</li></ul><p>G4.9版本：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7900b61baeb08459c96f5ec131302b85-85010.png" alt="G4.9版本："></p><h4 id="向量扩容示范"><a href="#向量扩容示范" class="headerlink" title="向量扩容示范"></a>向量扩容示范</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/c0640655601dcb97f9b843aa79b75bfd-a5b6d.png" alt="向量扩容示范"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/fa25a0efee12df1a7217ba4c3dc8fc3e-b3b72.png" alt="向量扩容示范"></p><h4 id="向量的迭代器"><a href="#向量的迭代器" class="headerlink" title="向量的迭代器"></a>向量的迭代器</h4><p>向量的迭代器实际上就是个指针，因为向量在物理空间上连续，可以随机访问，指针完全能应付。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/4357a1735241c0f4cf7b3337675d956f-6790e.png" alt="向量的迭代器"></p><p><strong>向量迭代器实质：使用适配器模式包装了<code>_Tp*</code>。</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9c0c3d525067662be0409430e3292dc5-320b0.png" alt="向量的迭代器"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/bc3b907f33ed8b45e0e48b829e291481-a2259.png" alt="向量迭代器"></p><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9de2d27b24e5bb52cd08544ed87c55cf-1f51e.png" alt="deque"></p><p>注意：控制中心的map是指向vector的，以后也是2倍增长。（map左右两边一般留有剩余空间，用于前后插入元素）。</p><p>参考：<a href="https://blog.csdn.net/JMW1407/article/details/106930972">C++ 标准模板库（STL）_序列式容器—— deque(模拟连续空间)（侯捷老师）</a></p><ol><li><p>map在初始化时会预留前后两个节点，并将start和finish迭代器指向map的存放数据的头尾区域。</p></li><li><p>在元素插入/删除时如果越过缓冲区，那么下一个/该缓冲区将会被申请/释放。</p></li><li>deque主要使用迭代器来模拟连续空间，迭代器的主要参数为：</li></ol><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// 保持与容器的联结</span><br>  T* cur;       <span class="hljs-comment">// 此迭代器所指之缓冲区中的现行元素</span><br>  T* first;     <span class="hljs-comment">// 此迭代器所指之缓冲区的头</span><br>  T* last;      <span class="hljs-comment">// 此迭代器所指之缓冲区的尾（含备用空间）</span><br>  map_pointer node; <span class="hljs-comment">//指向管控中心</span><br></code></pre></div></td></tr></table></figure><ol><li>保持连续性的关键在于源代码中的迭代器做了大量的操作符重载。</li><li>插入操作若不在两端，那么将会计算插入点离前后的距离谁比较短，取短的区域进行位移。</li></ol><h4 id="stack和queue"><a href="#stack和queue" class="headerlink" title="stack和queue"></a>stack和queue</h4><ul><li><p>stack内含了一个deque底层容器，所有事情交由deque去做：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">tmpplate&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>,<span class="hljs-keyword">class</span> <span class="hljs-title">Sequence</span> =</span> deque&lt;T&gt;&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">stack</span>&#123;</span><br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>stack和queue都可以选择list或deque作为底层容器，但是默认的deque速度会比较快。原因是list需要执行new操作，这种操作是普通语句的两百倍左右的时间，所以用deque。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">stack&lt;string,list&lt;string&gt;&gt; c;<br>queue&lt;string,list&lt;string&gt;&gt; c;<br></code></pre></div></td></tr></table></figure></li><li><p>stack和queue都不允许遍历，也不提供iterator。</p></li><li><p>stack可选择vector作为底层结构，但是queue不可选择vector作为底层结构（虽然编译器会通过，但是当queue使用pop行为时，编译器会报错，因为编译器只会做局部检查，就是你用了什么编译器就会检查什么）。</p></li><li><p>stack和queue都不可以选择set或map做底层结构（编译器也会通过，但是不能用，原因同上）。</p></li></ul><h3 id="RB-TREE"><a href="#RB-TREE" class="headerlink" title="RB-TREE"></a>RB-TREE</h3><ul><li>我们不应使用红黑树的迭代器改变元素值（因为元素有严谨的排列规则）。编程层面并未阻止此事。如此设计是正确的，因为红黑树即将为set和map服务（作为其底部支持），而map允许元素的data被改变，只有元素的key才是不可以被改变的。</li><li>红黑树提供遍历操作以及迭代器，按正常规则++遍历，便能获得排序状态。</li><li>红黑树提供两种插入操作：<code>insert_unique()</code>和<code>insert_equal()</code>。<ul><li>insert_unique()：key一定在树中独一无二。</li><li>insert_equal()：key一定在树中可以重复。</li></ul></li><li>节点value包含了key和data。key为标识，data是数据的组合。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/98f547d907431f6fe65ca78692299d05-f4830.png"  /></p><ul><li><p>红黑树的初始化所需要的参数中：</p><ul><li><p>keyofvalue：告诉红黑树，key要怎么拿。</p></li><li><p>compare：两个元素怎么比大小。</p></li></ul></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7dc9204bb800fef539f165e869569856-1059b.png" alt="红黑树的结构中"></p><ul><li><p>红黑树的结构中：</p><ul><li><p>node_count：节点数量</p></li><li><p>header：红黑树的头节点</p></li><li><p>key_compare：key的大小比较规则，应该是各function object。注意：仿函数的理论大小为0，因为它没有任何的数据。但是编译器会把它的大小变为1。因为编译器对于大小为0的class，编译出来的大小永远为1。</p></li></ul></li></ul><h4 id="set和multiset"><a href="#set和multiset" class="headerlink" title="set和multiset"></a>set和multiset</h4><ul><li>set和multiset都以红黑树作为底层结构，因此有元素自动排序的特性。排序的依据是key，而set和multiset的value和key二合一，也就是说value就是key。</li><li>set和multiset提供遍历操作以及迭代器，按照正常规则++遍历，便能获得排序状态。</li><li>我们无法使用set和multiset的迭代器改变元素值（因为key有严谨的排序规则）。set和multiset的迭代器是const类型的迭代器，所以无法改变元素内容。</li><li>set元素的key必须独一无二，因此它的<code>insert()</code>是红黑树的<code>insert_unique()</code>。</li><li>multiset的key可以重复，因此它的<code>insert()</code>是红黑树的<code>insert_equal()</code>。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/226616eb2ac701fa588539126010962a-e27d3.png" alt="set和multiset"></p><h4 id="map和multimap"><a href="#map和multimap" class="headerlink" title="map和multimap"></a>map和multimap</h4><ul><li>map/multimap以红黑树为底层结构。因此有元素自动排序特性。排序的依据是key。</li><li>map/multimap提供遍历操作及迭代器。按照正常规则++遍历，就能获得排序状态。</li><li>我们无法使用map/multimap的迭代器改变元素的key，但可以用它来改变元素的data。因此map/multimap内部自动将user指定的key type设为const，如此便能禁止user对元素的key赋值。即map构造RB-Tree的过程中，将<code>Key</code>和<code>T</code>组成了<code>pair&lt;const Key,T&gt;</code>传入了RB-Tree。</li><li>set元素的key必须独一无二，因此它的<code>insert()</code>是红黑树的<code>insert_unique()</code>。</li><li>multimap的key可以重复，因此它的<code>insert()</code>是红黑树的<code>insert_equal()</code>。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/09daead3d61f70f9e1c77fffde7773dc-57418.png" alt="map和multimap"></p><ul><li>multimap无法使用<code>[]</code>做插入，但是map可以。map的<code>operator[]</code>的操作是：如果找到该元素，便返回。若没有找到，就在map中合适的地方创建一个。<img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/2ef03b91b6d7aa257b7b8e3b027eefb8-7dd08.png" alt="map"></li></ul><h3 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/76b4b14163eb272f541bfe777f2532f8-c19db.png" style="zoom:50%;" /></p><ul><li>如果挂的链表太长的话，就要把它们打散，变成散列表。</li><li>如果元素个数比桶的个数还要多，就很危险。这种情况下就把桶增加两倍。然后重新将元素放进桶里。 <strong>所以桶的数量永远大于元素个数。</strong></li><li>翻倍(<strong>rehash</strong>)的原则是：原来的桶数量为53，那么就先翻倍成106，再找到离106最近最小的质数97。</li><li>桶中元素越少，查找和插入速度越快。所以有时候需要翻倍处理。</li><li>桶的数量已经写死了。<img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/269af63212907508fb2d06d575a17b06-ffe8e.png" style="zoom: 50%;" /></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/c3f6b7978fec1d67994c72d1affb0968-13938.png" style="zoom:50%;" /></p><ul><li><code>ExtractKey</code>：如何获取存储数据的Key，即仿函数</li><li><code>EqualKey</code>：如何比较两个Key相等，即仿函数</li><li><p>标准库提供了针对基本类型的hash函数，实质上就是把传入的东西再返回。而<code>char*</code>和<code>string</code>会通过一些换算形成哈希值。</p></li><li><p><strong>unordered</strong>容器的底层就是<strong>hashtable</strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>腾讯云访问github</title>
    <link href="/2020/08/26/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AE%BF%E9%97%AEgithub/"/>
    <url>/2020/08/26/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AE%BF%E9%97%AEgithub/</url>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo vi /etc/hosts<br></code></pre></div></td></tr></table></figure><p>添加：</p><figure class="highlight accesslog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs accesslog"># github<br><span class="hljs-number">204.232.175.78</span> http://documentcloud.github.com<br><span class="hljs-number">207.97.227.239</span> http://github.com<br><span class="hljs-number">204.232.175.94</span> http://gist.github.com<br><span class="hljs-number">107.21.116.220</span> http://help.github.com<br><span class="hljs-number">207.97.227.252</span> http://nodeload.github.com<br><span class="hljs-number">199.27.76.130</span> http://raw.github.com<br><span class="hljs-number">107.22.3.110</span> http://status.github.com<br><span class="hljs-number">204.232.175.78</span> http://training.github.com<br><span class="hljs-number">207.97.227.243</span> http://www.github.com<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Picgo设置腾讯云COS图床</title>
    <link href="/2020/08/09/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Picgo%E8%AE%BE%E7%BD%AE%E8%85%BE%E8%AE%AF%E4%BA%91COS%E5%9B%BE%E5%BA%8A/"/>
    <url>/2020/08/09/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Picgo%E8%AE%BE%E7%BD%AE%E8%85%BE%E8%AE%AF%E4%BA%91COS%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="1-设置COS版本"><a href="#1-设置COS版本" class="headerlink" title="1. 设置COS版本"></a>1. 设置COS版本</h2><p>设置为v5</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-04_18-43-06.png" alt="设置COS版本"></p><h2 id="2-设置SecretId、SecretKey和APPID"><a href="#2-设置SecretId、SecretKey和APPID" class="headerlink" title="2. 设置SecretId、SecretKey和APPID"></a>2. 设置SecretId、SecretKey和APPID</h2><p>打开腾讯云COS控制台，进入API密钥管理。找到<strong>SecretId</strong>、<strong>SecretKey</strong>和<strong>APPID</strong>并填入。若无密钥请先新建。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-04_18-44-10.png" alt="密钥管理"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-04_18-45-34.png" alt="密钥管理"></p><h2 id="3-设置存储空间名和存储区域"><a href="#3-设置存储空间名和存储区域" class="headerlink" title="3. 设置存储空间名和存储区域"></a>3. 设置存储空间名和存储区域</h2><p>创建存储桶时，关键的一步是要将权限设置为公有读私有写。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-04_18-52-11.png" alt="创建存储桶"></p><p><strong>存储空间名</strong>填入<strong>存储桶名称</strong>，然后<strong>存储区域</strong>填入<strong>所属地域</strong>，后面括号里面的内容。比如我的是ap-shanghai。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-04_18-53-10.png" alt="存储桶列表"></p><h2 id="4-设置指定存储路径"><a href="#4-设置指定存储路径" class="headerlink" title="4. 设置指定存储路径"></a>4. 设置指定存储路径</h2><p>这个存储路径指的是，你上传的文件在COS存储桶中所存放的位置。比如我的存储桶名称是左上角的images-12577xxxxx，然后我在这个存储桶中创建了一个blogs文件夹。现在我想把我上传的图片放在blogs文件夹里，那PicGo中的存储路径就要填入<strong>blogs/</strong>(bilogs后面的<strong>/</strong>不能省略)。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-04_18-55-26.png" alt="设置指定存储路径"></p><h2 id="5-设定自定义域名"><a href="#5-设定自定义域名" class="headerlink" title="5. 设定自定义域名"></a>5. 设定自定义域名</h2><p>这个自定义域名与PicGo在你上传图片成功后返回的网址相关，格式为<strong><a href="https://存储桶名称.cos.存储区域.myqcloud.com">https://存储桶名称.cos.存储区域.myqcloud.com</a></strong>。</p><p>比如我的是<a href="https://images-1257780535.cos.ap-shanghai.myqcloud.com。">https://images-1257780535.cos.ap-shanghai.myqcloud.com。</a></p><p>当我上传图片以后，PicGo返回给我一个<strong><a href="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-04_18-55-26.png">https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-04_18-55-26.png</a></strong>这个网址，将这个网址粘贴到你写的markdown文件即可。</p><h2 id="6-最终效果"><a href="#6-最终效果" class="headerlink" title="6. 最终效果"></a>6. 最终效果</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210204192315.png" alt="最终效果1"  /></p><p>图片上传后，在腾讯云COS中的指定路径下能找到上传的图片，就说明成功了。</p>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>腾讯云</tag>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Clion配置git</title>
    <link href="/2020/05/21/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Clion%E9%85%8D%E7%BD%AEgit/"/>
    <url>/2020/05/21/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Clion%E9%85%8D%E7%BD%AEgit/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文标题虽然是CLion配置Git，但是亲测全家桶下的其他软件也能按照同样的方法进行配置</p><p>在开始之前，需要确保你有Git账号且在本地环境已经配置好Git</p><h2 id="1-创建本地仓库"><a href="#1-创建本地仓库" class="headerlink" title="1. 创建本地仓库"></a>1. 创建本地仓库</h2><p>打开CLion，导航栏-&gt;VCS-&gt;Create Git Repository，选择你需要作为Git仓库的文件夹</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416141113.png" alt="选择文件夹"></p><p>之后打开我们选择的文件夹，发现已经被初始化</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416141350.png" alt="文件夹被初始化"></p><p>然后CLion的导航栏也相应发生了变化</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416141442.png" alt="导航栏变化"></p><h2 id="2-关联远程仓库"><a href="#2-关联远程仓库" class="headerlink" title="2. 关联远程仓库"></a>2. 关联远程仓库</h2><p>先复制我们Github上需要关联仓库的地址</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416142138.png" alt="点击复制"></p><p>接着打开CLion，依次Git-&gt;Manage Remotes</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416141653.png" alt="Manage Remotes"></p><p>点击加号，将刚才复制的git地址填入并确认</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416142253.png" alt="填入地址"></p><p>等待即可</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416142357.png" alt="等待"></p><h2 id="3-使用方法"><a href="#3-使用方法" class="headerlink" title="3. 使用方法"></a>3. 使用方法</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416155818.png" alt="提交"></p>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>IDE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>问题归纳</title>
    <link href="/2020/05/11/C++/%E9%97%AE%E9%A2%98%E5%BD%92%E7%BA%B3/"/>
    <url>/2020/05/11/C++/%E9%97%AE%E9%A2%98%E5%BD%92%E7%BA%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="引用的生命周期？"><a href="#引用的生命周期？" class="headerlink" title="引用的生命周期？"></a>引用的生命周期？</h2><h2 id="友元函数是类成员函数吗？"><a href="#友元函数是类成员函数吗？" class="headerlink" title="友元函数是类成员函数吗？"></a>友元函数是类成员函数吗？</h2><p>不是，友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。</p><p>参考：<a href="https://www.runoob.com/cplusplus/cpp-friend-functions.html">C++ 友元函数</a></p><h2 id="如何判断操作符重载放在类里还是类外？"><a href="#如何判断操作符重载放在类里还是类外？" class="headerlink" title="如何判断操作符重载放在类里还是类外？"></a>如何判断操作符重载放在类里还是类外？</h2><p>赋值（=）、下标（[]）、调用（()）和成员访问箭头（-&gt;）运算符必须是成员（函数）。</p><p>参考：<a href="https://blog.csdn.net/qq_29344757/article/details/78820189">为什么有的操作符重载函数只能是成员函数?</a></p><h2 id="初始化列表的优势体现在哪里？"><a href="#初始化列表的优势体现在哪里？" class="headerlink" title="初始化列表的优势体现在哪里？"></a>初始化列表的优势体现在哪里？</h2><ol><li>类成员中存在常量，如<code>const int a</code>,只能用初始化不能复制</li><li>类成员中存在引用，同样只能使用初始化不能赋值</li><li>提高效率</li></ol><p>参考：<a href="https://www.cnblogs.com/wuyepeng/p/9863763.html">使用初始化列表的好处</a></p><h2 id="为什么要虚的析构函数？"><a href="#为什么要虚的析构函数？" class="headerlink" title="为什么要虚的析构函数？"></a>为什么要虚的析构函数？</h2><p>这样做是为了当<strong>用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用</strong>。当然，<strong>并不是要把所有类的析构函数都写成虚函数</strong>。因为当类里面有虚函数的时候，编译器会给类添加一个虚函数表，里面来存放虚函数指针，这样就会增加类的存储空间。所以，只有<strong>当一个类被用来作为基类的时候，才把析构函数写成虚函数</strong>。</p><p>参考：<a href="https://blog.csdn.net/zhangjingyangguang/article/details/21549991">为什么要用虚析构函数</a></p><h2 id="什么叫做对象切割？"><a href="#什么叫做对象切割？" class="headerlink" title="什么叫做对象切割？"></a>什么叫做对象切割？</h2><h2 id="什么叫做编译转换？"><a href="#什么叫做编译转换？" class="headerlink" title="什么叫做编译转换？"></a>什么叫做编译转换？</h2><h2 id="返回值的生命周期"><a href="#返回值的生命周期" class="headerlink" title="返回值的生命周期"></a>返回值的生命周期</h2><h2 id="操作符重载作为成员函数和非成员函数时的优缺点"><a href="#操作符重载作为成员函数和非成员函数时的优缺点" class="headerlink" title="操作符重载作为成员函数和非成员函数时的优缺点"></a>操作符重载作为成员函数和非成员函数时的优缺点</h2><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><h2 id="为什么要用基类指针指向派生类？"><a href="#为什么要用基类指针指向派生类？" class="headerlink" title="为什么要用基类指针指向派生类？"></a>为什么要用基类指针指向派生类？</h2><p>在基类与派生类之间，有一个<strong>规定</strong>：派生类对象的地址可以赋给指向基类对象的指针变量（简称<strong>基类指针</strong>），即基类指针也可以指向派生类对象。为什么有这一规定呢？因为它可以实现<strong>多态性</strong>，即向不同的对象发送同一个消息，不同的对象在接受时会产生不同的行为。</p><p>基类指针可以指向基类对象；派生类指针可以指向派生类对象；基类指针可以指向派生类对象（无需强制转换），但只能引用基类中有的成员； 派生类指针指向基类对象，会引发语法错误。但派生类指针通过强制转换可指向基类对象。可是该动作很危险：若引用对象中不村在的派生类成员，会得到错误的结果。</p><p>参考：<a href="https://blog.csdn.net/hk121/article/details/81165391">为什么要用基类指针指向派生类对象？</a></p><h2 id="动态联编和静态联编"><a href="#动态联编和静态联编" class="headerlink" title="动态联编和静态联编"></a>动态联编和静态联编</h2><h2 id="向上转型和向下转型"><a href="#向上转型和向下转型" class="headerlink" title="向上转型和向下转型"></a>向上转型和向下转型</h2><h2 id="释放一个空指针会有什么问题"><a href="#释放一个空指针会有什么问题" class="headerlink" title="释放一个空指针会有什么问题"></a>释放一个空指针会有什么问题</h2><h2 id="c-类的内存模型"><a href="#c-类的内存模型" class="headerlink" title="c++类的内存模型"></a>c++类的内存模型</h2><h2 id="内存分配中的cookie"><a href="#内存分配中的cookie" class="headerlink" title="内存分配中的cookie"></a>内存分配中的cookie</h2><p>在malloc为用户分配内存的时候，除了分配用户本身的内存，还会在内存前后加上两个cookie，来记录分配了多少内存，这样在调用free函数的时候才能准确的回收内存。因此每次调用malloc函数都会产生cookie消耗。</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/338043328">C++内存管理（malloc和free中的cookie）</a></p><h2 id="Debug模式下多出来的内存空间干嘛用？Debugger-Header、no-man-land？"><a href="#Debug模式下多出来的内存空间干嘛用？Debugger-Header、no-man-land？" class="headerlink" title="Debug模式下多出来的内存空间干嘛用？Debugger Header、no man land？"></a>Debug模式下多出来的内存空间干嘛用？Debugger Header、no man land？</h2><h2 id="静态数据什么时候会被创建"><a href="#静态数据什么时候会被创建" class="headerlink" title="静态数据什么时候会被创建"></a>静态数据什么时候会被创建</h2><h2 id="纯虚函数的定义"><a href="#纯虚函数的定义" class="headerlink" title="纯虚函数的定义"></a>纯虚函数的定义</h2><h2 id="C-子类拥有和父类的同名非虚函数会发生什么情况？"><a href="#C-子类拥有和父类的同名非虚函数会发生什么情况？" class="headerlink" title="C++子类拥有和父类的同名非虚函数会发生什么情况？"></a>C++子类拥有和父类的同名非虚函数会发生什么情况？</h2><h2 id="C-函数签名"><a href="#C-函数签名" class="headerlink" title="C++函数签名"></a>C++函数签名</h2><h2 id="栈对象如何向上转型"><a href="#栈对象如何向上转型" class="headerlink" title="栈对象如何向上转型"></a>栈对象如何向上转型</h2><h2 id="C-中的原子对象"><a href="#C-中的原子对象" class="headerlink" title="C++中的原子对象"></a>C++中的原子对象</h2><h2 id="C-中的reorder"><a href="#C-中的reorder" class="headerlink" title="C++中的reorder"></a>C++中的reorder</h2><h2 id="C-的异常和底层机制"><a href="#C-的异常和底层机制" class="headerlink" title="C++的异常和底层机制"></a>C++的异常和底层机制</h2><h2 id="C-abort"><a href="#C-abort" class="headerlink" title="C++abort()"></a>C++abort()</h2><h2 id="C-List为什么会有maxsize"><a href="#C-List为什么会有maxsize" class="headerlink" title="C++List为什么会有maxsize?"></a>C++List为什么会有maxsize?</h2><h2 id="C-泛化指针"><a href="#C-泛化指针" class="headerlink" title="C++泛化指针"></a>C++泛化指针</h2><h2 id="C-的malloc详解"><a href="#C-的malloc详解" class="headerlink" title="C++的malloc详解"></a>C++的malloc详解</h2><h2 id="C-序列化"><a href="#C-序列化" class="headerlink" title="C++序列化"></a>C++序列化</h2><h2 id="C-访问级别底层原理？"><a href="#C-访问级别底层原理？" class="headerlink" title="C++访问级别底层原理？"></a>C++访问级别底层原理？</h2><h2 id="C-override"><a href="#C-override" class="headerlink" title="C++override?"></a>C++override?</h2><h2 id="C-如何充分利用CPU时间片？"><a href="#C-如何充分利用CPU时间片？" class="headerlink" title="C++如何充分利用CPU时间片？"></a>C++如何充分利用CPU时间片？</h2><h2 id="C-类中的typedef以及它的空间占用和底层实现？"><a href="#C-类中的typedef以及它的空间占用和底层实现？" class="headerlink" title="C++类中的typedef以及它的空间占用和底层实现？"></a>C++类中的typedef以及它的空间占用和底层实现？</h2><h2 id="C-引用折叠？"><a href="#C-引用折叠？" class="headerlink" title="C++引用折叠？"></a>C++引用折叠？</h2><h2 id="C-嵌入式指针？"><a href="#C-嵌入式指针？" class="headerlink" title="C++嵌入式指针？"></a>C++嵌入式指针？</h2><h2 id="C-类的静态函数能直接被调用吗？"><a href="#C-类的静态函数能直接被调用吗？" class="headerlink" title="C++类的静态函数能直接被调用吗？"></a>C++类的静态函数能直接被调用吗？</h2><p>答：可以。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符:: 就可以访问。 静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。 静态成员函数有一个类范围，他们不能访问类的this 指针。</p><h2 id="C-typename"><a href="#C-typename" class="headerlink" title="C++typename"></a>C++typename</h2><ul><li>typename在下面情况下禁止使用：<ul><li>模板定义之外，即typename只能用于模板的定义中</li><li>非限定类型，比如前面介绍过的<code>int</code>，<code>vector&lt;int&gt;</code>之类</li><li>基类列表中，比如<code>template &lt;class T&gt; class C1 : T::InnerType</code>不能在<code>T::InnerType</code>前面加typename</li><li>构造函数的初始化列表中</li></ul></li><li>如果类型是依赖于模板参数的限定名，那么在它之前<strong>必须</strong>加typename(除非是基类列表，或者在类的初始化成员列表中)</li><li>其它情况下typename是<strong>可选</strong>的，也就是说对于一个不是依赖名的限定名，该名称是可选的，例如<code>vector&lt;int&gt; vi;</code></li></ul><p>参考：<a href="https://feihu.me/blog/2014/the-origin-and-usage-of-typename/">知无涯之C++ typename的起源与用法</a></p><h2 id="C-volatile"><a href="#C-volatile" class="headerlink" title="C++volatile?"></a>C++volatile?</h2><p>一般说来，volatile用在如下的几个地方：</p><ul><li>中断服务程序中修改的供其它程序检测的变量需要加 volatile；</li><li>多任务环境下各任务间共享的标志应该加 volatile；</li><li>存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对它的读写都可能由不同意义；</li></ul><p>参考：<a href="https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777432.html">C/C++中volatile关键字详解</a></p><h2 id="C-创建对象用中括号"><a href="#C-创建对象用中括号" class="headerlink" title="C++创建对象用中括号{}"></a>C++创建对象用中括号{}</h2><h2 id="C-如何刷新缓冲区及其原理"><a href="#C-如何刷新缓冲区及其原理" class="headerlink" title="C++如何刷新缓冲区及其原理"></a>C++如何刷新缓冲区及其原理</h2><h2 id="在C-拷贝构造函数中使用初始化列表"><a href="#在C-拷贝构造函数中使用初始化列表" class="headerlink" title="在C++拷贝构造函数中使用初始化列表"></a>在C++拷贝构造函数中使用初始化列表</h2><p>参考：<a href="https://blog.csdn.net/justin12zhu/article/details/9174491">在C++拷贝构造函数中使用初始化列表</a></p><h2 id="C-释放一个空指针？"><a href="#C-释放一个空指针？" class="headerlink" title="C++释放一个空指针？"></a>C++释放一个空指针？</h2><h2 id="C-中进程的栈空间为多少？"><a href="#C-中进程的栈空间为多少？" class="headerlink" title="C++中进程的栈空间为多少？"></a>C++中进程的栈空间为多少？</h2><h2 id="C-中被调用函数如何被释放？返回值在什么时候被获取？"><a href="#C-中被调用函数如何被释放？返回值在什么时候被获取？" class="headerlink" title="C++中被调用函数如何被释放？返回值在什么时候被获取？"></a>C++中被调用函数如何被释放？返回值在什么时候被获取？</h2><h2 id="断言和异常的区别和使用场景"><a href="#断言和异常的区别和使用场景" class="headerlink" title="断言和异常的区别和使用场景?"></a>断言和异常的区别和使用场景?</h2>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows环境下的git配置</title>
    <link href="/2020/04/16/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84git%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/04/16/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84git%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="1-软件的安装"><a href="#1-软件的安装" class="headerlink" title="1.软件的安装"></a>1.软件的安装</h2><h3 id="1-1-软件下载"><a href="#1-1-软件下载" class="headerlink" title="1.1 软件下载"></a>1.1 软件下载</h3><p>下载地址：<a href="http://www.git-scm.com/download/">http://www.git-scm.com/download/</a></p><h3 id="1-2-软件安装"><a href="#1-2-软件安装" class="headerlink" title="1.2 软件安装"></a>1.2 软件安装</h3><p>配置详情：<a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html">https://www.cnblogs.com/xueweisuoyong/p/11914045.html</a></p><h2 id="2-SSH的配置"><a href="#2-SSH的配置" class="headerlink" title="2.SSH的配置"></a>2.SSH的配置</h2><h3 id="1-1-设置公钥私钥（若已有请跳过）"><a href="#1-1-设置公钥私钥（若已有请跳过）" class="headerlink" title="1.1 设置公钥私钥（若已有请跳过）"></a>1.1 设置公钥私钥（若已有请跳过）</h3><p>打开CMD，输入<strong>ssh-keygen -t rsa -C “你的邮箱地址”</strong>，按照提示输入并完成。</p><h3 id="1-2-设置Git"><a href="#1-2-设置Git" class="headerlink" title="1.2 设置Git"></a>1.2 设置Git</h3><p>打开Git CMD，输入<strong>git config —global user.name “用户名”</strong>，<strong>git config —global user.email “你的邮箱地址”</strong>。</p><h3 id="1-3-设置github"><a href="#1-3-设置github" class="headerlink" title="1.3 设置github"></a>1.3 设置github</h3><p>打开github个人主页，在右上角的头像里选择<strong>Settings</strong>，然后依次<strong>SSH and GPG keys</strong>-&gt;<strong>New SSH key</strong>。其中Title中写一个适当的标题，再将本地电脑<strong>C:\Users.ssh\id_rsa.pub</strong>中的内容复制到Key里面即可。</p>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存对齐</title>
    <link href="/2020/01/27/C++/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    <url>/2020/01/27/C++/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是内存对齐"><a href="#什么是内存对齐" class="headerlink" title="什么是内存对齐"></a>什么是内存对齐</h2><p>内存对齐（Memory alignment），也叫字节对齐。现代计算机中内存空间都是按照 Byte 划分的，CPU按照双字、字、字节访问存储内存，并通过总线进行传输（CPU把内存当成是一块一块的，块的大小可以是2、4、8、16字节大小，因此CPU在读取内存时是一块一块进行读取的。）。从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问<strong>特定类型变量</strong>(结构体、联合体等)的时候经常在<strong>特定的内存地址</strong>访问，这就需要各种类型数据按照<strong>一定的规则</strong>在空间上排列，而不是顺序的一个接一个的摆放。若未经一定规则的对齐，CPU的访址操作与总线的传输操作将会异常的复杂，所以现代编译器中都会对内存进行自动的对齐。</p><p><strong>假设</strong><br>在结构体里面有一个整型变量 a。CPU如果想取出结构体里面的变量a，首先装载结构体的首地址，然后根据偏移地址获得变量a：</p><ol><li>在内存对齐的情况下（如图1），由于变量a从偏移地址为 “0” 的位置开始，所以CPU获取a只需一步就能完成。</li><li>在内存未对齐的情况下（如图2），由于变量a从偏移地址 “2” 的位置开始，所以CPU需要先获取 “0” - “3” 内存地址里面的值，并取出其中的 “2” - “3” 中的内容。接着再获取 “4” - “7” 内存地址里面的值，并取出 “4” - “5” 中的内容。最后，将前后两次操作取得的最终值拼接，就获得了变量a。<br><img src="https://img-blog.csdnimg.cn/20200817155349568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkzOTQ4Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="内存"><br>显而易见，CPU在处理两种情况下的内存，效率和时间的差距是非常大的。</li></ol><h2 id="内存对齐的规则"><a href="#内存对齐的规则" class="headerlink" title="内存对齐的规则"></a>内存对齐的规则</h2><ol><li>数据成员对齐规则：第一个数据成员从<strong>特定类型变量</strong>的起始地址(即偏移量为0)开始存放。之后每个数据成员的偏移量K，由<strong>内存对齐系数</strong>和<strong>该数据成员长度</strong>之间最小的数值M的非负整数倍N决定。总结下来就是：K = M * N。如有需要，编译器会在数据成员之间加上填充字节(internal adding)。</li><li>特定类型变量对齐规则：在数据成员完成各自对齐之后，<strong>特定类型变量</strong>本身也要进行对齐。编译器会从<strong>内存对齐系数</strong>和<strong>该特定类型变量中，最大的数据成员的长度</strong>中取得最小值M。与数据成员对齐规则类似，整个特定类型变量的长度是M的非负整数倍N。即满足：sizeof(<em>特定类型变量</em>) = M * N。如有需要，编译器会在最后一个数据成员之后加上填充字节(trailing padding)。</li></ol><h2 id="内存对齐实例"><a href="#内存对齐实例" class="headerlink" title="内存对齐实例"></a>内存对齐实例</h2><h3 id="几个简单的例子"><a href="#几个简单的例子" class="headerlink" title="几个简单的例子"></a>几个简单的例子</h3><h4 id="类的内存对齐"><a href="#类的内存对齐" class="headerlink" title="类的内存对齐"></a>类的内存对齐</h4><h5 id="pragma-pack-n"><a href="#pragma-pack-n" class="headerlink" title="#pragma pack(n)"></a>#pragma pack(n)</h5><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">st1</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">char</span> a;<br><span class="hljs-keyword">int</span>  b;<br><span class="hljs-keyword">short</span> c;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">st2</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">short</span> c;<br><span class="hljs-keyword">char</span>  a;<br><span class="hljs-keyword">int</span>   b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;sizeof(st1) is &quot;</span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(st1) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sizeof(st2) is &quot;</span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(st2) &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(st1) is <span class="hljs-number">12</span><br><span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(st2) is <span class="hljs-number">8</span><br></code></pre></div></td></tr></table></figure><p>由上，我们发现两个问题：</p><ol><li>st1和st2两个结构体sizeof的值不应该都是1(char)+4(int)+2(short)=7byte吗？</li><li><p>st1和st2两个结构体的数据成员完全一样，只是它们的摆放(声明)顺序不一样，为什么最后sizeof出来的结果会不一样？</p><p>根据前文关于内存对齐的描述，我们可以这样解决(VC6默认内存对齐系数为8，以下未指定的内存对齐系数皆为8)：</p><p><strong>结构体st1内存分配过程（结果如下图）</strong></p></li><li>char a ：因为是第一个数据成员，所以它的偏移地址为”0”。</li><li>int b ：内存对齐系数为8，而sizeof(int)为4，两者最小为4。根据规则1，变量b的偏移地址应该为4的非负整数倍。此时该内存块可分配的偏移地址有效值为 “1”…，但是显然，”1”、”2”、”3” 这三个偏移地址并不是4的非负整数倍，只有偏移地址 “4” 符合要求。所以，变量b的偏移地址是 “4”，内存空间为 “4” - “7” 一共四个字节。</li><li>由于变量a从 “0” 开始只占了一个字节，而变量b是从 “4” 开始的，所以”1” - “3” 这三块内存是空闲的。此时编译器会自动填充(这里暂时用0代替填充的值，下文同)，填充的值由编译器来决定(这也就是为什么memcmp不能用来比较两个结构体，memcmp是逐个字节对比的，当字节对齐时，中间的填充部分是随机的，所以比较的结果是不正确的)。</li><li>short c：内存对齐系数为8，而sizeof(short)为2，两者最小为2。根据规则1，变量c的偏移地址应该为2的非负整数倍。此时该内存块可分配的偏移地址有效值为 “8”…，而 “8” 正好符合条件，所以变量c的偏移地址为 “8” ，内存空间为 “8” - “9” 一共两个字节。</li><li>至此，st1中的三个数据成员已经全部分配完毕，接下来就要考虑整体对齐。因为内存对齐系数为8，而st1中最大的数据成员b的长度为4，所以两者中最小为4。此时sizeof(st1)为10，而10并不是4的非负整数倍，不符合规则2，所以编译器会在 “10” - “11” 自动填充，使sizeof(st1)为12，符合规则2。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200817122054212.png#pic_center" alt="str1"></p><p><strong>结构体st2内存分配过程（结果如下图）</strong></p><ol><li>short c ：因为是第一个数据成员，所以它的偏移地址为”0”，内存地址为 “0” - “1” 一共两个字节。</li><li>char a ：内存对齐系数为8，而sizeof(char)为1，两者最小为1。根据规则1，变量a的偏移地址应该为1的非负整数倍。此时该内存块可分配的偏移地址有效值为 “2”…，而偏移地址 “2” 正好符合要求。所以，变量a的偏移地址是 “2”，内存地址为 “2” 一共一个字节。</li><li>int b：内存对齐系数为8，而sizeof(int)为4，两者最小为4。根据规则1，变量b的偏移地址应该为4的非负整数倍。此时该内存块可分配的偏移地址有效值为 “3”…，显然, “3” 并不符合要求，而 “4” 符合要求。所以，变量b的偏移地址为 “4”,内存地址为 “4” - “7” 一共4个字节。</li><li>由于变量a从 “2” 开始只占了一个字节，而变量b是从 “4” 开始的，所以 “3” 这块内存是空闲的，编译器会自动填充。</li><li><p>至此，st2中的三个数据成员已经全部分配完毕，接下来就要考虑整体对齐。因为内存对齐系数为8，而st2中最大的数据成员b的长度为4，所以两者中最小为4。此时sizeof(st2)为8，而8是4的非负整数倍，符合规则2，所以编译器不做任何处理。</p><p><img src="https://img-blog.csdnimg.cn/20200817151951314.png#pic_center" alt="st2"></p></li></ol><h2 id="修改内存对齐系数"><a href="#修改内存对齐系数" class="headerlink" title="修改内存对齐系数"></a>修改内存对齐系数</h2><p>若需修改内存对齐系数，需用：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> pack(n) <span class="hljs-comment">// n为内存对齐系数</span></span><br></code></pre></div></td></tr></table></figure></p><blockquote><p>参考资料：<br><a href="https://zhuanlan.zhihu.com/p/93822540">C/C++中内存对齐问题的一些理解</a><br><a href="https://songlee24.github.io/2014/09/20/memory-alignment/">C/C++内存对齐</a><br><a href="https://blog.csdn.net/N1neDing/article/details/80202103">内存对齐——规则及原因</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>桥模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%EF%BC%9A%E6%A1%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%EF%BC%9A%E6%A1%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度，乃至多个纬度的变化。</li><li>如何应对这种“多维度的变化”？如何利用面向对象技术来使得类型可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>将抽象部分(业务功能)与实现部分(平台实现)分离，使它们都可以独立地变化。 ——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用桥模式之前：</strong></p><p><code>Messager</code>类为父类，由父类派生出来的类用来实现不同平台，而这些<strong>平台类</strong>派生出来的<strong>业务类</strong>，用于完善<strong>平台类</strong>。但是站在<code>Messager</code>的角度来看，<strong>平台类</strong>和<strong>业务类</strong>都是用来完善<code>Messager</code>类。所以<code>Messager</code>类中声明了<strong>平台类</strong>和<strong>业务类</strong>所需的纯虚函数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Messager</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(string username, string password)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(string message)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span></span>=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Messager</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//平台实现 个数n</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerBase</span> :</span> <span class="hljs-keyword">public</span> Messager&#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//**********</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//**********</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//**********</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//**********</span><br>    &#125;<br>&#125;;<br><span class="hljs-comment">//平台实现</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerBase</span> :</span> <span class="hljs-keyword">public</span> Messager&#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//==========</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//==========</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//==========</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//==========</span><br>    &#125;<br>&#125;;<br><br><br><span class="hljs-comment">//业务抽象 个数m</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerLite</span> :</span> <span class="hljs-keyword">public</span> PCMessagerBase &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(string username, string password)</span></span>&#123;<br>        <br>        PCMessagerBase::<span class="hljs-built_in">Connect</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(string message)</span></span>&#123;<br>        <br>        PCMessagerBase::<span class="hljs-built_in">WriteText</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span></span>&#123;<br>        <br>        PCMessagerBase::<span class="hljs-built_in">DrawShape</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerPerfect</span> :</span> <span class="hljs-keyword">public</span> PCMessagerBase &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(string username, string password)</span></span>&#123;<br>        <br>        PCMessagerBase::<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        PCMessagerBase::<span class="hljs-built_in">Connect</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(string message)</span></span>&#123;<br>        <br>        PCMessagerBase::<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        PCMessagerBase::<span class="hljs-built_in">WriteText</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span></span>&#123;<br>        <br>        PCMessagerBase::<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        PCMessagerBase::<span class="hljs-built_in">DrawShape</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerLite</span> :</span> <span class="hljs-keyword">public</span> MobileMessagerBase &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(string username, string password)</span></span>&#123;<br>        <br>        MobileMessagerBase::<span class="hljs-built_in">Connect</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(string message)</span></span>&#123;<br>        <br>        MobileMessagerBase::<span class="hljs-built_in">WriteText</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span></span>&#123;<br>        <br>        MobileMessagerBase::<span class="hljs-built_in">DrawShape</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerPerfect</span> :</span> <span class="hljs-keyword">public</span> MobileMessagerBase &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(string username, string password)</span></span>&#123;<br>        <br>        MobileMessagerBase::<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        MobileMessagerBase::<span class="hljs-built_in">Connect</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(string message)</span></span>&#123;<br>        <br>        MobileMessagerBase::<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        MobileMessagerBase::<span class="hljs-built_in">WriteText</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span></span>&#123;<br>        <br>        MobileMessagerBase::<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        MobileMessagerBase::<span class="hljs-built_in">DrawShape</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//所有类的个数：1+n+m*n</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//编译时装配</span><br>        Messager *m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MobileMessagerPerfect</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>分析以上代码可得：</p><ul><li><p>由于<code>MobileMessagerBase</code>和<code>PCMessagerBase</code>有未实现的虚函数，所以它们依然是纯虚基类，无法实例化</p></li><li><p>分析<code>Messager</code>以及它派生出来的类，会发现实际上<code>Messager</code>这个类设计得不合理，主要功能应该分为两大块：</p><ul><li>由<code>Messager</code>派生的<code>XXXMessagerBase</code>实现的：<code>Login</code>、<code>SendMessage</code>、<code>SendPicture</code></li><li>由<code>XXXMessagerBase</code>派生的<code>XXXMessagerPerfect/Lite</code>实现的：<code>PlaySound</code>、<code>DrawShape</code>、<code>WriteText</code>、<code>Connect</code></li></ul></li><li><p>在本例中，变化方向有两个：</p><ul><li>平台实现：PC端、Mobile端，以后可能还有会Watch端….</li><li>业务抽象：Perfect版、Lite版，同样以后可能还有会EE版….</li></ul><p>所以这两个不同的变化方向，带动了行为的多态实现，也应该往两个方向走，而不应该放在同一个类里。</p></li></ul><p><strong>运用桥模式之后：</strong></p><ul><li>根据变化的维度，分离原先父类里的纯虚函数。此例中，根据<strong>平台实现</strong>和<strong>业务抽象</strong>进行分离。</li><li>参考装饰模式的方法，提取子类中相同类型的变量，往上提出</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Messager</span>&#123;</span><br><span class="hljs-keyword">protected</span>:<br>     MessagerImp* messagerImp;<span class="hljs-comment">//...</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">Messager</span>(MessagerImp* messagerImp)&#123;<span class="hljs-comment">//......</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(string username, string password)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(string message)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span></span>=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Messager</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerImp</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">MessagerImp</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><br><br><span class="hljs-comment">//平台实现 n</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerImp</span> :</span> <span class="hljs-keyword">public</span> MessagerImp&#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//**********</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//**********</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//**********</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//**********</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerImp</span> :</span> <span class="hljs-keyword">public</span> MessagerImp&#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//==========</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//==========</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//==========</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//==========</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//业务抽象 m</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerLite</span> :</span><span class="hljs-keyword">public</span> Messager &#123;<br><br>    <br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(string username, string password)</span></span>&#123;<br>        <br>        messagerImp-&gt;<span class="hljs-built_in">Connect</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(string message)</span></span>&#123;<br>        <br>        messagerImp-&gt;<span class="hljs-built_in">WriteText</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span></span>&#123;<br>        <br>        messagerImp-&gt;<span class="hljs-built_in">DrawShape</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerPerfect</span>  :</span><span class="hljs-keyword">public</span> Messager &#123;<br>      <br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(string username, string password)</span></span>&#123;<br>        <br>        messagerImp-&gt;<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        messagerImp-&gt;<span class="hljs-built_in">Connect</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(string message)</span></span>&#123;<br>        <br>        messagerImp-&gt;<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        messagerImp-&gt;<span class="hljs-built_in">WriteText</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span></span>&#123;<br>        <br>        messagerImp-&gt;<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        messagerImp-&gt;<span class="hljs-built_in">DrawShape</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//类的数目：1+n+m</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//运行时装配</span><br>    MessagerImp* mImp=<span class="hljs-keyword">new</span> <span class="hljs-built_in">PCMessagerImp</span>();<br>    Messager *m =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Messager</span>(mImp);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5d5d18da351868d348b7ed3f2df29f44-16294.png" alt="稳定部分"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>Bridge</strong>模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们。</li><li><strong>Bridge</strong>模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（<strong>即一个类只有一个变化的原因</strong>），复用性比较差。 Bridge模式是比多继承方案更好的解决方法。</li><li>Bridge模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单一职责</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%9A%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%9A%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件系统中，经常面临着”某些结构复杂的对象“的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是它们却拥有比较稳定一致的接口。</li><li>如何应对这种变化？如何向”客户程序（使用这些对象的程序）“隔离出”这些易变对象“，从而使得”依赖这些易变对象的客户程序“不随着需求改变而改变？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象</p><p> ——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用原型模型前：</strong>（借用<strong>工厂模式</strong>的代码，需求和工厂模式一样，只是在本例中，ISplitter的派生类除了有稳定的部分，假设也有剧烈改动的部分）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//抽象类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ISplitter</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//工厂基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SplitterFactory</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">SplitterFactory</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//具体类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySplitter</span> :</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-comment">//具体工厂</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinarySplitter</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TxtSplitter</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">PictureSplitter</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">VideoSplitter</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//mainform</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form<br>&#123;<br>    SplitterFactory*  factory;<span class="hljs-comment">//工厂</span><br><br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">MainForm</span>(SplitterFactory*  factory)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;factory=factory;<br>    &#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span></span>&#123;<br><br>ISplitter * splitter=<br>            factory-&gt;<span class="hljs-built_in">CreateSplitter</span>(); <span class="hljs-comment">//多态new</span><br>        <br>        splitter-&gt;<span class="hljs-built_in">split</span>();<br><br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>但是假设<code>ISplitter</code>派生类构造时需要非常多的资源，比如硬件资源和数据资源，而现在的需求场景又需要不断的创建派生类。这种把资源花费在创建开销上非常的奢侈（比如频繁创建一个数据库实例），所以由此引出一种可以克隆原来已有实例的原型模式，通过克隆降低频繁构造时带来的影响。</p><p><strong>运用原型模式后：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//抽象类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>; <span class="hljs-comment">//通过克隆自己来创建对象</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ISplitter</span>()&#123;&#125;<br><br>&#125;;<br><br><span class="hljs-comment">//具体类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySplitter</span> :</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinarySplitter</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TxtSplitter</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">PictureSplitter</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">VideoSplitter</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form<br>&#123;<br>    ISplitter*  prototype;<span class="hljs-comment">//原型对象</span><br><br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">MainForm</span>(ISplitter*  prototype)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;prototype=prototype;<br>    &#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span></span>&#123;<br><br>ISplitter * splitter=<br>            prototype-&gt;<span class="hljs-built_in">clone</span>(); <span class="hljs-comment">//克隆原型</span><br>        <br>        splitter-&gt;<span class="hljs-built_in">split</span>();<br>        <br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/910596454b87a89a0dd626669ff6d942-d51ba.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>通过克隆自己来创建对象</li><li><strong>Prototype</strong>模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类“拥有”稳定的接口“。</li><li><strong>Prototype</strong>模式对于”如何创建易变类的实体对象“采用”原型克隆“的方法来做，它使得我们可以非常灵活地动态创建”拥有某些稳定接口“的新对象，所需工作仅仅是注册一个新类的对象（即原型），然后在任何需要的地方Clone。</li><li><strong>Prototype</strong>模式中的Clone方法可以利用某些框架中的序列化来实现深拷贝。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对象创建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工厂模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件系统中，经常面临着创建对象的工作；由于需求的变化， 需要创建的对象的具体类型经常变化</li><li>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一 种“封装机制”来避免客户程序和这种“具体对象创建工作”的紧耦合？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。 Factory Method使得一个类的实例化延迟（目的：解耦；手段：虚函数）到子类。 ——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>假设现在有个文件分割器，并且按照需求派生了不同的子类</p><p><strong>运用工厂模式之前：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ISplitter</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySplitter</span> :</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form<br>&#123;<br>TextBox* txtFilePath;<br>TextBox* txtFileNumber;<br>ProgressBar* progressBar;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span></span>&#123;<br><br>ISplitter * splitter=<br>            <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinarySplitter</span>();<span class="hljs-comment">//依赖具体类，编译时绑定，与BinarySplitter为紧耦合</span><br><br>        splitter-&gt;<span class="hljs-built_in">split</span>();<br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>此时的<code>MainForm</code>里面，由于指定了<code>BinarySplitter</code>，导致了编译时绑定。</li><li><code>BinarySplitter</code>为<code>ISplitter</code>的派生类，而业务需求的变动实际上是对<code>BinarySplitter</code>的改变，即<code>ISplitter</code>的派生类为改动范围。所以根据依赖倒置原则，可以把<code>ISplitter</code>的派生类的<code>new</code>操作向上提取成一个抽象类。</li></ul><p><strong>运用工厂模式之后：</strong></p><ul><li>在代码中创建一个工厂，这个工厂的作用是：你需要什么类，我就把什么类返回给你</li><li>抽象这个工厂<code>SplitterFactory</code>，并且将它在<code>MainForm</code>中以组合的形式封装。对于<code>SplitterFactory</code>，由于它是抽象类的指针，所以在<code>MainForm</code>属于运行时绑定。</li><li>需要什么样的<code>ISplitter</code>派生类，就创建一个生产该类的工厂，并在<code>MainForm</code>中赋值。当<code>MainForm</code>需要该派生类时，就从<code>MainForm</code>中的工厂取。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//抽象类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ISplitter</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//工厂基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SplitterFactory</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">SplitterFactory</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//具体类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySplitter</span> :</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-comment">//具体工厂</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinarySplitter</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TxtSplitter</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">PictureSplitter</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">VideoSplitter</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//mainform</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form<br>&#123;<br>    SplitterFactory*  factory;<span class="hljs-comment">//工厂</span><br><br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">MainForm</span>(SplitterFactory*  factory)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;factory=factory;<br>    &#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span></span>&#123;<br><br>ISplitter * splitter=<br>            factory-&gt;<span class="hljs-built_in">CreateSplitter</span>(); <span class="hljs-comment">//多态new</span><br>        <br>        splitter-&gt;<span class="hljs-built_in">split</span>();<br><br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a76e6c6e79c2e106686805f7d28c8b05-b8379.png" alt="结构"></p><p>上图中：</p><ul><li><strong>Product</strong>：代表<code>ISplitter</code></li><li><strong>ConcreteProuct</strong>：代表<code>ISplitter</code>派生类</li><li><strong>Creator</strong>：代表<code>SplitterFactory</code></li><li><strong>ConcreteCreator</strong>：代表<code>SplitterFactory</code>派生类</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>Factory Method</strong>模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导致软件的脆弱。</li><li><strong>Factory Method</strong>模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。</li><li><strong>Factory Method</strong>模式解决“单个对象”的需求变化。<strong>缺点在于要求创建方法/参数相同</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对象创建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象工厂模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%9A%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%9A%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作。</li><li>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一 种“封装机制”来避免客户程序和这种“多系列具体对象创建工作” 的紧耦合？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。</p><p> ——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>现在的需求是：创建一个数据库的初始化类，数据库选择SQL Server，其中有三个方法：</p><ul><li><code>ConnectionString()</code></li><li><code>CommandText(...)</code></li><li><code>ExecuteReader()</code></li></ul><p>假设不管初始化哪种数据库，都需要通过这三个方法</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeDAO</span>&#123;</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;EmployeeDO&gt; <span class="hljs-title">GetEmployees</span><span class="hljs-params">()</span></span>&#123;<br>        SqlConnection* connection =<br>            <span class="hljs-keyword">new</span> <span class="hljs-built_in">SqlConnection</span>();<br>        connection-&gt;<span class="hljs-built_in">ConnectionString</span>(...);<br><br>        SqlCommand* command =<br>            <span class="hljs-keyword">new</span> <span class="hljs-built_in">SqlCommand</span>();<br>        command-&gt;<span class="hljs-built_in">CommandText</span>(...);<br>        command-&gt;<span class="hljs-built_in">SetConnection</span>(connection);<br><br>        SqlDataReader* reader = command-&gt;<span class="hljs-built_in">ExecuteReader</span>();<br>        <span class="hljs-keyword">while</span> (reader-&gt;<span class="hljs-built_in">Read</span>())&#123;<br><br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>虽然说这样写能够实现，但是如果要更换数据库的时候，比如更换成MySql时，就需要按照上面的代码重新再写一遍。而且现实中，对于同样类型的业务操作一般都提供了对外的接口，所以需要重构代码，将数据库的调用方式以多态的方式实现。</p><p>所以现在可以尝试使用工厂模式。</p><p><strong>运用工厂模式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//数据库访问有关的基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBConnection</span>&#123;</span><br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBConnectionFactory</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBConnection* <span class="hljs-title">CreateDBConnection</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBCommand</span>&#123;</span><br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBCommandFactory</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBCommand* <span class="hljs-title">CreateDBCommand</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDataReader</span>&#123;</span><br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDataReaderFactory</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDataReader* <span class="hljs-title">CreateDataReader</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><br><br><span class="hljs-comment">//支持SQL Server</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlConnection</span>:</span> <span class="hljs-keyword">public</span> IDBConnection&#123;<br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlConnectionFactory</span>:</span><span class="hljs-keyword">public</span> IDBConnectionFactory&#123;<br>    <br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlCommand</span>:</span> <span class="hljs-keyword">public</span> IDBCommand&#123;<br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlCommandFactory</span>:</span><span class="hljs-keyword">public</span> IDBCommandFactory&#123;<br>    <br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDataReader</span>:</span> <span class="hljs-keyword">public</span> IDataReader&#123;<br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDataReaderFactory</span>:</span><span class="hljs-keyword">public</span> IDataReaderFactory&#123;<br>    <br>&#125;;<br><br><span class="hljs-comment">//支持Oracle</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleConnection</span>:</span> <span class="hljs-keyword">public</span> IDBConnection&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleCommand</span>:</span> <span class="hljs-keyword">public</span> IDBCommand&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleDataReader</span>:</span> <span class="hljs-keyword">public</span> IDataReader&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeDAO</span>&#123;</span><br>    IDBConnectionFactory* dbConnectionFactory;<br>    IDBCommandFactory* dbCommandFactory;<br>    IDataReaderFactory* dataReaderFactory;<br>    <br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;EmployeeDO&gt; <span class="hljs-title">GetEmployees</span><span class="hljs-params">()</span></span>&#123;<br>        IDBConnection* connection =<br>            dbConnectionFactory-&gt;<span class="hljs-built_in">CreateDBConnection</span>();<br>        connection-&gt;<span class="hljs-built_in">ConnectionString</span>(<span class="hljs-string">&quot;...&quot;</span>);<br><br>        IDBCommand* command =<br>            dbCommandFactory-&gt;<span class="hljs-built_in">CreateDBCommand</span>();<br>        command-&gt;<span class="hljs-built_in">CommandText</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>        command-&gt;<span class="hljs-built_in">SetConnection</span>(connection); <span class="hljs-comment">//关联性</span><br><br>        IDBDataReader* reader = command-&gt;<span class="hljs-built_in">ExecuteReader</span>(); <span class="hljs-comment">//关联性</span><br>        <span class="hljs-keyword">while</span> (reader-&gt;<span class="hljs-built_in">Read</span>())&#123;<br><br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>虽然说对于<code>EmployeeDAO</code>类已经解除了静态绑定，通过三个指针转换成了更灵活的动态绑定，但是分析后发现：</p><ul><li>有了对象的接口，也有对象对应的工厂接口</li><li>这三个对象是同组的可以搭配的，有关联性，比如都是SQL Server的</li></ul><p>通过工厂模式的处理固然是好的，但是并不是最好的。虽然<code>EmployeeDAO</code>更灵活了，但是牺牲的是对于三个指针以及他们类型的处理。既然三个指针的类型实际上都是关联操作，那么可以将他们再进一步的抽象</p><p><strong>运用抽象工厂模式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//数据库访问有关的基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBConnection</span>&#123;</span><br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBCommand</span>&#123;</span><br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDataReader</span>&#123;</span><br>    <br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBFactory</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBConnection* <span class="hljs-title">CreateDBConnection</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBCommand* <span class="hljs-title">CreateDBCommand</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDataReader* <span class="hljs-title">CreateDataReader</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <br>&#125;;<br><br><br><span class="hljs-comment">//支持SQL Server</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlConnection</span>:</span> <span class="hljs-keyword">public</span> IDBConnection&#123;<br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlCommand</span>:</span> <span class="hljs-keyword">public</span> IDBCommand&#123;<br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDataReader</span>:</span> <span class="hljs-keyword">public</span> IDataReader&#123;<br>    <br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDBFactory</span>:</span><span class="hljs-keyword">public</span> IDBFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBConnection* <span class="hljs-title">CreateDBConnection</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBCommand* <span class="hljs-title">CreateDBCommand</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDataReader* <span class="hljs-title">CreateDataReader</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br> <br>&#125;;<br><br><span class="hljs-comment">//支持Oracle</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleConnection</span>:</span> <span class="hljs-keyword">public</span> IDBConnection&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleCommand</span>:</span> <span class="hljs-keyword">public</span> IDBCommand&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleDataReader</span>:</span> <span class="hljs-keyword">public</span> IDataReader&#123;<br>    <br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeDAO</span>&#123;</span><br>    IDBFactory* dbFactory;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;EmployeeDO&gt; <span class="hljs-title">GetEmployees</span><span class="hljs-params">()</span></span>&#123;<br>        IDBConnection* connection =<br>            dbFactory-&gt;<span class="hljs-built_in">CreateDBConnection</span>();<br>        connection-&gt;<span class="hljs-built_in">ConnectionString</span>(<span class="hljs-string">&quot;...&quot;</span>);<br><br>        IDBCommand* command =<br>            dbFactory-&gt;<span class="hljs-built_in">CreateDBCommand</span>();<br>        command-&gt;<span class="hljs-built_in">CommandText</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>        command-&gt;<span class="hljs-built_in">SetConnection</span>(connection); <span class="hljs-comment">//关联性</span><br><br>        IDBDataReader* reader = command-&gt;<span class="hljs-built_in">ExecuteReader</span>(); <span class="hljs-comment">//关联性</span><br>        <span class="hljs-keyword">while</span> (reader-&gt;<span class="hljs-built_in">Read</span>())&#123;<br><br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>将三个关联性强的对象封装到工厂类里，也就是把三个容易变化的东西关在笼子里。这样一来，不管是后续再增加何种类型的数据库，都能灵活应对。但是这种方法，却无法解决对新需求的变动。比如，无法在</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDBFactory</span>:</span><span class="hljs-keyword">public</span> IDBFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBConnection* <span class="hljs-title">CreateDBConnection</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBCommand* <span class="hljs-title">CreateDBCommand</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDataReader* <span class="hljs-title">CreateDataReader</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br> <span class="hljs-comment">//无法添加.</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p><code>SqlDBFactory</code>类里添加新的方法，因为这样会打破稳定。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/dbdf13cd830891883ced46289edb0fbf-ded07.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>一个模式稳定的部分，就是它的缺点</li><li>工厂模式是抽象工厂模式的特例</li><li>如果没有应对“多系列对象构建”的需求变化，则没有必要使用Abstract Factory**模式，这时候使用简单的工厂完全可以。</li><li>“系列对象”指的是在某一特定系列下的对象之间有相互依赖、 或作用的关系。不同系列的对象之间不能相互依赖。</li><li><strong>Abstract Factory</strong>模式主要在于应对“新系列”的需求变动。其缺点在于难以应对“新对象”的需求变动</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对象创建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构建器</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%9A%E6%9E%84%E5%BB%BA%E5%99%A8/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%9A%E6%9E%84%E5%BB%BA%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定</li><li>如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>将一个复杂对象的构建与其表示相分离，使得同样的构建过程(稳定)可以创建不同的表示(变化)。</p><p> ——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>建房子一般的流程都是一样的，从地基开始，等等….假设流程固定，但是整个流程却很庞大，如果把房子的属性和创建过程放在同一个类里，整个类会非常的臃肿。所以可以尝试将构建过程提取出来。</p><p><strong>运用构建器模式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//House：显示的部分</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">House</span>&#123;</span><br>    <span class="hljs-comment">//....</span><br>&#125;;<br><span class="hljs-comment">//HouseBuilder:创建细节</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HouseBuilder</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">House* <span class="hljs-title">GetResult</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> pHouse;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">HouseBuilder</span>()&#123;&#125;<br><span class="hljs-keyword">protected</span>:<br>    <br>    House* pHouse;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart1</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart2</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart3</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart4</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart5</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StoneHouse</span>:</span> <span class="hljs-keyword">public</span> House&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StoneHouseBuilder</span>:</span> <span class="hljs-keyword">public</span> HouseBuilder&#123;<br><span class="hljs-keyword">protected</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//pHouse-&gt;Part1 = ...;</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart2</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart3</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart4</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart5</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-comment">//HouseDirector：具体构造过程</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HouseDirector</span>&#123;</span><br>    <br><span class="hljs-keyword">public</span>:<br>    HouseBuilder* pHouseBuilder;<br>    <br>    <span class="hljs-built_in">HouseDirector</span>(HouseBuilder* pHouseBuilder)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;pHouseBuilder=pHouseBuilder;<br>    &#125;<br>    <br>    <span class="hljs-function">House* <span class="hljs-title">Construct</span><span class="hljs-params">()</span></span>&#123;<br>        <br>        pHouseBuilder-&gt;<span class="hljs-built_in">BuildPart1</span>();<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br>            pHouseBuilder-&gt;<span class="hljs-built_in">BuildPart2</span>();<br>        &#125;<br>        <br>        <span class="hljs-keyword">bool</span> flag=pHouseBuilder-&gt;<span class="hljs-built_in">BuildPart3</span>();<br>        <br>        <span class="hljs-keyword">if</span>(flag)&#123;<br>            pHouseBuilder-&gt;<span class="hljs-built_in">BuildPart4</span>();<br>        &#125;<br>        <br>        pHouseBuilder-&gt;<span class="hljs-built_in">BuildPart5</span>();<br>        <br>        <span class="hljs-keyword">return</span> pHouseBuilder-&gt;<span class="hljs-built_in">GetResult</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//实现（以伪代码形式）</span><br><span class="hljs-comment">//初始化House子类...添加属性等</span><br><span class="hljs-comment">//初始化HouseBuilder子类...在之前需实现创建过程中的具体细节...</span><br><span class="hljs-comment">//实例化HouseDirector，即HouseDirector(HouseBuilder)</span><br><span class="hljs-comment">//让HouseDirector执行创建流程Construct，并返回House类型</span><br><span class="hljs-comment">//至此一个House类型对象被创建出来</span><br></code></pre></div></td></tr></table></figure><p>注意：<code>HouseBuilder</code>和<code>HouseDirector</code>有些时候可以合并，依据实际业务场景或者类的设计。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6822e8f448c550326024214c80d01abd-c01d0.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p><strong>父类构造函数中调用虚函数是静态绑定，是不会去调用子类实现的虚函数的。</strong>若为动态绑定，那么子类构造时先调用父类的构造函数，父类的构造函数又调用子类实现的虚函数，这样做违背”伦理“。因为子类并没有构造出来，却被调用了其中的方法。</p></li><li><p>构建过程太过复杂，导致类变得很肥大。可以考虑将构建过程提取出来</p></li><li>Builder模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。</li><li>变化点在哪里，封装哪里—— Builder模式主要在于应对“复杂对象各个部分”的频繁需求变动。其缺点在于难以应对“分步骤构建算法”的需求变动。</li><li>在Builder模式中，要注意不同语言中构造器内调用虚函数的差别 （C++ vs. C#) 。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对象创建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>享元模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E6%80%A7%E8%83%BD%EF%BC%9A%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E6%80%A7%E8%83%BD%EF%BC%9A%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件系统采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行时代价：主要指内存需求方面的代价。</li><li>如何在避免大量细粒度对象问题的同时，让外部客户程序仍然能够透明地使用面向对象的方式来进行操作？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>运用共享技术有效地支持大量细粒度的对象</p><p>——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用享元模式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Font</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-comment">//unique object key</span><br>    string key;<br>    <br>    <span class="hljs-comment">//object state</span><br>    <span class="hljs-comment">//....</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Font</span>(<span class="hljs-keyword">const</span> string&amp; key)&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;;<br>ß<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FontFactory</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//使用map存放，可以根据实际情况更换数据结构</span><br>    map&lt;string,Font* &gt; fontPool;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Font* <span class="hljs-title">GetFont</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp; key)</span></span>&#123;<br><br>        map&lt;string,Font*&gt;::iterator item=fontPool.<span class="hljs-built_in">find</span>(key);<br>        <br>        <span class="hljs-keyword">if</span>(item!=footPool.<span class="hljs-built_in">end</span>())&#123;<span class="hljs-comment">//如果有</span><br>            <span class="hljs-keyword">return</span> fontPool[key];<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果没有</span><br>            Font* font = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Font</span>(key);<span class="hljs-comment">//创建一个新的对象</span><br>            fontPool[key]= font;<br>            <span class="hljs-keyword">return</span> font;<br>        &#125;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/74b3290484036b5227b72f08956d1b60-8f07f.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>用一种共享的方式创建对象，有就返回，没有就创建</li><li>一般来讲，对象的状态尽可能的实现只读的方式</li><li>面向对象很好地解决了抽象性的问题，但是作为一个运行在机器中的程序实体，我们需要考虑对象的代价问题。Flyweight主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。</li><li>Flyweight采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体实现方面，要注意对象状态的处理。</li><li>对象的数量太大从而导致对象内存开销加大，什么样的数量才算大？这需要我们仔细的根据具体应用情况进行评估，而不能凭空臆断。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对象性能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E6%80%A7%E8%83%BD%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E6%80%A7%E8%83%BD%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率。</li><li>如果绕过常规的构造器，提供一种机制来保证一个类只有一个实例？这应该是类设计者的责任，而不是使用者的责任。也就是说不应该规范使用者的使用方式，而是让类设计者在设计的时候就需要考虑。</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>保证一个类仅有一个实例，并提供一个该实例的全局访问点。</p><p>——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用单例模式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>();<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-keyword">const</span> Singleton&amp; other);<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">static</span> Singleton* m_instance;<br>&#125;;<br><br>Singleton* Singleton::m_instance=<span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-comment">//线程非安全版本</span><br><span class="hljs-function">Singleton* <span class="hljs-title">Singleton::getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (m_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>        m_instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> m_instance;<br>&#125;<br><br><span class="hljs-comment">//线程安全版本，但锁的代价过高</span><br><span class="hljs-function">Singleton* <span class="hljs-title">Singleton::getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    Lock lock;<br>    <span class="hljs-keyword">if</span> (m_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>        m_instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> m_instance;<br>&#125;<br><br><span class="hljs-comment">//双检查锁，但由于内存读写reorder不安全</span><br><span class="hljs-function">Singleton* <span class="hljs-title">Singleton::getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">if</span>(m_instance==<span class="hljs-literal">nullptr</span>)&#123;<br>        Lock lock;<br>        <span class="hljs-keyword">if</span> (m_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>            m_instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> m_instance;<br>&#125;<br><br><span class="hljs-comment">//C++ 11版本之后的跨平台实现 (volatile)</span><br>std::atomic&lt;Singleton*&gt; Singleton::m_instance;<br>std::mutex Singleton::m_mutex;<br><br><span class="hljs-function">Singleton* <span class="hljs-title">Singleton::getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    Singleton* tmp = m_instance.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>    std::<span class="hljs-built_in">atomic_thread_fence</span>(std::memory_order_acquire);<span class="hljs-comment">//获取内存fence</span><br>    <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mutex)</span></span>;<br>        tmp = m_instance.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>        <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span>) &#123;<br>            tmp = <span class="hljs-keyword">new</span> Singleton;<br>            std::<span class="hljs-built_in">atomic_thread_fence</span>(std::memory_order_release);<span class="hljs-comment">//释放内存fence</span><br>            m_instance.<span class="hljs-built_in">store</span>(tmp, std::memory_order_relaxed);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里需要特别注意双检查锁会发生的reorder问题：<br><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//双检查锁，但由于内存读写reorder不安全</span><br><span class="hljs-function">Singleton* <span class="hljs-title">Singleton::getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">if</span>(m_instance==<span class="hljs-literal">nullptr</span>)&#123;<span class="hljs-comment">//1</span><br>        Lock lock;<br>        <span class="hljs-keyword">if</span> (m_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>            m_instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<span class="hljs-comment">//2</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> m_instance;<span class="hljs-comment">//3</span><br>&#125;<br></code></pre></div></td></tr></table></figure></p><p>假设此时有两个线程A和B，且没有<code>Singleton</code>实例。</p><p>当A执行到<strong>代码行2</strong>时，由于编译器的优化，<strong>可能</strong>会将<code>new</code>本来的内部执行顺序从<strong>开辟内存-&gt;执行构造-&gt;赋予指针</strong>转变为<strong>开辟内存-&gt;赋予指针-&gt;执行构造</strong>，那么当A执行完<strong>赋予指针</strong>（即此时的<code>m_instance</code>已经被赋予地址了），并处于即将<strong>执行构造</strong>的时刻，B开始了。B执行到<strong>代码行1</strong>时，由于此时<code>m_instance</code>不是<code>nullptr</code>，所以B会直接执行<strong>代码行3</strong>，返回一块什么东西都没有的内存。若此时B中对<code>m_instance</code>进行操作，将会报错。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>构造和拷贝构造设置为私有的</li><li>Singleton模式中的实例构造器可以设置为protected以允许子类派生。</li><li>Singleton模式一般不要支持拷贝构造函数和Clone接口，因为这有可能导致多个对象实例，与Singleton模式的初衷违背。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对象性能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中介者模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，经常会出现多个对象相互关联交互的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。</li><li>在这种情况下，我们可以使用一个”中介对象“来管理对象间的关联关系，避免互相交互的对象之间的紧耦合引用关系，从而更好地抵御变化。</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>用一个中介对象来封装（封装变化）一系列的对象交互。中介者使各对象不需要显示的互相引用（编译时依赖-&gt;运行时依赖），从而使其耦合松散（管理变化），而且可以独立地改变它们之间的交互。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/c847ecd4609b6c48b916c0e25874ff44-15be6.png" alt="实例"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6c5c6f834db0f241439220930281478b-39b5b.png" alt="实例"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>与门面模式的区别：<ul><li>门面模式：系统内部和系统外部的隔离</li><li>中介者模式：系统内部的隔离</li></ul></li><li>将多个对象间复杂的关联关系解耦，Mediator模式将多个对象间的控制逻辑进行集中管理，变“多个对象互相关联”为“多个对象和一个中介者关联”，简化了系统的维护，抵御了可能的变化。</li><li>随着控制逻辑的复杂化，Mediator模式具体对象的实现可能相当复杂。这时候可以对Mediator模式对象进行分解处理。</li><li>Facade模式是解耦系统间（单项）的对象关联关系；Mediator模式是解耦系统内各个对象之间（双向）的关联关系。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口隔离</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在面向对象系统中，有些对象由于某种原因（比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等），直接访问会给使用者、或者系统结构带来很多麻烦。</li><li>如何在不失透明操作对象的同时来管理/控制这些对象特有的复杂性？增加一层间接层是软件开发中常见的解决方式</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>为其他对象提供一种代理以控制（隔离，使用接口）对这个对象的访问 </p><p>——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>使用代理模式之前：</strong></p><p>直接使用功能类</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISubject</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-comment">//功能类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealSubject</span>:</span> <span class="hljs-keyword">public</span> ISubject&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//....</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientApp</span>&#123;</span><br>    <br>    ISubject* subject;<br>    <br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">ClientApp</span>()&#123;<br>        subject=<span class="hljs-keyword">new</span> <span class="hljs-built_in">RealSubject</span>();<span class="hljs-comment">//直接使用</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoTask</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>        subject-&gt;<span class="hljs-built_in">process</span>();<br>        <br>        <span class="hljs-comment">//....</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>使用代理模式之后：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISubject</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><br><span class="hljs-comment">//Proxy的设计，添加了一层间接层</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubjectProxy</span>:</span> <span class="hljs-keyword">public</span> ISubject&#123;<br>    <br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//对RealSubject的一种间接访问，在其中可以进行安全控制等.</span><br>        <span class="hljs-comment">//....</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientApp</span>&#123;</span><br>    <br>    ISubject* subject;<br>    <br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">ClientApp</span>()&#123;<br>        subject=<span class="hljs-keyword">new</span> <span class="hljs-built_in">SubjectProxy</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoTask</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>        subject-&gt;<span class="hljs-built_in">process</span>();<br>        <br>        <span class="hljs-comment">//....</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/70792f3a5d1deb63a5ead7eca014ebc9-550f9.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>”增加一层间接层“是软件系统中对许多复杂问题的一种常见解决方法。在面向对象系统中，直接使用某些对象会带来很多问题，作为间接层的Proxy对象便是解决这一问题的常用手段。</li><li>具体Proxy设计模式的实现方法、实现粒度都相差很大，有些可能对单个对象做细粒度的控制，如copy-on-write技术，有些可能对组件模块提供抽象代理层，在架构层次对对象做proxy。</li><li><strong>Proxy并不一定要求保持接口完整的一致性，只要能够实现间接控制，有时候损及一些透明性是可以接受的。</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口隔离</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>适配器模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件系统中，由于应用环境的变化，常常需要将”一些现存的对象“放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。</li><li>如何应对这种”迁移的变化“？如何既能利用现有对象的良好实现，同时又满足新的应用环境所要求的接口？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用适配器模式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//目标接口（新接口）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ITarget</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">//遗留接口（老接口）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IAdaptee</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">//遗留类型</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OldClass</span>:</span> <span class="hljs-keyword">public</span> IAdaptee&#123;<br>    <span class="hljs-comment">//....</span><br>&#125;;<br><br><span class="hljs-comment">//对象适配器</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span>:</span> <span class="hljs-keyword">public</span> ITarget&#123; <span class="hljs-comment">//继承</span><br><span class="hljs-keyword">protected</span>:<br>    IAdaptee* pAdaptee;<span class="hljs-comment">//组合</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">Adapter</span>(IAdaptee* pAdaptee)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;pAdaptee=pAdaptee;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> data=pAdaptee-&gt;<span class="hljs-built_in">bar</span>();<br>        pAdaptee-&gt;<span class="hljs-built_in">foo</span>(data);<br>        <br>    &#125;<br>    <br>    <br>&#125;;<br><br><span class="hljs-comment">//类适配器</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span>:</span> <span class="hljs-keyword">public</span> ITarget,<br>               <span class="hljs-keyword">protected</span> OldClass&#123; <span class="hljs-comment">//多继承</span><br>               <br>               <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//实例化一个老版本的类</span><br>    IAdaptee* pAdaptee=<span class="hljs-keyword">new</span> <span class="hljs-built_in">OldClass</span>();<br>    <br>    <span class="hljs-comment">//利用适配器对这个老版本的类进行适配</span><br>    ITarget* pTarget=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Adapter</span>(pAdaptee);<br>    pTarget-&gt;<span class="hljs-built_in">process</span>();<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/75286f661f0eec847beeb6ccf5239ff3-fd5be.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Adapter模式主要应用于”希望复用一些现存的类，但是接口又与复用环境要求不一致的情况“，在遗留代码复用、类库迁移等方面非常有用。</li><li>GoF23定义了两种Adapter模式的实现结构：对象适配器和类适配器。但类适配器采用”多继承“的实现方式，一般不推荐使用。对象适配器采用”对象组合“的方式，更符合松耦合精神。</li><li>Adapter模式可以实现的非常灵活，不必拘泥于GoF23中定义的两种结构。例如，完全可以将Adapter模式中的”现存对象“作为新的接口方法参数，来达到适配的目的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口隔离</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>门面模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7a3928dde4ef2752ff9b4bb248907763-21c79.png" alt="动机"></p><ul><li>上述A方案的问题在于组件的客户和组件中各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。</li><li>如何简化外部客户程序和系统间的交互接口？如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解耦？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>为子系统中的一组接口提供一个一致（稳定）的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用（复用）。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/aaeb3252ee3997fa8d7ddb24e46ea28c-49978.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>门面模式实际上是一种开发素养，在考虑问题时需要一种边界的划分。面向使用者需要表示稳定，面向设计者需要快速的迭代</li><li>从客户程序的角度来看,Facade模式简化了整个组件系统的接口，对于组件内部与外部客户程序来说，达到一种”解耦“的效果。内部子系统的任何变化不会影响到Facade接口的变化。</li><li>Facade设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Facade很多时候更是一种<strong>架构设计模式</strong>。</li><li>Facade设计模式并非一个集装箱，可以任意地放进任何多个对象。Facade模式中组件的内部应该是”相互耦合关系比较大的一系列组件“，而不是一个简单的功能集合。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口隔离</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件的某些情况下，客户代码过多地依赖于对象容器复杂的内部实现结构，对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。</li><li>如何将”客户代码与复杂的对象容器结构“解耦？让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>将对象组合成树形结构以表示”部分-整体“的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性（稳定）。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>内部呈现一种树状结构，可以想象成文件系统，把<code>Composite</code>视为文件目录，<code>Leaf</code>视为文件。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Component</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//树节点</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Composite</span> :</span> <span class="hljs-keyword">public</span> Component&#123;<br>    <br>    string name;<br>    list&lt;Component*&gt; elements;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Composite</span>(<span class="hljs-keyword">const</span> string &amp; s) : <span class="hljs-built_in">name</span>(s) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Component* element)</span> </span>&#123;<br>        elements.<span class="hljs-built_in">push_back</span>(element);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Component* element)</span></span>&#123;<br>        elements.<span class="hljs-built_in">remove</span>(element);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>&#123;<br>        <br>        <span class="hljs-comment">//1. process current node</span><br>        <br>        <br>        <span class="hljs-comment">//2. process leaf nodes</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;e : elements)<br>            e-&gt;<span class="hljs-built_in">process</span>(); <span class="hljs-comment">//多态调用</span><br>         <br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//叶子节点</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leaf</span> :</span> <span class="hljs-keyword">public</span> Component&#123;<br>    string name;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Leaf</span>(string s) : <span class="hljs-built_in">name</span>(s) &#123;&#125;<br>            <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//process current node</span><br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Invoke</span><span class="hljs-params">(Component &amp; c)</span></span>&#123;<br>    <span class="hljs-comment">//...</span><br>    c.<span class="hljs-built_in">process</span>();<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-function">Composite <span class="hljs-title">root</span><span class="hljs-params">(<span class="hljs-string">&quot;root&quot;</span>)</span></span>;<br>    <span class="hljs-function">Composite <span class="hljs-title">treeNode1</span><span class="hljs-params">(<span class="hljs-string">&quot;treeNode1&quot;</span>)</span></span>;<br>    <span class="hljs-function">Composite <span class="hljs-title">treeNode2</span><span class="hljs-params">(<span class="hljs-string">&quot;treeNode2&quot;</span>)</span></span>;<br>    <span class="hljs-function">Composite <span class="hljs-title">treeNode3</span><span class="hljs-params">(<span class="hljs-string">&quot;treeNode3&quot;</span>)</span></span>;<br>    <span class="hljs-function">Composite <span class="hljs-title">treeNode4</span><span class="hljs-params">(<span class="hljs-string">&quot;treeNode4&quot;</span>)</span></span>;<br>    <span class="hljs-function">Leaf <span class="hljs-title">leat1</span><span class="hljs-params">(<span class="hljs-string">&quot;left1&quot;</span>)</span></span>;<br>    <span class="hljs-function">Leaf <span class="hljs-title">leat2</span><span class="hljs-params">(<span class="hljs-string">&quot;left2&quot;</span>)</span></span>;<br>    <br>    root.<span class="hljs-built_in">add</span>(&amp;treeNode1);<br>    treeNode1.<span class="hljs-built_in">add</span>(&amp;treeNode2);<br>    treeNode2.<span class="hljs-built_in">add</span>(&amp;leaf1);<br>    <br>    root.<span class="hljs-built_in">add</span>(&amp;treeNode3);<br>    treeNode3.<span class="hljs-built_in">add</span>(&amp;treeNode4);<br>    treeNode4.<span class="hljs-built_in">add</span>(&amp;leaf2);<br>    <br>    <span class="hljs-built_in">process</span>(root);<br>    <span class="hljs-built_in">process</span>(leaf2);<br>    <span class="hljs-built_in">process</span>(treeNode3);<br>  <br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/0abe476e99639c4f5f496e3e26560435-14578.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>组合模式的核心是多态的递归调用</strong></li><li>Composite模式采用树形结构来实现普遍存在的对象容器，从而将”一对多“的关系转化为”一对一“的关系，使得客户代码可以一致地（复用）处理对象和对象容器，无需关心处理的是单个的对象，还是组合的对象容器。<ul><li>一对多：即上例的，若<code>Leaf</code>也实现父类的虚函数，然后<code>Composite</code>的成员函数<code>process</code>中的<code>for</code>循环去掉或改写，对于客户而言，直接面对的就是这两个类型。</li><li>一对一：即上例。对于客户而言，客户仅需要使用<code>Component</code>类型即可，且不知道内部的数据是按照何种的数据结构组装。</li></ul></li><li>将”客户代码与复杂的对象容器结构“解耦是Composite的核心思想，解耦之后，客户代码将与纯粹的抽象接口，而非对象容器的内部实现结构发生依赖，从而更能”应对变化“。（比如上例的<code>invoke</code>方法）</li><li>Composite模式在具体实现中，可以让父对象中的子对象反向追溯；如果父对象有频繁的遍历需求，可使用缓存技巧来改善效率。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>职责链</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%81%8C%E8%B4%A3%E9%93%BE/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%81%8C%E8%B4%A3%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，一个请求可能被多个对象处理，但是每个请求在运行时只能有一个接收者，如果显示指定，将必不可少地带来请求发送者与接收者的紧耦合。</li><li>如何使请求的发送者不需要指定具体的接收者？让请求的接受者自己在运行时决定来处理请求，从而使两者解耦？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>类似于安卓中的事件分发机制</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//请求类型</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RequestType</span></span><br><span class="hljs-class">&#123;</span><br>    REQ_HANDLER1,<br>    REQ_HANDLER2,<br>    REQ_HANDLER3<br>&#125;;<br><span class="hljs-comment">//请求</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reqest</span></span><br><span class="hljs-class">&#123;</span><br>    string description;<br>    RequestType reqType;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Reqest</span>(<span class="hljs-keyword">const</span> string &amp; desc, RequestType type) : <span class="hljs-built_in">description</span>(desc), <span class="hljs-built_in">reqType</span>(type) &#123;&#125;<br>    <span class="hljs-function">RequestType <span class="hljs-title">getReqType</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> reqType; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">const</span> string&amp; <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> description; &#125;<br>&#125;;<br><span class="hljs-comment">//接受请求的类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChainHandler</span>&#123;</span><br>    <br>    <span class="hljs-comment">//设置下一个接受节点</span><br>    ChainHandler *nextChain;<br>    <span class="hljs-comment">//发送请求到下一个节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendReqestToNextHandler</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (nextChain != <span class="hljs-literal">nullptr</span>)<br>            nextChain-&gt;<span class="hljs-built_in">handle</span>(req);<br>    &#125;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">//判断是否接受请求</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">canHandleRequest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//请求处理</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ChainHandler</span>() &#123; nextChain = <span class="hljs-literal">nullptr</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setNextChain</span><span class="hljs-params">(ChainHandler *next)</span> </span>&#123; nextChain = next; &#125;<br>    <br>   <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">canHandleRequest</span>(req))<br>            <span class="hljs-built_in">processRequest</span>(req);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">sendReqestToNextHandler</span>(req);<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler1</span> :</span> <span class="hljs-keyword">public</span> ChainHandler&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canHandleRequest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> req.<span class="hljs-built_in">getReqType</span>() == RequestType::REQ_HANDLER1;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Handler1 is handle reqest: &quot;</span> &lt;&lt; req.<span class="hljs-built_in">getDescription</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;;<br>        <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler2</span> :</span> <span class="hljs-keyword">public</span> ChainHandler&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canHandleRequest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> req.<span class="hljs-built_in">getReqType</span>() == RequestType::REQ_HANDLER2;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Handler2 is handle reqest: &quot;</span> &lt;&lt; req.<span class="hljs-built_in">getDescription</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler3</span> :</span> <span class="hljs-keyword">public</span> ChainHandler&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canHandleRequest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> req.<span class="hljs-built_in">getReqType</span>() == RequestType::REQ_HANDLER3;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Handler3 is handle reqest: &quot;</span> &lt;&lt; req.<span class="hljs-built_in">getDescription</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Handler1 h1;<br>    Handler2 h2;<br>    Handler3 h3;<br>    h1.<span class="hljs-built_in">setNextChain</span>(&amp;h2);<br>    h2.<span class="hljs-built_in">setNextChain</span>(&amp;h3);<br>    <br>    <span class="hljs-function">Reqest <span class="hljs-title">req</span><span class="hljs-params">(<span class="hljs-string">&quot;process task ... &quot;</span>, RequestType::REQ_HANDLER3)</span></span>;<br>    h1.<span class="hljs-built_in">handle</span>(req);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5e3f3c6bc4af6c127e12ad584fccf3cf-63458.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Chain of Responsibility模式的应用场合在于”一个请求可能有多个接受者，但是最后真正的接受者只有一个“，这时候请求发送者就接受者的耦合有可能出现”变化脆弱“的症状，职责链的目的就是将二者解耦，从而更好地应对变化。</li><li>应用了Chain of Responsibility模式后，对象的职责分派将更具灵活性。我们可以在运行时动态添加/修改请求的职责。</li><li>如果请求传递到职责链的末尾仍得不到处理，应该有一个合理的缺省机制。这也是每一个接受对象的责任，而不是发出请求的对象的责任。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迭代器</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构：迭代器"><a href="#数据结构：迭代器" class="headerlink" title="数据结构：迭代器"></a>数据结构：迭代器</h1><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素；同时这种”透明遍历“也为”同一种算法在多种集合对象上进行操作“提供了可能。</li><li>使用面向对象技术将这种遍历机制抽象为”迭代器对象“为”应对变化中的集合对象“提供了一种优雅的fan</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露（稳定）该对象的内部表示。</p><p>——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Iterator</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">first</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T&amp; <span class="hljs-title">current</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCollection</span>&#123;</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function">Iterator&lt;T&gt; <span class="hljs-title">GetIterator</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectionIterator</span> :</span> <span class="hljs-keyword">public</span> Iterator&lt;T&gt;&#123;<br>    MyCollection&lt;T&gt; mc;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">CollectionIterator</span>(<span class="hljs-keyword">const</span> MyCollection&lt;T&gt; &amp; c): <span class="hljs-built_in">mc</span>(c)&#123; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">first</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function">T&amp; <span class="hljs-title">current</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyAlgorithm</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    MyCollection&lt;<span class="hljs-keyword">int</span>&gt; mc;<br>    <br>    Iterator&lt;<span class="hljs-keyword">int</span>&gt; iter= mc.<span class="hljs-built_in">GetIterator</span>();<br>    <br>    <span class="hljs-keyword">for</span> (iter.<span class="hljs-built_in">first</span>(); !iter.<span class="hljs-built_in">isDone</span>(); iter.<span class="hljs-built_in">next</span>())&#123;<br>        cout &lt;&lt; iter.<span class="hljs-built_in">current</span>() &lt;&lt; endl;<br>    &#125;<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/2c55fc126b3e7f7a0938bd54ea0af498-feb82.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>迭代器模式在C++已经过时了<ul><li>缺点是面向对象的迭代器的虚函数调用（动态绑定）需要性能成本，而泛型编程的多态是静态绑定。</li><li>有了泛型编程的迭代器，就没有了面向对象的迭代器了。</li></ul></li><li>迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示</li><li>迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。</li><li>迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状态模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%EF%BC%9A%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%EF%BC%9A%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，某些对象的状态如果改变，其行为也会随之而发生变化，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。</li><li>如何在运行时根据对象的状态透明地更改对象的行为，而不会为对象操作和状态转化之间引入紧耦合？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>允许一个对象在其内部状态改变时改变它的行为。从而使对象看起来似乎修改了行为。</p><p>——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用状态模式之前：</strong>（出现大量的if-else）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NetworkState</span></span><br><span class="hljs-class">&#123;</span><br>    Network_Open,<br>    Network_Close,<br>    Network_Connect,<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkProcessor</span>&#123;</span><br>    <br>    NetworkState state;<br><br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (state == Network_Open)&#123;<br><br>            <span class="hljs-comment">//**********</span><br>            state = Network_Close;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == Network_Close)&#123;<br><br>            <span class="hljs-comment">//..........</span><br>            state = Network_Connect;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == Network_Connect)&#123;<br><br>            <span class="hljs-comment">//$$$$$$$$$$</span><br>            state = Network_Open;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span> (state == Network_Open)&#123;<br>            <br>            <span class="hljs-comment">//**********</span><br>            state = Network_Connect;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == Network_Close)&#123;<br><br>            <span class="hljs-comment">//.....</span><br>            state = Network_Open;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == Network_Connect)&#123;<br><br>            <span class="hljs-comment">//$$$$$$$$$$</span><br>            state = Network_Close;<br>        &#125;<br>    <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>运用状态模式之后：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkState</span>&#123;</span><br><br><span class="hljs-keyword">public</span>:<br>    NetworkState* pNext;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">NetworkState</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//结合单例模式</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenState</span> :</span><span class="hljs-keyword">public</span> NetworkState&#123;<br>    <br>    <span class="hljs-keyword">static</span> NetworkState* m_instance;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> NetworkState* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (m_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>            m_instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">OpenState</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> m_instance;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span></span>&#123;<br>        <br>        <span class="hljs-comment">//**********</span><br>        pNext = CloseState::<span class="hljs-built_in">getInstance</span>();<span class="hljs-comment">//更改下一个状态</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span></span>&#123;<br>        <br>        <span class="hljs-comment">//..........</span><br>        pNext = ConnectState::<span class="hljs-built_in">getInstance</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span></span>&#123;<br>        <br>        <span class="hljs-comment">//$$$$$$$$$$</span><br>        pNext = OpenState::<span class="hljs-built_in">getInstance</span>();<br>    &#125;<br>    <br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloseState</span>:</span><span class="hljs-keyword">public</span> NetworkState&#123; &#125;<br><span class="hljs-comment">//...</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkProcessor</span>&#123;</span><br>    <br>    NetworkState* pState;<br>    <br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">NetworkProcessor</span>(NetworkState* pState)&#123;<br>        <br>        <span class="hljs-keyword">this</span>-&gt;pState = pState;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>        pState-&gt;<span class="hljs-built_in">Operation1</span>();<br>        pState = pState-&gt;pNext;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>        pState-&gt;<span class="hljs-built_in">Operation2</span>();<br>        pState = pState-&gt;pNext;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>        pState-&gt;<span class="hljs-built_in">Operation3</span>();<br>        pState = pState-&gt;pNext;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/be1b2752ed766f77c6f6f53a5dff29f9-c8dc1.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>状态模式倾向于结合单例模式</li><li>虚函数的本质实际上是运行时的if-else</li><li>State模式将所有与一个特定状态相关的行为都放入一个State的子类对象中，在对象状态切换的时候，切换相应的对象；但同时维持State的接口，这样实现了具体操作与状态转换之间的解耦。</li><li>为不同的状态引入不同的对象使得状态转换变得更加明确，而且可以保证不会出现状态不一致的情况，因为转换是原子性的，即要么彻底转换过来，要么不转换。</li><li>如果State对象没有实例变量，那么各个上下文可以共享同一个State对象，从而节省对象开销。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>状态变化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板方法</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>定义一个操作中的算法的骨架(稳定)，而将一些步骤延迟(变化)到子类中。Template Method使得子类可以不改变(复用)一个算法的结构即可重定义(override重写)该算法的某些特定步骤。——《设计模式》GoF</p></blockquote><p><strong>注意：除了可以灵活应对子步骤的变化外，“不要调用我，让我来调用你”的反向控制结构是Template Method的典型应用。</strong></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用模板方法之前：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//lib.cpp</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Library</span>&#123;</span><br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step1</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//...</span><br>&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step3</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step5</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//main.cpp</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//由应用开发人员来编写流程</span><br><span class="hljs-function">Library <span class="hljs-title">lib</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">Application <span class="hljs-title">app</span><span class="hljs-params">()</span></span>;<br><br>lib.<span class="hljs-built_in">Step1</span>();<br><br><span class="hljs-keyword">if</span> (app.<span class="hljs-built_in">Step2</span>())&#123;<br>lib.<span class="hljs-built_in">Step3</span>();<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br>app.<span class="hljs-built_in">Step4</span>();<br>&#125;<br><br>lib.<span class="hljs-built_in">Step5</span>();<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210708102904.png" alt="运用模板方法之前"></p><p><strong>运用模板方法之后：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//lib</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Library</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//稳定 template method</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span></span>&#123;<br>        <br>        <span class="hljs-built_in">Step1</span>();<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Step2</span>()) &#123; <span class="hljs-comment">//支持变化 ==&gt; 虚函数的多态调用</span><br>            <span class="hljs-built_in">Step3</span>(); <br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br>            <span class="hljs-built_in">Step4</span>(); <span class="hljs-comment">//支持变化 ==&gt; 虚函数的多态调用</span><br>        &#125;<br><br>        <span class="hljs-built_in">Step5</span>();<br><br>    &#125;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Library</span>()&#123; &#125;<br><br><span class="hljs-keyword">protected</span>:<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//稳定</span><br>        <span class="hljs-comment">//.....</span><br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step3</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//稳定</span><br>        <span class="hljs-comment">//.....</span><br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step5</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//稳定</span><br><span class="hljs-comment">//.....</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-comment">//变化</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>=<span class="hljs-number">0</span>; <span class="hljs-comment">//变化</span><br>&#125;;<br><br><span class="hljs-comment">//main</span><br><span class="hljs-comment">//应用程序开发人员</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> :</span> <span class="hljs-keyword">public</span> Library &#123;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//... 子类重写实现</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//... 子类重写实现</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Library* pLib=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Application</span>();<br>    lib-&gt;<span class="hljs-built_in">Run</span>();<br><br><span class="hljs-keyword">delete</span> pLib;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210708110113.png" alt="应用模板方法后"></p><p>在前后的对比中，实质上是运用了虚函数来推迟具体步骤（变化）的实现，但是总体的流程（稳定）是已经事先写好的。运用虚函数的机制将绑定延迟，交由子类实现</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210708110317.png" alt="早绑定与晚绑定"></p><p>早绑定实际上就是在日常开发中，我们调用别人事先写好的库。晚绑定则相反</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>可以通过寻找稳定点来设计并运用模式</li><li>在具体实现方面，被Template Method调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将它们设置为protected方法。</li><li>任何一个基类的析构函数都应该写成虚的</li><li>大多数的设计模式实质上都是“稳定中有变化”</li><li>如果结构中所有的东西都在变化，那么不建议使用设计模式，因为设计模式假设结构中至少有一个稳定点。同样，若是结构中的所有东西都是稳定的，那么运用设计模式也是没有意义的，因为设计模式是在稳定和变化中寻找隔离点。</li><li>稳定是相对的，考量相对的方法也是不一样的。比如A和B，A一年一次变化，而B一周一次变化，那么A对于B是稳定的。</li><li>Template Method模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制（虚函数的多态性）为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组件协作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备忘录模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%EF%BC%9A%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%EF%BC%9A%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，某些对象的状态在转换过程中，可能由于某种需要，要求程序能够回溯到对象之前处于某个点时的状态。如果使用一些公有接口来让其他对象得到对象的状态，便会暴露对象的细节实现。</li><li>如何实现对象状态的良好保存与恢复？但同时又不会因此而破坏对象本身的封装性？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原本保存的状态。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Memento</span></span><br><span class="hljs-class">&#123;</span><br>    string state;<br>    <span class="hljs-comment">//..</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Memento</span>(<span class="hljs-keyword">const</span> string &amp; s) : <span class="hljs-built_in">state</span>(s) &#123;&#125;<br>    <span class="hljs-function">string <span class="hljs-title">getState</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> state; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp; s)</span> </span>&#123; state = s; &#125;<br>&#125;;<br><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Originator</span></span><br><span class="hljs-class">&#123;</span><br>    string state;<br>    <span class="hljs-comment">//....</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Originator</span>() &#123;&#125;<br>    <span class="hljs-function">Memento <span class="hljs-title">createMomento</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">Memento <span class="hljs-title">m</span><span class="hljs-params">(state)</span></span>;<br>        <span class="hljs-keyword">return</span> m;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setMomento</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Memento &amp; m)</span> </span>&#123;<br>        state = m.<span class="hljs-built_in">getState</span>();<br>    &#125;<br>&#125;;<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Originator orginator;<br>    <br>    <span class="hljs-comment">//捕获对象状态，存储到备忘录</span><br>    Memento mem = orginator.<span class="hljs-built_in">createMomento</span>();<br>    <br>    <span class="hljs-comment">//... 改变orginator状态</span><br>    <br>    <span class="hljs-comment">//从备忘录中恢复</span><br>    orginator.<span class="hljs-built_in">setMomento</span>(memento);<br>   <br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a8c463389b28bf24c925f7dd4b745f7f-b47ff.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>备忘录(Memento)存储原发器(Originator)对象的内部状态，在需要时恢复原发器状态。</li><li>Memento模式的核心是信息隐藏，即Originator需要向外界隐藏信息，保持其封装性。但同时又需要将状态保持到外界（Memento）。</li><li>由于现代语言运行时（如C#、JAVA等）都具有相当的对象序列化支持，因此往往采用效率较高、又较容易正确实现的序列化方案来实现Memento模式。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>状态变化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>策略模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂； 而且有时候支持不使用的算法也是一个性能负担。</p><p>如何在运行时根据需要透明地更改对象的算法？将算法与对象本 身解耦，从而避免上述问题？</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程 序(稳定)而变化（扩展，子类化）。 ——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>运用策略模式之前：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TaxBase</span> &#123;</span><br>CN_Tax,<br>US_Tax,<br>DE_Tax,<br>FR_Tax       <span class="hljs-comment">//更改</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span>&#123;</span><br>    TaxBase tax;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>        <br>        <span class="hljs-keyword">if</span> (tax == CN_Tax)&#123;<br>            <span class="hljs-comment">//CN***********</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tax == US_Tax)&#123;<br>            <span class="hljs-comment">//US***********</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tax == DE_Tax)&#123;<br>            <span class="hljs-comment">//DE***********</span><br>        &#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tax == FR_Tax)&#123;  <span class="hljs-comment">//更改</span><br><span class="hljs-comment">//...</span><br>&#125;<br><br>        <span class="hljs-comment">//....</span><br>     &#125;<br>    <br>&#125;;<br></code></pre></div></td></tr></table></figure><p>运用策略模式之后：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaxStrategy</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">TaxStrategy</span>()&#123;&#125;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CNTax</span> :</span> <span class="hljs-keyword">public</span> TaxStrategy&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span></span>&#123;<br>        <span class="hljs-comment">//***********</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">USTax</span> :</span> <span class="hljs-keyword">public</span> TaxStrategy&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span></span>&#123;<br>        <span class="hljs-comment">//***********</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DETax</span> :</span> <span class="hljs-keyword">public</span> TaxStrategy&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span></span>&#123;<br>        <span class="hljs-comment">//***********</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//扩展</span><br><span class="hljs-comment">//*********************************</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FRTax</span> :</span> <span class="hljs-keyword">public</span> TaxStrategy&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span></span>&#123;<br><span class="hljs-comment">//.........</span><br>&#125;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    TaxStrategy* strategy;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SalesOrder</span>(StrategyFactory* strategyFactory)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;strategy = strategyFactory-&gt;<span class="hljs-built_in">NewStrategy</span>();<br>    &#125;<br>    ~<span class="hljs-built_in">SalesOrder</span>()&#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;strategy;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-function">Context <span class="hljs-title">context</span><span class="hljs-params">()</span></span>;<br>        <br>        <span class="hljs-keyword">double</span> val = <br>            strategy-&gt;<span class="hljs-built_in">Calculate</span>(context); <span class="hljs-comment">//多态调用</span><br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <br>&#125;;<br></code></pre></div></td></tr></table></figure><p>即：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5191ec8f720daee9fb5a2cdf2f6819c4-c2caee.png" alt="结构"></p><p>运用策略模式之前，代码违反开闭原则，不停的修改if-else。</p><p><strong>问题：</strong>if-else虽然更改了，但是更改的也只是在后面添加，前面的if-else不是也被复用了吗？</p><p><strong>答：</strong>复用性一般讲的是编译方面二进制的复用性。虽然只在后面添加，但是代码需要重新编译。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>面向过程的分而治之一般可以用面向对象的抽象来解决</p></li><li><p>当控制语句（if-else或switch）出现的时候，若出现控制语句会不停的修改，那么就可以考虑应用设计模式。相反的，绝对稳定不变的（比如一周有七天，周一干什么周二干什么…）可以保留控制语句</p></li><li>Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。</li><li>Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需 要Strategy模式。</li><li>如果Strategy对象没有实例变量，那么各个上下文可以共享同一个 Strategy对象，从而节省对象开销。（单例模式）</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组件协作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>观察者模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%EF%BC%9A%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%EF%BC%9A%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系” ——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密， 将使软件不能很好地抵御变化。——《设计模式》GoF</li><li>使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>以下代码为文件分割器。主要流程是<code>MainForm</code>调用<code>FileSplitter</code>来分割文件，<code>FileSplitter</code>在分割文件的过程中将计算出来的进度传给<code>MainForm</code>，由<code>MainForm</code>在界面上显示具体进度。</p><p>运用观察者模式之前：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span></span><br><span class="hljs-class">&#123;</span><br>string m_filePath;<br><span class="hljs-keyword">int</span> m_fileNumber;<br>ProgressBar* m_progressBar;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">FileSplitter</span>(<span class="hljs-keyword">const</span> string&amp; filePath, <span class="hljs-keyword">int</span> fileNumber, ProgressBar* progressBar) :<br><span class="hljs-built_in">m_filePath</span>(filePath), <br><span class="hljs-built_in">m_fileNumber</span>(fileNumber),<br><span class="hljs-built_in">m_progressBar</span>(progressBar)&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span></span>&#123;<br><br><span class="hljs-comment">//1.读取大文件</span><br><br><span class="hljs-comment">//2.分批次向小文件中写入</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++)&#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">float</span> progressValue = m_fileNumber;<br>progressValue = (i + <span class="hljs-number">1</span>) / progressValue;<br>m_progressBar-&gt;<span class="hljs-built_in">setValue</span>(progressValue);<br>&#125;<br><br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form<br>&#123;<br>TextBox* txtFilePath;<br>TextBox* txtFileNumber;<br>ProgressBar* progressBar;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span></span>&#123;<br><br>string filePath = txtFilePath-&gt;<span class="hljs-built_in">getText</span>();<br><span class="hljs-keyword">int</span> number = <span class="hljs-built_in">atoi</span>(txtFileNumber-&gt;<span class="hljs-built_in">getText</span>().<span class="hljs-built_in">c_str</span>());<br><br><span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number, progressBar)</span></span>;<br><br>splitter.<span class="hljs-built_in">split</span>();<br><br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>运用观察者模式之后：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IProgress</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span></span>=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IProgress</span>()&#123;&#125;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span></span><br><span class="hljs-class">&#123;</span><br>string m_filePath;<br><span class="hljs-keyword">int</span> m_fileNumber;<br><br>List&lt;IProgress*&gt;  m_iprogressList; <span class="hljs-comment">// 抽象通知机制，支持多个观察者</span><br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">FileSplitter</span>(<span class="hljs-keyword">const</span> string&amp; filePath, <span class="hljs-keyword">int</span> fileNumber) :<br><span class="hljs-built_in">m_filePath</span>(filePath), <br><span class="hljs-built_in">m_fileNumber</span>(fileNumber)&#123;<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span></span>&#123;<br><br><span class="hljs-comment">//1.读取大文件</span><br><br><span class="hljs-comment">//2.分批次向小文件中写入</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++)&#123;<br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">float</span> progressValue = m_fileNumber;<br>progressValue = (i + <span class="hljs-number">1</span>) / progressValue;<br><span class="hljs-built_in">onProgress</span>(progressValue);<span class="hljs-comment">//发送通知</span><br>&#125;<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addIProgress</span><span class="hljs-params">(IProgress* iprogress)</span></span>&#123;<br>m_iprogressList.<span class="hljs-built_in">push_back</span>(iprogress);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeIProgress</span><span class="hljs-params">(IProgress* iprogress)</span></span>&#123;<br>m_iprogressList.<span class="hljs-built_in">remove</span>(iprogress);<br>&#125;<br><br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span></span>&#123;<br><br>List&lt;IProgress*&gt;::iterator itor=m_iprogressList.<span class="hljs-built_in">begin</span>();<br><br><span class="hljs-keyword">while</span> (itor != m_iprogressList.<span class="hljs-built_in">end</span>() )<br>(*itor)-&gt;<span class="hljs-built_in">DoProgress</span>(value); <span class="hljs-comment">//更新进度条</span><br>itor++;<br>&#125;<br>&#125;<br>&#125;;<br><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form, <span class="hljs-keyword">public</span> IProgress<br>&#123;<br>TextBox* txtFilePath;<br>TextBox* txtFileNumber;<br><br>ProgressBar* progressBar;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span></span>&#123;<br><br>string filePath = txtFilePath-&gt;<span class="hljs-built_in">getText</span>();<br><span class="hljs-keyword">int</span> number = <span class="hljs-built_in">atoi</span>(txtFileNumber-&gt;<span class="hljs-built_in">getText</span>().<span class="hljs-built_in">c_str</span>());<br><br>ConsoleNotifier cn;<br><br><span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;<br><br>splitter.<span class="hljs-built_in">addIProgress</span>(<span class="hljs-keyword">this</span>); <span class="hljs-comment">//订阅通知</span><br>splitter.<span class="hljs-built_in">addIProgress</span>(&amp;cn)； <span class="hljs-comment">//订阅通知</span><br><br>splitter.<span class="hljs-built_in">split</span>();<br><br>splitter.<span class="hljs-built_in">removeIProgress</span>(<span class="hljs-keyword">this</span>);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span></span>&#123;<br>progressBar-&gt;<span class="hljs-built_in">setValue</span>(value);<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsoleNotifier</span> :</span> <span class="hljs-keyword">public</span> IProgress &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;.&quot;</span>;<br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>比较上面两段代码，在运用观察者模式之前：</p><ul><li><code>MainForm</code>与<code>FileSplitter</code>高耦合，从两者的初始化过程和相互之间捆绑的<code>ProgressBar</code>类型指针就可看出，牵一发而动全身。</li><li>对于<code>ProgressBar</code>，这种设计思路十分不妥。如果客户需求更改，使用其他的形式来显示进度，那么<code>ProgressBar</code>需要更换成其他的实现类。可以看出，此例违反了依赖倒置原则。</li></ul><p>在运用观察者模式之后：</p><ul><li>将<code>ProgressBar</code>抽象成一个父类，作为接口<code>IProgress</code>。经过这样的处理，不仅将<code>MainForm</code>和<code>FileSplitter</code>从紧耦合优化成了松耦合，还可以灵活的支持不同的进度显示。</li><li>对于<code>FileSplitter</code>来说，<code>MainForm</code>是接收<code>FileSplitter</code>通知（上例的通知就是进度）的一份子。只要在<code>FileSplitter</code>中注册过，那么每当<code>FileSplitter</code>发送通知，所有已经注册过的<code>MainForm</code>就会接收（继承的接口中实现的虚函数<code>DoProgress</code>被调用）到通知。此处，<code>FileSplitter</code>为<strong>“被观察者”</strong>，<code>MainForm</code>为<strong>“观察者”</strong>。</li><li>对于观察者而言：只要你注册了，就可以接收到通知。</li><li>对于被观察者而言：发送通知时，只要在被观察者内部注册过，都会进行发送</li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/26a238c797118c47e2d6c9190cac73dd-8d1f4c.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>C++虽然有多继承，但是不推荐使用，因为会带来耦合。而如果继承的是一个父类加上多个接口就可以。</li><li>对于现实需求有变化的实体，比如本文的进度条。有很多种方式可以表示进度，比如直接用数字表示。对于这种情况一般可以把容易变化的对象进行更深层次的抽象。对于本文中未运用观察者模式之前的代码，已经违反了依赖倒置原则。</li><li>有些框架是把Observer的注册、删除、通知放在一个基类里。</li><li>使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合。</li><li>目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。</li><li>观察者自己决定是否需要订阅通知，目标对象对此一无所知。</li><li>Observer模式是基于事件的UI框架中非常常用的设计模式，也是 MVC模式的一个重要组成部分。</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组件协作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%8F%98%E5%8C%96%EF%BC%9A%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%8F%98%E5%8C%96%EF%BC%9A%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，”行为请求者“与”行为实现者“通常呈现一种”紧耦合“。但在某些场合，比如需要对行为进行”记录、撤销/重(undo/redo)、事务“等处理，这种无法抵御变化的紧耦合是不合适的。</li><li>在这种情况下，如何将”行为请求者“与”行为实现者“解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>将一个请求（行为）封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Command</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteCommand1</span> :</span> <span class="hljs-keyword">public</span> Command<br>&#123;<br>    string arg;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ConcreteCommand1</span>(<span class="hljs-keyword">const</span> string &amp; a) : <span class="hljs-built_in">arg</span>(a) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt; <span class="hljs-string">&quot;#1 process...&quot;</span>&lt;&lt;arg&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteCommand2</span> :</span> <span class="hljs-keyword">public</span> Command<br>&#123;<br>    string arg;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ConcreteCommand2</span>(<span class="hljs-keyword">const</span> string &amp; a) : <span class="hljs-built_in">arg</span>(a) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt; <span class="hljs-string">&quot;#2 process...&quot;</span>&lt;&lt;arg&lt;&lt;endl;<br>    &#125;<br>&#125;;<br>        <br>        <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MacroCommand</span> :</span> <span class="hljs-keyword">public</span> Command<br>&#123;<br>    vector&lt;Command*&gt; commands;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addCommand</span><span class="hljs-params">(Command *c)</span> </span>&#123; commands.<span class="hljs-built_in">push_back</span>(c); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c : commands)<br>        &#123;<br>            c-&gt;<span class="hljs-built_in">execute</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br>                <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-function">ConcreteCommand1 <span class="hljs-title">command1</span><span class="hljs-params">(receiver, <span class="hljs-string">&quot;Arg ###&quot;</span>)</span></span>;<br>    <span class="hljs-function">ConcreteCommand2 <span class="hljs-title">command2</span><span class="hljs-params">(receiver, <span class="hljs-string">&quot;Arg $$$&quot;</span>)</span></span>;<br>    <br>    MacroCommand macro;<br>    macro.<span class="hljs-built_in">addCommand</span>(&amp;command1);<br>    macro.<span class="hljs-built_in">addCommand</span>(&amp;command2);<br>    <br>    macro.<span class="hljs-built_in">execute</span>();<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/54df981e468227d271d5f54e9d39c869-77569.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Command模式的根本目的在于将”行为请求者“与”行为实现者“解耦，在面向对象语言中，常见的实现手段是”将行为抽象为对象“。</li><li>实现<code>Command</code>接口的具体命令对象<code>ConcreteCommand</code>有时候根据需要可能会保存一些额外的状态信息。通过使用Composite模式，可以将多个”命令“封装为一个”复合命令“<code>MacroCommand</code>。</li><li>Command模式与C++中的函数对象有些类似。但两者定义行为接口的规范有所区别：Command以面向对象中的”接口-实现“来定义行为接口规范，更严格，但有性能损失；C++函数对象以函数签名来定义行为接口规范，更灵活，性能更高。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>行为变化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>访问器模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%8F%98%E5%8C%96%EF%BC%9A%E8%AE%BF%E9%97%AE%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%8F%98%E5%8C%96%EF%BC%9A%E8%AE%BF%E9%97%AE%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，由于需求的改变，某些类层次结构中常常需要增加新的行为（方法），如果在基类中做这样的更改，将会给子类带来很繁重的变更负担，甚至破坏原有设计。</li><li>如何在不改变类层次结构的前提下，在运行时根据需要透明地为类层次结构上的各个类动态添加新的操作，从而避免上述问题？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>表示一个作用于某对象结构中的各元素的操作。使得可以在不改变（稳定）各元素的类的前提下定义（扩展）作用于这些元素的新操作（变化）。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用访问器模式之前：</strong></p><p>如果后期需求的变动，需要<code>Element</code>派生类需要添加功能，那么不仅在<code>Element</code>中需要添加，同时<code>Element</code>派生类中也需要添加，违反了开闭原则。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visitor</span>;</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Element</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Func1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Func3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//...</span><br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Element</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementA</span> :</span> <span class="hljs-keyword">public</span> Element<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func1</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementB</span> :</span> <span class="hljs-keyword">public</span> Element<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func1</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <span class="hljs-comment">//***</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">//***</span><br>    &#125;<br>    <br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>运用访问器模式之后：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visitor</span>;</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Element</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor&amp; visitor)</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//第一次多态辨析</span><br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Element</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementA</span> :</span> <span class="hljs-keyword">public</span> Element<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor &amp;visitor)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        visitor.<span class="hljs-built_in">visitElementA</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <br><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementB</span> :</span> <span class="hljs-keyword">public</span> Element<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor &amp;visitor)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        visitor.<span class="hljs-built_in">visitElementB</span>(*<span class="hljs-keyword">this</span>); <span class="hljs-comment">//第二次多态辨析</span><br>    &#125;<br><br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visitor</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitElementA</span><span class="hljs-params">(ElementA&amp; element)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitElementB</span><span class="hljs-params">(ElementB&amp; element)</span> </span>= <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Visitor</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//==================================</span><br><br><span class="hljs-comment">//扩展1</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visitor1</span> :</span> <span class="hljs-keyword">public</span> Visitor&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visitElementA</span><span class="hljs-params">(ElementA&amp; element)</span> <span class="hljs-keyword">override</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Visitor1 is processing ElementA&quot;</span> &lt;&lt; endl;<br>    &#125;<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visitElementB</span><span class="hljs-params">(ElementB&amp; element)</span> <span class="hljs-keyword">override</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Visitor1 is processing ElementB&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br>     <br><span class="hljs-comment">//扩展2</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visitor2</span> :</span> <span class="hljs-keyword">public</span> Visitor&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visitElementA</span><span class="hljs-params">(ElementA&amp; element)</span> <span class="hljs-keyword">override</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Visitor2 is processing ElementA&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visitElementB</span><span class="hljs-params">(ElementB&amp; element)</span> <span class="hljs-keyword">override</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Visitor2 is processing ElementB&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br>        <br>    <br><br>        <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Visitor2 visitor;<br>    ElementB elementB;<br>    elementB.<span class="hljs-built_in">accept</span>(visitor);<span class="hljs-comment">// double dispatch</span><br>    <br>    ElementA elementA;<br>    elementA.<span class="hljs-built_in">accept</span>(visitor);<br><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果此时需要为Element派生类添加新功能，只需要将Visitor再派生出一个子类出来，让这个子类来解决即可。</p><p>但是这个模式看起来会比较不灵活，原因是Element必须是稳定的，在设计之初就应该确定好，后期不能再更改了；同样的Element派生类的数量也需要稳定不变。</p><p>用白话解释就是：将我交给别人执行，只是别人很懒，不愿意我有任何改动。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/2c641454658042ce3af98cbf658b4bc2-476f4.png" alt="结构"></p><p>从整体看感觉有点像在代码层面模仿类的虚函数实现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Visitor存在的前提是Element派生类的个数确定。也就是说当Element的派生数量不稳定，剧烈变化，访问器模式就不适用了。</li><li>Visitor模式通过所谓的双重分发（double dispatch）来实现在不更改（不添加新的操作-编译时）Element类层次结构的前提下，在运行时透明地为类层次结构上的各个类动态添加新的操作（支持变化）。</li><li>所谓双重分发即Visitor模式中间包括了两个多态分发（注意其中的多态机制）：第一个为accept方法的多态辨析；第二个为visitElementX方法的多态辨析。</li><li>Visitor模式的最大缺点在于扩展类层次结构（增添新的Element子类），会导致Visitor模式的改变。因此Visitor模式适用于”Element类层次结构稳定，而其中的操作却经常面临频繁改动”。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>行为变化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象设计原则</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h2 id="依赖倒置（DIP）"><a href="#依赖倒置（DIP）" class="headerlink" title="依赖倒置（DIP）"></a>依赖倒置（DIP）</h2><ul><li>高层模块(稳定)不应该依赖于低层模块（变化），二者应依赖于抽象（稳定）</li><li>抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）</li></ul><p><strong>注：这里所说的依赖是编译式依赖</strong></p><p>现在需要我们写一个能画指定图形的方法，我们通常在脑海里会有如下思路：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">line</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">line</span>();<br>~<span class="hljs-built_in">line</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">rect</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">rect</span>();<br>~<span class="hljs-built_in">rect</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawShape</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string type)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;line&quot;</span>)<br>&#123;<br>line l;<br>l.<span class="hljs-built_in">draw</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;rect&quot;</span>)<br>&#123;<br>rect r;<br>r.<span class="hljs-built_in">draw</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">drawShape</span>(<span class="hljs-string">&quot;line&quot;</span>);<span class="hljs-comment">/*画直线*/</span><br><span class="hljs-built_in">drawShape</span>(<span class="hljs-string">&quot;rect&quot;</span>);<span class="hljs-comment">/*画矩形*/</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><br>这时候，需求变了，需要再添加一个画圆形的方法，那么上面的代码需要改成：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">line</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">line</span>();<br>~<span class="hljs-built_in">line</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">rect</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">rect</span>();<br>~<span class="hljs-built_in">rect</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">circle</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">circle</span>();<br>~<span class="hljs-built_in">circle</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawShape</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string type)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;line&quot;</span>)<br>&#123;<br>line l;<br>l.<span class="hljs-built_in">draw</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;rect&quot;</span>)<br>&#123;<br>rect r;<br>r.<span class="hljs-built_in">draw</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;circle&quot;</span>)<span class="hljs-comment">/*此处改动*/</span><br>&#123;<br>circle c;<br>c.<span class="hljs-built_in">draw</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">drawShape</span>(<span class="hljs-string">&quot;line&quot;</span>);<span class="hljs-comment">/*画直线*/</span><br><span class="hljs-built_in">drawShape</span>(<span class="hljs-string">&quot;rect&quot;</span>);<span class="hljs-comment">/*画矩形*/</span><br><span class="hljs-built_in">drawShape</span>(<span class="hljs-string">&quot;circle&quot;</span>);<span class="hljs-comment">/*画圆形*/</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​        看起来没毛病，逻辑上符合我们的需求。在实际应用场景中，高层模块通常调用低层模块。在上述代码里，我们可以把main函数看成高层模块，line，rect，circle等具体实现类看成低层模块。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道在开发中，需求是不断在变化的。今天让你添加一个画圆形的需求，明天又让你添加一个画梯形的需求。从需求的角度看，低层模块不断在变化，这是其一。其二，代码修改的原因不仅限于需求变更。从低层模块的内部出发，不同的平台，不同的硬件，不同的API或者调用方法，都会导致低层模块的实现随时更改。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据这两点，我们可以得出低层模块是不稳定的，是随时会更改的。此时我们再来看上面的代码，会发现高层模块直接依赖于低层模块，这将导致高层模块也变得不稳定，不符合依赖倒置原则。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210415173908.png" alt="不符合依赖倒置原则"><br>        为了满足依赖倒置原则，我们从面向对象设计的一个核心出发：抽象。我们把低层模块抽象成一个基类，即shape，并让所有需求实现接口draw()。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shape</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">shape</span>();<br>~<span class="hljs-built_in">shape</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">line</span>:</span><span class="hljs-keyword">public</span> shape<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">line</span>();<br>~<span class="hljs-built_in">line</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">rect</span> :</span><span class="hljs-keyword">public</span> shape<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">rect</span>();<br>~<span class="hljs-built_in">rect</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>shape* s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">rect</span>();<br>s-&gt;<span class="hljs-built_in">draw</span>();<span class="hljs-comment">/*画矩形*/</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​        如果再添加一个画圆形的需求，和line、rect这两个类一样，我们只要负责实现circle这个类就行，而我们抽象出来的shape这个类是不需要改变的，也就是说这个抽象类是稳定的，通过接口隔离了高低两个模块。此时高层模块依赖于抽象，低层模块也依赖于抽象。</p><p>​        若此时我们需要修改画直线的方法，只要修改line类中的draw方法即可，抽象出来的shape我们无需改动。也就是说，抽象不关心你是如何实现的（抽象不依赖于实现细节），但是你要实现什么，由抽象来决定（实现细节应该依赖于抽象）。<br><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210415180439.png" alt="图2"></p><h2 id="开放封闭原则（OCP）"><a href="#开放封闭原则（OCP）" class="headerlink" title="开放封闭原则（OCP）"></a>开放封闭原则（OCP）</h2><ul><li>对扩展开放，对更改封闭</li><li>类模块应该是可扩展的，但是不可修改</li></ul><p>依旧是这段代码，只是稍加修改：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">line</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">line</span>();<br>~<span class="hljs-built_in">line</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">rect</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">rect</span>();<br>~<span class="hljs-built_in">rect</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">drawShape</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">drawShape</span>();<br>~<span class="hljs-built_in">drawShape</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string type)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;line&quot;</span>)<br>&#123;<br>line l;<br>l.<span class="hljs-built_in">draw</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;rect&quot;</span>)<br>&#123;<br>rect r;<br>r.<span class="hljs-built_in">draw</span>();<br>&#125;<br>&#125;<br><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>drawShape d;<br>d.<span class="hljs-built_in">draw</span>(<span class="hljs-string">&quot;line&quot;</span>);<span class="hljs-comment">/*画直线*/</span><br>d.<span class="hljs-built_in">draw</span>(<span class="hljs-string">&quot;rect&quot;</span>);<span class="hljs-comment">/*画矩形*/</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><br>此时同样新增了一个画圆形的需求：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">line</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">line</span>();<br>~<span class="hljs-built_in">line</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">rect</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">rect</span>();<br>~<span class="hljs-built_in">rect</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">circle</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">circle</span>();<br>~<span class="hljs-built_in">circle</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">drawShape</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">drawShape</span>();<br>~<span class="hljs-built_in">drawShape</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string type)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;line&quot;</span>)<br>&#123;<br>line l;<br>l.<span class="hljs-built_in">draw</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;rect&quot;</span>)<br>&#123;<br>rect r;<br>r.<span class="hljs-built_in">draw</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;circle&quot;</span>)<span class="hljs-comment">/*此处更改*/</span><br>&#123;<br>circle c;<br>c.<span class="hljs-built_in">draw</span>();<br>&#125;<br>&#125;<br><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>drawShape ds;<br>ds.<span class="hljs-built_in">draw</span>(<span class="hljs-string">&quot;line&quot;</span>);<span class="hljs-comment">/*画直线*/</span><br>ds.<span class="hljs-built_in">draw</span>(<span class="hljs-string">&quot;rect&quot;</span>);<span class="hljs-comment">/*画矩形*/</span><br>ds.<span class="hljs-built_in">draw</span>(<span class="hljs-string">&quot;circle&quot;</span>);<span class="hljs-comment">/*画圆形*/</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​        这样的写法在逻辑上没有任何问题，也符合我们的需求。但是当有新的需求不断出现，drawShape类中的draw方法就得不停的修改。这种做法不仅会让开发效率低下，而且还违反了开放封闭原则（对更改封闭）。<br>​        为了满足开放封闭原则，我们同样采取抽象的办法：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shape</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">shape</span>();<br>~<span class="hljs-built_in">shape</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">line</span> :</span><span class="hljs-keyword">public</span> shape<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">line</span>();<br>~<span class="hljs-built_in">line</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">rect</span> :</span><span class="hljs-keyword">public</span> shape<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">rect</span>();<br>~<span class="hljs-built_in">rect</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">circle</span>:</span><span class="hljs-keyword">public</span> shape<br>&#123;<br><span class="hljs-built_in">circle</span>();<br>~<span class="hljs-built_in">circle</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">drawShape</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">drawShape</span>();<br>~<span class="hljs-built_in">drawShape</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(shape* s)</span></span><br><span class="hljs-function"></span>&#123;<br>s-&gt;<span class="hljs-built_in">draw</span>();<br>&#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>drawShape ds;<br>ds.<span class="hljs-built_in">draw</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">rect</span>());<span class="hljs-comment">/*画矩形*/</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​        我们添加了一个shape抽象类，原有的drawShape中的draw方法重写，修改成依赖于shape提供的接口draw。这时你的需求无论怎么添加（对扩展开放），drawShape这个类始终不用修改（对更改封闭）。<br>​        开放封闭原则和依赖倒置原则，在抽象这个角度上都有一定的相似性。借用另外一位博主的话：“开放封闭原则通过抽象来避免代码发生更改，而依赖倒置原则更偏向于层和层之间的解耦”。</p><h2 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h2><ul><li>一个类应该仅有一个引起它变化的原因</li><li>变化的方向隐含着类的责任</li></ul><p>字面意思，说白了就是一个类应该只有一种职责，避免责任太多导致的代码臃肿（比如上帝类）。</p><h2 id="Liskov替换原则（LSP）"><a href="#Liskov替换原则（LSP）" class="headerlink" title="Liskov替换原则（LSP）"></a>Liskov替换原则（LSP）</h2><ul><li>子类必须能够替换它们的基类（IS-A）</li><li>继承表达类型抽象<br>所有需要父类的地方，子类都可以传过去。</li></ul><h2 id="GOF模式分类"><a href="#GOF模式分类" class="headerlink" title="GOF模式分类"></a>GOF模式分类</h2><p>从目的来看：</p><ol><li>创建型</li><li>结构型</li><li>行为型</li></ol><p>从范围来看：</p><ol><li>类模式处理类与子类的静态关系</li><li>对象模式处理对象间的动态关系</li></ol><hr><h3 id="从封装变化角度对模式分类"><a href="#从封装变化角度对模式分类" class="headerlink" title="从封装变化角度对模式分类"></a>从封装变化角度对模式分类</h3><div class="table-container"><table><thead><tr><th style="text-align:left">类别</th><th>模式</th></tr></thead><tbody><tr><td style="text-align:left">组件协作</td><td>Template Method,Strategy,Observer/Event</td></tr><tr><td style="text-align:left">单一职责</td><td>Decoraror,Bridge</td></tr><tr><td style="text-align:left">对象创建</td><td>Factory Method,Abstract Factory,Prototype,Builder</td></tr><tr><td style="text-align:left">对象性能</td><td>Singleton,Flyweight</td></tr><tr><td style="text-align:left">接口隔离</td><td>Facade,Proxy,Mediator, Adapter</td></tr><tr><td style="text-align:left">状态变化</td><td>Memento,State</td></tr><tr><td style="text-align:left">数据结构</td><td>Composite,Iterator,Chain of Resposibility</td></tr><tr><td style="text-align:left">行为变化</td><td>Command,Visitor</td></tr><tr><td style="text-align:left">领域问题</td><td>Interpreter</td></tr></tbody></table></div><ul><li>组件协作：现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过晚期绑定，来实现框架与应用程序之 间的松耦合，是二者之间协作时常用的模式。</li><li>单一职责：在软件组件的设计中，如果责任划分的不清晰，使用继承得到的 结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。</li><li>对象创建：通过“对象创建” 模式绕开new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。</li><li>对象性能：面向对象很好地解决了”抽象“的问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面对对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。</li><li>接口隔离：在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。</li><li>状态变化：在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？”状态变化“模式为这一问题提供了一种解决方案。</li><li>数据结构：常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。</li><li>行为变化：在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。”行为变化“模式将组件的行为和组件本身进行解耦，从而支持组件行为的变化，实现两者之间的松耦合。</li><li>领域规则：在特定领域中，某些变化虽然频繁，但可以抽象为某种规则。这时候，结合特定领域，将问题抽象为语法规则，将问题抽象为语法规则，从而给出在该领域下的一般性解决方案。</li></ul><h2 id="重构获得模式"><a href="#重构获得模式" class="headerlink" title="重构获得模式"></a>重构获得模式</h2><p>即通过修正来得到一种良好的解决方案</p><p>重构技巧：（以下五点实际上是同一回事）</p><ul><li>静态-&gt;动态</li><li>早绑定-&gt;晚绑定</li><li>继承-&gt;组合</li><li>编译时依赖-&gt;运行时依赖</li><li>紧耦合-&gt;松耦合</li></ul><p>重构要点：</p><ol><li>寻找变化点，在变化点处应用设计模式。将变化和稳定分离开</li></ol><h2 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h2><ul><li>不要为了模式而模式</li><li>关注抽象类&amp;接口</li><li>理清变化点和稳定点</li><li>审视依赖关系</li><li>要有Framework和Application的区隔思维</li><li>良好的设计是演化的结果</li></ul><h2 id="什么时候不用模式"><a href="#什么时候不用模式" class="headerlink" title="什么时候不用模式"></a>什么时候不用模式</h2><ul><li>代码可读性很差时</li><li>需求理解还很浅时</li><li>变化没有显现时</li><li>不是系统的关键依赖点</li><li>项目没有复用价值时</li><li>项目将要发布时</li></ul><blockquote><p>参考：<br><a href="https://blog.csdn.net/tjiyu/article/details/76551307">面向对象设计原则（三）：里氏替换原则（LSP）</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解释器模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%A2%86%E5%9F%9F%E8%A7%84%E5%88%99%EF%BC%9A%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%A2%86%E5%9F%9F%E8%A7%84%E5%88%99%EF%BC%9A%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，如果某一特定领域的问题比较复杂，类似的结构不断重复出现，如果使用普通的编程方式来实现将面临非常频繁的变化。</li><li>在这种情况下，将特定领域的问题表达为某种语法规则下的句子，然后构建一个解释器来解释这样的句子，从而达到解决问题的目的。</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表达来解释语言中的句子。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>以下模拟计算算术表达式（只有加法和减法）：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Expression</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; var)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Expression</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//变量表达式</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VarExpression</span>:</span> <span class="hljs-keyword">public</span> Expression &#123;<br>    <br>    <span class="hljs-keyword">char</span> key;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">VarExpression</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>&amp; key)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;key = key;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; var)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> var[key];<br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-comment">//符号表达式</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SymbolExpression</span> :</span> <span class="hljs-keyword">public</span> Expression &#123;<br>    <br>    <span class="hljs-comment">// 运算符左右两个参数</span><br><span class="hljs-keyword">protected</span>:<br>    Expression* left;<br>    Expression* right;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SymbolExpression</span>( Expression* left,  Expression* right):<br>        <span class="hljs-built_in">left</span>(left),<span class="hljs-built_in">right</span>(right)&#123;<br>        <br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-comment">//加法运算</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddExpression</span> :</span> <span class="hljs-keyword">public</span> SymbolExpression &#123;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">AddExpression</span>(Expression* left, Expression* right):<br>        <span class="hljs-built_in">SymbolExpression</span>(left,right)&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; var)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> left-&gt;<span class="hljs-built_in">interpreter</span>(var) + right-&gt;<span class="hljs-built_in">interpreter</span>(var);<br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-comment">//减法运算</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubExpression</span> :</span> <span class="hljs-keyword">public</span> SymbolExpression &#123;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SubExpression</span>(Expression* left, Expression* right):<br>        <span class="hljs-built_in">SymbolExpression</span>(left,right)&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; var)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> left-&gt;<span class="hljs-built_in">interpreter</span>(var) - right-&gt;<span class="hljs-built_in">interpreter</span>(var);<br>    &#125;<br>    <br>&#125;;<br><br><br><br><span class="hljs-function">Expression*  <span class="hljs-title">analyse</span><span class="hljs-params">(string expStr)</span> </span>&#123;<br>    <br>    stack&lt;Expression*&gt; expStack;<br>    Expression* left = <span class="hljs-literal">nullptr</span>;<br>    Expression* right = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;expStr.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>(expStr[i])<br>        &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                <span class="hljs-comment">// 加法运算</span><br>                left = expStack.<span class="hljs-built_in">top</span>();<br>                right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">VarExpression</span>(expStr[++i]);<br>                expStack.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">AddExpression</span>(left, right));<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                <span class="hljs-comment">// 减法运算</span><br>                left = expStack.<span class="hljs-built_in">top</span>();<br>                right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">VarExpression</span>(expStr[++i]);<br>                expStack.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">SubExpression</span>(left, right));<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-comment">// 变量表达式</span><br>                expStack.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">VarExpression</span>(expStr[i]));<br>        &#125;<br>    &#125;<br>   <br>    Expression* expression = expStack.<span class="hljs-built_in">top</span>();<br><br>    <span class="hljs-keyword">return</span> expression;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">(Expression* expression)</span></span>&#123;<br>    <br>    <span class="hljs-comment">//释放表达式树的节点内存...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;<br>    <br>    <br>    string expStr = <span class="hljs-string">&quot;a+b-c+d-e&quot;</span>;<br>    map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; var;<br>    var.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">5</span>));<br>    var.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">2</span>));<br>    var.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">1</span>));<br>    var.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-number">6</span>));<br>    var.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">10</span>));<br><br>    <br>    Expression* expression= <span class="hljs-built_in">analyse</span>(expStr);<br>    <br>    <span class="hljs-keyword">int</span> result=expression-&gt;<span class="hljs-built_in">interpreter</span>(var);<br>    <br>    cout&lt;&lt;result&lt;&lt;endl;<br>    <br>    <span class="hljs-built_in">release</span>(expression);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a81690cc50fbd0dc2f1b5dbf2208a81e-ad92d.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Interpreter模式的应用场合是Interpreter模式应用中的难点，只有满足”业务规则频繁变化，且类似的结构不断重复出现，并且容易抽象为语法规则的问题“才适合使用Interpreter模式。</li><li>使用Interpreter模式来表示文法规则，从而可以使用面向对象技巧来方便地”扩展“文法。</li><li>Interpreter模式比较适合简单的文法表示，对于复杂的文法表示，Interpreter模式会产生比较大的类层次结构，需要求助于语法分析生成器这样的标准工具。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>领域规则</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
