<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>高级开发</title>
    <link href="/2021/05/11/C++/%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91/"/>
    <url>/2021/05/11/C++/%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="类体里的内联函数"><a href="#类体里的内联函数" class="headerlink" title="类体里的内联函数"></a>类体里的内联函数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br><span class="hljs-built_in">complex</span> (T r = <span class="hljs-number">0</span>, T i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i)&#123;&#125; <br>complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp;); <br><span class="hljs-function">T <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125; <span class="hljs-comment">//内联函数的候选人</span><br><span class="hljs-function">T <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125; <span class="hljs-comment">//内联函数的候选人</span><br><span class="hljs-keyword">private</span>: <br>T re, im; <span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-keyword">const</span> complex&amp;);  <br>&#125;;<br></code></pre></div></td></tr></table></figure><p>在类体里定义的函数会成为内联函数的<strong>候选人</strong>，最终是否为内联函数由编译器决定。</p><h3 id="构造函数的重载"><a href="#构造函数的重载" class="headerlink" title="构造函数的重载"></a>构造函数的重载</h3><p>构造函数重载的情况很常见，但是比如</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br><span class="hljs-built_in">complex</span> (<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i) &#123;&#125; <span class="hljs-comment">//构造函数1</span><br><span class="hljs-built_in">complex</span> () : <span class="hljs-built_in">re</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">im</span>(<span class="hljs-number">0</span>) &#123;&#125; <span class="hljs-comment">//构造函数2</span><br>complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp;); <br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125; <br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125; <br><span class="hljs-keyword">private</span>: <br><span class="hljs-keyword">double</span> re, im; <br><br><span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-keyword">const</span> complex&amp;);  <br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>构造函数1</strong>和<strong>构造函数2</strong>是不能同时存在的，原因是<strong>构造函数1</strong>的形参设置了默认值，编译器无法分辨它和<strong>构造函数2</strong>的区别</p><h2 id="参数传递与返回值"><a href="#参数传递与返回值" class="headerlink" title="参数传递与返回值"></a>参数传递与返回值</h2><h3 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h3><p>const关键字用于成员函数（如下面代码段中的<strong>一号const</strong>和<strong>二号const</strong>），表示该成员函数所执行的内容不会改变类里面的数据。</p><p>另外，const用于变量（如下面代码段中的<strong>三号const</strong>），表示该变量的值无法被修改。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/*xxx.h*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">complex</span> (<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i)  &#123; &#125; <br>    complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp;); <br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125; <span class="hljs-comment">//一号const</span><br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125; <span class="hljs-comment">//二号const</span><br><span class="hljs-keyword">private</span>: <br>    <span class="hljs-keyword">double</span> re, im; <br>    <span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-keyword">const</span> complex&amp;);  <br>&#125;;<br><br><span class="hljs-comment">/*mian.cc*/</span><br><span class="hljs-comment">//...</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">const</span> complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//三号const</span><br>cout &lt;&lt; c1.<span class="hljs-built_in">real</span>();<span class="hljs-comment">//代码1</span><br>cout &lt;&lt; c1.<span class="hljs-built_in">imag</span>();<span class="hljs-comment">//代码2</span><br>&#125;<br><span class="hljs-comment">//...</span><br></code></pre></div></td></tr></table></figure><p>假设有两种情况：</p><ol><li>一号const和二号const存在</li><li>一号const和二号const不存在</li></ol><p>第一种情况是正确的。c1为const，故无法更改c1的内容。又因为<strong>real()</strong>方法为const，所以<strong>代码1</strong>和<strong>代码2</strong>不会报错。</p><p>第二种情况是错误的。此时<strong>real()</strong>和<strong>imag()</strong>这两个成员函数不是const，而c1变量又是const，当执行<code>cout&lt;&lt;c1.real();</code>时，编译器认为<strong>real()</strong>这个方法可能会改变c1变量的内容，故会报错。这种情况下把<strong>三号const</strong>也去掉，编译器就不会报错了。</p><p>不过为了程序的健壮性与开发规范，没有改变类数据的成员函数加上const是必不可少的。</p><h3 id="参数传递和返回值传递"><a href="#参数传递和返回值传递" class="headerlink" title="参数传递和返回值传递"></a>参数传递和返回值传递</h3><ol><li>值传递：值有多大就传多大</li><li>指针：传地址</li><li>引用：引用的底层就是指针，传引用就是传指针</li></ol><p><strong>参数和返回值传递尽量使用引用</strong>。不过有些情况可以用值，比如值的大小&lt;4字节时，速度会更快点。</p><p>引用速度很快，但是它和指针一样，内容会被修改。当我们只想追求参数传递速度而不想改变引用的内容时，可以使用const来修饰引用。如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br><span class="hljs-built_in">complex</span> (<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i)  &#123; &#125; <br>complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp;); <span class="hljs-comment">//const引用修饰的形参</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125; <br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125; <br><span class="hljs-keyword">private</span>: <br><span class="hljs-keyword">double</span> re, im; <br><span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-keyword">const</span> complex&amp;);<span class="hljs-comment">//const引用修饰的返回值</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>当函数返回值为函数的<strong>局部变量</strong>时，禁止使用引用。</p><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>在一个类里声明一个友元函数，表示这个友元函数可以随意访问这个类的内容，比如private修饰的类成员数据。即类对于友元函数失去了封装性。</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br><span class="hljs-built_in">complex</span> (<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i)  &#123; &#125; <br>complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp;); <br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125; <br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125; <br><span class="hljs-keyword">private</span>: <br><span class="hljs-keyword">double</span> re, im ; <br><span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-keyword">const</span> complex&amp;);  <br>&#125;;<br><br><span class="hljs-keyword">inline</span> complex&amp; __doapl (complex* ths, <span class="hljs-keyword">const</span> complex&amp; r) &#123; <br>    ths - &gt;re += r.re ; <br>    ths - &gt;im += r.im ; <br>    <span class="hljs-keyword">return</span> *ths ; <br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于友元函数还有个特例：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br><span class="hljs-built_in">complex</span> (<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i)  &#123; &#125; <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> complex&amp; param)</span> </span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> param.re + param.im; &#125; <br><span class="hljs-keyword">private</span>: <br><span class="hljs-keyword">double</span> re, im; <br>&#125;;<br><span class="hljs-comment">//...</span><br>&#123; <br><span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>; <br>complex c2; <br>c2.<span class="hljs-built_in">func</span>(c1); <br>&#125;<br><span class="hljs-comment">//...</span><br></code></pre></div></td></tr></table></figure><p>上面的例子是正确。虽然re和im这两个类成员数据是私有的，但是c2却能访问c1的私有变量。这个隐藏属性用一句话就能解释：</p><p><strong>相同 class 的各个 objects 互为 friends (友元)</strong>。</p><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><h3 id="成员函数的隐藏参数"><a href="#成员函数的隐藏参数" class="headerlink" title="成员函数的隐藏参数"></a>成员函数的隐藏参数</h3><p>所有成员函数都自带一个隐藏的<strong>this</strong>指针</p><h3 id="返回值引用的语法分析"><a href="#返回值引用的语法分析" class="headerlink" title="返回值引用的语法分析"></a>返回值引用的语法分析</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//XXX.h</span><br><span class="hljs-comment">//方法1</span><br><span class="hljs-keyword">inline</span> complex&amp;<span class="hljs-comment">//返回值是引用类型，速度更快</span><br>__doapl(complex* ths, <span class="hljs-keyword">const</span> complex&amp; r) &#123; <br>    ... <br>    <span class="hljs-keyword">return</span> *ths; <span class="hljs-comment">//这里的*表示取ths这个指针的内容</span><br>&#125; <br><br><span class="hljs-comment">//方法2</span><br><span class="hljs-keyword">inline</span> complex&amp; <span class="hljs-comment">//这里返回值改成“值”类型也是没问题的</span><br>complex::<span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp; r) &#123; <span class="hljs-comment">//这里的参数列表只有一个r,这个r指的是右值。而左值是隐藏的this</span><br>    <span class="hljs-keyword">return</span> __doapl(<span class="hljs-keyword">this</span>,r); <span class="hljs-comment">//调用__doapl</span><br>&#125;<br><br><span class="hljs-comment">//main.c</span><br>&#123;<br><span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-function">complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>c2 += c1;<span class="hljs-comment">//上面代码的返回值类型的改动不会影响到这行代码的结果</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>__doapl</strong>这个函数的返回值为引用，所以调用该函数者，无论是以值的类型接收还是以引用的类型接收都可以，与<strong>__doapl</strong>无关。</p><p>我们设计<strong>方法2</strong>的时候，如果只考虑使用者只会编写出<code>c2 += c1</code>这种情况，那么方法2的返回值类型改成void的也是可以的。但是当使用者编写出<code>c3 += c2 += c1</code>这样的连续赋值的代码时，方法2为void返回值类型就会出错。</p><p>一个好的函数设计应该做到：</p><p><strong>传递者无需知道接收者是以引用形式接收</strong></p><p>那么如何判断一个函数的返回值类型能不能为引用呢？其实很简单，只要判断返回值在函数内是不是该函数的临时变量，如果是，就老老实实的用值类型；如果不是，即该返回值是事先存在的（还没调用到该函数时就已经存在了），那么就可以用引用类型的返回值。</p><h3 id="操作符重载的非成员函数与临时对象"><a href="#操作符重载的非成员函数与临时对象" class="headerlink" title="操作符重载的非成员函数与临时对象"></a>操作符重载的非成员函数与临时对象</h3><p>例1：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//函数1</span><br><span class="hljs-keyword">inline</span> complex <br><span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">const</span> complex&amp; x, <span class="hljs-keyword">const</span> complex&amp; y) <br>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>(<span class="hljs-built_in">real</span> (x) + <span class="hljs-built_in">real</span> (y), <span class="hljs-built_in">imag</span> (x) + <span class="hljs-built_in">imag</span> (y)); <br>&#125; <br><br><span class="hljs-comment">//函数2</span><br><span class="hljs-keyword">inline</span> complex <br><span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">const</span> complex&amp; x, <span class="hljs-keyword">double</span> y) <br>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>(<span class="hljs-built_in">real</span> (x) + y, <span class="hljs-built_in">imag</span> (x)); <br>&#125; <br><br><span class="hljs-comment">//函数3</span><br><span class="hljs-keyword">inline</span> complex <br><span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">const</span> complex&amp; y) <br>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>(x + <span class="hljs-built_in">real</span> (y), <span class="hljs-built_in">imag</span> (y)); <br>&#125;<br><br><span class="hljs-comment">//函数4</span><br><span class="hljs-keyword">inline</span> complex<br><span class="hljs-keyword">operator</span> - (<span class="hljs-keyword">const</span> complex&amp; x)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span> (-<span class="hljs-built_in">real</span> (x), -<span class="hljs-built_in">imag</span> (x));<br>&#125;<br><br><span class="hljs-comment">//函数5</span><br><span class="hljs-keyword">inline</span> complex<br><span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">const</span> complex&amp; x)<br>&#123;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-comment">//main.c</span><br>&#123;<br><span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br>complex c2;<br>c2 = c1 + c2;<span class="hljs-comment">//对应函数1</span><br>c2 = c1 + <span class="hljs-number">5</span>;<span class="hljs-comment">//对应函数2</span><br>c2 = <span class="hljs-number">7</span> + c1;<span class="hljs-comment">//对应函数3</span><br>    cout &lt;&lt; -c1;<span class="hljs-comment">//对应函数4</span><br>    cout &lt;&lt; +c1;<span class="hljs-comment">//对应函数5</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面的函数1~4的返回值类型都是值，而不是引用。原因是这几个函数最后返回的complex都是<strong>临时对象</strong>，所以不能用引用，否则会出错。函数5应该可以把返回值类型改成引用，由于代码源自标准库，所以设计者有他的道理或者说该函数不够完美。</p><p>例2：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//函数1</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> complex</span><br><span class="hljs-function"><span class="hljs-title">conj</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> complex&amp; x)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span> (<span class="hljs-built_in">real</span> (x), -<span class="hljs-built_in">imag</span> (x));<br>&#125;<br><br><span class="hljs-comment">//函数2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream.h&gt;</span></span><br>ostream&amp;<span class="hljs-comment">//函数2的返回值类型</span><br><span class="hljs-keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="hljs-keyword">const</span> complex&amp; x)<br>&#123;<br><span class="hljs-keyword">return</span> os &lt;&lt; <span class="hljs-string">&#x27;(&#x27;</span> &lt;&lt; <span class="hljs-built_in">real</span> (x) &lt;&lt; <span class="hljs-string">&#x27;,&#x27;</span> &lt;&lt; <span class="hljs-built_in">imag</span> (x) &lt;&lt; <span class="hljs-string">&#x27;)&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">//main.c</span><br>&#123;<br><span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-built_in">conj</span>(c1);<span class="hljs-comment">//代码1</span><br>cout &lt;&lt; c1 &lt;&lt; <span class="hljs-built_in">conj</span>(c1);<span class="hljs-comment">//代码2</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于函数2，返回值类型可以为void，但是只有代码1才能正确执行。当返回值类型为引用时，代码1和代码2都能正确执行。</p><p>另外，我们也可以写出<code>c1&lt;&lt;cout;</code>这样的代码，将<strong>函数2</strong>写为成员函数就会出现这种情况，不过一般不这么做，因为不符合规范。</p><h2 id="拷贝构造，拷贝复制，析构（Big-Three）"><a href="#拷贝构造，拷贝复制，析构（Big-Three）" class="headerlink" title="拷贝构造，拷贝复制，析构（Big Three）"></a>拷贝构造，拷贝复制，析构（Big Three）</h2><h3 id="默认的Big-Three"><a href="#默认的Big-Three" class="headerlink" title="默认的Big Three"></a>默认的Big Three</h3><p>编译器都会给类默认生成Big Three，当然我们也可以自己写。但是当一个类里面有指针类型的成员变量时，我们最好要自定义Big Three。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">String</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr = <span class="hljs-number">0</span>); <span class="hljs-comment">//构造函数</span><br><span class="hljs-built_in">String</span>(<span class="hljs-keyword">const</span> String&amp; str); <span class="hljs-comment">//拷贝构造</span><br>String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> String&amp; str);<span class="hljs-comment">//拷贝复制 </span><br>~<span class="hljs-built_in">String</span>(); <span class="hljs-comment">//析构函数</span><br><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">get_c_str</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_data; &#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">char</span>* m_data;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-title">String::String</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr = <span class="hljs-number">0</span>)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (cstr) &#123;<br>m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-built_in">strlen</span>(cstr)+<span class="hljs-number">1</span>];<br><span class="hljs-built_in">strcpy</span>(m_data, cstr);<br>&#125;<br><span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 未指定初值</span><br>m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1</span>]; *m_data = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">inline</span><br>String::~<span class="hljs-built_in">String</span>() &#123;<br><span class="hljs-keyword">delete</span>[] m_data;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="对象拥有指针时的拷贝构造"><a href="#对象拥有指针时的拷贝构造" class="headerlink" title="对象拥有指针时的拷贝构造"></a>对象拥有指针时的拷贝构造</h3><p>编译器自带的拷贝构造有缺点，比如当一个对象1中有一个指针指向内存的地址，而通过编译器给的拷贝构造进行拷贝时，对象2也会拥有这个指针，同时也指向同一块内存，所以这并不是真正意义上的拷贝。所以<strong>当类含有指针，我们一定不能使用默认的拷贝构造</strong>。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416173442.png" alt="拷贝构造示例"></p><h3 id="拷贝复制中的检测自我赋值"><a href="#拷贝复制中的检测自我赋值" class="headerlink" title="拷贝复制中的检测自我赋值"></a>拷贝复制中的检测自我赋值</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">inline</span><br>String&amp; String::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> String&amp; str)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;str)<span class="hljs-comment">//检测自我赋值</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><br><span class="hljs-keyword">delete</span>[] m_data;<span class="hljs-comment">//第一步，删除自己的空间</span><br>m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-built_in">strlen</span>(str.m_data) + <span class="hljs-number">1</span>];<span class="hljs-comment">//第二步，创建空间，空间大小参考复制的对象</span><br><span class="hljs-built_in">strcpy</span>(m_data, str.m_data);<span class="hljs-comment">//第三步，将复制的对象的内容复制到自己的空间里</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416173919.png" alt="检测自我复制"></p><p>假设我们执行<code>a=a;</code>,此时若没有<strong>检测自我赋值</strong>，直接执行第一步，那么执行当第二步的时候，由于<code>str.m_data</code>这个指针已经被第一步删除了，所以会出错。</p><h2 id="堆、栈与内存管理"><a href="#堆、栈与内存管理" class="headerlink" title="堆、栈与内存管理"></a>堆、栈与内存管理</h2><h3 id="new和delete的详解"><a href="#new和delete的详解" class="headerlink" title="new和delete的详解"></a>new和delete的详解</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417172347.png" alt="new"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417172442.png" alt="delete"></p><h3 id="动态分配所得到的内存块以及array"><a href="#动态分配所得到的内存块以及array" class="headerlink" title="动态分配所得到的内存块以及array"></a>动态分配所得到的内存块以及array</h3><p>一块由动态分配得到的内存如下所示：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417175419.png" alt="内存"></p><p>须知：分配出来内存的大小必须为16的倍数。</p><p>绿色的内存区域是我们为类型分配空间时，该类型占用的存储空间。</p><p>头尾两块红色的内存，称为cookie，它的作用是表示这块内存的大小和状态。比如一块内存大小为64的内存，转换为16进制为0x40，但是我们看最左边的那片内存，头尾的cookie却是0x41，原因是当这片内存处于释放状态时，cookie的最后一位为0；而当这片内存处于使用状态时，cookie的最后一位为1。所以0x41实际上代表着：这块内存的大小为64且正在被使用。</p><p>灰色的内存区域表示处于debug模式下需要用到的空间，具体名称见下图。</p><p>浅绿色的内存区域表示当这块内存区域的大小不是16的倍数时，需要多余的内存区域。这块内存区域纯粹是起到了填充的作用，让整片内存区域变成16的倍数。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417181042.png" alt="动态分配array"></p><p>上图中String这边对应着下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">String</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr = <span class="hljs-number">0</span>);<br><span class="hljs-built_in">String</span>(<span class="hljs-keyword">const</span> String&amp; str);<br>String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> String&amp; str);<br>~<span class="hljs-built_in">String</span>();<br><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">get_c_str</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_data; &#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">char</span>* m_data;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-title">String::String</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr = <span class="hljs-number">0</span>)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (cstr) &#123;<br>m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-built_in">strlen</span>(cstr)+<span class="hljs-number">1</span>];<span class="hljs-comment">//这里的new使用中括号，会导致下面析构函数的delete使用中括号</span><br><span class="hljs-built_in">strcpy</span>(m_data, cstr);<br>&#125;<br><span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 未指定初值</span><br>m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1</span>]; *m_data = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">inline</span><br>String::~<span class="hljs-built_in">String</span>() &#123;<br><span class="hljs-keyword">delete</span>[] m_data;<span class="hljs-comment">//这里的delete使用中括号，是因为上面构造函数的new使用了中括号</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>array new、array delete这两者需要互相搭配</strong>，不然像下图的情况，会导致内存泄露：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417174307.png" alt="示意图"></p><h3 id="new和delete的重载"><a href="#new和delete的重载" class="headerlink" title="new和delete的重载"></a>new和delete的重载</h3><p>对于new和delete的重载比较特殊，对于<strong>全局</strong>的重载只能改变<code>new</code>内部的<code>operator new</code>。比如</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Complex* pc = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">//此处的new并不能被重载</span><br><br><span class="hljs-comment">//**********</span><br><span class="hljs-keyword">void</span>* mem = <span class="hljs-keyword">operator</span> <span class="hljs-built_in"><span class="hljs-keyword">new</span></span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Complex));<span class="hljs-comment">//只有这里的new会被重载</span><br>pc = <span class="hljs-keyword">static_cast</span>&lt;Complex*&gt;(mem);<br>pc-&gt;Complex::<span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br><span class="hljs-comment">//**********</span><br></code></pre></div></td></tr></table></figure><p>实际上，类里对于<code>operator new</code>的重载必须是<code>static</code>静态方法，因为<code>operator new</code>无法通过对象来调用。但是又因为<strong>必须</strong>是<code>static</code>，所以我们可以省略不写，编译器会自动转成静态方法。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/66788b8ddbd5222fc1305edc2eb807b9-291fd.png" alt="new和delete的重载"></p><p>成员的重载和全局的重载类似，但是成员的重载只会影响具体的对象，并不会影响到全局。比如：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/802ea01e86c5f33027bb662e7cb8f6eb-fe55d.png" alt="成员的重载"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f93c6a1d0fbc45623c36504b87fc7ff7-9832f.png" alt="成员的重载"></p><p>内存池经常使用这种重载的写法。</p><h4 id="new和delete重载例子"><a href="#new和delete重载例子" class="headerlink" title="new和delete重载例子"></a>new和delete重载例子</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6d9b9f2bcaea735bfe0440039666101e-2c912.png" alt="new和delete重载例子"></p><p>注意：若使用者想绕过成员重载的new和delete，那么可以使用域运算符强制使用全局的new和delete：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">Foo* pf = ::<span class="hljs-keyword">new</span> Foo;<span class="hljs-comment">//强制使用全局的new</span><br>::<span class="hljs-keyword">delete</span> pf;<span class="hljs-comment">//强制使用全局的delete</span><br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8d373471aa84c1428828b9fbc2b7a43b-483b9.png" alt="new和delete重载例子"></p><p>本例中的<code>Foo</code>大小为$int(4)+long(4)+string(4) = 12$，五个<code>Foo</code>就是$12<em>5=60$。但是上图中，大小为5的<code>Foo</code>指针数组的<em>*size</em></em>却为64。这多出来的4个字节实际上是计数器，记录了该数组的元素个数，不然当<code>array delete</code>的时候，无法正常释放。</p><p>还有一点，上图右边的内存示意图，表示当<code>array new</code>时，对象的构造是自上而下，即从下标为0开始的元素构造到最后一个；而<code>array delete</code>的顺序正好相反。</p><h4 id="placement-operator-new-delete"><a href="#placement-operator-new-delete" class="headerlink" title="placement operator new/delete"></a>placement operator new/delete</h4><p>因为new操作符是先分配内存，再执行构造函数，所以当构造函数发生异常后，需要及时的归还内存，否则会造成内存泄漏。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/711308668153592ca45c4aada96ad2bc-c4497.png" alt="placement operator new/delete"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/d85663e5f18393030570a21bb364de79-d3e5d.png" alt="placement operator new/delete"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/427d96d859f4c379c07aeb0c363f03fc-c443a.png" alt="placement operator new/delete"></p><h4 id="c-库例子：basic-string使用new-extra-扩充申请量"><a href="#c-库例子：basic-string使用new-extra-扩充申请量" class="headerlink" title="c++库例子：basic_string使用new(extra)扩充申请量"></a>c++库例子：basic_string使用new(extra)扩充申请量</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f40ea2a9e53c950064695b344070ea3f-68f51.png" alt="c++库例子：basic_string使用new(extra)扩充申请量"></p><h2 id="拓展补充：类模板、函数模板及其他"><a href="#拓展补充：类模板、函数模板及其他" class="headerlink" title="拓展补充：类模板、函数模板及其他"></a>拓展补充：类模板、函数模板及其他</h2><h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><p><strong>每个类成员函数都有一个指向自己所处对象的this指针</strong>，通过对象调用成员函数时，会把对象的地址放到成员函数里变成this指针</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417194726.png" alt="示意图"></p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ol><li>静态数据、静态函数与对象脱离，它不属于对象。它只有一份，存储在内存的某片区域</li><li>静态函数没有this指针，所以它只能处理静态的数据</li><li>静态函数可以通过类名调用，也可以通过对象名调用</li><li>只有调用或执行到含有静态数据的函数或代码块，该静态数据才会被创建</li></ol><h3 id="模板简介"><a href="#模板简介" class="headerlink" title="模板简介"></a>模板简介</h3><p>类模板：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">complex</span> (T r = <span class="hljs-number">0</span>, T i = <span class="hljs-number">0</span>): <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i) &#123; &#125;<br>complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp;);<br><span class="hljs-function">T <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125;<br><span class="hljs-function">T <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125;<br><span class="hljs-keyword">private</span>:<br>T re, im;<br><span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-keyword">const</span> complex&amp;); <br>&#125;;<br><br>&#123;<br><span class="hljs-function">complex&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2.5</span>,<span class="hljs-number">1.5</span>)</span></span>;<span class="hljs-comment">//代码1</span><br><span class="hljs-function">complex&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">6</span>)</span></span>;<span class="hljs-comment">//代码2</span><br>...<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>当执行到<strong>代码1</strong>和<strong>代码</strong>2时，类模板会根据<code>double</code>和<code>int</code>生成相应的代码。这种行为会造成代码的膨胀，但是这是必要的。</p><p>函数模板：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417201643.png" alt="函数模板"></p><p>类模板的类型用<strong>typename</strong>来代替，而函数模板用<strong>class</strong>来代替，虽然看起来两者不同，但是意思上是一样的。</p><p>类模板和函数模板的不同点在于<strong>引数推导</strong>，即编译器会根据实参的类型来推导，比如上图<code>r3 = min(r1,r2)</code>中的<strong>r1</strong>和<strong>r2</strong>。</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417212750.png" alt="命名空间"></p><h2 id="组合与继承"><a href="#组合与继承" class="headerlink" title="组合与继承"></a>组合与继承</h2><h3 id="组合-has-a"><a href="#组合-has-a" class="headerlink" title="组合 has-a"></a>组合 has-a</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417212913.png" alt="复合例子1"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417212933.png" alt="复合例子2"></p><h3 id="组合关系下的构造与析构"><a href="#组合关系下的构造与析构" class="headerlink" title="组合关系下的构造与析构"></a>组合关系下的构造与析构</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417213018.png" alt="复合的析构"></p><h3 id="委托-Composition-by-reference"><a href="#委托-Composition-by-reference" class="headerlink" title="委托 Composition by reference"></a>委托 Composition by reference</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417213157.png" alt="委托"></p><p>这样的做法很好，因为这样做可以保持左边不变右边变，即提供给客户端的接口不变，但是实现接口的功能可以改变。这样又称为编译防火墙，因为左边不变，所以左边无需再编译。</p><p>委托和组合的区别：</p><ol><li>组合中，两者的生命周期是同时的。而在委托里，两者的生命周期可以分先后。</li></ol><h3 id="继承关系下的构造与析构"><a href="#继承关系下的构造与析构" class="headerlink" title="继承关系下的构造与析构"></a>继承关系下的构造与析构</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417221702.png" alt="继承"></p><h3 id="继承-组合关系下的构造与析构"><a href="#继承-组合关系下的构造与析构" class="headerlink" title="继承+组合关系下的构造与析构"></a>继承+组合关系下的构造与析构</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/d47977674578fa527e49b603340f0e60-d4e93.png" alt="继承+组合关系下的构造与析构"></p><h2 id="虚函数与多态"><a href="#虚函数与多态" class="headerlink" title="虚函数与多态"></a>虚函数与多态</h2><h3 id="内存中的继承"><a href="#内存中的继承" class="headerlink" title="内存中的继承"></a>内存中的继承</h3><p>函数继承：子类继承了父类的函数调用权</p><h3 id="继承与模板方法"><a href="#继承与模板方法" class="headerlink" title="继承与模板方法"></a>继承与模板方法</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210418075133.png" alt="模板方法"></p><h3 id="委托-继承与观察者模式"><a href="#委托-继承与观察者模式" class="headerlink" title="委托+继承与观察者模式"></a>委托+继承与观察者模式</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210418080207.png" alt="观察者模式"></p><h4 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/25e2643d8ad391fd2a7ee50d3e4ac2a9-375551.png" alt="委托+继承"></p><ol><li>add()函数不能为纯虚函数的原因：如果是纯虚函数，那么Primitive这个类就必须实现。</li><li>Composite是个容器，可以同时存放Primitive和自身。这种情况下可以抽象出两者的父类，并以父类的指针作为容器的元素。</li><li>应用场景：可以把Primitive看成文件，Composite看成目录。</li></ol><h4 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h4><p>若有如下需求：在一个树状继承体系中，创建出一个未来才会实现的类。即在代码中对未来的类进行提前的封装，然后进行相关的操作？</p><p>设想：派生出来的子类创建完自己后，将自己的位置告诉给父类，让父类存储。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/cd0bd4e2038edfe0b32e67c780956a79-737a8.png" alt="Prototype"></p><p>父类：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">imageType</span> &#123;</span> LSAT, SPOT &#125;; <span class="hljs-comment">//子类类型的枚举变量</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Image</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <br>    <span class="hljs-function"><span class="hljs-keyword">static</span> Image *<span class="hljs-title">findAndClone</span><span class="hljs-params">(imageType)</span></span>; <br>    <br>    <span class="hljs-keyword">protected</span>: <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> imageType <span class="hljs-title">returnType</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//由子类实现，让子类返回自己的类型</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Image *<span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//由子类实现clone过程</span><br>    <span class="hljs-built_in">addPrototype</span>(Image *image) &#123; <span class="hljs-comment">// 当 Image 的每个子类被声明时，它会注册它的static void原型</span><br>                _prototypes[_nextSlot++] = image;<br>            &#125; <br>    <br>    <span class="hljs-keyword">private</span>: <br>    <span class="hljs-keyword">static</span> Image *_prototypes[<span class="hljs-number">10</span>]; <span class="hljs-comment">// addPrototype() 在这里保存每个注册的原型</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _nextSlot; <br>&#125;; <br>Image *Image::_prototypes[]; <br><span class="hljs-keyword">int</span> Image::_nextSlot;<br><span class="hljs-comment">// 客户需要实例时调用这个公共静态成员函数</span><br><span class="hljs-comment">// 返回一个 Image子类</span><br><span class="hljs-function">Image *<span class="hljs-title">Image::findAndClone</span><span class="hljs-params">(imageType type)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; _nextSlot; i++)<br><span class="hljs-keyword">if</span> (_prototypes[i]-&gt;<span class="hljs-built_in">returnType</span>() == type)<br><span class="hljs-keyword">return</span> _prototypes[i]-&gt;<span class="hljs-built_in">clone</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>子类：<br><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LandSatImage</span>:</span> <span class="hljs-keyword">public</span> Image &#123; <br>    <span class="hljs-keyword">public</span>: <br>    <span class="hljs-function">imageType <span class="hljs-title">returnType</span><span class="hljs-params">()</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> LSAT; <br>    &#125; <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;  <br>        cout &lt;&lt; <span class="hljs-string">&quot;LandSatImage::draw &quot;</span> &lt;&lt; _id &lt;&lt; endl; <br>    &#125; <br>    <span class="hljs-comment">// 当clone被调用时, 调用带了一个假参数(dummy)的构造函数：LandSatImage(int dummy)</span><br>    <span class="hljs-function">Image *<span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">LandSatImage</span>(<span class="hljs-number">1</span>); <br>    &#125; <br>    <span class="hljs-keyword">protected</span>: <br>    <span class="hljs-comment">// 只会被clone()函数调用 </span><br>    <span class="hljs-built_in">LandSatImage</span>(<span class="hljs-keyword">int</span> dummy) &#123;<br>                _id = _count++; <br>            &#125; <br>    <span class="hljs-keyword">private</span>: <br>    <span class="hljs-comment">// 始化 Image 子类 - 这会导致调用默认的构造函数，它注册子类的原型 </span><br>    <span class="hljs-keyword">static</span> LandSatImage _landSatImage; <br>    <span class="hljs-comment">// 这仅在初始化私有静态数据成员时调用 </span><br>    <span class="hljs-built_in">LandSatImage</span>() &#123; <span class="hljs-built_in">addPrototype</span>(<span class="hljs-keyword">this</span>); &#125; <br>    <span class="hljs-comment">// 区分每个实例所需 </span><br>    <span class="hljs-keyword">int</span> _id; <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _count; <br>&#125;; <br><span class="hljs-comment">// 注册子类的原型</span><br>LandSatImage LandSatImage::_landSatImage; <br><span class="hljs-comment">// 区分每个实例所需</span><br><span class="hljs-keyword">int</span> LandSatImage::_count = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//略</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpotImage</span>:</span> <span class="hljs-keyword">public</span> Image<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">imageType <span class="hljs-title">returnType</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> SPOT;<br>&#125;<br>    <span class="hljs-comment">//....与class LandSatImage相似，略</span><br>&#125;<br></code></pre></div></td></tr></table></figure></p><p>main:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 模拟创建请求</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> NUM_IMAGES = <span class="hljs-number">8</span>; <br>imageType input[NUM_IMAGES] = &#123; LSAT, LSAT, LSAT, SPOT, LSAT, SPOT, SPOT, LSAT &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>Image* images[NUM_IMAGES];<br><span class="hljs-comment">// 给定一个图像类型，找到正确的原型，并返回一个克隆</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_IMAGES; i++)<br>images[i] = Image::<span class="hljs-built_in">findAndClone</span>(input[i]);<br><span class="hljs-comment">// 证明已克隆正确的图像对象</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NUM_IMAGES; i++)<br>images[i]-&gt;<span class="hljs-built_in">draw</span>();<br><span class="hljs-comment">// 释放动态内存</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NUM_IMAGES; i++)<br><span class="hljs-keyword">delete</span> images[i];<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="conversion-function（转换函数）"><a href="#conversion-function（转换函数）" class="headerlink" title="conversion function（转换函数）"></a>conversion function（转换函数）</h2><ul><li>转换函数没有返回类型</li><li>为了程序的健壮性，转换函数需要加const</li><li>转换类型不一定得是基本类型，自定义类型也行，只要编译器认得转换的类型就可以。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Fraction</span>(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> den=<span class="hljs-number">1</span>) <br>  : <span class="hljs-built_in">m_numerator</span>(num), <span class="hljs-built_in">m_denominator</span>(den)<br>&#123;&#125;<br><br>    <span class="hljs-comment">//转换函数</span><br> <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <br>      <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)m_numerator / m_denominator; <br> &#125;<br> <br><span class="hljs-keyword">private</span>:   <br>   <span class="hljs-keyword">int</span> m_numerator;    <span class="hljs-comment">//分子</span><br>   <span class="hljs-keyword">int</span> m_denominator;  <span class="hljs-comment">//分母</span><br>&#125;;<br><br><span class="hljs-comment">//main.cpp...</span><br><span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-keyword">double</span> d = <span class="hljs-number">4</span> + f;<span class="hljs-comment">//f将会被转换为0.6</span><br></code></pre></div></td></tr></table></figure><p>若没有转换函数，重载运算符<code>+</code>，也能运行</p><h3 id="STL中的转换函数"><a href="#STL中的转换函数" class="headerlink" title="STL中的转换函数"></a>STL中的转换函数</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/e131cbce529c3873f473dd3a802fbfb5-21f79b.png" alt="STL中的转换函数"></p><h2 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h2><h3 id="non-explicit-one-argument-ctor"><a href="#non-explicit-one-argument-ctor" class="headerlink" title="non-explicit-one-argument ctor"></a>non-explicit-one-argument ctor</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Fraction</span>(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> den=<span class="hljs-number">1</span>) <br>  : <span class="hljs-built_in">m_numerator</span>(num), <span class="hljs-built_in">m_denominator</span>(den)&#123;&#125;<br><br> Fraction <span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">const</span> Fraction&amp; f) &#123;  <br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fraction</span>(......);<br>&#125;<br>    <br><span class="hljs-keyword">private</span>:   <br>   <span class="hljs-keyword">int</span> m_numerator;    <span class="hljs-comment">//分子</span><br>   <span class="hljs-keyword">int</span> m_denominator;  <span class="hljs-comment">//分母</span><br>&#125;<br><br><span class="hljs-comment">//main.cpp...</span><br><span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;<br>Fraction d2 = f + <span class="hljs-number">4</span>;<span class="hljs-comment">//调用 non-explicit 构造函数，将4转换为Fraction(4,1)，然后调用operator+</span><br></code></pre></div></td></tr></table></figure><p>本例中：</p><ul><li>Fraction的构造函数，虽然说有两个形式参数，但是由于其中有一个默认值，所以实际上这个构造函数可以看成<strong>单实参</strong>构造函数。（单实参并不是单形参）</li><li>在编译器编译到<code>Fraction d2 = f + 4;</code>这条语句的时候，找到了Fraction类中operator+重载函数，但是该重载函数的参数为<code>Fraction&amp;</code>类型，所以编译器接下来会<strong>尝试</strong>将<code>4</code>转换为Fraction类型。在此例中，有了<strong>“单实参构造函数“</strong>的前提条件，编译器将会调用<code>Fraction</code>的构造函数，将<code>4</code>传入，即执行<code>Fraction(4,1)</code>。</li></ul><h3 id="conversion-function-vs-non-explicit-one-argument-ctor"><a href="#conversion-function-vs-non-explicit-one-argument-ctor" class="headerlink" title="conversion function vs. non-explicit-one-argument ctor"></a>conversion function vs. non-explicit-one-argument ctor</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Fraction</span>(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> den=<span class="hljs-number">1</span>) <br>  : <span class="hljs-built_in">m_numerator</span>(num), <span class="hljs-built_in">m_denominator</span>(den)&#123;&#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <br>      <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)m_numerator / m_denominator; <br> &#125;<br> <br> Fraction <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Fraction&amp; f) &#123;  <br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fraction</span>(......);<br>&#125; <br><br><span class="hljs-keyword">private</span>:   <br>   <span class="hljs-keyword">int</span> m_numerator;    <span class="hljs-comment">//分子</span><br>   <span class="hljs-keyword">int</span> m_denominator;  <span class="hljs-comment">//分母</span><br>&#125;;<br><br><span class="hljs-comment">//main.cpp</span><br><span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>; <br>Fraction d2 = f + <span class="hljs-number">4</span>;<span class="hljs-comment">//[Error]ambiguous  </span><br></code></pre></div></td></tr></table></figure><p>在本例中，由于同时重载了<code>double()</code>和<code>operator+</code>，所以当编译器编译<code>double d2 = f + 4;</code>时，会遇到问题，即二义性问题。编译器接来下处理<code>f + 4</code>会面临两种抉择：</p><ol><li>将<code>f</code>通过<code>double()</code>转化<code>0.6</code>，即<code>0.6+4</code></li><li>将<code>4</code>通过构造函数转化为<code>Fraction(4,1)</code>，即<code>f+Fraction(4,1)</code></li></ol><p>编译器不知道该怎么选择，所以会报错：<strong>ambiguous</strong>  </p><h3 id="explicit-one-argument-ctor"><a href="#explicit-one-argument-ctor" class="headerlink" title="explicit-one-argument ctor"></a>explicit-one-argument ctor</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Fraction</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> den=<span class="hljs-number">1</span>)</span> <span class="hljs-comment">//加入explicit关键字</span></span><br><span class="hljs-function">  : m_numerator(num), m_denominator(den)&#123;</span>&#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <br>      <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)m_numerator / m_denominator; <br> &#125;<br> <br> Fraction <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Fraction&amp; f) &#123;  <br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fraction</span>(......);<br>&#125; <br>    <br><span class="hljs-keyword">private</span>:   <br>   <span class="hljs-keyword">int</span> m_numerator;    <span class="hljs-comment">//分子</span><br>   <span class="hljs-keyword">int</span> m_denominator;  <span class="hljs-comment">//分母</span><br>&#125;;<br><br><span class="hljs-comment">//main.cpp</span><br><span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;<br>Fraction d2 = f + <span class="hljs-number">4</span>;<span class="hljs-comment">//[Error]conversion from &#x27;double&#x27; to &#x27;Fraction&#x27; requested</span><br></code></pre></div></td></tr></table></figure><p>本例中，在构造函数的前面添加了<code>explicit</code>关键字。这个关键字的作用就是告诉编译器：</p><p><strong>只有当构造函数被显式的调用，编译器才可以调用构造函数</strong></p><p>所以当编译器编译<code>Fraction d2 = f + 4;</code>时，已经不会再尝试地将<code>4</code>转化为<code>Fraction(4,1)</code>了，只会将<code>f</code>通过<code>double()</code>进行转换，所以<code>f+4</code>会变成<code>0.6+4</code>。又因为<code>d2</code>是Fraction类型，所以编译器报错是正常的。</p><h2 id="pointer-like-classes"><a href="#pointer-like-classes" class="headerlink" title="pointer-like classes"></a>pointer-like classes</h2><p>也可以对类进行分类：比如像指针的类，像函数的类</p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><h4 id="关于operator-和operator-gt"><a href="#关于operator-和operator-gt" class="headerlink" title="关于operator*和operator-&gt;"></a>关于operator*和operator-&gt;</h4><p>智能指针中都会带有一个一般的指针。</p><p>在智能指针中，重载操作符<code>*</code>和<code>-&gt;</code>一般都是固定写法。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/34dc5fe416e326ad1ec2a555b1c1fed6-c414f2.png" alt="关于operator*和operator-&gt;"></p><p>对于图中三个已经编号的语句：</p><ul><li>语句1看起来很正常，因为重载操作符<code>*</code>，返回的同样是解引用。所以<code>Foo f(*sp)</code>实际上就是<code>Foo f(*px)</code>。</li><li>而对于语句2，如果通过重载操作符<code>-&gt;</code>返回值为<code>px</code>的话，按照正常的思路，<code>sp-&gt;method()</code>就会变成<code>pxmethod()</code>，少了<code>-&gt;</code>。但是实际上，语句2会变成语句3。原因是是C++的语法规定：<strong>-&gt;符号有个特殊的行为，在-&gt;符号作用的结果上，-&gt;符号会继续作用下去。</strong></li></ul><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>迭代器其实也是智能指针</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/58ff59423d173f39de7f3c07a6639191-a6f205.png" alt="迭代器"></p><h2 id="function-like-classes：仿函数"><a href="#function-like-classes：仿函数" class="headerlink" title="function-like classes：仿函数"></a>function-like classes：仿函数</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/bcbb678ba6becab283407c1b358ca181-f3318a.png" alt="仿函数"></p><p>调用方法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">select1st&lt;Pair&gt;()()<br>select2nd&lt;Pair&gt;()()<br></code></pre></div></td></tr></table></figure><p>在一个class里重载<code>()</code>，说明用意就是想让<strong>class</strong>变成一个<strong>function</strong>。对于这种模仿函数行为的对象，称之为函数对象。（stl里面有很多的仿函数）</p><h2 id="namespace经验谈"><a href="#namespace经验谈" class="headerlink" title="namespace经验谈"></a>namespace经验谈</h2><p>对于测试程序，可以使用<code>namespace</code>。比如：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8d4c799728c33e47f9ea6b6385880545-b66f52.png" alt="namespace经验谈"></p><h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><h3 id="class-template"><a href="#class-template" class="headerlink" title="class template"></a>class template</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/af7e08d3ba53835799e99215f45aa80c-d1a5b2.png" alt="类模板"></p><h3 id="member-template：成员模板"><a href="#member-template：成员模板" class="headerlink" title="member template：成员模板"></a>member template：成员模板</h3><p>这种成员模板的应用在STL标准库中大量出现：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b8270b8b0d56bd28cc0c9e01e8008574-ae6359.png" alt="member template 1"></p><p>智能指针中模仿向上转型的做法：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/51f2f90ada34ecd33f6f6380f26ca958-a29028.png" alt="member template 2"></p><h3 id="specialization：模板特化"><a href="#specialization：模板特化" class="headerlink" title="specialization：模板特化"></a>specialization：模板特化</h3><ul><li>特化可以写任意版本</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8bed3c001f2f63d2ceddcf13ad43eb0d-151429.png" alt="模板特化"></p><h4 id="partial-specialization：模板偏特化"><a href="#partial-specialization：模板偏特化" class="headerlink" title="partial specialization：模板偏特化"></a>partial specialization：模板偏特化</h4><ul><li>模板绑定参数需要从左边到右边进行绑定，比如形参次序为1，2，3，4，5，那么绑定参数不能挑选出1，3，5进行绑定，只能1，2，3这样绑定。</li></ul><h5 id="个体偏特化"><a href="#个体偏特化" class="headerlink" title="个体偏特化"></a>个体偏特化</h5><p>对某种具体类型的特殊处理，比如对bool类型偏特化：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/cecfd818959022054a9923abcb3d8698-2ddbe1.png" alt="单个偏特化"></p><h5 id="范围偏特化"><a href="#范围偏特化" class="headerlink" title="范围偏特化"></a>范围偏特化</h5><p>对某个范围的类型进行特殊处理，比如对<strong>所有</strong>指针类型进行偏特化：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/ccf5547367e4a7c109b8db153d0582a4-2cea76.png" alt="范围偏特化"></p><h3 id="template-template-parameter：模板模板参数"><a href="#template-template-parameter：模板模板参数" class="headerlink" title="template template parameter：模板模板参数"></a>template template parameter：模板模板参数</h3><h4 id="对于list的例子"><a href="#对于list的例子" class="headerlink" title="对于list的例子"></a>对于list的例子</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/33c4d4e3c79a9f39707e67c21c688199-f878bf.png" alt="模板模板参数"></p><p>现在的需求是：动态的指定<code>list</code>的类型，就相当于<code>list&lt;string&gt;</code>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">XCls&lt;string,list&gt; mylist1;<span class="hljs-comment">//错误</span><br></code></pre></div></td></tr></table></figure><p>虽然说结合上面的模板模板参数，看起来语法正确，但是由于<code>list</code>不止有一个模板参数，所以编译<code>XCls&lt;string,list&gt; mylist1;</code>编译器会报错。为了实现需求，可以使用：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> Lst = list&lt;T,allocator&lt;T&gt;&gt;;<br></code></pre></div></td></tr></table></figure><p>然后再：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">XCls&lt;string,Lst&gt; mylist1;<span class="hljs-comment">//正确</span><br></code></pre></div></td></tr></table></figure><h4 id="对于智能指针的例子"><a href="#对于智能指针的例子" class="headerlink" title="对于智能指针的例子"></a>对于智能指针的例子</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/60f943f55fb92522b88c79061ece7635-a17588.png" alt="对于智能指针的例子"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">XCls&lt;string,shared_ptr&gt; p1;<span class="hljs-comment">//正确</span><br>XCls&lt;<span class="hljs-keyword">double</span>,unique_ptr&gt; p2;<span class="hljs-comment">//错误</span><br>XCls&lt;<span class="hljs-keyword">int</span>,weak_ptr&gt; p3;<span class="hljs-comment">//错误</span><br>XCls&lt;<span class="hljs-keyword">long</span>,auto_ptr&gt; p4;<span class="hljs-comment">//正确</span><br></code></pre></div></td></tr></table></figure><p>同样的，参考对于list的例子，p2和p3错误的原因也是因为模板的参数不是唯一的。</p><h4 id="一个不是模板模板参数的例子"><a href="#一个不是模板模板参数的例子" class="headerlink" title="一个不是模板模板参数的例子"></a>一个不是模板模板参数的例子</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b1dd9c5d60a6f8e2197052c8dd45178e-34bb35.png" alt="一个不是模板模板参数的例子"></p><p>虽然说<code>Sequence</code>的默认参数是<code>deque&lt;T&gt;</code>，这个默认参数是一个模板类型的参数。但是他作为参数的时候已经不算是模板了，而是由模板初始化而来的一个参数。也就是说它已经被确定了。</p><h3 id="variadic-templates：数量不定的模板参数（C-11）"><a href="#variadic-templates：数量不定的模板参数（C-11）" class="headerlink" title="variadic templates：数量不定的模板参数（C++11）"></a>variadic templates：数量不定的模板参数（C++11）</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b6f56c4064300c100f3b179589d66b96-c7d814.png" alt="variadic templates：数量不定的模板参数"></p><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>可以在指定模板参数后，在模板后面加()直接生成临时的对象。比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span>*p allocator&lt;<span class="hljs-keyword">int</span>&gt;().<span class="hljs-built_in">allocate</span>(<span class="hljs-number">512</span>,(<span class="hljs-keyword">int</span>*)<span class="hljs-number">0</span>);<br></code></pre></div></td></tr></table></figure><h2 id="auto（C-11）"><a href="#auto（C-11）" class="headerlink" title="auto（C++11）"></a>auto（C++11）</h2><p>auto关键字可以让编译器自动推导类型</p><ul><li>所有变量都用auto可取吗？不行：<ul><li>对于变量的类型需要很熟悉，且auto的可读性不高</li><li>不可能每一次在声明对象的时候都赋值</li></ul></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/28998a55f89820c73ef91e0c3fcd8581-7889b2.png" alt="auto"></p><h2 id="ranged-base-for-：for新写法（C-11）"><a href="#ranged-base-for-：for新写法（C-11）" class="headerlink" title="ranged-base for ：for新写法（C++11）"></a>ranged-base for ：for新写法（C++11）</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8e75a572eebe3e248f33caa6cd148262-ebcb46.png" alt="ranged-base for ：for新写法（C++11）"></p><ul><li>pass by value：实际上是值传递，<strong>vec</strong>拷贝了一份赋值给<strong>elem</strong>，传值无法修改原来的值</li><li>pass by reference：<strong>vec</strong>将当前迭代元素的引用赋值给<strong>elem</strong>，传引用可以修改原来的值</li></ul><h2 id="reference：引用"><a href="#reference：引用" class="headerlink" title="reference：引用"></a>reference：引用</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/28e8af9de3f3e70f82cd704c38b65447-b2cca6.png" alt="reference：引用"></p><ul><li><p>虽然说引用的底层是指针，指针大小在32位上是4个字节。但是引用代表的东西sizeof多大，引用sizeof就多大</p></li><li><p>引用代表的东西的地址在哪里，引用的地址就在哪里</p></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/56041a3b3f0c57e698c49ed766c64dca-f12e4d.png" alt=""></p><h3 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h3><blockquote><p>引用就是一个漂亮的指针</p></blockquote><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f49b1cb39974da549e0c65f5d904b80e-4c0f1c.png" alt=""></p><p>Q：const是不是函数签名的一部分？</p><p>A：是</p><p><strong>注意：函数签名不含返回值</strong></p><h2 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h2><h3 id="关于vptr和vtbl"><a href="#关于vptr和vtbl" class="headerlink" title="关于vptr和vtbl"></a>关于vptr和vtbl</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b4a9e8f6e13e6d20e65eda01095ce90e-d9e28.png" alt="关于vptr和vtbl"></p><ul><li>只要类里面有一个以上的虚函数，那么这个类以及它的派生类在内存里就会多一根指针，这个指针就是虚表指针</li><li>继承函数是继承调用权，而不是继承函数的内存大小。所以父类若有虚函数，子类一定也有虚函数</li><li>动态绑定的三个条件<ul><li>通过指针调用</li><li>指针为up-cast，向上转型</li><li>调用的是虚函数</li></ul></li><li>静态绑定：编译时直接指定某个地址</li></ul><h3 id="关于this指针"><a href="#关于this指针" class="headerlink" title="关于this指针"></a>关于this指针</h3><ul><li>在C++的成员函数里面，一定有一个隐藏的this作为参数。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a9d134fab38b6f37fc66b43f2e205b77-abf79.png" alt="关于this指针"></p><h4 id="汇编层面的函数调用"><a href="#汇编层面的函数调用" class="headerlink" title="汇编层面的函数调用"></a>汇编层面的函数调用</h4><h5 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/dc0e09af8263a41969ed8ab2396e9ecc-0f736.png" alt="汇编层面的多态"></p><h5 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7f59aad8017b1fe873dec0b1da9cf192-43f3b.png" alt="动态绑定"></p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h3 id="const-member-functions：常量成员函数"><a href="#const-member-functions：常量成员函数" class="headerlink" title="const member functions：常量成员函数"></a>const member functions：常量成员函数</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/52c2717bc969b0b16180cc37360601b1-4963e.png" alt="const member functions：常量成员函数 "></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新特性</tag>
      
      <tag>对象模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>域名解析教程</title>
    <link href="/2021/04/10/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Godaddy%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2021/04/10/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Godaddy%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在开始之前，需要一个域名和VPS。一开始我选择的是狗爹域名和腾讯云VPS。结果到后面网站需要备案的时候麻烦来了：国外域名注册商提供的域名无法在国内进行备案(将域名从狗爹转入到国内的域名注册商后就可以备案了)…一开始我买狗爹的域名是想绑定在搬瓦工VPS上，后面感觉在大多数的使用情况下使用国内的VPS，响应会比较快，就用了腾讯云。然后配置的时候一路通行，到备案的时候给卡住了…所以个人建议：</p><ol><li>如果你是做类似于外贸的网站，或是用的国外VPS，建议在国外域名注册商那儿注册域名。而且听说国外建站无需备案</li><li>如果只是做个人网站，而且在国内访问比较频繁的话，直接选择国内VPS+国内域名注册商，方便省心。</li></ol><p>本文也是写到备案这块发现了这个问题，所以后面干脆在腾讯云又买了个域名。感觉腾讯云会比狗爹便宜许多，墙裂推荐</p><p>虽然本文具体写的是<strong>Godaddy域名绑定到腾讯云服务器</strong>，但是除了Godaddy官网操作的那部分不一样之外，其他注册商购买的域名(比如腾讯云、阿里云)绑定到腾讯云的操作其实是一样的，直接看”<strong>2.2 添加解析</strong>“就好</p><hr><hr><h2 id="2-Godaddy域名绑定到腾讯云服务器"><a href="#2-Godaddy域名绑定到腾讯云服务器" class="headerlink" title="2. Godaddy域名绑定到腾讯云服务器"></a>2. Godaddy域名绑定到腾讯云服务器</h2><h3 id="2-1-DNS地址设置"><a href="#2-1-DNS地址设置" class="headerlink" title="2.1 DNS地址设置"></a>2.1 DNS地址设置</h3><p>进入腾讯云的DNS解析页面</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410170812.png" alt="进入设置页面"></p><p>进入DNSPod控制台</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410171019.png" alt="进入DNSPod控制台"></p><p>添加域名</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410171154.png" alt="添加域名"></p><p>此时会显示DNS不正确</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410171303.png" alt="DNS不正确"></p><p>鼠标移动到状态上面，此时会显示</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410171449.png" alt="查看详情1"></p><p>点击查看详情</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410171616.png" alt="查看详情2"></p><p>记住腾讯云提供的两个DNS服务器地址，然后打开<a href="https://dcc.godaddy.com/">Godaddy</a>，登录后点击需要修改DNS的域名，进入该域名的管理界面</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410171918.png" alt="点击域名"></p><p>进入页面后，拉至网页的最下方，找到<strong>Manage DNS</strong>，并点击进入下一个界面</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410172049.png" alt="点击Manage DNS"></p><p>进入页面后，找到<strong>Nameservers</strong>的<em>*Changes</em>，并点击进入下一个界面</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410172522.png" alt="Change"></p><p>接着点击<strong>Enter my own nameservers (advanced)</strong>进入下一个界面</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410172707.png" alt="Enter my own nameservers (advanced)"></p><p>在输入框输入刚才腾讯云提供的两个DNS地址，然后点击Save</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410173004.png" alt="输入地址并保存"></p><p>此时会跳出一个提示框，要是没什么问题直接勾选并继续即可</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410173117.png" alt="勾选并继续"></p><p>此时会发一个密码到你注册狗爹时使用的邮箱，点击发送密码</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410173326.png" alt="发送密码"></p><p>输入邮箱收到的密码，点击验证</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410173439.png" alt="输入密码并验证"></p><p>等待一会，在出现的页面中找到Nmaeservers，看看两个Nameserver是不是我们刚才更改的地址，如果是的话就可以</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410173614.png" alt="修改成功"></p><p>返回腾讯云，等待一段时间后点击重新验证。我这里是修改完DNS地址后直接重新验证就可以了</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410173839.png" alt="重新验证"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410173932.png" alt="验证结果"></p><hr><h3 id="2-2-添加解析"><a href="#2-2-添加解析" class="headerlink" title="2.2 添加解析"></a>2.2 添加解析</h3><p>在<strong>DNSPOD</strong>点击待解析的域名</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410194832.png" alt="待解析域名"></p><p>点击<strong>添加第一条记录</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410200036.png" alt="添加第一条记录"></p><p>根据自己的需要，按照提示填写，然后点击<strong>确认</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410200129.png" alt="按照提示填写"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410200321.png" alt=""></p><p>至此已经完成了，在浏览器中输入域名也可顺利的访问。但是由于我们的网站还未备案，所以没过一会就会出现让你备案的网页。想要好好的用，就老老实实的备案吧(备案之前需要先将域名从狗爹转入国内域名注册商)</p><hr><hr><h2 id="错误及问题记录"><a href="#错误及问题记录" class="headerlink" title="错误及问题记录"></a>错误及问题记录</h2><h3 id="1-DNS-PROBE-FINISHED-NXDOMAIN"><a href="#1-DNS-PROBE-FINISHED-NXDOMAIN" class="headerlink" title="1. DNS_PROBE_FINISHED_NXDOMAIN"></a>1. DNS_PROBE_FINISHED_NXDOMAIN</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410200903.png" alt="DNS_PROBE_FINISHED_NXDOMAIN"></p><p>这个问题是在我刚在宝塔面板给网站添加域名后访问出现的，然后等了大概两三分钟再打开就没问题了。</p><h3 id="2-This-Web-page-is-parked-FREE-courtesy-of-GoDaddy-未解决"><a href="#2-This-Web-page-is-parked-FREE-courtesy-of-GoDaddy-未解决" class="headerlink" title="2. This Web page is parked FREE, courtesy of GoDaddy.(未解决)"></a>2. This Web page is parked FREE, courtesy of GoDaddy.(未解决)</h3><p>当我满怀期待地在地址栏输入我的域名并回车后，结果眼前出现了一个神秘男子</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410201653.png" alt="神秘男子"></p><p>但是我从宝塔面板点击我的域名，网页却正常的显示</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410210330.png" alt="正常显示"></p><p>而我用另一台设备打开这个网页的时候，也是能正常的显示原本的内容。</p><p>后面猜想了一下，应该跟DNS服务器有关</p><p>这个是没法正常打开网页的设备的DNS服务器地址</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410210543.png" alt="DNS服务器"></p><p>这个是能够正常打开的设备的DNS服务器地址</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410210833.png" alt="另一台设备"></p><p>个人认为，可能因为是我刚在腾讯云添加了DNS解析，而一些DNS服务器的解析记录还没有更新，所以才会导致出现这种情况。</p><p>至于为什么在同一台机子上，直接用浏览器打开和用宝塔面板进入会出现两种情况，我想了一下，应该是因为宝塔面板是安装在我域名解析的那台服务器上。也就是说当我从宝塔面板进入时，宝塔面板把”<strong>自己</strong>“返回给了我让我进入，而没有经过域名解析…怪我才疏学浅，目前能想到的原因只有这个</p><hr><h3 id="3-该网站未根据工信部相关法律规则进行备案"><a href="#3-该网站未根据工信部相关法律规则进行备案" class="headerlink" title="3. 该网站未根据工信部相关法律规则进行备案"></a>3. 该网站未根据工信部相关法律规则进行备案</h3><p>网站多访问几次以后，出现了以下页面</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410202119.png" alt="网站未备案"></p><p>没有解决方法，在国内还是老老实实备案吧</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410202344.png" alt="开始备案"></p><p>注意，Godaddy购买的域名在国内是无法进行备案的。如果一定要备案，需要把域名从狗爹转到国内的域名注册商。</p><hr><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://segmentfault.com/q/1010000002309400#">一个注册域名能分配多少子域名?</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>建站</category>
      
    </categories>
    
    
    <tags>
      
      <tag>腾讯云</tag>
      
      <tag>Godaddy</tag>
      
      <tag>VPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建wordpress</title>
    <link href="/2021/03/26/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BAWordPress/"/>
    <url>/2021/03/26/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BAWordPress/</url>
    
    <content type="html"><![CDATA[<h2 id="1-VPS"><a href="#1-VPS" class="headerlink" title="1.VPS"></a>1.VPS</h2><p>搭建WordPress需要一个VPS，对于VPS这部分就不详细描述了，毕竟作为程序员都会有一两个vps吧。</p><h2 id="2-宝塔面板"><a href="#2-宝塔面板" class="headerlink" title="2.宝塔面板"></a>2.宝塔面板</h2><p>使用宝塔面板会比较方便管理VPS</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323115100.png" alt="宝塔面板"></p><p>Linux下安装宝塔面板只需要一句话</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh<br></code></pre></div></td></tr></table></figure><p>如果是国内云服务商提供的VPS（腾讯云、阿里云、华为云等），需要先开端口：<a href="https://www.bt.cn/bbs/thread-19376-1-1.html">https://www.bt.cn/bbs/thread-19376-1-1.html</a></p><p>安装完成后，使用<code>bt</code>命令查看登录方式</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323125207.png" alt="查看宝塔信息"></p><p>在浏览器地址栏输入<strong>外网面板地址</strong>，然后在登录页面输入<strong>username</strong>和<strong>password</strong>即可进入宝塔面板</p><p>这里先讲一下宝塔面板的两个功能：</p><ol><li>安全</li><li>软件商店</li></ol><p>安全用来放行端口，只有在这里把端口放行了，外网才能使用这个端口</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323130008.png" alt="端口放心"></p><p>软件商店用来安装一些环境，这边推荐安装以下内容：</p><ul><li>Nginx 1.18.0</li><li>MySQL 5.7.33</li><li>PHP-7.4</li><li>Pure-Ftpd 1.0.49</li><li>phpMyAdmin 4.4</li></ul><p>其中包括<strong>wordpress</strong>需要用到的环境，还有一些方便管理的工具，安装步骤如下：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323125634.png" alt="软件商店"></p><p>选择编译安装</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323130341.png" alt="选择编译安装"></p><h2 id="3-wordpress"><a href="#3-wordpress" class="headerlink" title="3.wordpress"></a>3.wordpress</h2><h3 id="3-1-wordpress下载"><a href="#3-1-wordpress下载" class="headerlink" title="3.1 wordpress下载"></a>3.1 wordpress下载</h3><ul><li>中文版：<a href="https://cn.wordpress.org/latest-zh_CN.zip">https://cn.wordpress.org/latest-zh_CN.zip</a></li><li>英文版：<a href="https://wordpress.org/latest.zip">https://wordpress.org/latest.zip</a></li></ul><p>复制上面的连接，然后打开宝塔面板中的<strong>文件</strong>，进入<strong>/www/wwwroot</strong>目录，选择<strong>远程下载</strong>，把刚才复制的链接填到<strong>URL地址</strong>中并确认</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323131605.png" alt="远程下载"></p><p>等待下载</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323131742.png" alt="等待下载"></p><p>下载完成后解压文件</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323131900.png" alt="解压1"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323131938.png" alt="解压2"></p><p>解压完成</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323132025.png" alt="解压完成"></p><h3 id="3-2-wordpress数据库创建"><a href="#3-2-wordpress数据库创建" class="headerlink" title="3.2 wordpress数据库创建"></a>3.2 wordpress数据库创建</h3><p>打开宝塔面板的<strong>网站</strong>，点击添加站点，输入域名(如果没有域名，可以用VPS的外网IP代替)，然后根目录选择我们刚才解压的文件，接着提交即可。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323132906.png" alt="添加网站"></p><p>接下来配置数据库，打开宝塔面板的<strong>数据库</strong>，点击<strong>添加数据库</strong>，输入<strong>数据库名</strong>、<strong>用户名</strong>、<strong>密码</strong>，这三条信息需要记住，后面会用到。然后提交即可</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323133242.png" alt="创建数据库"></p><h3 id="3-3-wordpress数据库配置"><a href="#3-3-wordpress数据库配置" class="headerlink" title="3.3 wordpress数据库配置"></a>3.3 wordpress数据库配置</h3><p>进入宝塔面板的网站，点击刚才我们创建网站的根目录</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323141336.png" alt="点击根目录"></p><p>找到<strong>wp-config-sample.php</strong>这个文件，点击<strong>编辑</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323141443.png" alt="编辑文件"></p><p>找到图中所示，填入刚才我们数据库创建时的<strong>数据库名</strong>、<strong>用户名</strong>、<strong>密码</strong>，并保存</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323141638.png" alt="编辑前"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323141757.png" alt="编辑后"></p><p>然后重命名<strong>wp-config-sample.php</strong>为<strong>wp-config.php</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323141914.png" alt="重命名1"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323141937.png" alt="重命名2"></p><h3 id="3-4-wordpress的安装"><a href="#3-4-wordpress的安装" class="headerlink" title="3.4 wordpress的安装"></a>3.4 wordpress的安装</h3><p>在浏览器地址栏中输入：<strong><a href="http://域名/wp-admin">http://域名/wp-admin</a></strong>，如果前面配置成功的话，会出现以下页面：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323142211.png" alt="wordpress安装页面"></p><p>填入信息后点击安装，安装成功如下：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323142326.png" alt="安装成功"></p><p>点击登录</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323142415.png" alt="登录"></p><p>登录成功后进入wordpress的后台管理界面</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323142518.png" alt="后台管理界面"></p><p>至此，wordpress安装成功</p>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wordpress</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web版SSH搭建</title>
    <link href="/2021/03/23/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/web%E7%89%88SSH%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/03/23/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/web%E7%89%88SSH%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>目前web版的SSH很多，但是走的都是别人的服务器，会比较不安全。正好最近看到了<strong>Sshwifty</strong>，可以部署到自己的服务器并用外网访问</p><p><a href="https://github.com/nirui/sshwifty">Sshwifty项目地址</a></p><hr><h2 id="2-Sshwifty"><a href="#2-Sshwifty" class="headerlink" title="2. Sshwifty"></a>2. Sshwifty</h2><h3 id="2-1-安装Sshwifty"><a href="#2-1-安装Sshwifty" class="headerlink" title="2.1 安装Sshwifty"></a>2.1 安装Sshwifty</h3><p>使用docker安装（没安装docker的先安装docker）：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker run --detach \<br>  --restart always \<br>  --publish 8182:8182 \<br>  --name sshwifty \<br>  niruix/sshwifty:latest<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323162439.png" alt="安装成功"></p><hr><h3 id="2-2-安装证书"><a href="#2-2-安装证书" class="headerlink" title="2.2 安装证书"></a>2.2 安装证书</h3><p>先<code>docker ps</code>查看一下Sshwifty有没有在运行，如果出现下图说明有在运行，我们需要先停止Sshwifty</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323165435.png" alt="在运行"></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker stop CONTAINER ID<br>docker rm CONTAINER ID<br></code></pre></div></td></tr></table></figure><p>然后再安装证书<br><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">openssl req -newkey rsa:4096 -nodes -keyout domain.key -x509 -days 90 -out domain.crt<br></code></pre></div></td></tr></table></figure></p><p>输入信息，随便填写即可</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323163708.png" alt="ssl"></p><p>接着执行</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker run --detach \<br>  --restart always \<br>  --publish 8182:8182 \<br>  --env SSHWIFTY_DOCKER_TLSCERT=&quot;$(cat domain.crt)&quot; \<br>  --env SSHWIFTY_DOCKER_TLSCERTKEY=&quot;$(cat domain.key)&quot; \<br>  --name sshwifty \<br>  niruix/sshwifty:latest<br></code></pre></div></td></tr></table></figure><h3 id="2-3-使用Sshwifty"><a href="#2-3-使用Sshwifty" class="headerlink" title="2.3 使用Sshwifty"></a>2.3 使用Sshwifty</h3><p>浏览器地址栏输入：<strong>服务器IP地址:8182</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-03-23_16-57-04.png" alt="等待"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323170246.png" alt="使用1"></p><p>点击左上角的加号添加</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323170449.png" alt="添加"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323170535.png" alt="IDO"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323170559.png" alt="输入密码"></p><h2 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h2><h3 id="1-Unable-to-initialize-client-application-TypeError-Cannot-read-property-‘importKey’-of-undefined"><a href="#1-Unable-to-initialize-client-application-TypeError-Cannot-read-property-‘importKey’-of-undefined" class="headerlink" title="1.  Unable to initialize client application: TypeError: Cannot read property ‘importKey’ of undefined"></a>1.  Unable to initialize client application: TypeError: Cannot read property ‘importKey’ of undefined</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323163039.png" alt="错误1"></p><p>在访问地址前加上<strong>https</strong>即可</p><h3 id="2-ssh-handshake-failed-ssh-unable-to-authenticate-attempted-methods-none-password-no-supported-methods-remain"><a href="#2-ssh-handshake-failed-ssh-unable-to-authenticate-attempted-methods-none-password-no-supported-methods-remain" class="headerlink" title="2. ssh: handshake failed: ssh: unable to authenticate, attempted methods [none password], no supported methods remain"></a>2. ssh: handshake failed: ssh: unable to authenticate, attempted methods [none password], no supported methods remain</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323171046.png" alt="错误2"></p>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git常见用法</title>
    <link href="/2021/03/09/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Git/"/>
    <url>/2021/03/09/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Git/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Git在本地环境的使用"><a href="#1-Git在本地环境的使用" class="headerlink" title="1. Git在本地环境的使用"></a>1. Git在本地环境的使用</h2><h3 id="1-1-在本地初始化一个Git仓库"><a href="#1-1-在本地初始化一个Git仓库" class="headerlink" title="1.1 在本地初始化一个Git仓库"></a>1.1 在本地初始化一个Git仓库</h3><p>在本地新建一个文件夹，用于做Git的仓库。并在该目录下创建新文件</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304170419.png" alt="新建文件夹"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304170551.png" alt="新建文件"></p><p>接着<strong>初始化</strong>这个新建的目录。在该目录下打开命令行，键入</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git init<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304170804.png" alt="初始化新建文件夹"></p><hr><h3 id="1-2-查看本地仓库的状态"><a href="#1-2-查看本地仓库的状态" class="headerlink" title="1.2 查看本地仓库的状态"></a>1.2 查看本地仓库的状态</h3><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git status<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304174055.png" alt="查看状态"></p><p>其中，”<strong>On branch master</strong>“表示本地仓库默认在<strong>master</strong>分支，”<strong>Untracked files</strong>“表示”<strong>test.markdown</strong>“这个文件还没有被跟踪，还没有提交在git仓库里。并且下面会提示你可以使用”<strong>git add</strong>“去操作你想要提交的文件。</p><p>如果该目录没有被初始化，将会出现以下结果</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304200343.png" alt="没有初始化"></p><hr><h3 id="1-3-添加文件到Git暂存区"><a href="#1-3-添加文件到Git暂存区" class="headerlink" title="1.3 添加文件到Git暂存区"></a>1.3 添加文件到Git暂存区</h3><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git add 文件名<br></code></pre></div></td></tr></table></figure><p>添加文件后可以查看一下仓库此时的状态</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304174623.png" alt="提交Git到暂存区"></p><p>“<strong>Changes to be committed</strong>“表示”<strong>test.markdown</strong>“这个文件等待被提交，当然你可以使用</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git <span class="hljs-built_in">rm</span> -<span class="hljs-literal">-cached</span><br></code></pre></div></td></tr></table></figure><p>这个命令去移除这个缓存</p><hr><h3 id="1-4-提交暂存区里的文件"><a href="#1-4-提交暂存区里的文件" class="headerlink" title="1.4 提交暂存区里的文件"></a>1.4 提交暂存区里的文件</h3><p>在我们提交之前，需要先设置自己的用户名和邮箱。这些信息会出现在所有的commit记录里。</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git config -<span class="hljs-literal">-global</span> user.name <span class="hljs-string">&quot;你的名字&quot;</span><br>git config -<span class="hljs-literal">-global</span> user.email <span class="hljs-string">&quot;你的邮箱&quot;</span><br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309213610.png" alt="设置信息"></p><p>设置完后，就可以进行提交了</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git commit <span class="hljs-literal">-m</span> <span class="hljs-string">&#x27;first commit&#x27;</span><br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304204937.png" alt="提交"></p><p>其中，” <strong>-m ‘first commit’ </strong> “表示提交的时候附加信息，跟备注类似。此时再查看一下Git的状态</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304205137.png" alt="查看状态"></p><p>为什么要先”<strong>add</strong>“再”<strong>commit</strong>“呢？首先，”<strong>git add</strong>“是先把改动添加到一个”暂存区“，可以理解为是一个缓存区域，临时保存你的改动，而”<strong>git commit</strong>“才是最后真正的提交。这样做的好处就是防止误提交。</p><hr><h3 id="1-5-查看log"><a href="#1-5-查看log" class="headerlink" title="1.5 查看log"></a>1.5 查看log</h3><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git log<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304205500.png" alt="查看log"></p><p>“<strong>git log</strong>“命令可以查看所有产生的commit记录，其中，”<strong>first commit</strong>“为1.4步骤中我们提交时添加的附加信息，我们1.4节添加的用户名和邮箱也出现在里面</p><hr><h3 id="1-6-分支的查看、添加与切换"><a href="#1-6-分支的查看、添加与切换" class="headerlink" title="1.6 分支的查看、添加与切换"></a>1.6 分支的查看、添加与切换</h3><p>branch即分支的意思。在一个项目里，两个人负责不同的模块，就创建两个分支。两个人分别在各自的分支里对代码进行的改动，互相独立，互不影响。等到最后两个人的模块都完成了，再统一把分支合并起来。</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch</span><br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304205806.png" alt="查看分支"></p><p>我们有一个默认的master分支，前面的”*”号表示master是我们当前使用的分支。注意，当我们的Git仓库没有任何提交的话，直接查看分支情况会出现什么都没有的情况。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304210053.png" alt="空branch"></p><p>添加一个分支也很简单，只需要</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git branch 分支名<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304210244.png" alt="添加分支"></p><p>新建分支的命令是基于当前所在分支的基础上进行的，即以上是基于<strong>master</strong>分支新建了一个叫做<strong>_zhong</strong>的分支，此时<strong>_zhong</strong>分支跟<strong>master</strong>分支的内容完全一 样。如果你有 A、B、C三个分支，三个分支是三位同学的，各分支内容不一样，如果你当前 是在 B 分支，如果执行新建分支命令，则新建的分支内容跟 B 分支是一样的，同理如果当前 所在是 C 分支，那就是基于 C 分支基础上新建的分支。</p><p>但是当前分支并不是新建的”_zhong”分支，所以还需要通过一条命令切换当前分支</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git checkout 分支名<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304210451.png" alt="切换分支"></p><p>还有一条命令更方便，可以直接新建分支并直接切换</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git checkout <span class="hljs-literal">-b</span> 分支名<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304210652.png" alt="直接切换"></p><hr><h3 id="1-7-分支合并与删除"><a href="#1-7-分支合并与删除" class="headerlink" title="1.7 分支合并与删除"></a>1.7 分支合并与删除</h3><p>分支合并就是字面意思，当项目需要模块集成时就需要把各个分支合并到<strong>master</strong>这个主分支里面来。</p><p>合并分支前，要确保当前的分支是<strong>master</strong>，所以第一步就是切换到<strong>master</strong>这个主分支</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git checkout master<br>git merge 分支名<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304224904.png" alt="分支合并"></p><p>既然”<strong>_zhong</strong>“这个分支已经被我们合并到主分支里面去了，此时他已经没用了，就可以把他删除掉</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git branch <span class="hljs-literal">-d</span> 分支名<br>git branch <span class="hljs-literal">-D</span> 分支名<br></code></pre></div></td></tr></table></figure><p>上面两个命令选一个就可以，区别在于”<strong>-D</strong>“为强制删除。有些时候会删除失败，因为”<strong>_zhong</strong>“分支里面的代码可能还没有合并到master，使用”<strong>-d</strong>“是删除不了的，Git会提示你”<strong>_zhong</strong>“分支里还有未合并的代码，此时使用”<strong>-D</strong>“就可以强制删除</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304230029.png" alt="删除与强制删除"></p><hr><h3 id="1-8-添加版本"><a href="#1-8-添加版本" class="headerlink" title="1.8 添加版本"></a>1.8 添加版本</h3><p>我们在客户端开发的时候经常有版本的概念，比如v1.0、v1.1之类的，不同的版本肯定对应不 同的代码，所以我一般要给我们的代码加上标签，这样假设v1.1版本出了一个新bug，但是又 不晓得v1.0是不是有这个bug，有了标签就可以顺利切换到v1.0的代码，重新打个包测试了。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210313175008.png" alt="添加版本"></p><hr><hr><h2 id="2-向Github提交代码"><a href="#2-向Github提交代码" class="headerlink" title="2. 向Github提交代码"></a>2. 向Github提交代码</h2><h3 id="2-1-基本条件"><a href="#2-1-基本条件" class="headerlink" title="2.1 基本条件"></a>2.1 基本条件</h3><ol><li>Github账号</li><li>SSH及使用SSH连接到Github</li></ol><p>这些都是最基础的东西，就不再赘述</p><hr><h3 id="2-2-关联Github仓库"><a href="#2-2-关联Github仓库" class="headerlink" title="2.2 关联Github仓库"></a>2.2 关联Github仓库</h3><p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作。</p><p>在Github创建完仓库后，记住这个仓库名。然后进入你要关联的本地仓库，打开powershell</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git remote add origin git@github.com:你的Github名称/仓库名.git<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309171818.png" alt="关联"></p><p>也可以使用以下命令，查看我们当前项目有哪些远程仓库</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git remote <span class="hljs-literal">-v</span><br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309213054.png" alt="查看仓库"></p><hr><h3 id="2-3-将本地资源更新到Github"><a href="#2-3-将本地资源更新到Github" class="headerlink" title="2.3 将本地资源更新到Github"></a>2.3 将本地资源更新到Github</h3><p>现在我要将我本地仓库的文件更新到Github上的<strong>HelloWorld</strong>这个仓库</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git push origin master<br></code></pre></div></td></tr></table></figure><p>其中，远程库的名字就是<strong>origin</strong>，这是Git默认的也是大家公认的叫法，当然你也可以自己取个名字。<strong>master</strong>指的是在本地的master分支。</p><p>所以这条命令的意思就是把<strong>本地Git仓库</strong>的<strong>master</strong>分支，推送到<strong>Github</strong>中与本地<strong>Git仓库</strong>关联的<strong>Github仓库</strong>中。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309180525.png" alt="仓库"></p><p>推送完成，这时候可以打开Github仓库查看我们推送的内容。注意，需要选择<strong>master分支</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309182850.png" alt="查看推送情况"></p><hr><h3 id="2-4-从Github更新资源到本地"><a href="#2-4-从Github更新资源到本地" class="headerlink" title="2.4 从Github更新资源到本地"></a>2.4 从Github更新资源到本地</h3><p>如果别人提交代码到远程仓库，这个时候你需要把远程仓库的最新代码拉下来，然后保证两端代码的同步</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git pull origin master<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309205925.png" alt="pull"></p><p>一般我们在<strong>push</strong>之前都会先<strong>pull</strong> ，这样不容易冲突。</p><hr><h3 id="2-5-克隆"><a href="#2-5-克隆" class="headerlink" title="2.5 克隆"></a>2.5 克隆</h3><p>克隆可以理解为高级点的复制。将一个项目从Github克隆到本地，那么该项目在本地就已经是一个Git仓库了，不需要使用<code>git init</code>进行初始化，而且都已经关联好了远程仓库，我们只需要在本地的项目目录下任意修改或者添加文件，然后进行commit，之后就可以执行<code>git pull origin master</code>等相关操作。</p><p>在克隆之前，需要获取仓库地址</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309214931.png" alt="获取仓库地址"></p><p>然后打开本地项目所在的父目录，执行</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git clone git@github.com:你的Github/仓库名.git<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309215251.png" alt="仓库克隆"></p><p>进入本地项目，我们会发现目录中有个”<strong>.git</strong>“文件，有这个文件就说明这已经是个本地的Git仓库了。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309215354.png" alt="本地项目"></p><hr><hr><h2 id="3-Git进阶与技巧"><a href="#3-Git进阶与技巧" class="headerlink" title="3. Git进阶与技巧"></a>3. Git进阶与技巧</h2><h3 id="3-1-给命令起别名"><a href="#3-1-给命令起别名" class="headerlink" title="3.1 给命令起别名"></a>3.1 给命令起别名</h3><p>“<strong>alias</strong>“这个命令类似于Python里面的<code>import tensorflow as tf</code>，作用是给命令起个别名。我们每次都输入<code>git push origin master</code>就很繁琐，要是我们给这条命令起个别名，比如<code>git psm</code>，那我们就可以直接使用<code>git psm</code>来代替<code>git push origin master</code>。</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git config -<span class="hljs-literal">-global</span> alias.别名 <span class="hljs-string">&#x27;命令&#x27;</span><br></code></pre></div></td></tr></table></figure><p>当然，别名可以根据自己的习惯来取</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210310162622.png" alt="别名"></p><p>下面是一些比较好用的命令：</p><h4 id="3-1-1-高级日志"><a href="#3-1-1-高级日志" class="headerlink" title="3.1.1 高级日志"></a>3.1.1 高级日志</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git config -<span class="hljs-literal">-global</span> alias.lg <span class="hljs-string">&quot;log --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%</span><br><span class="hljs-string">d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit --date=relative&quot;</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="3-2-给终端设置颜色"><a href="#3-2-给终端设置颜色" class="headerlink" title="3.2 给终端设置颜色"></a>3.2 给终端设置颜色</h3><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git config -<span class="hljs-literal">-global</span> color.ui true<br></code></pre></div></td></tr></table></figure><hr><h3 id="3-3-设置Git编辑器"><a href="#3-3-设置Git编辑器" class="headerlink" title="3.3 设置Git编辑器"></a>3.3 设置Git编辑器</h3><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git config -<span class="hljs-literal">-global</span> core.editor <span class="hljs-string">&quot;vim&quot;</span> <br></code></pre></div></td></tr></table></figure><p>将编辑器设置为<strong>vim</strong>，当然也可以设置为其他的，但是前提是本机有安装。</p><hr><h3 id="3-4-对比文件差异"><a href="#3-4-对比文件差异" class="headerlink" title="3.4 对比文件差异"></a>3.4 对比文件差异</h3><p>我们经常在做代码改动，但是有的时候2天前的代码了，做了哪些改动都忘记了，在提交之前需要确认下，这个时候就可以用diff来查看你到底做了哪些改动。直接输入<code>git diff</code>只能比较当前文件和暂存区文件差异。</p><p>此时往<strong>test.markdown</strong>这个文件添加一行字”<strong>fefe</strong>“，然后执行<code>git diff</code>。我们会发现终端给出的信息是<strong>绿色</strong>的”<strong>+</strong>“号，然后后面跟着”<strong>fefe</strong>“，由此我们可知绿色加号表示的是增加的内容。</p><p>接着我们继续修改这个文件。我们先删除第一次添加的”<strong>fefe</strong>“，然后敲入”<strong>新增加的行</strong>“，并再次执行<code>git diff</code>。我们会发现增加的”<strong>新增加的行</strong>“显示出来了，但是我们删除的”<strong>fefe</strong>“并没有显示。这是因为我们并没有执行<code>git add</code>将文件放入暂存区。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210313171234.png" alt="还未进入暂存区"></p><p>我们先将文件加入暂存区，然后将里面的”<strong>新增加的行</strong>“删除，接着添加”<strong>第二次新增加的行</strong>“。这次我们再<code>git diff</code>就会发现，添加和删除的改动同时给了我们提示。没错，相对应地，绿色”<strong>+</strong>“号为增加，红色”<strong>-</strong>“号为删除。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210313172009.png" alt="放入暂存区"></p><h4 id="3-4-1-比较两次提交之间的差异"><a href="#3-4-1-比较两次提交之间的差异" class="headerlink" title="3.4.1 比较两次提交之间的差异"></a>3.4.1 比较两次提交之间的差异</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git <span class="hljs-built_in">diff</span> &lt;<span class="hljs-variable">$id1</span>&gt; &lt;<span class="hljs-variable">$id2</span>&gt;<br></code></pre></div></td></tr></table></figure><h4 id="3-4-2-在两个分支之间比较"><a href="#3-4-2-在两个分支之间比较" class="headerlink" title="3.4.2 在两个分支之间比较"></a>3.4.2 在两个分支之间比较</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git <span class="hljs-built_in">diff</span> &lt;branch1&gt;..&lt;branch2&gt;<br></code></pre></div></td></tr></table></figure><h4 id="3-4-3-比较暂存区和版本库差异"><a href="#3-4-3-比较暂存区和版本库差异" class="headerlink" title="3.4.3 比较暂存区和版本库差异"></a>3.4.3 比较暂存区和版本库差异</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git <span class="hljs-built_in">diff</span> -<span class="hljs-literal">-staged</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="3-5-checkout命令的拓展"><a href="#3-5-checkout命令的拓展" class="headerlink" title="3.5 checkout命令的拓展"></a>3.5 checkout命令的拓展</h3><p>“<strong>checkout</strong>“一般用作切换分支使用，比如切换到develop分支，可以执行：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git checkout develop<br></code></pre></div></td></tr></table></figure><h4 id="3-5-1-切换tag"><a href="#3-5-1-切换tag" class="headerlink" title="3.5.1 切换tag"></a>3.5.1 切换tag</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git checkout v1.<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h4 id="3-5-2-切换到某次commit"><a href="#3-5-2-切换到某次commit" class="headerlink" title="3.5.2 切换到某次commit"></a>3.5.2 切换到某次commit</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git checkout  ffd9f2dd68f1eb21d36cee50dbdd504e95d9c8f7<br></code></pre></div></td></tr></table></figure><p>后面的一长串是<strong>commit_id</strong>，是每次<strong>commit</strong>的SHA1值，可以根据<code>git log</code>看到。</p><h4 id="3-5-3-撤销文件"><a href="#3-5-3-撤销文件" class="headerlink" title="3.5.3 撤销文件"></a>3.5.3 撤销文件</h4><p>假设我们在一个分支开发 一个小功能，刚写完一半，这时候需求变了，而且是大变化，之前写的代码完全用不了了，好在你刚写，甚至都没有 git add 进暂存区，这个时候很简单的一个操作就直接把原文件还原</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git checkout a.md<br></code></pre></div></td></tr></table></figure><p>注意：只能撤销还没有<strong>add</strong>进暂存区的文件。</p><hr><h3 id="3-6-代码的临时保存"><a href="#3-6-代码的临时保存" class="headerlink" title="3.6 代码的临时保存"></a>3.6 代码的临时保存</h3><p>设想一个场景，假设我们正在一个新的分支做新的功能，这个时候突然有一个紧急的bug需要 修复，而且修复完之后需要立即发布。当然你说我先把刚写的一点代码进行提交不就行了 么？这样理论上当然是ok的，但是这会产品垃圾<strong>commit</strong>，原则上我们每次的<strong>commit</strong>都要有<strong>实际的意义</strong>，你的代码只是刚写了一半，还没有什么实际的意义是不建议就这样commit的，那 么有没有一种比较好的办法，可以让我暂时切到别的分支，修复完bug再切回来，而且代码也 能保留的呢？</p><p>这个时候 stash 命令就大有用处了，前提是我们的代码<strong>没有</strong>进行<strong>commit</strong> ，哪怕你执行了<strong>add</strong>也没关系</p><h4 id="3-6-1-保存代码"><a href="#3-6-1-保存代码" class="headerlink" title="3.6.1 保存代码"></a>3.6.1 保存代码</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git stash<br></code></pre></div></td></tr></table></figure><p>意思就是把当前分支所有没有<strong>commit</strong>的代码先暂存起来，这个时候你再执行<code>git status</code>你会发现当前分支很干净，几乎看不到任何改动，你的代码改动也看不见了，但其实是暂存起来了。</p><h4 id="3-6-3-查询保存记录"><a href="#3-6-3-查询保存记录" class="headerlink" title="3.6.3 查询保存记录"></a>3.6.3 查询保存记录</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git stash list<br></code></pre></div></td></tr></table></figure><h4 id="3-6-4-还原代码"><a href="#3-6-4-还原代码" class="headerlink" title="3.6.4 还原代码"></a>3.6.4 还原代码</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git stash apply<br></code></pre></div></td></tr></table></figure><p>之前的代码全部又回来了，就好像一切都没发生过一样</p><h4 id="3-6-5-删除记录"><a href="#3-6-5-删除记录" class="headerlink" title="3.6.5 删除记录"></a>3.6.5 删除记录</h4><p>紧接着你最好需要把暂存区的这次<strong>stash</strong>记录删除</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git stash drop<br></code></pre></div></td></tr></table></figure><p>当然后面可以跟<strong>stash_id</strong>参数来删除指定的某条记录，不跟参数就是删除最近的</p><h4 id="3-6-6-还原并删除记录"><a href="#3-6-6-还原并删除记录" class="headerlink" title="3.6.6 还原并删除记录"></a>3.6.6 还原并删除记录</h4><p>其实还有更方便的指令</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git stash pop<br></code></pre></div></td></tr></table></figure><p>来代替<strong>apply</strong>命令，<strong>pop</strong>跟<strong>apply</strong>的唯一区别就是<strong>pop</strong>不但会帮你把代码还原，还自动帮你把这条<strong>stash</strong>记录删除，省的自己再<strong>drop</strong>一次了</p><h4 id="3-6-7-清空记录"><a href="#3-6-7-清空记录" class="headerlink" title="3.6.7 清空记录"></a>3.6.7 清空记录</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git stash <span class="hljs-built_in">clear</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="3-7-另一种合并"><a href="#3-7-另一种合并" class="headerlink" title="3.7 另一种合并"></a>3.7 另一种合并</h3><p>我们知道<strong>merge</strong>是用来合并分支的命令，同时，<strong>rebase</strong>命令也是合并的意思，操作起来也和<strong>merge</strong>命令一样</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git checkout master <br>git rebase featureA<br></code></pre></div></td></tr></table></figure><p><strong>rebase</strong>跟<strong>merge</strong>的区别可以理解成有两个书架，你需要把两个书架的书整理到一起 去，第一种做法是<strong>merge</strong> ，比较粗鲁暴力，就直接腾出一块地方把另一个书架的书全部放进去，虽然暴力，但是这种做法你可以知道哪些书是来自另一个书架的；第二种做法就是<strong>rebase</strong> ，他会把两个书架的书先进行比较，按照购书的时间来给他重新排序，然后重新放置好，这样做的好处就是合并之后的书架看起来很有逻辑，但是你很难清晰的知道哪些书来自哪个书架的。 </p><p>只能说各有好处的，不同的团队根据不同的需要以及不同的习惯来选择就好。</p><hr><h3 id="3-8-解决冲突"><a href="#3-8-解决冲突" class="headerlink" title="3.8 解决冲突"></a>3.8 解决冲突</h3><p>假设这样一个场景，A和B两位同学各自开了两个分支来开发不同的功能，大部分情况下都会 尽量互不干扰的，但是有一个需求A需要改动一个基础库中的一个类的方法，不巧B这个时候 由于业务需要也改动了基础库的这个方法，因为这种情况比较特殊，A和B都认为不会对地方 造成影响，等两人各自把功能做完了，需要合并的到主分支<strong>master</strong>的时候，我们假设先合并A的分支，这个时候没问题的，之后再继续合并B的分支，这个时候想想也知道就有冲突了， 因为A和B两个人同时更改了同一个地方，Git 本身他没法判断你们两个谁更改的对，但是这个时候他会智能的提示有<strong>conflicts</strong> ，需要手动解决这个冲突之后再重新进行一次<strong>commit</strong>提交。以下是一个例子：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210313183311.png" alt="冲突例子"></p><p>以上截图里就是冲突的示例，冲突的地方由 == == 分出了上下两个部分，上部分一个叫<strong>HEAD</strong>的字样代表是我当前所在分支的代码，下半部分是一个叫<strong>baidu_activity</strong>分支的代 码，可以看到HEAD对gradle插件进行了升级，同时新增了一个插件，所以我们很容易判断哪些代码该保留，哪些代码该删除，我们只需要移除掉那些老旧代码，而且同也要把那些 &lt;&lt;&lt; HEAD、==== 以及 &gt;&gt;&gt;&gt;&gt;&gt;baidu_activity 这些标记符号也一并删除，最后进行一次 commit 就ok了。</p><p>我们在开发的过程中一般都会约定尽量大家写的代码不要彼此影响，以减少出现冲突的可 能，但是冲突总归无法避免的，我们需要了解并掌握解决冲突的方法。</p><hr><hr><h2 id="4-Git-Flow"><a href="#4-Git-Flow" class="headerlink" title="4.Git Flow"></a>4.Git Flow</h2><p><strong>Git Flow</strong>是一种比较成熟的分支管理流程，我们先看一张能清晰的描述他整个工作流程的图</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210316151643.png" alt="Git Flow"></p><p>一般开发来说，大部分情况下都会拥有两个分支<strong>master</strong>和<strong>develop</strong>，他们的职责分别是：</p><ul><li>master：永远处在即将发布(production-ready)状态</li><li>develop：最新的开发状态</li></ul><p>确切的说<strong>master</strong>、<strong>develop</strong>分支大部分情况下都会保持一致，只有在上线前的测试阶段<strong>develop</strong>比<strong>master</strong>的代码要多，一旦测试没问题，准备发布了，这时候会将<strong>develop</strong>合并到<strong>master</strong>上。 但是我们发布之后又会进行下一版本的功能开发，开发中间可能又会遇到需要紧急修复 bug ，一个功能开发完成之后突然需求变动了等情况，所以<strong>Git Flow</strong>除了以上<strong>master</strong>和<strong>develop</strong>两个主要分支以外，还提出了以下三个辅助分支：</p><ul><li>feature: 开发新功能的分支, 基于develop, 完成后merge回develop</li><li>release: 准备要发布版本的分支, 用来修复bug，基于develop，完成后merge回develop和master</li><li>hotfix: 修复master上的问题, 等不及 release 版本就必须马上上线. 基于 master, 完成后 merge 回 master 和 develop</li></ul><p>举个例子，假设我们已经有 master 和 develop 两个分支了，这个时候我们准备做一个功能 A，第一步我们要做的，就是基于 develop 分支新建个分支：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git branch feature/A<br></code></pre></div></td></tr></table></figure><p>看到了吧，其实就是一个规范，规定了所有开发的功能分支都以 feature 为前缀。 但是这个时候做着做着发现线上有一个紧急的 bug 需要修复，那赶紧停下手头的工作，立刻切换master 分支，然后再此基础上新建一个分支：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git branch hotfix/B<br></code></pre></div></td></tr></table></figure><p>代表新建了一个紧急修复分支，修复完成之后直接合并到develop和master ，然后发布。</p><p>然后再切回我们的 feature/A 分支继续着我们的开发，如果开发完了，那么合并回develop分 支，然后在develop分支属于测试环境，跟后端对接并且测试的差不多了，感觉可以发布到正式环境了，这个时候再新建一个 release 分支：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git branch release/<span class="hljs-number">1.0</span><br></code></pre></div></td></tr></table></figure><p>这个时候所有的 api、数据等都是正式环境，然后在这个分支上进行最后的测试，发现 bug 直 接进行修改，直到测试 ok 达到了发布的标准，最后把该分支合并到 develop 和 master 然后 进行发布。</p><hr><hr><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h3 id="1-Enter-passphrase-for-key"><a href="#1-Enter-passphrase-for-key" class="headerlink" title="1. Enter passphrase for key"></a>1. Enter passphrase for key</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309182939.png" alt="需要密码"></p><p>这个问题出现在每次使用ssh连接Github都需要输入密码，所以删除掉之前的密码即可</p><figure class="highlight cmd"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmd">ssh-keygen -p<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309183534.png" alt="删除密码"></p><p>注意，”<strong>Enter file in which the key is (C:\Users\15606/.ssh/id_rsa):</strong>“这条语句后面只需按回车键。</p><p>这时候再push一下就不需要再次输入密码了</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309183847.png" alt="再次push"></p><hr><h3 id="2-“仓库名”-does-not-appear-to-be-a-git-repository"><a href="#2-“仓库名”-does-not-appear-to-be-a-git-repository" class="headerlink" title="2. “仓库名” does not appear to be a git repository"></a>2. “仓库名” does not appear to be a git repository</h3><p>这个问题是由于本地仓库和远程仓库没有进行关联，只需按照本文的2.2节进行处理。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309171953.png" alt="失败"></p><hr><h3 id="3-Access-has-been-restricted"><a href="#3-Access-has-been-restricted" class="headerlink" title="3. Access has been restricted"></a>3. Access has been restricted</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309172509.png" alt="滥用检测机制"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309172547.png" alt="滥用2"></p><p>这个问题….不知道怎么解决</p><hr><h3 id="4-不同目录下的同名文件的提交（未解决）"><a href="#4-不同目录下的同名文件的提交（未解决）" class="headerlink" title="4.不同目录下的同名文件的提交（未解决）"></a>4.不同目录下的同名文件的提交（未解决）</h3><p>在使用CLion的Git模块时发生的错误，父目录为Learn，而子目录分别是A和B，A和B中分别有main.c这个文件。我先提交的A，后面再提交B，结果B的提交说明会覆盖掉A中main.c的提交说明。</p><p>参考：<a href="https://www.cnblogs.com/kevingrace/p/5690241.html">[Git忽略提交规则 - .gitignore配置运维总结]</a></p><hr><hr><h2 id="心得或经验"><a href="#心得或经验" class="headerlink" title="心得或经验"></a>心得或经验</h2><ol><li>每次的commit必须要有实际的意义</li></ol><h2 id="参考及引用说明"><a href="#参考及引用说明" class="headerlink" title="参考及引用说明"></a>参考及引用说明</h2><ol><li>《learn-github-from-zero》-作者：stormzhang，个人网站：<a href="http://stormzhang.com/">http://stormzhang.com/</a></li><li>“廖雪峰的官方网站”-作者：廖雪峰，个人网站：<a href="https://www.liaoxuefeng.com/sha">https://www.liaoxuefeng.com/sha</a></li><li>“菜鸟教程”：网站：<a href="https://www.runoob.com/git/git-tutorial.html">https://www.runoob.com/git/git-tutorial.html</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标准归纳</title>
    <link href="/2021/03/03/C++/%E6%96%B0%E6%A0%87%E5%87%86%E5%BD%92%E7%BA%B3/"/>
    <url>/2021/03/03/C++/%E6%96%B0%E6%A0%87%E5%87%86%E5%BD%92%E7%BA%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="Variadic-Templates"><a href="#Variadic-Templates" class="headerlink" title="Variadic Templates"></a>Variadic Templates</h2><ul><li>可以有任意多个参数数量，同时参数类型也可以是任意多个</li><li>可变参数模板可以用于递归操作。所以需要同时写一个处理最后情况，即没有参数的函数。否则编译出错。</li></ul><p>比如常见的操作有：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span>... Types&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printX</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; firstArg,<span class="hljs-keyword">const</span> Type&amp;... args)</span></span>&#123;<span class="hljs-comment">//将会被递归调用</span><br>    cout&lt;&lt;firstArg&lt;&lt;endl;<br>    <span class="hljs-keyword">sizeof</span>...(args);<span class="hljs-comment">//可以获得args的数量</span><br>    <span class="hljs-built_in">printX</span>(args...);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printX</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//这个函数必须写，否则当args的个数为0时会报错</span><br><br><span class="hljs-comment">//使用</span><br><span class="hljs-built_in">printX</span>(<span class="hljs-number">7.5</span>,<span class="hljs-string">&quot;hello&quot;</span>,bitset&lt;<span class="hljs-number">16</span>&gt;(<span class="hljs-number">377</span>),<span class="hljs-number">42</span>);<br></code></pre></div></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>tuple：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/2e28effd572df93c0a3d7d35ce0f9f9b-3954c.png"  /></p><h2 id="Initializer-list"><a href="#Initializer-list" class="headerlink" title="Initializer-list"></a>Initializer-list</h2><p>C++新标准的语法糖之一，可以接受个数不定的参数。</p><p>基本用法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i&#123;&#125;;<span class="hljs-comment">//i被初始化为0</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; vec&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-comment">//动态数组vec中有两个值0和1</span><br><span class="hljs-comment">//...</span><br></code></pre></div></td></tr></table></figure><p>它的背后支撑是 <code>initializer_list&lt;T&gt;</code>，而 <code>initializer_list&lt;T&gt;</code>里面其实就是<code>array</code>。</p><p>所以也可以使用它来作为函数的形参：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(initializer_list&lt;<span class="hljs-keyword">int</span>&gt; initlist)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : initlist)&#123;<br>        <span class="hljs-comment">//....</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="for-loop"><a href="#for-loop" class="headerlink" title="for-loop"></a>for-loop</h2><p>新标准的<strong>for-loop</strong>会被编译器解释为如下的代码：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/70b905fedc4141555829534729444a7e-7a7fd.png"  /></p><p>其中，<code>begin()</code>和 <code>end()</code>成为新标准的全局函数。</p><h3 id="错误使用"><a href="#错误使用" class="headerlink" title="错误使用"></a>错误使用</h3><p>对于以下情况，<strong>for-loop</strong>无法正常编译：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp; s)</span></span>;<span class="hljs-comment">//禁止隐式转换</span><br><span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">//...</span><br>vectot&lt;string&gt; vec;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> C&amp; elem : vec)&#123;<span class="hljs-comment">//错误！因为没有定义string转C类型的类型转换函数</span><br>cout&lt;&lt;elem&lt;&lt;endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="delete和-default"><a href="#delete和-default" class="headerlink" title="=delete和=default"></a>=delete和=default</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7b2b1face664b066dc6d68ae9abd9eee-58f42.png"  /></p><h3 id="big-five"><a href="#big-five" class="headerlink" title="big-five"></a>big-five</h3><ul><li>默认的<strong>big-five</strong>只有在需要的时候（被调用）才会被编译器合成</li><li>所有的<strong>big-five</strong>都是<code>public</code>且<code>inline</code>的</li><li>如果class没有pointer member，用默认的<strong>big-five</strong>就够了。反例：比如C++中的<code>string</code>，由于它里面的成员变量有指针，所以使用默认的big-five容易出错。另外，对于<code>string</code>类，里面有引用计数，感觉应该是为了实现写时复制读时共享。</li><li>如果一个类只允许让友元类或家族成员拷贝，那么可以把拷贝控制放到<code>private</code>里，且不能定义。在<strong>boost</strong>库中有一个类<code>noncopyable</code>，这个类就是把拷贝控制放到<code>private</code>里，而且从它派生的子类也会继承它的性质。</li></ul><h3 id="delete"><a href="#delete" class="headerlink" title="=delete"></a>=delete</h3><ul><li><code>=delete</code>可用于任何函数身上</li><li>一个比较典型的例子：为了让某类型的对象只有一份，可以把该类的拷贝构造和拷贝赋值设置为<code>=delete</code>，让使用者禁止调用拷贝构造和拷贝赋值。</li></ul><h3 id="default"><a href="#default" class="headerlink" title="=default"></a>=default</h3><ul><li><code>=default</code>只能用于<strong>big-five</strong></li></ul><h2 id="Alias-Template"><a href="#Alias-Template" class="headerlink" title="Alias Template"></a>Alias Template</h2><p>化名可以带参数，比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> Vec = std:vector&lt;T,MyAlloc&lt;T&gt;&gt;;<span class="hljs-comment">//使用自己的内存分配器代替标准库的内存分配器</span><br><br>Vec&lt;<span class="hljs-keyword">int</span>&gt; coll;<span class="hljs-comment">//别名可以含参，等同于下面</span><br>std:vector&lt;T,MyAlloc&lt;T&gt;&gt; coll;<br></code></pre></div></td></tr></table></figure><p>注意：虽然说别名可以带参数，但是无法对别名进行特化，只能对它代替的本体进行特化。</p><p>但是使用<strong>macro</strong>无法达到同样的效果：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Vec<span class="hljs-meta-string">&lt;T&gt;</span> template<span class="hljs-meta-string">&lt;typename T&gt;</span> std:vector<span class="hljs-meta-string">&lt;T,MyAlloc&lt;T&gt;</span>&gt;;<span class="hljs-comment">//如果使用宏定义</span></span><br><br><span class="hljs-comment">//对于Vec&lt;int&gt; coll;会变成如下的样子</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">int</span>&gt; std:vector&lt;<span class="hljs-keyword">int</span>,MyAlloc&lt;<span class="hljs-keyword">int</span>&gt;&gt;;<span class="hljs-comment">//不是我们想要的效果</span><br></code></pre></div></td></tr></table></figure><p>而且，使用 <code>typedef</code>也无法达到相同的效果，因为 <code>typedef</code>是不接受参数的。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>若想实现一个函数，这个函数的实参是容器+数据类型，比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">func</span>(list,string);<span class="hljs-comment">//希望该函数在内部组装成list&lt;string&gt;</span><br></code></pre></div></td></tr></table></figure><p>如果使用以下的方法不可取：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/0e3e4da418ba56a8d09599e81084e714-2c4e3.png" alt=""></p><p>解决方法1：使用模板+迭代器+萃取机制。</p><p>可以使用萃取机取出元素类型，比如：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9b118fa0855d9281180f42badcfabda8-bb430.png"  /></p><p>解决方法2：使用模板别名和模板模板参数。如下：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/269cad0f9f8e281a3c0a082393cc68c3-c4a7c.png"  /></p><h3 id="别名的其他用法"><a href="#别名的其他用法" class="headerlink" title="别名的其他用法"></a>别名的其他用法</h3><p>除了用于模板的<strong>别名</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">charT</span>&gt;</span> <br><span class="hljs-keyword">using</span> mystring = std::basic_string&lt;CharT,std::char_traits&lt;CharT&gt;&gt;;<br><span class="hljs-comment">//...</span><br>mystring&lt;<span class="hljs-keyword">char</span>&gt; str;<br></code></pre></div></td></tr></table></figure><p>还能用于模板的参数：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Container</span>&#123;</span><br><span class="hljs-keyword">using</span> value_type = T;<br>&#125;;<br><span class="hljs-comment">//上下代码等同效果</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Cntr&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fn2</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Cntr&amp; c)</span></span>&#123;<br>    <span class="hljs-keyword">typename</span> Cntr::value_type n;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>也能用于函数：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> func = <span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(*)(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>);<span class="hljs-comment">//等效于typedef void(*func)(int,int);</span><br><span class="hljs-comment">//...</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">example</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span></span>&#123;&#125;<br>func fn = example;<br></code></pre></div></td></tr></table></figure><p><code>typedef</code>和<strong>别名</strong>实际上的差别并不大，但是<strong>别名</strong>的灵活性更胜一筹。</p><h2 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h2><p>在函数后头添加这个关键字，表示这个函数保证不会发生异常。比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></div></td></tr></table></figure><p>也可以对 <code>noexcept</code>添加条件，比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span></span>;<span class="hljs-comment">//可以添加条件，表示符合这个条件就不会发生异常</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Type&amp; x,Type&amp; y)</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-keyword">noexcept</span>(x.swap(y)))</span></span>&#123;<br>    x.<span class="hljs-built_in">swap</span>(y);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意：如果发生异常，没有及时处理，那么这个异常就会进入 <code>std::terminate()</code>，并且调用 <code>std::abort()</code>结束程序。</p><p>另外，对于用户自定义类的移动函数，也需要在后面添加 <code>noexcept</code>关键字。如果没有添加，特别是使用容器 <code>vector</code>时，<code>vector</code>只会调用开销更大的拷贝函数，而不会去调用移动函数。（能够生长的容器只有 <code>vector</code>和 <code>deque</code>）</p><p>使用 <code>noexcept</code>可以让编译器对代码进行优化。</p><h2 id="override"><a href="#override" class="headerlink" title="override"></a>override</h2><p>这个关键字只是为了让编译器帮助检查，避免重写过程中的错误，不一定需要使用。但是感觉写了也增加了程序的可读性。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Base</span>&#123;</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfunc</span><span class="hljs-params">(<span class="hljs-keyword">float</span>)</span></span>&#123;&#125;  <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test1</span>:</span>Base&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>&#123;&#125;  <span class="hljs-comment">//本意是重写Base的vfunc函数，但是由于失误更改了形参类型</span><br>     <span class="hljs-comment">//编译器会认为定义了一个新函数</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test2</span>:</span>Base&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-keyword">override</span></span>&#123;&#125;  <span class="hljs-comment">//本意是重写Base的vfunc函数，但是由于失误更改了形参类型</span><br>       <span class="hljs-comment">//不过有override关键字的存在，编译器发现了错误</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>这个关键字和 <code>override</code>一样，也是为了让编译器帮助检查。</p><p>这个关键字可用于类身上，它的作用就是告诉编译器：我是这个继承体系之下的最后一个，不能再有类继承我了。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Base</span> <span class="hljs-keyword">final</span>&#123;</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test</span>:</span>Base&#123;&#125;;<span class="hljs-comment">//错误！不能继承一个final类</span><br></code></pre></div></td></tr></table></figure><p>也可以用于虚函数身上，作用同上。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">strcuct Base&#123;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span></span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test</span>:</span>Base&#123;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//错误！不能重写一个final虚函数</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p>使用 <code>decltype</code>关键字可以找到一个表达式的类型，相当于 <code>typeof</code>。比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">map&lt;string,<span class="hljs-keyword">float</span>&gt; coll;<br><span class="hljs-keyword">decltype</span>(coll)::value_type elem;<span class="hljs-comment">//可以使用decltype获得容器的类型</span><br><span class="hljs-comment">//等同于以下</span><br><span class="hljs-comment">//before C++11</span><br>map&lt;string,<span class="hljs-keyword">float</span>&gt;::value_type elem;<br></code></pre></div></td></tr></table></figure><p>它可以用来声明一个 <code>return type</code>：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T1 x,T2 y)</span>-&gt;<span class="hljs-title">decltype</span><span class="hljs-params">(x+y)</span></span>&#123;&#125;;<br></code></pre></div></td></tr></table></figure><p>也可以用于模板元编程：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T obj)</span></span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> <span class="hljs-title">decltype</span><span class="hljs-params">(obj)</span>::iterator iType</span>;<span class="hljs-comment">//取迭代器，当然前提是T有迭代器</span><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>还可以用于 <code>lambda</code>：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-keyword">const</span> Person&amp; p1,<span class="hljs-keyword">const</span> Person&amp; p2)&#123;<br>    <span class="hljs-comment">//....</span><br>&#125;;<br><span class="hljs-function">std::set&lt;Person,<span class="hljs-title">decltype</span><span class="hljs-params">(cmp)</span>&gt; <span class="hljs-title">coll</span><span class="hljs-params">(cmp)</span></span>;<span class="hljs-comment">//常用于对容器的排序</span><br></code></pre></div></td></tr></table></figure><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p><code>lambda</code>有点像<strong>inline function</strong>，它可以被当作函数参数或一个局部object。</p><p>它有很多形式：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">[]&#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;hello&quot;</span>&lt;&lt;std::endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">[]&#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;hello&quot;</span>&lt;&lt;std::endl;<br>&#125;();<span class="hljs-comment">//注意这个括号，表示直接调用，输出hello</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> func = []&#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;hello&quot;</span>&lt;&lt;std::endl;<br>&#125;;<br><span class="hljs-built_in">func</span>();<span class="hljs-comment">//输出hello</span><br></code></pre></div></td></tr></table></figure><p>它的语法如下：</p><script type="math/tex; mode=display">[\ \ ]\ ()\ mutable_{opt}\ throwSpec_{opt}->retType_{opt}\{...\}</script><ul><li><p><strong>[ ]</strong>为捕获列表，可以为空，也可以写入变量。捕获方式可以是值传递，也可以是引用传递。</p><ul><li>[=]：全部都是值传递</li><li>[&amp;a]：a变量引用传递</li><li>[a]：a变量值传递</li><li>[&amp;a,=]：a变量引用传递，其他变量值传递</li></ul></li><li><strong>( )</strong>为形参列表</li><li>$mutable_{opt}$表示是否可以改动捕获列表中的变量。</li><li>$throwSpec_{opt}$表示是否丢出异常</li><li>$retType_{opt}$表示返回类型。</li><li>$mutable<em>{opt}$​、$throwSpec</em>{opt}$​、$retType_{opt}$可有可无。若三者都不存在，可以不写<strong>( )</strong>。但是若三者有一个出现，那么<strong>( )</strong>必须存在。</li><li><strong>{ }</strong>为函数本体</li></ul><h2 id="Rvalue-references"><a href="#Rvalue-references" class="headerlink" title="Rvalue references"></a>Rvalue references</h2><ul><li>左值：可以出现在等号的左侧</li><li>右值：只能出现在等号的右侧<ul><li>右值引用可以避免不必要的拷贝</li><li>临时对象也是右值</li><li>右值没有名称</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用SSR实现局域网代理</title>
    <link href="/2021/03/01/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8SSR%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BB%A3%E7%90%86/"/>
    <url>/2021/03/01/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8SSR%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><h3 id="1-设置路由器"><a href="#1-设置路由器" class="headerlink" title="1. 设置路由器"></a>1. 设置路由器</h3><p>既然要实现局域网代理，那么首先，需要给作为代理服务器的设备设置静态IP地址。</p><p>我的代理服务器静态IP地址设置为192.168.3.9，在此举出以便于下文编写。</p><h4 id="1-1-从路由器关闭DHCP-不推荐"><a href="#1-1-从路由器关闭DHCP-不推荐" class="headerlink" title="1.1 从路由器关闭DHCP(不推荐)"></a>1.1 从路由器关闭DHCP(不推荐)</h4><p>打开路由器的设置页面，以华为路由器为例，找到DHCP相关设置，并关闭DHCP。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301091942.png" alt="关闭DHCP"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301091909.png" alt="提示"></p><p>该方法不推荐使用，原因如上图</p><h4 id="1-2-从路由器添加静态IP地址"><a href="#1-2-从路由器添加静态IP地址" class="headerlink" title="1.2 从路由器添加静态IP地址"></a>1.2 从路由器添加静态IP地址</h4><p>在路由器的DHCP页面找到添加静态IP地址的选项</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301092234.png" alt="添加"></p><p>选择需要作为代理服务器的设备即可</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301092321.png" alt="静态IP地址绑定"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301092447.png" alt="完成"></p><h4 id="1-3-直接在代理服务器上设置静态IP地址"><a href="#1-3-直接在代理服务器上设置静态IP地址" class="headerlink" title="1.3 直接在代理服务器上设置静态IP地址"></a>1.3 直接在代理服务器上设置静态IP地址</h4><p>打开代理服务器上的”<strong>网络连接</strong>“，找到连接到路由器的网卡，右键点击呼出上下文，选择属性并进入，IP地址相关不再赘述。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301092813.png" alt="设置静态IP"></p><h3 id="2-设置SSR"><a href="#2-设置SSR" class="headerlink" title="2. 设置SSR"></a>2. 设置SSR</h3><p>在Surface上右键小飞机-&gt;更多-&gt;选项设置</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301080311.png" alt="设置SSR"></p><p>勾选”<strong>允许来自局域网的连接</strong>“即可</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301080602.png" alt="选项设置"></p><h2 id="Windows客户端"><a href="#Windows客户端" class="headerlink" title="Windows客户端"></a>Windows客户端</h2><h4 id="1-PAC文件"><a href="#1-PAC文件" class="headerlink" title="1. PAC文件"></a>1. PAC文件</h4><p>右键小飞机找到PAC文件地址并复制</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210303210609.png" alt="PAC文件地址"></p><h4 id="2-设置windows代理"><a href="#2-设置windows代理" class="headerlink" title="2. 设置windows代理"></a>2. 设置windows代理</h4><p>在<strong>客户端</strong>，依次打开控制面板-&gt;网络和Internet-&gt;代理，在自动设置代理里面的脚本地址中填入刚才复制的PAC地址，其中，IP地址需要更换成代理服务器的地址</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210303211509.png" alt=""></p><h2 id="随记"><a href="#随记" class="headerlink" title="随记"></a>随记</h2><h3 id="1-自动代理和手动代理的区别"><a href="#1-自动代理和手动代理的区别" class="headerlink" title="1. 自动代理和手动代理的区别"></a>1. 自动代理和手动代理的区别</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301091636.png" alt="自动代理和手动代理"></p><ol><li>自动代理：需要配置PAC(proxy auto-config)脚本文件，根据PAC文件流量会自动选择走代理还是直连。<a href="https://www.barretlee.com/blog/2016/08/25/pac-file/">详解代理自动配置 PAC</a></li><li>手动代理：除了指定的地址不走代理，流量会经代理访问剩余地址</li></ol>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>局域网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows10环境使用Jekyll+github page搭建个人博客</title>
    <link href="/2021/02/05/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Windows10%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8Jekyll+github%20page%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/02/05/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Windows10%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8Jekyll+github%20page%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="1-搭建Jekyll"><a href="#1-搭建Jekyll" class="headerlink" title="1.搭建Jekyll"></a>1.搭建Jekyll</h2><h3 id="1-1-安装Ruby"><a href="#1-1-安装Ruby" class="headerlink" title="1.1 安装Ruby"></a>1.1 安装Ruby</h3><p>Ruby是一种类似于Python的面向对象的语言。</p><p><a href="https://rubyinstaller.org/downloads/">Ruby下载网址</a></p><p>根据自己的开发环境选择对应版本。注意，需要选择<strong>Ruby+Devkit</strong>。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205111003.png" alt="Ruby下载"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205114122.png" alt="License"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205114157.png" alt="Destination"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205114232.png" alt="Components"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205114344.png" alt="等待安装完成"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205114601.png" alt="安装完成"></p><p>等待一会，会跳出命令行界面。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-04-58.png" alt="RubyInstaller2"></p><p>直接按ENTER执行。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205114946.png" alt="正在安装"></p><p>安装完成后关闭窗口即可</p><hr><h3 id="1-2-安装Jekyll"><a href="#1-2-安装Jekyll" class="headerlink" title="1.2 安装Jekyll"></a>1.2 安装Jekyll</h3><p>打开CMD，输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">gem install jekyll bundler<br></code></pre></div></td></tr></table></figure><p>执行，然后等待安装完成。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205115635.png" alt="CMD安装"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205115733.png" alt="CMD安装完成"></p><p>现在验证Jekyll安装是否完成，只需在CMD中输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">jekyll -v<br></code></pre></div></td></tr></table></figure><p>若出现下图结果，表示Jekyll安装成功。若安装失败，重新启动系统，然后<strong>jekyll -v</strong>再次运行。如果错误仍然存在，请打开<a href="https://github.com/oneclick/rubyinstaller2/issues/new">RubyInstaller问题</a>。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205115903.png" alt="Jekyll安装完成" style="zoom:200%;" /></p><hr><h3 id="1-3-使用Jekyll创建网站"><a href="#1-3-使用Jekyll创建网站" class="headerlink" title="1.3 使用Jekyll创建网站"></a>1.3 使用Jekyll创建网站</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">jekyll new blog<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-12-25.png" alt="jekyll new blog"></p><p>完成后在C:\Users\你的用户名下会有个blog的文件夹，内容如下</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210206092035.png" alt="网站创建成功"></p><p><a id='target'>关键</a>:接着安装一些依赖</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">gem <span class="hljs-keyword">install</span> sdbm<br>gem <span class="hljs-keyword">install</span> webrick<br>gem <span class="hljs-keyword">install</span> net-telnet<br>gem <span class="hljs-keyword">install</span> xmlrpc<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-31-34.png" alt="安装依赖"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210206093914.png" alt="安装依赖"></p><p>然后进入blog目录，<strong>shift+鼠标右键</strong>呼出上下文菜单，打开<strong>Powershell窗口</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210206094145.png" alt="上下文菜单"></p><p>在Powershell中输入</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">bundle add webrick<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-36-13.png" alt="bundle add webrick"></p><p>最后运行Jekyll服务</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">jekyll server<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-36-43.png" alt="Jekyll服务"></p><p>打开本地浏览器，输入网址</p><figure class="highlight http"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs http">http://localhost:4000<br></code></pre></div></td></tr></table></figure><p>成功运行<img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-37-34.png" alt=""></p><h3 id="1-4-发布博客"><a href="#1-4-发布博客" class="headerlink" title="1.4 发布博客"></a>1.4 发布博客</h3><p>发布博客很简单，只需要根据Jekyll指定的格式发布即可</p><p>在blog目录下有个_posts文件夹，这个文件夹专门存放markdown文件。里面自带了一个标准的markdown</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304155824.png" alt="默认文件"></p><p>里面内容如下：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">---<br>layout: post    <br>title:  &quot;Welcome to Jekyll!&quot;<br>date:   2021-02-06 09:10:43 +0800<br>categories: jekyll update<br><br>---<br><br>您可以在“ <span class="hljs-emphasis">_posts”目录中找到此信息。继续进行编辑，然后重新构建站点以查看您的更改。您可以用许多不同的方法重建站点，但是最常见的方法是运行“ jekyll serve”，它会启动Web服务器并在文件更新时自动重新生成站点。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">Jekyll要求按照以下格式命名博客文章文件：</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">`YEAR-MONTH-DAY-title.MARKUP`</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">其中“YEAR”是四位数，“MONTH”和“DAY”都是两位数，“ MARKUP”是表示文件中使用的格式的文件扩展名。在那之后，包括必要的前题。查看这篇文章的来源，以了解其工作原理。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">Jekyll还为代码段提供了强大的支持：</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">&#123;% highlight ruby %&#125;</span><br><span class="hljs-emphasis">def print_</span>hi(name)<br>  puts &quot;Hi, #&#123;name&#125;&quot;<br>end<br>print<span class="hljs-emphasis">_hi(&#x27;Tom&#x27;)</span><br><span class="hljs-emphasis">#=&gt; prints &#x27;Hi, Tom&#x27; to STDOUT.</span><br><span class="hljs-emphasis">&#123;% endhighlight %&#125;</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">查看[Jekyll docs] [jekyll-docs]，以获取有关如何充分利用Jekyll的更多信息。在[Jekyll的GitHub存储库] [jekyll-gh]中提交所有错误/功能请求。如有疑问，可以在[Jekyll Talk] [jekyll-talk]上提问。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">[jekyll-docs]: https://jekyllrb.com/docs/home</span><br><span class="hljs-emphasis">[jekyll-gh]:   https://github.com/jekyll/jekyll</span><br><span class="hljs-emphasis">[jekyll-talk]: https://talk.jekyllrb.com/</span><br></code></pre></div></td></tr></table></figure><p>总结一下，就是发布博客最简单的方法就是在_posts目录下，按照它给定的格式创建一个markdown文件，然后在markdown文件的头部，添加一个<strong>front matter</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304160530.png" alt="创建markdown文件"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304160709.png" alt="编写markdown"></p><p>重新运行jekyll服务，然后进入主页</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304160815.png" alt="主页显示"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304161001.png" alt="进入博客"></p><h2 id="2-创建github-page"><a href="#2-创建github-page" class="headerlink" title="2. 创建github page"></a>2. 创建github page</h2><h3 id="2-1-创建仓库"><a href="#2-1-创建仓库" class="headerlink" title="2.1 创建仓库"></a>2.1 创建仓库</h3><p>首先需要一个Github账号，相信大家都有了吧</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210212191956.png" alt="创建仓库1"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210212193329.png" alt="创建仓库2"></p><p>仓库创建成功效果如下图</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210212193101.png" alt="创建成功"></p><h3 id="2-2-设置github-page"><a href="#2-2-设置github-page" class="headerlink" title="2.2 设置github page"></a>2.2 设置github page</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210212193442.png" alt="点击setting"></p><p>下拉找到github page，并点击<strong>Choose a theme</strong>选择一个主题</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210212193555.png" alt="github page选项"></p><h2 id="错误记录"><a href="#错误记录" class="headerlink" title="错误记录"></a>错误记录</h2><h3 id="1-jekyll-创建网站时卡住"><a href="#1-jekyll-创建网站时卡住" class="headerlink" title="1. jekyll 创建网站时卡住"></a>1. jekyll 创建网站时卡住</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205154036.png" alt="jekyll 创建网站时卡住"></p><p>先卸载掉Jekyll</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">gem unistall jekyll <br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-00-22.png" alt="卸载Jekyll"></p><p>然后打开之前下载的rubyinstaller-devkit-xxx.exe可执行文件，按照之前的步骤安装，最重要的是到了这一步</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-04-58.png" alt="RubyInstaller2"></p><p>直接ENTER键安装全部，不需要选择1~3之间的任意选项。然后剩下的步骤照常即可。</p><h3 id="2-servlet-rb-3-in-require’-cannot-load-such-file-—-webrick-LoadError"><a href="#2-servlet-rb-3-in-require’-cannot-load-such-file-—-webrick-LoadError" class="headerlink" title="2. servlet.rb:3:in `require’: cannot load such file — webrick (LoadError)"></a>2. servlet.rb:3:in `require’: cannot load such file — webrick (LoadError)</h3><p>启动Jekyll服务时出错</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-29-39.png" alt="报错"></p><p>原因是启动服务前没有安装相应的依赖，并加入到bundle里面。<a href='#target'>解决方法</a>及<a href="https://github.com/jekyll/jekyll/issues/8523">参考</a></p><h2 id="随记"><a href="#随记" class="headerlink" title="随记"></a>随记</h2><h3 id="1-Jeklly"><a href="#1-Jeklly" class="headerlink" title="1. Jeklly"></a>1. Jeklly</h3><h4 id="1-1-config-yml文件"><a href="#1-1-config-yml文件" class="headerlink" title="1.1  _config.yml文件"></a>1.1  _config.yml文件</h4><p><strong>原始网页：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304115655.png" alt="原始网页"></p><p><strong>原始文件：</strong></p><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-comment"># 欢迎来到 Jekyll!</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 此配置文件用于影响整个博客的设置和值</span><br><span class="hljs-comment"># 应该设置一次，以后很少编辑。如果你发现自己经常编辑此文件，请考虑使用Jekyll的数据文件功能用于您需要经常更新的数据。</span><br><span class="hljs-comment">#由于技术原因，当您使用&#x27;bundle exec jekyll serve&#x27;，不会自动重新加载该文件</span><br><span class="hljs-comment"># 如果更改此文件，请重新启动服务器进程。</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 如果您需要有关YAML语法的帮助，以下是一些快速参考: </span><br><span class="hljs-comment"># https://learn-the-web.algonquindesign.ca/topics/markdown-yaml-cheat-sheet/#yaml</span><br><span class="hljs-comment"># https://learnxinyminutes.com/docs/yaml/</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 网站设置</span><br><span class="hljs-comment"># 这些用于个性化您的新站点。如果您查看HTML文件，您将看到它们通过&#123;&#123;site.title&#125;&#125;，&#123;&#123;site.email&#125;&#125;等访问。</span><br><span class="hljs-comment"># 在模板中通过&#123;&#123;site.myvariable&#125;&#125;可以创建任何想要的自定义变量，并且可以访问它们</span><br><br><span class="hljs-attr">title:</span> <span class="hljs-string">Your</span> <span class="hljs-string">awesome</span> <span class="hljs-string">title</span> <span class="hljs-comment"># 此处修改网页标题</span><br><span class="hljs-attr">email:</span> <span class="hljs-string">your-email@example.com</span> <span class="hljs-comment"># 此处修改个人邮箱</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">&gt;-</span> <span class="hljs-comment"># 此处添加网页描述。这意味着忽略换行符，直到“baseurl：”为止</span><br>  <span class="hljs-string">Write</span> <span class="hljs-string">an</span> <span class="hljs-string">awesome</span> <span class="hljs-string">description</span> <span class="hljs-string">for</span> <span class="hljs-string">your</span> <span class="hljs-string">new</span> <span class="hljs-string">site</span> <span class="hljs-string">here.</span> <span class="hljs-string">You</span> <span class="hljs-string">can</span> <span class="hljs-string">edit</span> <span class="hljs-string">this</span><br>  <span class="hljs-string">line</span> <span class="hljs-string">in</span> <span class="hljs-string">_config.yml.</span> <span class="hljs-string">It</span> <span class="hljs-string">will</span> <span class="hljs-string">appear</span> <span class="hljs-string">in</span> <span class="hljs-string">your</span> <span class="hljs-string">document</span> <span class="hljs-string">head</span> <span class="hljs-string">meta</span> <span class="hljs-string">(for</span><br>  <span class="hljs-string">Google</span> <span class="hljs-string">search</span> <span class="hljs-string">results)</span> <span class="hljs-string">and</span> <span class="hljs-string">in</span> <span class="hljs-string">your</span> <span class="hljs-string">feed.xml</span> <span class="hljs-string">site</span> <span class="hljs-string">description.</span><br><span class="hljs-attr">baseurl:</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># 您网站的子路径，例如/blog</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># 您网站的基本主机名和协议，例如http://example.com</span><br><span class="hljs-attr">twitter_username:</span> <span class="hljs-string">jekyllrb</span><br><span class="hljs-attr">github_username:</span>  <span class="hljs-string">jekyll</span><br><br><span class="hljs-comment"># 构建设置</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">minima</span> <span class="hljs-comment"># 主题</span><br><span class="hljs-attr">plugins:</span> <span class="hljs-comment"># 插件</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">jekyll-feed</span><br><br><span class="hljs-comment"># 从进程中排除</span><br><span class="hljs-comment"># 默认情况下不会处理以下项目</span><br><span class="hljs-comment"># 此处“exclude：”下列出的任何项目都会自动添加到内部的“默认列表”。</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 排除的项目可以通过显式列出目录或在“ include：”列表中输入其条目的文件路径。</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># exclude:</span><br><span class="hljs-comment">#   - .sass-cache/</span><br><span class="hljs-comment">#   - .jekyll-cache/</span><br><span class="hljs-comment">#   - gemfiles/</span><br><span class="hljs-comment">#   - Gemfile</span><br><span class="hljs-comment">#   - Gemfile.lock</span><br><span class="hljs-comment">#   - node_modules/</span><br><span class="hljs-comment">#   - vendor/bundle/</span><br><span class="hljs-comment">#   - vendor/cache/</span><br><span class="hljs-comment">#   - vendor/gems/</span><br><span class="hljs-comment">#   - vendor/ruby/</span><br><br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://sspai.com/post/54608">GitHub Pages 搭建教程</a></li><li><a href="https://segmentfault.com/a/1190000011337349">Windows环境下Jekyll+Github搭建个人博客</a></li><li><a href="https://www.bilibili.com/video/BV1rC4y1878Y/?spm_id_from=333.788.recommend_more_video.0">十分钟搭建个人博客：Jekyll+GitHub Pages</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github page</tag>
      
      <tag>Jekyll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xxx atribute should be defined</title>
    <link href="/2020/12/29/Android/%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/xxx_atribute_should_be_defined/"/>
    <url>/2020/12/29/Android/%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/xxx_atribute_should_be_defined/</url>
    
    <content type="html"><![CDATA[<h2 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h2><h3 id="1-’xxx’-atribute-should-be-defined"><a href="#1-’xxx’-atribute-should-be-defined" class="headerlink" title="1.’xxx’ atribute should be defined"></a>1.’xxx’ atribute should be defined</h3><p>在一开始自定义shape和selector的时候，会有 <strong>‘xxx’ attribute should be defined</strong>的问题。主要原因是xml文件存放的文件夹有错，应该放在drawable文件夹下。<br><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201228171559.png" alt=""><br><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201228171732.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>错误记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Startup</title>
    <link href="/2020/12/27/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Startup/"/>
    <url>/2020/12/27/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Startup/</url>
    
    <content type="html"><![CDATA[<ul><li>StartupCode的重要功能：让静态对象的构造函数正确的被调用</li><li>main()是由启动码函数调用</li></ul><h2 id="mainCRTStartup"><a href="#mainCRTStartup" class="headerlink" title="mainCRTStartup()"></a>mainCRTStartup()</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/54dc87706cafbf193f1a014a2af24970-5ee36.png" alt="C++程序的运行调用栈" style="zoom:100%;" /></p><ol><li><code>_heap_init()</code>：初始化堆内存</li><li><code>_ioinit()</code>：IO初始化<ul><li>任何一个C++程序第一次分配内存的大小都是256</li></ul></li><li><code>GetCommandLineA()</code>：命令行参数初始化。</li><li><code>_crtGetEnvironmentStringsA()</code>：环境变量初始化。从操作系统获取环境变量，并申请空间来存放这些环境变量。</li><li><code>_setargv()</code>：设置命令行参数。<img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/05dad4c0dbed55a7e04b9da98315d795-c474a.png" alt="设置命令行参数。"></li><li><code>_setenvp()</code>：分配<code>_crtGetEnvironmentStringsA()</code>刚才保存的环境变量，将它们存放在一个表中。其中，<code>_environ</code>指向这个表。<ul><li><code>_setenvp()</code>一共执行了n次内存分配操作，n等于一次表的内存分配+k个环境变量的内存分配，其中表的内存分配大小等于k个环境变量的指针大小再加上一个末尾的0。即$sizeof(表)=(k+1)*4$。（效果同<code>_setargv()</code>）<img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b37fc061c3c963ffd880c6e723d93471-dba61.png" style="zoom: 100%;" /></li><li>归还之前<code>_crtGetEnvironmentStringsA()</code>临时保存环境变量的内存。</li></ul></li></ol><p>3，4，5，6都在处理字符串</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/3d90aa9de9a2d03fe3386692e2c88316-1894d.png" alt=""></p><h2 id="WindowsXP-sp2-Heap"><a href="#WindowsXP-sp2-Heap" class="headerlink" title="WindowsXP-sp2 Heap"></a>WindowsXP-sp2 Heap</h2><ul><li>win上采用<strong>前区块</strong>来取代<strong>下cookie</strong></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6c367818cbe928e82625201a7ab44cb7-c6411.png" style="zoom:100%;" /></p><ul><li>debug信息是附加在内存块的尾部</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/98f2c9918d2fee82b83d8ae8b50ac89f-ff0a8.png" style="zoom: 100%;" /></p><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><ul><li>I/O泛指程序与外界的各种交互作用，包括file，pipe，network，console，semaphore等等，或泛指能被OS理解为file的任何事务，file在此是一个广义概念。</li><li>C通过一个pointer to FILE来进行file操作。在OS层面，Linux对应FILE的是File Descriptor（fd）,Windows对应的则是file handle，二者都用来映射kernel file object。</li><li>fd具体是个index of opened file table，一个进程拥有的的这个table是个array of pointers，每个pointer指向一个kernel opened object。当client开启一个file，OS会建立一个（kernel）opened file object并找到上述table中的一个idle entry指向之，然后以该entry的index作为fd。此table位于kernel mode，因此client即使拥有fd<strong>亦无法</strong>获得table address。Linux的fd中，0，1，2分别代表stdin、stdout、stderr。</li><li>C的File与Linux的fd必有一对一的关系。只要有table address p（kernel mode中才可得），p+fd就只想opened file table的某个entry，从而可得kernel file object。</li><li>Windows的file handle和Linux的fd大同小异，但handle不是index，而是index经某种变换后的结果。</li><li>ioinit就是要在client space中建立起stdin，stdout，stderr及其对应的FILEs，使程序进入main()之后立即可用printf()，scanf()等函数。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a72dd579fe9d4a3b0e7a7ec0afb459a8-ff92f.png" style="zoom: 100%;" /></p><ul><li>ioinfo对应了我们写的程序中的FILE（一对一）</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9d38b8e139329e440bd76a40bd36105d-db095.png" style="zoom:100%;" /></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/d9dd37a8490234a9b7eb62a00de58928-c1840.png" style="zoom:100%;" /></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
      <tag>CRT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL：allocator</title>
    <link href="/2020/12/24/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/STL%EF%BC%9Aallocator/"/>
    <url>/2020/12/24/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/STL%EF%BC%9Aallocator/</url>
    
    <content type="html"><![CDATA[<h2 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9f392e29eaa3de0bce406431de47678e-57e69.png" alt="运行模式"></p><ul><li>STL：allocator的客户是STL的容器，如果在容器以外用的话会很麻烦，因为要记录使用的内存大小，以便于销毁的时候需要将大小告诉<code>deallocator</code>，让<code>deallocator</code>找到<code>free_list</code>的对应节点。</li><li><code>free_list</code>管理了16个节点，这16个节点从下标0到下标15，依次管理着8bytes、16bytes、24bytes、32bytes…128bytes的内存区域（按照8bytes增长）。</li><li>通过分配器分配的内存大小，在分配器内部会被设置为某个数的倍数，也就是类似内存对齐。原因是只有对象的size大于等于指针的大小（比如四字节），才能在未分配的内存块里使用指针。<code>vector&lt;bool&gt;</code>可能是个不好的用法，因为浪费了很多内存。</li><li><code>allocator</code>内存分配链表中的不同节点，指向的一大块内存区域都被等分为<strong>20</strong>块相同的内存块。就比如负责32bytes的节点，指向一共有20块大小为32bytes的内存区域，这块内存区域的大小即为20*32bytes。</li><li>如果内存区域用光了，如果有备用空间的话，就拿备用空间的内存，没有的话就向malloc申请一块2*20*(所需空间大小)的内存区域。比如这时候假设需要96bytes的空间，且没有备用空间，那么分配器会向malloc申请2<em>20个96btyes大小的空间，然后用前面的20个来给96bytes用，剩下的20\</em>96bytes的空间将成为备用空间。此时再要申请128bytes的内存块，又因为内存分配链表中，管理128bytes的节点中没有内容，那么就会将备用空间拿来用，划分内存块的流程是20*96bytes/128bytes，即划分为10*128bytes。（这个只是简单流程，更具体的流程看PDF）</li><li><code>start_free</code>和<code>end_free</code>指向备用区域（内存池）的头尾两端。</li><li>每次向<code>malloc</code>申请内存时都会有个追加量。</li><li><code>allocate</code>和<code>deallocate</code>都会先判断元素大小是否合法，如果不合法将调用第一级别的<code>allocate</code>和<code>deallocate</code>。</li><li>如果传入<code>deallocate</code>的对象指针p并非当初从<code>allocate</code>所得，在size参数合法的情况下，p依然会被并入到<code>free_list</code>中去。如果p所指的大小不是8的倍数，甚至会带来灾难。</li><li><code>chunk_alloc</code>中对碎片的处理：将碎片插入到合适的#号free-list中，一般情况是将节点接入链表的中间区域，而不一定是链表的最末尾。</li><li><code>deallocate</code>完全没有调用<code>free</code>和<code>delete</code>，源于其设计上的先天缺陷。</li></ul><h3 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h3><h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/e58fed98c2c7536e2576006a55cd8f90-f4728.png"  /></p><h4 id="将C-allocator转移到C"><a href="#将C-allocator转移到C" class="headerlink" title="将C++ allocator转移到C"></a>将C++ allocator转移到C</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/e8a2e33a35b2a1c866eee7bf827676fe-e9261.png" alt="C++"  /></p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><h5 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">obj* *p1,*p2;<span class="hljs-comment">//等效于下面代码</span><br>obj **p1,*p2;<span class="hljs-comment">//等效于下面代码</span><br>obj** p1;obj* p2;<br></code></pre></div></td></tr></table></figure><h5 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">void</span><span class="hljs-params">(*set_malloc_handler(<span class="hljs-keyword">void</span> (*f)()))</span><span class="hljs-params">()</span></span><br></code></pre></div></td></tr></table></figure><p>等效于</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*new_handler)</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(new_handler p)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br></code></pre></div></td></tr></table></figure><p>也等效于</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*H)</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> H <span class="hljs-title">set_malloc_handler</span><span class="hljs-params">(H f)</span></span>;<br></code></pre></div></td></tr></table></figure><h2 id="allocator源码"><a href="#allocator源码" class="headerlink" title="allocator源码"></a>allocator源码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span>  <span class="hljs-comment">//for malloc(),realloc()</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;</span>  <span class="hljs-comment">//for size_t</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory.h&gt;</span>  <span class="hljs-comment">//for memcpy()</span></span><br><br><span class="hljs-comment">//#define __THROW_BAD_ALLOC   cerr &lt;&lt; &quot;out of memory&quot; &lt;&lt; endl; exit(1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __THROW_BAD_ALLOC   exit(1)</span><br><br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">// 第1級配置器。</span><br><span class="hljs-comment">//----------------------------------------------</span><br><br><span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*oom_handler)() = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">oom_malloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*my_malloc_handler)();<br>  <span class="hljs-keyword">void</span>* result;<br><br>  <span class="hljs-keyword">for</span> (;;) &#123;    <span class="hljs-comment">//不斷嘗試釋放、配置、再釋放、再配置…</span><br>    my_malloc_handler = oom_handler;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;<br>    (*my_malloc_handler)();    <span class="hljs-comment">//呼叫處理常式，企圖釋放記憶體</span><br>    result = <span class="hljs-built_in">malloc</span>(n);        <span class="hljs-comment">//再次嘗試配置記憶體</span><br>    <span class="hljs-keyword">if</span> (result) <span class="hljs-keyword">return</span>(result);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">oom_realloc</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *p, <span class="hljs-keyword">size_t</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*my_malloc_handler)();<br>  <span class="hljs-keyword">void</span>* result;<br><br>  <span class="hljs-keyword">for</span> (;;) &#123;    <span class="hljs-comment">//不斷嘗試釋放、配置、再釋放、再配置…</span><br>    my_malloc_handler = oom_handler;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;<br>    (*my_malloc_handler)();    <span class="hljs-comment">//呼叫處理常式，企圖釋放記憶體。</span><br>    result = <span class="hljs-built_in">realloc</span>(p, n);    <span class="hljs-comment">//再次嘗試配置記憶體。</span><br>    <span class="hljs-keyword">if</span> (result) <span class="hljs-keyword">return</span>(result);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">malloc_allocate</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">void</span> *result = <span class="hljs-built_in">malloc</span>(n);   <span class="hljs-comment">//直接使用 malloc()</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == result) result = <span class="hljs-built_in">oom_malloc</span>(n);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">malloc_deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-keyword">size_t</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">free</span>(p);  <span class="hljs-comment">//直接使用 free()</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">malloc_reallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *p, <span class="hljs-keyword">size_t</span> old_sz, <span class="hljs-keyword">size_t</span> new_sz)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">void</span>* result = <span class="hljs-built_in">realloc</span>(p, new_sz); <span class="hljs-comment">//直接使用 realloc()</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == result) result = <span class="hljs-built_in">oom_realloc</span>(p, new_sz);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*<span class="hljs-built_in">set_malloc_handler</span>(<span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*f)()))()<br>&#123; <span class="hljs-comment">//類似 C++ 的 set_new_handler().</span><br>  <span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*old)() = oom_handler;<br>  oom_handler = f;<br>  <span class="hljs-keyword">return</span>(old);<br>&#125;<br><br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">//第二級配置器</span><br><span class="hljs-comment">//----------------------------------------------</span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span>__ALIGN = <span class="hljs-number">8</span>&#125;;                        <span class="hljs-comment">//小區塊的上調邊界</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span>__MAX_BYTES = <span class="hljs-number">128</span>&#125;;                  <span class="hljs-comment">//小區塊的上限</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span>__NFREELISTS = __MAX_BYTES/__ALIGN&#125;; <span class="hljs-comment">//free-lists 個數</span><br><br><span class="hljs-comment">// union obj &#123;                   //G291[o],CB5[x],VC6[x]</span><br><span class="hljs-comment">//   union obj* free_list_link;  //這麼寫在 VC6 和 CB5 中也可以，</span><br><span class="hljs-comment">// &#125;;                            //但以後就得使用 &quot;union obj&quot; 而不能只寫 &quot;obj&quot;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">obj</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">obj</span>* <span class="hljs-title">free_list_link</span>;</span><br>&#125; obj;<br><br><span class="hljs-keyword">char</span>*   start_free = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span>*   end_free = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">size_t</span>  heap_size = <span class="hljs-number">0</span>;<br>obj* free_list[__NFREELISTS]<br>     = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">ROUND_UP</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> bytes)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (((bytes) + __ALIGN<span class="hljs-number">-1</span>) &amp; ~(__ALIGN - <span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">FREELIST_INDEX</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> bytes)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (((bytes) + __ALIGN<span class="hljs-number">-1</span>)/__ALIGN - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">// We allocate memory in large chunks in order to</span><br><span class="hljs-comment">// avoid fragmentingthe malloc heap too much.</span><br><span class="hljs-comment">// We assume that size is properly aligned.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Allocates a chunk for nobjs of size &quot;size&quot;.</span><br><span class="hljs-comment">// nobjs may be reduced if it is inconvenient to</span><br><span class="hljs-comment">// allocate the requested number.</span><br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">//char* chunk_alloc(size_t size, int&amp; nobjs)  //G291[o],VC6[x],CB5[x]</span><br><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">chunk_alloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span>* nobjs)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span>* result;<br>  <span class="hljs-keyword">size_t</span> total_bytes = size * (*nobjs);   <span class="hljs-comment">//原 nobjs 改為 (*nobjs)</span><br>  <span class="hljs-keyword">size_t</span> bytes_left = end_free - start_free;<br><br>  <span class="hljs-keyword">if</span> (bytes_left &gt;= total_bytes) &#123;<br>      result = start_free;<br>      start_free += total_bytes;<br>      <span class="hljs-keyword">return</span>(result);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bytes_left &gt;= size) &#123;<br>      *nobjs = bytes_left / size;         <span class="hljs-comment">//原 nobjs 改為 (*nobjs)</span><br>      total_bytes = size * (*nobjs);      <span class="hljs-comment">//原 nobjs 改為 (*nobjs)</span><br>      result = start_free;<br>      start_free += total_bytes;<br>      <span class="hljs-keyword">return</span>(result);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">size_t</span> bytes_to_get =<br>                 <span class="hljs-number">2</span> * total_bytes + <span class="hljs-built_in">ROUND_UP</span>(heap_size &gt;&gt; <span class="hljs-number">4</span>);<br>      <span class="hljs-comment">// Try to make use of the left-over piece.</span><br>      <span class="hljs-keyword">if</span> (bytes_left &gt; <span class="hljs-number">0</span>) &#123;<br>          obj* <span class="hljs-keyword">volatile</span> *my_free_list =<br>                 free_list + <span class="hljs-built_in">FREELIST_INDEX</span>(bytes_left);<br><br>          ((obj*)start_free)-&gt;free_list_link = *my_free_list;<br>          *my_free_list = (obj*)start_free;<br>      &#125;<br>      start_free = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(bytes_to_get);<br>      <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == start_free) &#123;<br>          <span class="hljs-keyword">int</span> i;<br>          obj* <span class="hljs-keyword">volatile</span> *my_free_list, *p;<br><br>          <span class="hljs-comment">//Try to make do with what we have. That can&#x27;t</span><br>          <span class="hljs-comment">//hurt. We do not try smaller requests, since that tends</span><br>          <span class="hljs-comment">//to result in disaster on multi-process machines.</span><br>          <span class="hljs-keyword">for</span> (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;<br>              my_free_list = free_list + <span class="hljs-built_in">FREELIST_INDEX</span>(i);<br>              p = *my_free_list;<br>              <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != p) &#123;<br>                  *my_free_list = p -&gt; free_list_link;<br>                  start_free = (<span class="hljs-keyword">char</span>*)p;<br>                  end_free = start_free + i;<br>                  <span class="hljs-keyword">return</span>(<span class="hljs-built_in">chunk_alloc</span>(size, nobjs));<br>                  <span class="hljs-comment">//Any leftover piece will eventually make it to the</span><br>                  <span class="hljs-comment">//right free list.</span><br>              &#125;<br>          &#125;<br>          end_free = <span class="hljs-number">0</span>;       <span class="hljs-comment">//In case of exception.</span><br>          start_free = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc_allocate</span>(bytes_to_get);<br>          <span class="hljs-comment">//This should either throw an exception or</span><br>          <span class="hljs-comment">//remedy the situation. Thus we assume it</span><br>          <span class="hljs-comment">//succeeded.</span><br>      &#125;<br>      heap_size += bytes_to_get;<br>      end_free = start_free + bytes_to_get;<br>      <span class="hljs-keyword">return</span>(<span class="hljs-built_in">chunk_alloc</span>(size, nobjs));<br>  &#125;<br>&#125;<br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">// Returns an object of size n, and optionally adds</span><br><span class="hljs-comment">// to size n free list. We assume that n is properly aligned.</span><br><span class="hljs-comment">// We hold the allocation lock.</span><br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">refill</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> nobjs = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">char</span>* chunk = <span class="hljs-built_in">chunk_alloc</span>(n,&amp;nobjs);<br>    obj* <span class="hljs-keyword">volatile</span> *my_free_list;   <span class="hljs-comment">//obj** my_free_list;</span><br>    obj* result;<br>    obj* current_obj;<br>    obj* next_obj;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == nobjs) <span class="hljs-keyword">return</span>(chunk);<br>    my_free_list = free_list + <span class="hljs-built_in">FREELIST_INDEX</span>(n);<br><br>    <span class="hljs-comment">//Build free list in chunk</span><br>    result = (obj*)chunk;<br>    *my_free_list = next_obj = (obj*)(chunk + n);<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;  ; ++i) &#123;<br>      current_obj = next_obj;<br>      next_obj = (obj*)((<span class="hljs-keyword">char</span>*)next_obj + n);<br>      <span class="hljs-keyword">if</span> (nobjs<span class="hljs-number">-1</span> == i) &#123;<br>          current_obj-&gt;free_list_link = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">break</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          current_obj-&gt;free_list_link = next_obj;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>(result);<br>&#125;<br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> n)</span>  <span class="hljs-comment">//n must be &gt; 0</span></span><br><span class="hljs-function"></span>&#123;<br>  obj* <span class="hljs-keyword">volatile</span> *my_free_list;    <span class="hljs-comment">//obj** my_free_list;</span><br>  obj* result;<br><br>  <span class="hljs-keyword">if</span> (n &gt; (<span class="hljs-keyword">size_t</span>)__MAX_BYTES) &#123;<br>      <span class="hljs-keyword">return</span>(<span class="hljs-built_in">malloc_allocate</span>(n));<br>  &#125;<br><br>  my_free_list = free_list + <span class="hljs-built_in">FREELIST_INDEX</span>(n);<br>  result = *my_free_list;<br>  <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">void</span>* r = <span class="hljs-built_in">refill</span>(<span class="hljs-built_in">ROUND_UP</span>(n));<br>      <span class="hljs-keyword">return</span> r;<br>  &#125;<br><br>  *my_free_list = result-&gt;free_list_link;<br>  <span class="hljs-keyword">return</span> (result);<br>&#125;<br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *p, <span class="hljs-keyword">size_t</span> n)</span>  <span class="hljs-comment">//p may not be 0</span></span><br><span class="hljs-function"></span>&#123;<br>  obj* q = (obj*)p;<br>  obj* <span class="hljs-keyword">volatile</span> *my_free_list;   <span class="hljs-comment">//obj** my_free_list;</span><br><br>  <span class="hljs-keyword">if</span> (n &gt; (<span class="hljs-keyword">size_t</span>) __MAX_BYTES) &#123;<br>      <span class="hljs-built_in">malloc_deallocate</span>(p, n);<br>      <span class="hljs-keyword">return</span>;<br>  &#125;<br>  my_free_list = free_list + <span class="hljs-built_in">FREELIST_INDEX</span>(n);<br>  q-&gt;free_list_link = *my_free_list;<br>  *my_free_list = q;<br>&#125;<br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">reallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *p, <span class="hljs-keyword">size_t</span> old_sz, <span class="hljs-keyword">size_t</span> new_sz)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">void</span> * result;<br>  <span class="hljs-keyword">size_t</span> copy_sz;<br><br>  <span class="hljs-keyword">if</span> (old_sz &gt; (<span class="hljs-keyword">size_t</span>) __MAX_BYTES &amp;&amp; new_sz &gt; (<span class="hljs-keyword">size_t</span>) __MAX_BYTES) &#123;<br>      <span class="hljs-keyword">return</span>(<span class="hljs-built_in">realloc</span>(p, new_sz));<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ROUND_UP</span>(old_sz) == <span class="hljs-built_in">ROUND_UP</span>(new_sz)) <span class="hljs-keyword">return</span>(p);<br>  result = <span class="hljs-built_in">allocate</span>(new_sz);<br>  copy_sz = new_sz &gt; old_sz? old_sz : new_sz;<br>  <span class="hljs-built_in">memcpy</span>(result, p, copy_sz);<br>  <span class="hljs-built_in">deallocate</span>(p, old_sz);<br>  <span class="hljs-keyword">return</span>(result);<br>&#125;<br><span class="hljs-comment">//----------------------------------------------</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>上拉加载和下拉刷新</title>
    <link href="/2020/12/21/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0/"/>
    <url>/2020/12/21/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="SmartRefreshLayout结合RecyclerView"><a href="#SmartRefreshLayout结合RecyclerView" class="headerlink" title="SmartRefreshLayout结合RecyclerView"></a>SmartRefreshLayout结合RecyclerView</h2><h3 id="1-创建错误布局（空数据布局）"><a href="#1-创建错误布局（空数据布局）" class="headerlink" title="1.创建错误布局（空数据布局）"></a>1.创建错误布局（空数据布局）</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201220162105.png" alt="空数据布局"></p><h4 id="EmptyView-java"><a href="#EmptyView-java" class="headerlink" title="EmptyView.java"></a>EmptyView.java</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><br><span class="hljs-comment">//import ...</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmptyView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinearLayout</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ImageView icon;<br>    <span class="hljs-keyword">private</span> TextView title;<br>    <span class="hljs-keyword">private</span> Button action;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EmptyView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(context, <span class="hljs-keyword">null</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EmptyView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(context, attrs, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EmptyView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs, <span class="hljs-keyword">int</span> defStyleAttr)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(context, attrs, defStyleAttr, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EmptyView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs, <span class="hljs-keyword">int</span> defStyleAttr, <span class="hljs-keyword">int</span> style)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context, attrs, defStyleAttr, style);<br>        setOrientation(VERTICAL);<br>        setGravity(Gravity.CENTER);<br>        <span class="hljs-comment">//加载布局文件</span><br>        LayoutInflater.from(context).inflate(R.layout.layout_empty_view, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">true</span>);<br><br>        icon = findViewById(R.id.empty_icon);<br>        title = findViewById(R.id.empty_text);<br>        action = findViewById(R.id.empty_action);<br>    &#125;<br><br>    <span class="hljs-comment">//设置图片</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEmptyIcon</span><span class="hljs-params">(<span class="hljs-meta">@DrawableRes</span> <span class="hljs-keyword">int</span> iconRes)</span> </span>&#123;<br>        icon.setImageResource(iconRes);<br>    &#125;<br><br>    <span class="hljs-comment">//设置标题</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTitle</span><span class="hljs-params">(String text)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (TextUtils.isEmpty(text)) &#123;<br>            <span class="hljs-comment">//如果文本为空，设置text隐藏</span><br>            title.setVisibility(GONE);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            title.setText(text);<br>            title.setVisibility(VISIBLE);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">//设置按钮</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setButton</span><span class="hljs-params">(String text, View.OnClickListener listener)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (TextUtils.isEmpty(text)) &#123;<br>            action.setVisibility(GONE);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            action.setText(text);<br>            action.setVisibility(VISIBLE);<br>            action.setOnClickListener(listener);<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="layout-empty-view-xml"><a href="#layout-empty-view-xml" class="headerlink" title="layout_empty_view.xml"></a>layout_empty_view.xml</h4><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><br>    <span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;center&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center_horizontal&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/empty_icon&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@drawable/icon_empty_no_data&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/empty_text&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;16dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;虽然什么也没有,要不下拉刷新试试&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#999999&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;16sp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:visibility</span>=<span class="hljs-string">&quot;visible&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:text</span>=<span class="hljs-string">&quot;虽然什么也没有,要不下拉刷新看看&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TextView</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.button.MaterialButton</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/empty_action&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;16dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:paddingLeft</span>=<span class="hljs-string">&quot;16dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:paddingRight</span>=<span class="hljs-string">&quot;16dp&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#ffffff&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;14sp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:visibility</span>=<span class="hljs-string">&quot;gone&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:backgroundTint</span>=<span class="hljs-string">&quot;#ff678f&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:cornerRadius</span>=<span class="hljs-string">&quot;20dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:text</span>=<span class="hljs-string">&quot;朕知道了&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">com.google.android.material.button.MaterialButton</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br><br><br></code></pre></div></td></tr></table></figure><h3 id="2-编写总布局"><a href="#2-编写总布局" class="headerlink" title="2.编写总布局"></a>2.编写总布局</h3><h4 id="layout-refresh-view-xml"><a href="#layout-refresh-view-xml" class="headerlink" title="layout_refresh_view.xml"></a>layout_refresh_view.xml</h4><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">FrameLayout</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span><br><br>        <br>        <span class="hljs-tag">&lt;<span class="hljs-name">com.scwang.smartrefresh.layout.SmartRefreshLayout</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/refresh_layout&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><br><br>            <span class="hljs-comment">&lt;!-- 头 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">com.scwang.smartrefresh.layout.header.ClassicsHeader</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com.scwang.smartrefresh.layout.header.ClassicsHeader</span>&gt;</span><br><br>            <span class="hljs-comment">&lt;!-- 内容展示 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">androidx.recyclerview.widget.RecyclerView</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/recycler_view&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.recyclerview.widget.RecyclerView</span>&gt;</span><br><br>            <span class="hljs-comment">&lt;!-- 尾 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">com.scwang.smartrefresh.layout.footer.ClassicsFooter</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com.scwang.smartrefresh.layout.footer.ClassicsFooter</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">com.scwang.smartrefresh.layout.SmartRefreshLayout</span>&gt;</span><br><br><br><span class="hljs-comment">&lt;!--       错误布局 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">com.mooc.libcommon.view.EmptyView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/empty_view&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;100dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com.mooc.libcommon.view.EmptyView</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">FrameLayout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><p>注：需转化为dataBinding布局</p><h3 id="3-编写基础的ListFragment"><a href="#3-编写基础的ListFragment" class="headerlink" title="3.编写基础的ListFragment"></a>3.编写基础的ListFragment</h3><h4 id="AbsListFragment-class"><a href="#AbsListFragment-class" class="headerlink" title="AbsListFragment.class"></a>AbsListFragment.class</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><br><span class="hljs-comment">//import androidx.fragment.app.Fragment;</span><br><span class="hljs-comment">//import ...</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbsListFragment</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">M</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbsViewModel</span>&lt;<span class="hljs-title">T</span>&gt;&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Fragment</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OnRefreshListener</span>, <span class="hljs-title">OnLoadMoreListener</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> LayoutRefreshViewBinding binding;<br>    <span class="hljs-keyword">protected</span> RecyclerView mRecyclerView;<br>    <span class="hljs-keyword">protected</span> SmartRefreshLayout mRefreshLayout;<br>    <span class="hljs-keyword">protected</span> EmptyView mEmptyView;<br>    <span class="hljs-keyword">protected</span> PagedListAdapter&lt;T, RecyclerView.ViewHolder&gt; adapter;<br>    <span class="hljs-keyword">protected</span> M mViewModel;<br>    <span class="hljs-keyword">protected</span> DividerItemDecoration decoration;<br><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LayoutInflater inflater, <span class="hljs-meta">@Nullable</span> ViewGroup container, <span class="hljs-meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-comment">//获取databinding布局</span><br>        binding = LayoutRefreshViewBinding.inflate(inflater, container, <span class="hljs-keyword">false</span>);<br>        binding.getRoot().setFitsSystemWindows(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//获得view</span><br>        mRecyclerView = binding.recyclerView;<br>        mRefreshLayout = binding.refreshLayout;<br>        mEmptyView = binding.emptyView;<br><br>        <span class="hljs-comment">//打开上拉刷新</span><br>        mRefreshLayout.setEnableRefresh(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//打开下拉加载</span><br>        mRefreshLayout.setEnableLoadMore(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//设置上拉刷新监听事件</span><br>        mRefreshLayout.setOnRefreshListener(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-comment">//设置下拉加载监听事件</span><br>        mRefreshLayout.setOnLoadMoreListener(<span class="hljs-keyword">this</span>);<br><br>        <span class="hljs-comment">//设置适配器</span><br>        adapter = getAdapter();<br>        mRecyclerView.setAdapter(adapter);<br>        <span class="hljs-comment">//设置垂直线性布局</span><br>        mRecyclerView.setLayoutManager(<span class="hljs-keyword">new</span> LinearLayoutManager(getContext(), LinearLayoutManager.VERTICAL, <span class="hljs-keyword">false</span>));<br>        <span class="hljs-comment">//设置列表动画为空</span><br>        mRecyclerView.setItemAnimator(<span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//默认给列表中的Item 一个 10dp的ItemDecoration</span><br>        decoration = <span class="hljs-keyword">new</span> DividerItemDecoration(getContext(), LinearLayoutManager.VERTICAL);<br>        decoration.setDrawable(ContextCompat.getDrawable(getContext(), R.drawable.list_divider));<br>        mRecyclerView.addItemDecoration(decoration);<br><br>        genericViewModel();<br>        <span class="hljs-keyword">return</span> binding.getRoot();<br><br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">genericViewModel</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//利用 子类传递的 泛型参数实例化出absViewModel 对象。</span><br>        ParameterizedType type = (ParameterizedType) getClass().getGenericSuperclass();<br>        Type[] arguments = type.getActualTypeArguments();<br>        <span class="hljs-keyword">if</span> (arguments.length &gt; <span class="hljs-number">1</span>) &#123;<br>            Type argument = arguments[<span class="hljs-number">1</span>];<br>            Class modelClaz = ((Class) argument).asSubclass(AbsViewModel.class);<br>            mViewModel = (M) ViewModelProviders.of(<span class="hljs-keyword">this</span>).get(modelClaz);<br><br>            <span class="hljs-comment">//触发页面初始化数据加载的逻辑</span><br>            mViewModel.getPageData().observe(<span class="hljs-keyword">this</span>, pagedList -&gt; submitList(pagedList));<br><br>            <span class="hljs-comment">//监听分页时有无更多数据,以决定是否关闭上拉加载的动画</span><br>            mViewModel.getBoundaryPageData().observe(<span class="hljs-keyword">this</span>, hasData -&gt; finishRefresh(hasData));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//加载数据到界面</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">submitList</span><span class="hljs-params">(PagedList&lt;T&gt; result)</span> </span>&#123;<br>        <span class="hljs-comment">//只有当新数据集合大于0 的时候，才调用adapter.submitList</span><br>        <span class="hljs-comment">//否则可能会出现 页面----有数据-----&gt;被清空-----空布局</span><br>        <span class="hljs-keyword">if</span> (result.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            adapter.submitList(result);<br>        &#125;<br>        <span class="hljs-comment">//结束刷新</span><br>        finishRefresh(result.size() &gt; <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finishRefresh</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> hasData)</span> </span>&#123;<br><br>        <span class="hljs-comment">//获得adapter当前的数据集合</span><br>        PagedList&lt;T&gt; currentList = adapter.getCurrentList();<br>        <span class="hljs-comment">//判断是否有数据</span><br>        hasData = hasData || currentList != <span class="hljs-keyword">null</span> &amp;&amp; currentList.size() &gt; <span class="hljs-number">0</span>;<br>        RefreshState state = mRefreshLayout.getState();<br>        <br>        <span class="hljs-comment">//isOpening等同isLoading || isRefreshing</span><br>        <span class="hljs-keyword">if</span> (state.isFooter &amp;&amp; state.isOpening) &#123;<span class="hljs-comment">//当前于Footer一系列状态中</span><br>            <span class="hljs-comment">//上拉加载完成</span><br>            mRefreshLayout.finishLoadMore();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state.isHeader &amp;&amp; state.isOpening) &#123;<span class="hljs-comment">//当前于Header一系列状态中</span><br>            <span class="hljs-comment">//下拉刷新完成</span><br>            mRefreshLayout.finishRefresh();<br>        &#125;<br><br>        <span class="hljs-comment">//如果有数据，隐藏错误布局</span><br>        <span class="hljs-keyword">if</span> (hasData) &#123;<br>            mEmptyView.setVisibility(View.GONE);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mEmptyView.setVisibility(View.VISIBLE);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 因而 我们在 onCreateView的时候 创建了 PagedListAdapter</span><br><span class="hljs-comment">     * 所以，如果arguments 有参数需要传递到Adapter 中，那么需要在getAdapter()方法中取出参数。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>     <span class="hljs-comment">//设置虚方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> PagedListAdapter <span class="hljs-title">getAdapter</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><br></code></pre></div></td></tr></table></figure><h3 id="4-编写适配器"><a href="#4-编写适配器" class="headerlink" title="4.编写适配器"></a>4.编写适配器</h3><h4 id="AbsPagedListAdapter-class"><a href="#AbsPagedListAdapter-class" class="headerlink" title="AbsPagedListAdapter.class"></a>AbsPagedListAdapter.class</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><br><span class="hljs-comment">//import ...</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一个能够添加HeaderView,FooterView的PagedListAdapter。</span><br><span class="hljs-comment"> * 解决了添加HeaderView和FooterView时 RecyclerView定位不准确的问题</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt;  Java Bean</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;VH&gt;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbsPagedListAdapter</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">VH</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ViewHolder</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">PagedListAdapter</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">VH</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> SparseArray&lt;View&gt; mHeaders = <span class="hljs-keyword">new</span> SparseArray&lt;&gt;();<br>    <span class="hljs-keyword">private</span> SparseArray&lt;View&gt; mFooters = <span class="hljs-keyword">new</span> SparseArray&lt;&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> BASE_ITEM_TYPE_HEADER = <span class="hljs-number">100000</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> BASE_ITEM_TYPE_FOOTER = <span class="hljs-number">200000</span>;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">AbsPagedListAdapter</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> DiffUtil.ItemCallback&lt;T&gt; diffCallback)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(diffCallback);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addHeaderView</span><span class="hljs-params">(View view)</span> </span>&#123;<br>        <span class="hljs-comment">//判断给View对象是否还没有处在mHeaders数组里面</span><br>        <span class="hljs-keyword">if</span> (mHeaders.indexOfValue(view) &lt; <span class="hljs-number">0</span>) &#123;<br>            mHeaders.put(BASE_ITEM_TYPE_HEADER++, view);<br>            notifyDataSetChanged();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFooterView</span><span class="hljs-params">(View view)</span> </span>&#123;<br>        <span class="hljs-comment">//判断给View对象是否还没有处在mFooters数组里面</span><br>        <span class="hljs-keyword">if</span> (mFooters.indexOfValue(view) &lt; <span class="hljs-number">0</span>) &#123;<br>            mFooters.put(BASE_ITEM_TYPE_FOOTER++, view);<br>            notifyDataSetChanged();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 移除头部</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeHeaderView</span><span class="hljs-params">(View view)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> index = mHeaders.indexOfValue(view);<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        mHeaders.removeAt(index);<br>        notifyDataSetChanged();<br>    &#125;<br><br>    <span class="hljs-comment">// 移除底部</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeFooterView</span><span class="hljs-params">(View view)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> index = mFooters.indexOfValue(view);<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        mFooters.removeAt(index);<br>        notifyDataSetChanged();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHeaderCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mHeaders.size();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFooterCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mFooters.size();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> itemCount = <span class="hljs-keyword">super</span>.getItemCount();<br>        <span class="hljs-keyword">return</span> itemCount + mHeaders.size() + mFooters.size();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOriginalItemCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getItemCount() - mHeaders.size() - mFooters.size();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemViewType</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (isHeaderPosition(position)) &#123;<br>            <span class="hljs-comment">//返回该position对应的headerview的  viewType</span><br>            <span class="hljs-keyword">return</span> mHeaders.keyAt(position);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (isFooterPosition(position)) &#123;<br>            <span class="hljs-comment">//footer类型的，需要计算一下它的position实际大小</span><br>            position = position - getOriginalItemCount() - mHeaders.size();<br>            <span class="hljs-keyword">return</span> mFooters.keyAt(position);<br>        &#125;<br>        position = position - mHeaders.size();<br>        <span class="hljs-keyword">return</span> getItemViewType2(position);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemViewType2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFooterPosition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> position &gt;= getOriginalItemCount() + mHeaders.size();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeaderPosition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> position &lt; mHeaders.size();<br>    &#125;<br><br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> VH <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ViewGroup parent, <span class="hljs-keyword">int</span> viewType)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (mHeaders.indexOfKey(viewType) &gt;= <span class="hljs-number">0</span>) &#123;<br>            View view = mHeaders.get(viewType);<br>            <span class="hljs-keyword">return</span> (VH) <span class="hljs-keyword">new</span> RecyclerView.ViewHolder(view) &#123;<br>            &#125;;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (mFooters.indexOfKey(viewType) &gt;= <span class="hljs-number">0</span>) &#123;<br>            View view = mFooters.get(viewType);<br>            <span class="hljs-keyword">return</span> (VH) <span class="hljs-keyword">new</span> RecyclerView.ViewHolder(view) &#123;<br>            &#125;;<br>        &#125;<br><br><br>        <span class="hljs-keyword">return</span> onCreateViewHolder2(parent, viewType);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> VH <span class="hljs-title">onCreateViewHolder2</span><span class="hljs-params">(ViewGroup parent, <span class="hljs-keyword">int</span> viewType)</span></span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> VH holder, <span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (isHeaderPosition(position) || isFooterPosition(position))<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//列表中正常类型的itemView的 position 咱们需要减去添加headerView的个数</span><br>        position = position - mHeaders.size();<br>        onBindViewHolder2(holder, position);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder2</span><span class="hljs-params">(VH holder, <span class="hljs-keyword">int</span> position)</span></span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewAttachedToWindow</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> RecyclerView.ViewHolder holder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!isHeaderPosition(holder.getAdapterPosition()) &amp;&amp; !isFooterPosition(holder.getAdapterPosition())) &#123;<br>            <span class="hljs-keyword">this</span>.onViewAttachedToWindow2((VH) holder);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewAttachedToWindow2</span><span class="hljs-params">(VH holder)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewDetachedFromWindow</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> RecyclerView.ViewHolder holder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!isHeaderPosition(holder.getAdapterPosition()) &amp;&amp; !isFooterPosition(holder.getAdapterPosition())) &#123;<br>            <span class="hljs-keyword">this</span>.onViewDetachedFromWindow2((VH) holder);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewDetachedFromWindow2</span><span class="hljs-params">(VH holder)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerAdapterDataObserver</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> RecyclerView.AdapterDataObserver observer)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.registerAdapterDataObserver(<span class="hljs-keyword">new</span> AdapterDataObserverProxy(observer));<br>    &#125;<br><br>    <span class="hljs-comment">//如果我们先添加了headerView,而后网络数据回来了再更新到列表上</span><br>    <span class="hljs-comment">//由于Paging在计算列表上item的位置时 并不会顾及我们有没有添加headerView，就会出现列表定位的问题</span><br>    <span class="hljs-comment">//实际上 RecyclerView#setAdapter方法，它会给Adapter注册了一个AdapterDataObserver</span><br>    <span class="hljs-comment">//咱么可以代理registerAdapterDataObserver()传递进来的observer。在各个方法的实现中，把headerView的个数算上，再中转出去即可</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdapterDataObserverProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">AdapterDataObserver</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> RecyclerView.AdapterDataObserver mObserver;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AdapterDataObserverProxy</span><span class="hljs-params">(RecyclerView.AdapterDataObserver observer)</span> </span>&#123;<br>            mObserver = observer;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onChanged</span><span class="hljs-params">()</span> </span>&#123;<br>            mObserver.onChanged();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemRangeChanged</span><span class="hljs-params">(<span class="hljs-keyword">int</span> positionStart, <span class="hljs-keyword">int</span> itemCount)</span> </span>&#123;<br>            mObserver.onItemRangeChanged(positionStart + mHeaders.size(), itemCount);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemRangeChanged</span><span class="hljs-params">(<span class="hljs-keyword">int</span> positionStart, <span class="hljs-keyword">int</span> itemCount, <span class="hljs-meta">@Nullable</span> Object payload)</span> </span>&#123;<br>            mObserver.onItemRangeChanged(positionStart + mHeaders.size(), itemCount, payload);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemRangeInserted</span><span class="hljs-params">(<span class="hljs-keyword">int</span> positionStart, <span class="hljs-keyword">int</span> itemCount)</span> </span>&#123;<br>            mObserver.onItemRangeInserted(positionStart + mHeaders.size(), itemCount);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemRangeRemoved</span><span class="hljs-params">(<span class="hljs-keyword">int</span> positionStart, <span class="hljs-keyword">int</span> itemCount)</span> </span>&#123;<br>            mObserver.onItemRangeRemoved(positionStart + mHeaders.size(), itemCount);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemRangeMoved</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fromPosition, <span class="hljs-keyword">int</span> toPosition, <span class="hljs-keyword">int</span> itemCount)</span> </span>&#123;<br>            mObserver.onItemRangeMoved(fromPosition + mHeaders.size(), toPosition + mHeaders.size(), itemCount);<br>        &#125;<br><br><br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>每个继承于PagedListAdapter的RecyclerViewAdatpter，都必须在构造方法里面复写下图中的某个方法。<br><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201220172145.png" alt="PagedListAdapter"></p><ul><li>PagedListAdapter(@NonNull DiffUtil.ItemCallback<T> diffCallback)：这个是给新旧数据集做拆分页，做比对的时候，需要使用的一个回调</li><li>PagedListAdapter(@NonNull AsyncDifferConfig<T> config)：做拆分页时的一个配置。AsyncDifferConfig的设置如下表：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">private final Executor mMainThreadExecutor;</td><td style="text-align:left">主线程线程池</td></tr><tr><td style="text-align:left">private final Executor mBackgroundThreadExecutor;</td><td style="text-align:left">子线程线程池</td></tr><tr><td style="text-align:left">private final DiffUtil.ItemCallback<T> mDiffCallback;</td><td style="text-align:left">做拆分页的回调</td></tr></tbody></table></div><h4 id="FeedAdapter-class"><a href="#FeedAdapter-class" class="headerlink" title="FeedAdapter.class"></a>FeedAdapter.class</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//import ...</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeedAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbsPagedListAdapter</span>&lt;<span class="hljs-title">Feed</span>, <span class="hljs-title">FeedAdapter</span>.<span class="hljs-title">ViewHolder</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LayoutInflater inflater;<br>    <span class="hljs-keyword">protected</span> Context mContext;<br>    <span class="hljs-keyword">protected</span> String mCategory;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FeedAdapter</span><span class="hljs-params">(Context context, String category)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> DiffUtil.ItemCallback&lt;Feed&gt;() &#123;<br>            <span class="hljs-comment">//判断两个Item是否相等</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">areItemsTheSame</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Feed oldItem, <span class="hljs-meta">@NonNull</span> Feed newItem)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> oldItem.id == newItem.id;<br>            &#125;<br>            <span class="hljs-comment">//比较两个Item里面的内容是否相同</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">areContentsTheSame</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Feed oldItem, <span class="hljs-meta">@NonNull</span> Feed newItem)</span> </span>&#123;<br>                <span class="hljs-comment">//Feed中的equals方法被复写</span><br>                <span class="hljs-keyword">return</span> oldItem.equals(newItem);<br>            &#125;<br>        &#125;);<br><br>        inflater = LayoutInflater.from(context);<br>        mContext = context;<br>        mCategory = category;<br>    &#125;<br><br>    <span class="hljs-comment">//返回Feed是图片类型还是视频类型</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemViewType2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        Feed feed = getItem(position);<br>        <span class="hljs-keyword">if</span> (feed.itemType == Feed.TYPE_IMAGE_TEXT) &#123;<br>            <span class="hljs-keyword">return</span> R.layout.layout_feed_type_image;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (feed.itemType == Feed.TYPE_VIDEO) &#123;<br>            <span class="hljs-keyword">return</span> R.layout.layout_feed_type_video;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> ViewHolder <span class="hljs-title">onCreateViewHolder2</span><span class="hljs-params">(ViewGroup parent, <span class="hljs-keyword">int</span> viewType)</span> </span>&#123;<br>        ViewDataBinding binding = DataBindingUtil.inflate(inflater, viewType, parent, <span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ViewHolder(binding.getRoot(), binding);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder2</span><span class="hljs-params">(ViewHolder holder, <span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Feed feed = getItem(position);<br><br>        holder.bindData(feed);<br><br>        holder.itemView.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>                FeedDetailActivity.startFeedDetailActivity(mContext, feed, mCategory);<br>                onStartFeedDetailActivity(feed);<br>                <span class="hljs-keyword">if</span> (mFeedObserver == <span class="hljs-keyword">null</span>) &#123;<br>                    mFeedObserver = <span class="hljs-keyword">new</span> FeedObserver();<br>                    LiveDataBus.get()<br>                            .with(InteractionPresenter.DATA_FROM_INTERACTION)<br>                            .observe((LifecycleOwner) mContext, mFeedObserver);<br>                &#125;<br>                mFeedObserver.setFeed(feed);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartFeedDetailActivity</span><span class="hljs-params">(Feed feed)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> FeedObserver mFeedObserver;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeedObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span>&lt;<span class="hljs-title">Feed</span>&gt; </span>&#123;<br><br>        <span class="hljs-keyword">private</span> Feed mFeed;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onChanged</span><span class="hljs-params">(Feed newOne)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (mFeed.id != newOne.id)<br>                <span class="hljs-keyword">return</span>;<br>            mFeed.author = newOne.author;<br>            mFeed.ugc = newOne.ugc;<br>            mFeed.notifyChange();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFeed</span><span class="hljs-params">(Feed feed)</span> </span>&#123;<br><br>            mFeed = feed;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewHolder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ViewHolder</span> </span>&#123;<br><br>        <span class="hljs-keyword">public</span> ViewDataBinding mBinding;<br>        <span class="hljs-keyword">public</span> ListPlayerView listPlayerView;<br>        <span class="hljs-keyword">public</span> ImageView feedImage;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View itemView, ViewDataBinding binding)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(itemView);<br>            mBinding = binding;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bindData</span><span class="hljs-params">(Feed item)</span> </span>&#123;<br>            <span class="hljs-comment">//这里之所以手动绑定数据的原因是 图片 和视频区域都是需要计算的</span><br>            <span class="hljs-comment">//而dataBinding的执行默认是延迟一帧的。</span><br>            <span class="hljs-comment">//当列表上下滑动的时候 ，会明显的看到宽高尺寸不对称的问题</span><br><br>            mBinding.setVariable(com.mooc.ppjoke.BR.feed, item);<br>            mBinding.setVariable(BR.lifeCycleOwner, mContext);<br>            <span class="hljs-keyword">if</span> (mBinding <span class="hljs-keyword">instanceof</span> LayoutFeedTypeImageBinding) &#123;<span class="hljs-comment">//图片类型</span><br>                LayoutFeedTypeImageBinding imageBinding = (LayoutFeedTypeImageBinding) mBinding;<br>                feedImage = imageBinding.feedImage;<br>                imageBinding.feedImage.bindData(item.width, item.height, <span class="hljs-number">16</span>, item.cover);<br>                <span class="hljs-comment">//imageBinding.setFeed(item);</span><br>                <span class="hljs-comment">//imageBinding.interactionBinding.setLifeCycleOwner((LifecycleOwner) mContext);</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mBinding <span class="hljs-keyword">instanceof</span> LayoutFeedTypeVideoBinding) &#123;<span class="hljs-comment">//视频类型</span><br>                LayoutFeedTypeVideoBinding videoBinding = (LayoutFeedTypeVideoBinding) mBinding;<br>                videoBinding.listPlayerView.bindData(mCategory, item.width, item.height, item.cover, item.url);<br>                listPlayerView = videoBinding.listPlayerView;<br>                <span class="hljs-comment">//videoBinding.setFeed(item);</span><br>                <span class="hljs-comment">//videoBinding.interactionBinding.setLifeCycleOwner((LifecycleOwner) mContext);</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isVideoItem</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> mBinding <span class="hljs-keyword">instanceof</span> LayoutFeedTypeVideoBinding;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> ListPlayerView <span class="hljs-title">getListPlayerView</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> listPlayerView;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br></code></pre></div></td></tr></table></figure><h3 id="5-编写下拉刷新的通用配置"><a href="#5-编写下拉刷新的通用配置" class="headerlink" title="5.编写下拉刷新的通用配置"></a>5.编写下拉刷新的通用配置</h3><h4 id="AbsViewModel-class"><a href="#AbsViewModel-class" class="headerlink" title="AbsViewModel.class"></a>AbsViewModel.class</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//import ...</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbsViewModel</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewModel</span> </span>&#123;<br><br><br>    <span class="hljs-keyword">protected</span> PagedList.Config config;<br>    <span class="hljs-keyword">private</span> DataSource dataSource;<br>    <span class="hljs-keyword">private</span> LiveData&lt;PagedList&lt;T&gt;&gt; pageData;<br><br>    <span class="hljs-keyword">private</span> MutableLiveData&lt;Boolean&gt; boundaryPageData = <span class="hljs-keyword">new</span> MutableLiveData&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbsViewModel</span><span class="hljs-params">()</span> </span>&#123;<br><br>        config = <span class="hljs-keyword">new</span> PagedList.Config.Builder()<br>                .setPageSize(<span class="hljs-number">10</span>)<span class="hljs-comment">//每次分页加载的数量</span><br>                .setInitialLoadSizeHint(<span class="hljs-number">12</span>)<span class="hljs-comment">//初始化加载时的数量</span><br>                <span class="hljs-comment">// .setMaxSize(100)；</span><br>                <span class="hljs-comment">// .setEnablePlaceholders(false)//设置数据未满的占位符</span><br>                <span class="hljs-comment">// .setPrefetchDistance()//设置根据距离屏幕底部几个item时，加载下一页</span><br>                .build();<br><br>        pageData = <span class="hljs-keyword">new</span> LivePagedListBuilder(factory, config)<br>                .setInitialLoadKey(<span class="hljs-number">0</span>)<span class="hljs-comment">//加载初始化区域的时候，需要传递的参数。如果是多个参数，需要组装成javabean对象</span><br>                <span class="hljs-comment">//.setFetchExecutor()</span><br>                .setBoundaryCallback(callback)<span class="hljs-comment">//监听Pagedlist数据加载的状态</span><br>                .build();<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> LiveData&lt;PagedList&lt;T&gt;&gt; getPageData() &#123;<br>        <span class="hljs-keyword">return</span> pageData;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">getDataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LiveData&lt;Boolean&gt; <span class="hljs-title">getBoundaryPageData</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> boundaryPageData;<br>    &#125;<br><br>    <span class="hljs-comment">//PagedList数据被加载情况的边界回调callback</span><br>    <span class="hljs-comment">//但 不是每一次分页 都会回调这里，具体请看 ContiguousPagedList#mReceiver#onPageResult</span><br>    <span class="hljs-comment">//deferBoundaryCallbacks</span><br>    PagedList.BoundaryCallback&lt;T&gt; callback = <span class="hljs-keyword">new</span> PagedList.BoundaryCallback&lt;T&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onZeroItemsLoaded</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">//新提交的PagedList中没有数据</span><br>            boundaryPageData.postValue(<span class="hljs-keyword">false</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemAtFrontLoaded</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> T itemAtFront)</span> </span>&#123;<br>            <span class="hljs-comment">//新提交的PagedList中第一条数据被加载到列表上</span><br>            boundaryPageData.postValue(<span class="hljs-keyword">true</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemAtEndLoaded</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> T itemAtEnd)</span> </span>&#123;<br>            <span class="hljs-comment">//新提交的PagedList中最后一条数据被加载到列表上</span><br>        &#125;<br>    &#125;;<br><br>    DataSource.Factory factory = <span class="hljs-keyword">new</span> DataSource.Factory() &#123;<br>        <span class="hljs-meta">@NonNull</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">//如果dataSource为空或者无效</span><br>            <span class="hljs-keyword">if</span> (dataSource == <span class="hljs-keyword">null</span> || dataSource.isInvalid()) &#123;<br>                dataSource = createDataSource();<br>            &#125;<br>            <span class="hljs-keyword">return</span> dataSource;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">//该方法推迟到子类实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> DataSource <span class="hljs-title">createDataSource</span><span class="hljs-params">()</span></span>;<br><br><br>    <span class="hljs-comment">//可以在这个方法里 做一些清理 的工作</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCleared</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br><br><br></code></pre></div></td></tr></table></figure><h4 id="AbsViewModel的实现类HomeViewModel-class"><a href="#AbsViewModel的实现类HomeViewModel-class" class="headerlink" title="AbsViewModel的实现类HomeViewModel.class"></a>AbsViewModel的实现类HomeViewModel.class</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//import ...</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeViewModel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbsViewModel</span>&lt;<span class="hljs-title">Feed</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> witchCache = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">private</span> MutableLiveData&lt;PagedList&lt;Feed&gt;&gt; cacheLiveData = <span class="hljs-keyword">new</span> MutableLiveData&lt;&gt;();<br>    <span class="hljs-keyword">private</span> AtomicBoolean loadAfter = <span class="hljs-keyword">new</span> AtomicBoolean(<span class="hljs-keyword">false</span>);<br>    <span class="hljs-keyword">private</span> String mFeedType;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">createDataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FeedDataSource();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> MutableLiveData&lt;PagedList&lt;Feed&gt;&gt; getCacheLiveData() &#123;<br>        <span class="hljs-keyword">return</span> cacheLiveData;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFeedType</span><span class="hljs-params">(String feedType)</span> </span>&#123;<br><br>        mFeedType = feedType;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeedDataSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ItemKeyedDataSource</span>&lt;<span class="hljs-title">Integer</span>, <span class="hljs-title">Feed</span>&gt; </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadInitial</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LoadInitialParams&lt;Integer&gt; params, <span class="hljs-meta">@NonNull</span> LoadInitialCallback&lt;Feed&gt; callback)</span> </span>&#123;<br>            <span class="hljs-comment">//加载初始化数据的</span><br>            Log.e(<span class="hljs-string">&quot;homeviewmodel&quot;</span>, <span class="hljs-string">&quot;loadInitial: &quot;</span>);<br>            <span class="hljs-comment">//先加载缓存</span><br>            loadData(<span class="hljs-number">0</span>, params.requestedLoadSize, callback);<br>            witchCache = <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadAfter</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LoadParams&lt;Integer&gt; params, <span class="hljs-meta">@NonNull</span> LoadCallback&lt;Feed&gt; callback)</span> </span>&#123;<br>            <span class="hljs-comment">//向后加载分页数据的</span><br>            Log.e(<span class="hljs-string">&quot;homeviewmodel&quot;</span>, <span class="hljs-string">&quot;loadAfter: &quot;</span>);<br>            loadData(params.key, params.requestedLoadSize, callback);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBefore</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LoadParams&lt;Integer&gt; params, <span class="hljs-meta">@NonNull</span> LoadCallback&lt;Feed&gt; callback)</span> </span>&#123;<br>            callback.onResult(Collections.emptyList());<br>            <span class="hljs-comment">//能够向前加载数据的</span><br>            <span class="hljs-comment">//比如进入首页时在第三页，但是想往前加载第一第二页</span><br>        &#125;<br><br><br>        <span class="hljs-comment">//通过最后一条Item的信息，来返回id</span><br>        <span class="hljs-meta">@NonNull</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getKey</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Feed item)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> item.id;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> count, ItemKeyedDataSource.LoadCallback&lt;Feed&gt; callback)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (key &gt; <span class="hljs-number">0</span>) &#123;<br>            loadAfter.set(<span class="hljs-keyword">true</span>);<br>        &#125;<br>        <span class="hljs-comment">//feeds/queryHotFeedsList</span><br>        Request request = ApiService.get(<span class="hljs-string">&quot;/feeds/queryHotFeedsList&quot;</span>)<br>                .addParam(<span class="hljs-string">&quot;feedType&quot;</span>, mFeedType)<br>                .addParam(<span class="hljs-string">&quot;userId&quot;</span>, UserManager.get().getUserId())<br>                .addParam(<span class="hljs-string">&quot;feedId&quot;</span>, key)<br>                .addParam(<span class="hljs-string">&quot;pageCount&quot;</span>, count)<br>                .responseType(<span class="hljs-keyword">new</span> TypeReference&lt;ArrayList&lt;Feed&gt;&gt;() &#123;<br>                &#125;.getType());<br><br>        <span class="hljs-keyword">if</span> (witchCache) &#123;<br>            request.cacheStrategy(Request.CACHE_ONLY);<br>            request.execute(<span class="hljs-keyword">new</span> JsonCallback&lt;List&lt;Feed&gt;&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCacheSuccess</span><span class="hljs-params">(ApiResponse&lt;List&lt;Feed&gt;&gt; response)</span> </span>&#123;<br>                    Log.e(<span class="hljs-string">&quot;loadData&quot;</span>, <span class="hljs-string">&quot;onCacheSuccess: &quot;</span>);<br>                    MutablePageKeyedDataSource dataSource = <span class="hljs-keyword">new</span> MutablePageKeyedDataSource&lt;Feed&gt;();<br>                    dataSource.data.addAll(response.body);<br><br>                    PagedList pagedList = dataSource.buildNewPagedList(config);<br>                    cacheLiveData.postValue(pagedList);<br><br>                    <span class="hljs-comment">//下面的不可取，否则会报</span><br>                    <span class="hljs-comment">// java.lang.IllegalStateException: callback.onResult already called, cannot call again.</span><br>                    <span class="hljs-comment">//if (response.body != null) &#123;</span><br>                    <span class="hljs-comment">//  callback.onResult(response.body);</span><br>                    <span class="hljs-comment">// &#125;</span><br>                &#125;<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Request netRequest = witchCache ? request.clone() : request;<br>            netRequest.cacheStrategy(key == <span class="hljs-number">0</span> ? Request.NET_CACHE : Request.NET_ONLY);<br>            ApiResponse&lt;List&lt;Feed&gt;&gt; response = netRequest.execute();<br>            List&lt;Feed&gt; data = response.body == <span class="hljs-keyword">null</span> ? Collections.emptyList() : response.body;<br><br>            callback.onResult(data);<br><br>            <span class="hljs-keyword">if</span> (key &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">//通过BoundaryPageData发送数据 告诉UI层 是否应该主动关闭上拉加载分页的动画</span><br>                ((MutableLiveData) getBoundaryPageData()).postValue(data.size() &gt; <span class="hljs-number">0</span>);<br>                loadAfter.set(<span class="hljs-keyword">false</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        Log.e(<span class="hljs-string">&quot;loadData&quot;</span>, <span class="hljs-string">&quot;loadData: key:&quot;</span> + key);<br><br>    &#125;<br><br>    <span class="hljs-meta">@SuppressLint(&quot;RestrictedApi&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadAfter</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, ItemKeyedDataSource.LoadCallback&lt;Feed&gt; callback)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (loadAfter.get()) &#123;<br>            callback.onResult(Collections.emptyList());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ArchTaskExecutor.getIOThreadExecutor().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                loadData(id, config.pageSize, callback);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p><a href="https://blog.csdn.net/zsp_android_com/article/details/86235067">刷新加载（SmartRefreshLayout）</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RecyclerView</tag>
      
      <tag>SmartRefreshLayout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>点赞实现</title>
    <link href="/2020/12/19/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E7%82%B9%E8%B5%9E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/12/19/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E7%82%B9%E8%B5%9E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>利用dataBinding实现点赞颜色更改和点赞图片更改</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">variable</span></span><br><span class="hljs-tag">        <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;comment&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.mooc.ppjoke.model.Comment&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.mooc.ppjoke.ui.InteractionPresenter&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;android.text.TextUtils&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;android.view.View&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.mooc.ppjoke.utils.StringConvert&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center_vertical&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@&#123;comment.ugc.likeCount&gt;0?StringConvert.convertFeedUgc(comment.ugc.likeCount):null&#125;&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@&#123;comment.ugc.hasLiked?@color/color_theme:@color/color_3d3&#125;&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;@dimen/sp_12&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:text</span>=<span class="hljs-string">&quot;1000&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TextView</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_marginLeft</span>=<span class="hljs-string">&quot;@dimen/dp_2&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:onClick</span>=<span class="hljs-string">&quot;@&#123;()-&gt;InteractionPresenter.toggleCommentLike(lifeCycleOwner,comment)&#125;&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@&#123;comment.ugc.hasLiked?@drawable/icon_cell_liked:@drawable/icon_cell_like&#125;&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:src</span>=<span class="hljs-string">&quot;@drawable/icon_cell_liked&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">ImageView</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dataBinding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标签实现</title>
    <link href="/2020/12/17/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E6%A0%87%E7%AD%BE%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/12/17/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E6%A0%87%E7%AD%BE%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="MaterialButton"><a href="#MaterialButton" class="headerlink" title="MaterialButton"></a>MaterialButton</h2><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201217213919.png" alt="MaterialButton效果图"></p><ol><li>修改xml文档</li></ol><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.button.MaterialButton</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;20dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@color/color_2f2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;@dimen/sp_10&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:backgroundTint</span>=<span class="hljs-string">&quot;@color/color_gray&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:icon</span>=<span class="hljs-string">&quot;@drawable/icon_tag&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:cornerRadius</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:iconGravity</span>=<span class="hljs-string">&quot;textStart&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:iconPadding</span>=<span class="hljs-string">&quot;@dimen/dp_4&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:iconSize</span>=<span class="hljs-string">&quot;@dimen/dp_12&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:iconTintMode</span>=<span class="hljs-string">&quot;multiply&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:text</span>=<span class="hljs-string">&quot;神秘皮皮虾&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">com.google.android.material.button.MaterialButton</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><ol><li>修改style.xml文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;AppTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.MaterialComponents.Light.NoActionBar&quot;</span>&gt;</span><span class="xml"></span><br><span class="xml">        <span class="hljs-comment">&lt;!-- Customize your theme here. --&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimary&quot;</span>&gt;</span>@color/colorPrimary<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimaryDark&quot;</span>&gt;</span>@color/colorPrimaryDark<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorAccent&quot;</span>&gt;</span>@color/colorAccent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;materialButtonStyle&quot;</span>&gt;</span>@style/materialButton<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;materialButton&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Widget.MaterialComponents.Button&quot;</span>&gt;</span><span class="xml"></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:paddingLeft&quot;</span>&gt;</span>8dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:paddingRight&quot;</span>&gt;</span>8dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:paddingTop&quot;</span>&gt;</span>4dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:paddingBottom&quot;</span>&gt;</span>4dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:inset&quot;</span>&gt;</span>0dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:insetLeft&quot;</span>&gt;</span>0dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:insetRight&quot;</span>&gt;</span>0dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:insetBottom&quot;</span>&gt;</span>0dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:insetTop&quot;</span>&gt;</span>0dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:minWidth&quot;</span>&gt;</span>0dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:minHeight&quot;</span>&gt;</span>0dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:elevation&quot;</span>&gt;</span>0dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MaterialButton</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataSource</title>
    <link href="/2020/12/17/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/DataSource/"/>
    <url>/2020/12/17/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/DataSource/</url>
    
    <content type="html"><![CDATA[<ul><li><p>DataSource<Key,Value>数据源：</p><ol><li>Key对应加载数据的条件信息</li><li>Value对应数据实体类</li></ol></li><li><p>内置三种对象<br>  |对象|描述|场景<br>  |:——————————————-|:—————————————————|:—————————————————|<br>  |PageKeyedDataSource<Key,Value>|适用于目标数据根据页信息请求数据的场景|初始化的时候加载第一页信息，上拉加载第二页…根据页码来请求数据|<br>  |ItemKeyedDataSource<Key,Value>|适用于目标数据的加载依赖特定item的信息|当页面滑动到最底下的时候，根据最后一个item的信息，来请求下一页的数据|<br>  |PositionalDataSource<T>|适用于目标数据总数固定，通过特定的位置加载数据|规定有一百条数据，指定要这些数据中的哪条数据|</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DataSource</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小型内存分配器</title>
    <link href="/2020/12/13/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%B0%8F%E5%9E%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/"/>
    <url>/2020/12/13/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%B0%8F%E5%9E%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>起因：</p><ul><li>提升速度</li><li>降低浪费率（cookie），或者说减少cookie的用量</li></ul><h2 id="per-class-allocator-1"><a href="#per-class-allocator-1" class="headerlink" title="per-class allocator 1"></a>per-class allocator 1</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Screen</span>(<span class="hljs-keyword">int</span> x):<span class="hljs-built_in">i</span>(x)&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> i;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">size_t</span>)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    Screen* next;<span class="hljs-comment">//用来指向申请的内存池</span><br>    <span class="hljs-keyword">static</span> Screen* freeStore;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> screenChunk;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> i;<span class="hljs-comment">//该类数据</span><br>&#125;;<br><br>Screen* Screen::freeStore = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Screen::screenChunk = <span class="hljs-number">24</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* Screen::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    Screen* p;<br>    <span class="hljs-keyword">if</span>(!freeStore)<br>    &#123;<br>        <span class="hljs-keyword">size_t</span> chunk = screenChunk * size;<span class="hljs-comment">//申请内存的大小</span><br>        freeStore = p = <span class="hljs-keyword">reinterpret_cast</span>&lt;Screen*&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[chunk]);<br>        <span class="hljs-comment">//将一大块分割片片，当作linked list串接起来</span><br>        <span class="hljs-keyword">for</span>(;p!=&amp;freeStore[screenChunk<span class="hljs-number">-1</span>];++p)<br>            p-&gt;next = p+<span class="hljs-number">1</span>;<br>        p-&gt;next = <span class="hljs-number">0</span>;<br>    &#125;<br>    p = freeStore;<br>    freeStore = freeStore-&gt;next;<span class="hljs-comment">//指向链表首位</span><br>    <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//把链表传回去</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> Screen::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *p, <span class="hljs-keyword">size_t</span>)</span></span><br><span class="hljs-function"></span>&#123;        <span class="hljs-comment">//将指针回收到单向链表之中，放回前端</span><br>    (<span class="hljs-keyword">static_cast</span>&lt;Screen*&gt;(p))-&gt;next = freeStore;<br>    freeStore = <span class="hljs-keyword">static_cast</span>&lt;Screen*&gt;(p);    <br>&#125; <br></code></pre></div></td></tr></table></figure><ul><li>这种设计虽然降低了cookie的数量，但是会引发多耗用一个next的问题，即多了个指针的大小。</li><li><code>operator delete</code>并不算是释放，而是将p归还到链表中，可以让下一个创建者继续使用，而原先p指向的那个区域的旧东西将被新创建者覆盖。</li></ul><h2 id="per-class-allocator-2"><a href="#per-class-allocator-2" class="headerlink" title="per-class allocator 2"></a>per-class allocator 2</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Airplane</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AirplaneRep</span> &#123;</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> miles;<br><span class="hljs-keyword">char</span> type;<br>&#125;;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>AirplaneRep rep;<span class="hljs-comment">//此指针指向使用中的对象</span><br>Airplane* next;<span class="hljs-comment">//此指针指向free list上的对象</span><br>&#125;;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getMiles</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> rep.miles;&#125;<br><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> rep.type;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> m, <span class="hljs-keyword">char</span> t)</span> </span>&#123;<br>rep.miles = m;<br>rep.type = t;<br>&#125;<br><span class="hljs-comment">//重载new和delete</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* deadObject, <span class="hljs-keyword">size_t</span> size)</span></span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> BLOCK_SIZE;<br><span class="hljs-keyword">static</span> Airplane* headOfFreeList;<br>&#125;;<br>Airplane* Airplane::headOfFreeList;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Airplane::BLOCK_SIZE = <span class="hljs-number">512</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* Airplane::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//在继承发生时可能size大小有误</span><br><span class="hljs-keyword">if</span>(size != <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Airplane))<br><span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in"><span class="hljs-keyword">new</span></span>(size);<br>Airplane* p = headOfFreeList;<br><span class="hljs-keyword">if</span>(p)<span class="hljs-comment">//如果p有效就把链表头部向下移</span><br>headOfFreeList = p-&gt;next;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//如果链表已空，申请一大块内存</span><br>Airplane* newBlock = <span class="hljs-keyword">static_cast</span>&lt;Airplane*&gt;<br>            (::<span class="hljs-keyword">operator</span> <span class="hljs-built_in"><span class="hljs-keyword">new</span></span>(BLOCK_SIZE * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Airplane)));<br><br><span class="hljs-comment">//将小块穿成一个freelist</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; BLOCK_SIZE - <span class="hljs-number">1</span>; ++i)<br>newBlock[i].next = &amp;newBlock[i+<span class="hljs-number">1</span>];<br>newBlock[BLOCK_SIZE - <span class="hljs-number">1</span>].next = <span class="hljs-number">0</span>;<br>p = newBlock;<br>headOfFreeList = &amp;newBlock[<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//operator delete截获一个内存块</span><br><span class="hljs-comment">//如果大小正确，就把它加到freelist前端</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> Airplane::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* deadObject, <span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(deadObject == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(size != <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Airplane)) &#123;<br>::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(deadObject)</span></span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>Airplane* carcass = <span class="hljs-keyword">static_cast</span>&lt;Airplane*&gt;(deadObject);<br>carcass-&gt;next = headOfFreeList;<br>headOfFreeList = carcass;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>这种设计很巧妙的运用了联合体。当该内存块在单元中未使用，就让<code>next</code>指针指向下一个未分配的内存块，当这个块被实例化后，next所占用的4个字节就是真正的数据了。若该内存块被创建者使用，创建者就可以使用<code>AirplaneRep</code>的数据覆盖掉<code>next</code>指针。这样做相比<strong>per-class allocator 1</strong>的方法少了额外放成员变量的空间，也就是说将指针和数据合二为一了，根据使用场景不同使用不同的变量。</li><li><code>operator new</code>中<code>for(int i = 1; i &lt; BLOCK_SIZE - 1; ++i)&#123;...&#125;</code>的迭代值<code>i</code>是从<strong>1</strong>开始的，原因是只有当内存中没有这个链表内存空间才会走到当前for循环，也就是说<strong>第一次</strong>有创建者需要一个<code>Airplane</code>。所以直接返回一个第一个对象的空间就可以了，并不需要将该对象的<code>next</code>指向下一个链表内存块，因为对于使用者来说，<code>next</code>指针对他没用处。</li><li>而至于<code>operator delete</code>中为什么要多创建一个<code>Airplane* carcass</code>的原因，有点摸不着头脑。感觉只能这么解释：因为传进来的<code>deadObject</code>使用的是联合体中的<code>AirplaneRep</code>，而<code>AirplaneRep</code>中并没有<code>next</code>指针，所以不能用<code>deadObject</code>去获得<code>next</code>指针，只能通过创建一个新的指针<code>carcass</code>通过显式转换指向<code>deadObject</code>，然后根据这个<code>carcass</code>去修改<code>next</code>的值。</li></ul><h2 id="static-allocator-3"><a href="#static-allocator-3" class="headerlink" title="static allocator 3"></a>static allocator 3</h2><p>之前的两个版本<strong>per-class allocator 1</strong>和<strong>per-class allocator 2</strong>都是在类里重载<code>new</code>和<code>delete</code>，实际上都是完成同样的任务，所以可以将这部分的内存分配抽出来成为一个<code>allocator</code>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">allocator</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">obj</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">obj</span>* <span class="hljs-title">next</span>;</span><br>&#125;;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*,<span class="hljs-keyword">size_t</span>)</span></span>;<br><span class="hljs-keyword">private</span>:<br>obj* freeStore = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> CHUNK = <span class="hljs-number">5</span>;<span class="hljs-comment">//这里小一些以便观察</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">allocator::deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p,<span class="hljs-keyword">size_t</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//将*p收回插入free list 前端</span><br>((obj*)p)-&gt;next = freeStore;<br>freeStore = (obj*)p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">allocator::allocate</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>obj* p;<br><span class="hljs-keyword">if</span>(!freeStore) &#123;<br><span class="hljs-comment">//linked list为空，于是申请一大块</span><br><span class="hljs-keyword">size_t</span> chunk = CHUNK * size;<br>freeStore = p = (obj*)<span class="hljs-built_in">malloc</span>(chunk);<br><br><span class="hljs-comment">//将分配得来的一大块当作linked list</span><br><span class="hljs-comment">//串接起来</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (CHUNK - <span class="hljs-number">1</span>); ++i) &#123;<br>p-&gt;next = (obj*)((<span class="hljs-keyword">char</span>*)p + size);<br>p = p-&gt;next;<br>&#125;<br>p-&gt;next = <span class="hljs-literal">nullptr</span>;<br>&#125;<br>p = freeStore;<br>freeStore = freeStore-&gt;next;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">long</span> L;<br>string str;<br><span class="hljs-keyword">static</span> allocator myAlloc;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Foo</span>(<span class="hljs-keyword">long</span> l):<span class="hljs-built_in">L</span>(<span class="hljs-number">1</span>)&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> </span>&#123;<br><span class="hljs-keyword">return</span> myAlloc.<span class="hljs-built_in">allocate</span>(size);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* pdead,<span class="hljs-keyword">size_t</span> size)</span> </span>&#123;<br><span class="hljs-keyword">return</span> myAlloc.<span class="hljs-built_in">deallocate</span>(pdead,size);<br>&#125;<br>&#125;;<br>allocator Foo::myAlloc;<br></code></pre></div></td></tr></table></figure><ul><li><p>这个版本由于allocator的提取，所以增加了代码的复用性。</p></li><li><p>因为<code>const int CHUNK = 5</code>，所以在内存里面分配的容量会比较小，便于管理。例如创建了<strong>23</strong>个<code>Foo</code>，在下图中可以看到地址是不连续的：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/0cdb64f500e17561171414bbe163980f-ed140.png" style="zoom: 50%;" /></p></li><li><p>因为在<code>Foo</code>中的<code>allocator</code>为<code>static</code>类型，所以<code>Foo</code>独自拥有一个静态的<code>allocator</code>变量。推而广之，可以针对不同的类维护<code>allocator</code>里的<code>freeStore</code>和<code>next</code>，即每个类都有单独的区域，不互相影响。</p></li></ul><h3 id="macro-for-static-allocator"><a href="#macro-for-static-allocator" class="headerlink" title="macro for static allocator"></a>macro for static allocator</h3><p>由偷懒而引发的小技巧：<strong>static allocator</strong>中的<code>allocator</code>可以进一步写成以下形式，然后在类里的使用会非常方便。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECLARE_POOL_ALLOC() \</span><br><span class="hljs-meta">public: \</span><br><span class="hljs-meta">    void* operator new(size_t size) &#123; return myAlloc.allocate(size); &#125; \</span><br><span class="hljs-meta">    void operator delete(void* p) &#123; myAlloc.deallocate(p, 0); &#125; \</span><br><span class="hljs-meta">protected: \</span><br><span class="hljs-meta">    static allocator myAlloc; </span><br><br><span class="hljs-comment">// IMPLEMENT_POOL_ALLOC -- used in class implementation file</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMPLEMENT_POOL_ALLOC(class_name) \</span><br><span class="hljs-meta">allocator class_name::myAlloc; </span><br><br><br><span class="hljs-comment">// in class definition file</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span><br>   <span class="hljs-built_in">DECLARE_POOL_ALLOC</span>()<br><span class="hljs-keyword">public</span>: <br><span class="hljs-keyword">long</span> L;<br>string str;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Foo</span>(<span class="hljs-keyword">long</span> l) : <span class="hljs-built_in">L</span>(l) &#123;  &#125;   <br>&#125;;<br><span class="hljs-comment">//in class implementation file</span><br><span class="hljs-built_in">IMPLEMENT_POOL_ALLOC</span>(Foo) <br></code></pre></div></td></tr></table></figure><h2 id="new-handler"><a href="#new-handler" class="headerlink" title="new handler"></a>new handler</h2><p>当<code>operator new</code>没有能力分配我们所申请的内存，会抛出一个<code>std::bad_alloc</code> exception。某些老旧编译器则是返回0，但是我们依然可以让我们的编译器返回0，做法是：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">new</span>(nothrow) Foo;<span class="hljs-comment">//此称为nothrow形式</span><br></code></pre></div></td></tr></table></figure><p>当我们不按照上面的写法，而是想让我们的内存分配失败时执行我们想要的行为可以吗？可以，C++提供了一个机制<strong>new handler</strong>，我们首先需实现一个形为如下的函数：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*new_handler)</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(new_handler p)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br></code></pre></div></td></tr></table></figure><p>使用方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;new&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cassert&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//我们写的new_handler函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">noMoreMemory</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//在此写上我们希望的行为</span><br>cerr &lt;&lt; <span class="hljs-string">&quot;out of memory&quot;</span>;<br><span class="hljs-built_in">abort</span>();<span class="hljs-comment">//此处若没有这条，那么内存分配失败将一直输出&quot;out of memory&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//设置new_handler</span><br><span class="hljs-built_in">set_new_handler</span>(noMoreMemory);<br><br><span class="hljs-keyword">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100000000000000000</span>];<br><span class="hljs-built_in">assert</span>(p);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意：<strong>new handler</strong>的设计只有两种选择</p><ul><li>让更多的内存可用</li><li>调用<code>abort()</code>或<code>exit()</code></li></ul><p><strong>operator new源码：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7142b5769c270e56124913e1a424b890-1c387.png" style="zoom:50%;" /></p><p><strong>new handler源码：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/c93305fadc36ed14255c47a1efdb058a-8b3c7.png" style="zoom: 67%;" /></p><h2 id="delete-和-default"><a href="#delete-和-default" class="headerlink" title="= delete 和 = default"></a>= delete 和 = default</h2><p><code>= default</code>的作用是：该函数使用默认版本。比如使用默认的构造、拷贝构造等。</p><p><code>= delete</code>的作用是：让该函数无效。</p><p>参考：<a href="https://blog.csdn.net/qq_41453285/article/details/100606913">C++:73—-C++11标准（类的删除函数：=delete关键字、阻止构造、阻止拷贝、private阻止拷贝控制）</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dataBinding</title>
    <link href="/2020/12/09/Android/Jetpack/dataBinding/"/>
    <url>/2020/12/09/Android/Jetpack/dataBinding/</url>
    
    <content type="html"><![CDATA[<h2 id="1-在build-gradle文件中配置"><a href="#1-在build-gradle文件中配置" class="headerlink" title="1.在build.gradle文件中配置"></a>1.在build.gradle文件中配置</h2><p>配置dataBinging无需引用任何的依赖，只需要在build.gradle中配置即可</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">android &#123;<br>    <br>    <span class="hljs-comment">//....</span><br><br>    dataBinding&#123;<br>        enabled=<span class="hljs-keyword">true</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-修改xml布局文件"><a href="#2-修改xml布局文件" class="headerlink" title="2.修改xml布局文件"></a>2.修改xml布局文件</h2><ol><li><p>先将原有布局转换成dataBinging布局<br><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201216234512.png" alt="转换布局"></p></li><li><p>修改xml文件</p></li></ol><h3 id="2-1-在TextView里面使用"><a href="#2-1-在TextView里面使用" class="headerlink" title="2.1 在TextView里面使用"></a>2.1 在TextView里面使用</h3><h4 id="2-1-1-例一"><a href="#2-1-1-例一" class="headerlink" title="2.1.1 例一"></a>2.1.1 例一</h4><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- a.xml --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">variable</span></span><br><span class="hljs-tag">            <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;User&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.mooc.ppjoke.model.User&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/author_name&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@&#123;user.name&#125;&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">tools:text</span>=<span class="hljs-string">&quot;use_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TextView</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- b.xml --&gt;</span><br>    <span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">variable</span></span><br><span class="hljs-tag">            <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;feed&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Feed&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.mooc.ppjoke.model.Feed&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span></span><br><span class="hljs-tag">        <span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;@layout/layout_feed_author&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:user</span>=<span class="hljs-string">&quot;@&#123;feed.author&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><p>在data标签里声明变量：在import标签里引入变量所在的类，variable标签里的type为变量类型，name为变量的名称。在例一中，b.xml包含了a.xml。a.xml中的user，是由b.xml中include标签里的app:user传入的。<br>注：即使user.name为空也不会报错，因为dataBinding是空安全的</p><h4 id="2-1-2-例二"><a href="#2-1-2-例二" class="headerlink" title="2.1.2 例二"></a>2.1.2 例二</h4><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">variable</span></span><br><span class="hljs-tag">            <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;feedText&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> /&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;android.text.TextUtils&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;android.view.View&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@&#123;feedText&#125;&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:visibility</span>=<span class="hljs-string">&quot;@&#123;TextUtils.isEmpty(feedText)?View.GONE:View.VISIBLE&#125;&quot;</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><p>判断feedText是否为空。若为空，则设置android:visibility属性为不显示；若有值，则设置android:visibility属性为显示。</p><h3 id="2-2-在ImageView里面使用"><a href="#2-2-在ImageView里面使用" class="headerlink" title="2.2 在ImageView里面使用"></a>2.2 在ImageView里面使用</h3><ol><li>写一个继承自AppCompatImageView的类</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PPImageView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatImageView</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-comment">//image_url：图片的url；isCircle：图片是否有圆角</span><br>    <span class="hljs-comment">//requireAll：若为true，表示配置的时候只有把参数全都设置了，才能调用该方法</span><br>    <span class="hljs-comment">//这个方法的第一个参数一定是类自身</span><br>    <span class="hljs-meta">@BindingAdapter(value = &#123;&quot;image_url&quot;, &quot;isCircle&quot;&#125;, requireAll = false)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setImageUrl</span><span class="hljs-params">(PPImageView view, String imageUrl, <span class="hljs-keyword">boolean</span> isCircle, <span class="hljs-keyword">int</span> radius)</span> </span>&#123;<br><br>        RequestBuilder&lt;Drawable&gt; builder = Glide.with(view).load(imageUrl);<br>        <span class="hljs-comment">//是否圆角</span><br>        <span class="hljs-keyword">if</span> (isCircle) &#123;<br>            builder.transform(<span class="hljs-keyword">new</span> CircleCrop());<br>        &#125;<br>        <span class="hljs-comment">//设置图片的尺寸</span><br>        ViewGroup.LayoutParams layoutParams = view.getLayoutParams();<br>        <span class="hljs-keyword">if</span> (layoutParams != <span class="hljs-keyword">null</span> &amp;&amp; layoutParams.width &gt; <span class="hljs-number">0</span> &amp;&amp; layoutParams.height &gt; <span class="hljs-number">0</span>) &#123;<br>            builder.override(layoutParams.width, layoutParams.height);<br>        &#125;<br>        builder.into(view);<br>    &#125;<br></code></pre></div></td></tr></table></figure><ol><li>在xml文件中配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">com.mooc.ppjoke.view.PPImageView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/avatar&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;@dimen/dp_40&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;@dimen/dp_40&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:image_url</span>=<span class="hljs-string">&quot;@&#123;user.avatar&#125;&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:isCircle</span>=<span class="hljs-string">&quot;@&#123;true&#125;&quot;</span></span><br><span class="hljs-tag">            &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com.mooc.ppjoke.view.PPImageView</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>注：<strong>@BindingAdapter</strong>注解中的requireAll参数设置为true时，只有配置了<strong>app:image_url</strong>和<strong>app:isCircle</strong>，才能调用PPImageView中的setImageUrl方法。</p><h2 id="dataBinding特殊性"><a href="#dataBinding特殊性" class="headerlink" title="dataBinding特殊性"></a>dataBinding特殊性</h2><ol><li>强校验</li><li>空安全</li><li>根据经验，dataBinding在布局文件里绑定视频资源的时候，会延迟一帧。扩展：如果需要绑定的数据需要计算宽和高，建议使用原生方法</li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dataBinding</tag>
      
      <tag>Jetpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>malloc与free</title>
    <link href="/2020/12/08/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/malloc%E4%B8%8Efree/"/>
    <url>/2020/12/08/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/malloc%E4%B8%8Efree/</url>
    
    <content type="html"><![CDATA[<h2 id="SBH（VC6）"><a href="#SBH（VC6）" class="headerlink" title="SBH（VC6）"></a>SBH（VC6）</h2><ul><li><p><strong>SBH = Small Block Heap</strong></p></li><li><p><code>HeapAlloc()</code>：windows内存分配函数</p></li></ul><p>在新版本如VC10，已经不做小块的内存管理了，统统将操作丢给<code>HeapAlloc()</code>，因为<code>HeapAlloc()</code>也开始做小块内存管理了。</p><p>下图为C++程序的运行调用栈（VC6）：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/54dc87706cafbf193f1a014a2af24970-5ee36.png" alt="C++程序的运行调用栈"  /></p><p>上图中的常量<code>_sbh_threshold</code>的值为<strong>1016</strong>，和<strong>1024</strong>差了<strong>8</strong>个字节，这8个字节就是内存块上下的<strong>cookie</strong>。当我们需要的内存块加上<strong>cookie</strong>一共超过了<strong>1024</strong>，那么<strong>SBH</strong>将会把内存分配的操作<strong>转交给操作系统处理</strong>。由此可见小区块定义的大小就是1024。</p><p>自下而上，首先进入操作系统内核部分，由操作调用<code>mainCRTStartup()</code>，即CRT的动作。</p><h3 id="heap-init"><a href="#heap-init" class="headerlink" title="_heap_init()"></a>_heap_init()</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6ae13a524af0ecd498241c14b290e7d4-c5fe0.png" alt=" _heap_init()"  /></p><ul><li><code>_heap_init()</code>从操作系统的<strong>CRT Heap</strong>申请空间，来应付CRT的需求，<code>_sbh_pHeaderList</code>指向这个空间。</li><li><code>bitvEntryHi</code>和<code>bitvEntryLo</code>实际上会组合起来，即一共64bit。</li><li><code>_heap_init()</code>做的事实际上就是分配了16个<strong>Header</strong>。</li><li>一个<strong>Header</strong>管理<strong>1MB</strong>。</li></ul><p><strong>Header</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> BITVEC;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagHeader</span></span><br><span class="hljs-class">&#123;</span><br>BITVEC bitvEntryHi;<br>BITVEC bitvEntryLo;<br>BITVEC bitvCommit;<br><span class="hljs-keyword">void</span>* pHeapData;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagRegion</span>* <span class="hljs-title">pRegion</span>;</span><br>&#125;<br>HEADER,*PHEADER;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/d58d5e1aad1b8db3e051fdad0f205cf7-6b918.png" alt="**Header**："></p><h3 id="ioinit-（SBH运行例子：malloc与free）"><a href="#ioinit-（SBH运行例子：malloc与free）" class="headerlink" title="_ioinit()（SBH运行例子：malloc与free）"></a>_ioinit()（SBH运行例子：malloc与free）</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/0f99d7cce6fa99cafeb92ce68548dc1e-99459.png" alt="_ioinit()"  /></p><p><code>_ioinit()</code>是跟io相关的初始化，也是<strong>第一次</strong>内存分配。</p><h4 id="添加DebugHeader"><a href="#添加DebugHeader" class="headerlink" title="添加DebugHeader"></a>添加DebugHeader</h4><p>假设在<strong>DEBUG</strong>模式下，首先要给<strong>IO所需的空间</strong>附着<strong>DebugHeader</strong>：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b79b80c6866320719070b90bfe43ff9f-bab51.png"  /></p><ul><li><code>nSize</code>就是IO需要的空间大小，对于IO来说就是256字节。</li><li><code>_CrtMemBlockHeader</code>为<strong>debug</strong>模式下，附着在我们申请的内存之上的东西，即<strong>DebugHeader</strong>。</li><li><code>szFileName</code>是指针，存放文件名；再结合<code>nLine</code>存放的行数，调试器可以知道这块内存是从哪一个文件的哪一行分配出来的。</li><li><code>nDataSize</code>记录着原本所需分配的内存大小，即<code>nSize</code>。</li><li><code>nBlockUse</code>记录该内存块的用途。<img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7e3c56f6d983475ba91219ef3806bf6b-93c18.png" style="zoom:50%;" /></li><li><code>IRequest</code>为流水号，因为图中的内存块是第一块分配的内存，所以<code>IRequest</code>的内容为1。</li><li><code>gap[nNoMansLandSize]</code>的作用就是，万一我们使用的时候超过<code>nSize</code>的边界，到达<code>nNoMansLandSize</code>区域，调试器就可以检查出来。</li><li>在调试模式下，经过malloc分配的所有内存块，都会被登记起来。即使被我们使用了，也会被登记。所以调试器可以进行追踪内存等动作。</li></ul><p>至此，<code>blockSize</code>的大小已经计算出来了，然后根据计算的大小从<code>malloc</code>获得了内存。接着需要往内存里面写内容：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b4dcea961f8a609d602b7d31d5068c7b-fefe5.png" alt="填充"  /></p><p>可以看到，<code>nNoMansLandSize</code>区域被填充了<code>0xFD</code>，IO真正的区域（大小为<code>nSize</code>）被填充了<code>0xCD</code>。这也就是为什么在调试的时候看内存会出现很多“<strong>烫烫烫….</strong>”。</p><h4 id="添加cookie及RoundUp"><a href="#添加cookie及RoundUp" class="headerlink" title="添加cookie及RoundUp"></a>添加cookie及RoundUp</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9e5757177cd3b04692df36a354577d6f-95be9.png"  /></p><p>有了blockSize以及相应大小的内存区域，接下来：</p><ul><li>在内存块上下添加<strong>cookie</strong>，这个<strong>cookie</strong>的值需要变成<strong>16的倍数</strong>，所以在上图根据计算变成了<code>0x130</code>。</li><li>因为这块内存是正在使用的，所以将<code>0x130</code>变成<code>0x131</code>。</li></ul><h4 id="管理模式"><a href="#管理模式" class="headerlink" title="管理模式"></a>管理模式</h4><ul><li>SBH为了管理1MB，成本是16K。</li><li>SBH通过控制中心分配内存块的行为与STL：allocator的行为几乎相似。</li><li>SBH对区域的粒度划分如此细致，是为了更好的将内存归还给OS。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/64e245b7a20655a9367ed949b23d8149-9775f.png" alt="管理模式"  /></p><h5 id="全回收"><a href="#全回收" class="headerlink" title="全回收"></a>全回收</h5><ul><li>如果没有下cookie的设计，就没办法往上合并。</li><li>SBH手上有两个全回收才会将其中一个Group还给OS。</li><li>每次回收只会往上和往下查看上下区块的cookie<strong>一次</strong>。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/78d00a624e830a518a6e9d2a845063b6-7e63b.png" alt="全回收"  /></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Room数据库</title>
    <link href="/2020/12/06/Android/Jetpack/Room%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2020/12/06/Android/Jetpack/Room%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-meta">@Database(entities = &#123;Cache.class&#125;, version = 1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheDatabase</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RoomDatabase</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用抽象类的原因：RoomDatabase是使用注解来使用相关的功能，在编译时使用annotationprocesser来实现类。在使用abstract声明的时候，运行时会产生一个CacheDatabase的实现类。这样一来就不用复写RoomDatabase的几个默认方法</p><h2 id="数据库的创建"><a href="#数据库的创建" class="headerlink" title="数据库的创建"></a>数据库的创建</h2><ol><li>inMemoryDatabaseBuilder()：创建一个内存数据库</li><li>databaseBuilder()：常规创建</li></ol><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><ol><li>allowMainThreadQueries()：是否允许在主线程进行查询，默认是关闭的。如果关闭情况下在主线程查询数据库，将会抛出异常</li><li>addCallback()：数据库创建和打开后的回调</li><li>setQueryExecutor()：设置查询的线程池</li><li>openHelperFactory()：数据库Heper的工厂类</li><li>setJournalMode()：设置数据库的日志模式</li><li>fallbackToDestructiveMigration()：数据库升级异常之后的回滚，设置后将重新创建数据库。若不设置将会销毁数据库</li><li>fallbackToDestructiveMigrationFrom()：数据库升级异常后根据指定版本进行回滚</li><li>addMigrations()：数据库跨版本升级</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-comment">//跨版本升级举例</span><br><br><span class="hljs-comment">//....</span><br><span class="hljs-comment">//数据库从版本1升级到版本3</span><br><span class="hljs-keyword">static</span> Migration sMigration = <span class="hljs-keyword">new</span> Migration(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">migrate</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> SupportSQLiteDatabase database)</span> </span>&#123;<br>        database.execSQL(<span class="hljs-string">&quot;alter table teacher rename to student&quot;</span>);<br>        database.execSQL(<span class="hljs-string">&quot;alter table teacher add column teacher_age INTEGER NOT NULL default 0&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> CacheDatabase database;<br>database = Room.databaseBuilder(AppGlobals.getApplication(), CacheDatabase.class, <span class="hljs-string">&quot;ppjoke_cache&quot;</span>).  addMigrations(sMigration).build();<br><br></code></pre></div></td></tr></table></figure><h2 id="Database注解"><a href="#Database注解" class="headerlink" title="@Database注解"></a>@Database注解</h2><ol><li>entities：数据库中有哪些表</li><li>version：后续数据库升级可用到</li><li>exportSchema：默认为true。会导出一个JSON文件，内容为数据库在升级或创建数据表的时候的操作。也包含了所有表的字段和字段的描述。需要在包的build.gradle文件中配置</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA">defaultConfig &#123;<br>        ...<br><br>        javaCompileOptions&#123;<br>            annotationProcessorOptions&#123;<br>                arguments=[<span class="hljs-string">&quot;room.schemaLocation&quot;</span>:<span class="hljs-string">&quot;$projectDir/schemas&quot;</span>.toString()]<span class="hljs-comment">//表示文件放在包的根目录下的schemas文件夹下</span><br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><h2 id="Entity相关"><a href="#Entity相关" class="headerlink" title="@Entity相关"></a>@Entity相关</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-meta">@Entity(tableName = &quot;cache&quot;,</span><br><span class="hljs-meta">        foreignKeys = &#123;entity = User.class,parentColumns = &quot;id&quot;,childColumns = &quot;key&quot;,</span><br><span class="hljs-meta">        onDelete = &quot;ForeignKey.RESTRICT&quot;,onUpdate = &quot;ForeignKey.SET_DEFAULT&quot;&#125;</span><br><span class="hljs-meta">        )</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-meta">@PrimaryKey(autoGenerate = false)</span><br>    <span class="hljs-keyword">public</span> String key;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] data;<br><br>    <span class="hljs-meta">@Embedded</span> <br>    <span class="hljs-keyword">public</span> User user<br><br>    <span class="hljs-meta">@Relation(entity = Address.class,parentColumn = &quot;id&quot;,entityColumn = &quot;id&quot;,projection = &#123;&#125;)</span><br>    <span class="hljs-keyword">public</span> Address address;<br><br>    <span class="hljs-meta">@ColumnInfo(name = &quot;name&quot;)</span><br>    <span class="hljs-keyword">public</span> String name;<br><br>    <span class="hljs-meta">@Ignore</span><br>    <span class="hljs-keyword">public</span> String age;<br><br>    <span class="hljs-meta">@TypeConverters(value = &#123;DateConverter.class&#125;)</span><br>    <span class="hljs-keyword">public</span> Date mDate;<br><br>&#125;<br><br># DateConverter.class<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateConverter</span> </span>&#123;<br><br>    <span class="hljs-meta">@TypeConverter</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title">date2Long</span><span class="hljs-params">(Date date)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> date.getTime();<br>    &#125;<br><br>    <span class="hljs-meta">@TypeConverter</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">long2Date</span><span class="hljs-params">(Long data)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Date(data);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><ul><li><strong>@ColumnInfo</strong> ：若不加这条注解，表创建时，name在表中的字段名称不变(name)。而加入 <strong>@ColumnInfo(name = “name_”)</strong>，当表创建时，name在表中映射的列名为name_。</li><li><strong>@Embedded</strong> ：对象嵌套,User对象中所有字段,也都会被映射到cache表中</li><li><strong>@Entity</strong> ：定义表的名称</li><li><strong>@PrimaryKey</strong> ：定义表的主键,其中的autoGenerate为true时表示主键自动生成</li><li><strong>foreignKeys</strong> : 定义表的外键。其中entity表示外键所在的表，parentColumns表示外键在其原表中的列名，而childColumns表示外键关联本表中列的列名。onDelete表示外键删除时本表所需动作，onUpdate同理。具体宏作用如下表。<br>  |宏|描述|<br>  |:————|:—————|<br>  |NO_ACTION|什么都不做|<br>  |RESTRICT|当外键删除时，本表中关联的键也会立即删除|<br>  |SET_NULL|设置为空值|<br>  |SET_DEFAULT|设置为默认值|<br>  |CASCADE|与RESTRICT相似，区别在于RESTRICT会立即发生|</li><li><strong>@Ignore</strong> ：该注解标记的字段将不会出现在表中</li><li><strong>@Relation</strong> ：关联查询。entity表示要关联的表，parentColumn表示关联表中的列名，entityColumn表示本表中的列名，projection是个数组，里面填写关联查询所需要返回的列名。</li><li><strong>@TypeConverters</strong> ：它是TypeConverter的集合。可以标记在方法、参数、类、字段上面。当Date类型存入数据库时转换成Long类型，或者从数据库取出后将Long类型转换成Date类型，使用的是DateConverter.class中用 <strong>@TypeConverter</strong> 标注的方法。<strong>@TypeConverter</strong>所标注的方法，必须有一个参数，还有一个不是void类型的返回值。</li></ul><h2 id="Dao相关"><a href="#Dao相关" class="headerlink" title="@Dao相关"></a>@Dao相关</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-meta">@Dao</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CacheDao</span> </span>&#123;<br><br>    <span class="hljs-meta">@Insert(onConflict = OnConflictStrategy.REPLACE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">save</span><span class="hljs-params">(Cache cache)</span></span>;<br><br>    <span class="hljs-comment">//如果是一对多,这里可以写List&lt;Cache&gt;</span><br>    <span class="hljs-meta">@Query(&quot;select *from cache where `key`=:key&quot;)</span><br>    <span class="hljs-function">Cache <span class="hljs-title">getCache</span><span class="hljs-params">(String key)</span></span>;<br><br>    <span class="hljs-comment">//只能传递对象昂,删除时根据Cache中的主键 来比对的</span><br>    <span class="hljs-meta">@Delete</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">delete</span><span class="hljs-params">(Cache cache)</span></span>;<br><br>    <span class="hljs-comment">//只能传递对象昂,删除时根据Cache中的主键 来比对的</span><br>    <span class="hljs-meta">@Update(onConflict = OnConflictStrategy.REPLACE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(Cache cache)</span></span>;<br><br><br><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>当一个类被 <strong>@Dao</strong> 标记，说明它是一个能操作数据库的一个类。可标注在 <strong>interface</strong> 类或者 <strong>abstract</strong> 类上面</li><li><strong>@Insert</strong> 、<strong>@Query</strong> 、 <strong>@Delete</strong> 、<strong>@Update</strong> 等注解</li><li>@Insert(onConflict = OnConflictStrategy.REPLACE)中的<strong>onConflict</strong>表示当插入时发生冲突的行为( <strong>@Update</strong> 也是一样)。<br>  |宏|描述|<br>  |:————|:—————|<br>  |REPLACE|直接用新的数据替换掉旧的数据|<br>  |ROLLBACK|回滚，保留旧的数据|<br>  |ABORT|终止提交，保留旧的数据|<br>  |FAIL|提交失败|<br>  |IGNORE|忽略本次提交|</li><li><strong>@Delete</strong> 中的参数可以是对象、集合、数组等。</li><li><strong>@Transaction</strong> ：所标记的方法将会被当作事务来提交</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Room数据库</tag>
      
      <tag>Jetpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ExecutorService</title>
    <link href="/2020/12/03/JAVA/ExecutorService/"/>
    <url>/2020/12/03/JAVA/ExecutorService/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>ExecutorService是Java中对线程池定义的一个接口，它位于java.util.concurrent包中，在这个接口中定义了和后台任务执行相关的方法：</p><ol><li>ThreadPoolExecutor</li><li>ScheduledThreadPoolExecutor</li></ol><p>除此之外，ExecutorService还继承了Executor接口（注意区分Executor接口和Executors工厂类），这个接口只有一个execute()方法，最后我们看一下整个继承树：<br><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201203213311.png" alt="继承树"></p><h2 id="ExecutorService的创建"><a href="#ExecutorService的创建" class="headerlink" title="ExecutorService的创建"></a>ExecutorService的创建</h2><p>创建一个什么样的ExecutorService的实例（即线程池）需要根据具体应用场景而定，不过Java给我们提供了一个Executors工厂类，它可以帮助我们很方便的创建各种类型ExecutorService线程池，Executors一共可以创建下面这四类线程池：</p><ol><li>newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li><li>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li><li>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</li><li>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ol><p><em>注意</em>：Executors只是一个工厂类，它所有的方法返回的都是ThreadPoolExecutor、ScheduledThreadPoolExecutor这两个类的实例。</p><h2 id="ExecutorService的使用"><a href="#ExecutorService的使用" class="headerlink" title="ExecutorService的使用"></a>ExecutorService的使用</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br>executorService.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Asynchronous task&quot;</span>);<br>    &#125;<br>&#125;);<br><br>executorService.shutdown();<br></code></pre></div></td></tr></table></figure><h2 id="ExecutorService的执行"><a href="#ExecutorService的执行" class="headerlink" title="ExecutorService的执行"></a>ExecutorService的执行</h2><ul><li>execute(Runnable)</li><li>submit(Runnable)</li><li>submit(Callable)</li><li>invokeAny(…)</li><li>invokeAll(…)</li></ul><h3 id="execute-Runnable"><a href="#execute-Runnable" class="headerlink" title="execute(Runnable)"></a>execute(Runnable)</h3><p>这个方法接收一个Runnable实例，并且异步的执行</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ExecutorService executorService = Executors.newSingleThreadExecutor();<br><br>executorService.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Asynchronous task&quot;</span>);<br>    &#125;<br>&#125;);<br><br>executorService.shutdown();<br></code></pre></div></td></tr></table></figure><p>这个方法有个问题，就是没有办法获知task的执行结果。如果我们想获得task的执行结果，我们可以传入一个Callable的实例。</p><h3 id="submit-Runnable"><a href="#submit-Runnable" class="headerlink" title="submit(Runnable)"></a>submit(Runnable)</h3><p>submit(Runnable)和execute(Runnable)区别是前者可以返回一个Future对象，通过返回的Future对象，我们可以检查提交的任务是否执行完毕。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br>Future future = executorService.submit(<span class="hljs-keyword">new</span> Runnable() &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Asynchronous task&quot;</span>);<br>&#125;<br>&#125;);<br><br>future.get(); <span class="hljs-comment">/*该方法会产生阻塞*/</span><br><br></code></pre></div></td></tr></table></figure><p>如果任务执行完成，future.get()方法会返回一个null。</p><h3 id="submit-Callable"><a href="#submit-Callable" class="headerlink" title="submit(Callable)"></a>submit(Callable)</h3><p>submit(Callable)和submit(Runnable)类似，也会返回一个Future对象，但是除此之外，submit(Callable)接收的是一个Callable的实现，Callable接口中的call()方法有一个返回值，可以返回任务的执行结果，而Runnable接口中的run()方法是void的，没有返回值。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br>Future future = executorService.submit(<span class="hljs-keyword">new</span> Callable()&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Asynchronous Callable&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Callable Result&quot;</span>;<br>    &#125;<br>&#125;);<br><br>System.out.println(<span class="hljs-string">&quot;future.get() = &quot;</span> + future.get());<span class="hljs-comment">/*该方法会产生阻塞*/</span><br><br></code></pre></div></td></tr></table></figure><p>如果任务执行完成，future.get()方法会返回Callable任务的执行结果。</p><h3 id="invokeAny-…"><a href="#invokeAny-…" class="headerlink" title="invokeAny(…)"></a>invokeAny(…)</h3><p>invokeAny(…)方法接收的是一个Callable的集合，执行这个方法不会返回Future，但是会返回所有Callable任务中其中一个任务的执行结果。这个方法也无法保证返回的是哪个任务的执行结果，反正是其中的某一个。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ExecutorService executorService = Executors.newSingleThreadExecutor();<br><br>Set&lt;Callable&lt;String&gt;&gt; callables = <span class="hljs-keyword">new</span> HashSet&lt;Callable&lt;String&gt;&gt;();<br><br>callables.add(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Task 1&quot;</span>;<br>    &#125;<br>&#125;);<br>callables.add(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Task 2&quot;</span>;<br>    &#125;<br>&#125;);<br>callables.add(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Task 3&quot;</span>;<br>    &#125;<br>&#125;);<br><br>String result = executorService.invokeAny(callables);<br>System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>executorService.shutdown();<br></code></pre></div></td></tr></table></figure><p>每次执行都会返回一个结果，并且返回的结果是变化的，可能会返回“Task2”也可是“Task1”或者其它。</p><h3 id="invokeAll-…"><a href="#invokeAll-…" class="headerlink" title="invokeAll(…)"></a>invokeAll(…)</h3><p>invokeAll(…)与 invokeAny(…)类似也是接收一个Callable集合，但是前者执行之后会返回一个Future的List，其中对应着每个Callable任务执行后的Future对象。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ExecutorService executorService = Executors.newSingleThreadExecutor();<br><br>Set&lt;Callable&lt;String&gt;&gt; callables = <span class="hljs-keyword">new</span> HashSet&lt;Callable&lt;String&gt;&gt;();<br><br>callables.add(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Task 1&quot;</span>;<br>    &#125;<br>&#125;);<br>callables.add(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Task 2&quot;</span>;<br>    &#125;<br>&#125;);<br>callables.add(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Task 3&quot;</span>;<br>    &#125;<br>&#125;);<br><br>List&lt;Future&lt;String&gt;&gt; futures = executorService.invokeAll(callables);<br><br><span class="hljs-keyword">for</span>(Future&lt;String&gt; future : futures)&#123;<br>    System.out.println(<span class="hljs-string">&quot;future.get = &quot;</span> + future.get());<br>&#125;<br><br>executorService.shutdown();<br><br></code></pre></div></td></tr></table></figure><h2 id="ExecutorService的关闭"><a href="#ExecutorService的关闭" class="headerlink" title="ExecutorService的关闭"></a>ExecutorService的关闭</h2><p>当我们使用完成ExecutorService之后应该关闭它，否则它里面的线程会一直处于运行状态。</p><p>举个例子，如果的应用程序是通过main()方法启动的，在这个main()退出之后，如果应用程序中的ExecutorService没有关闭，这个应用将一直运行。之所以会出现这种情况，是因为ExecutorService中运行的线程会阻止JVM关闭。</p><p>如果要关闭ExecutorService中执行的线程，我们可以调用ExecutorService.shutdown()方法。在调用shutdown()方法之后，ExecutorService不会立即关闭，但是它不再接收新的任务，直到当前所有线程执行完成才会关闭，所有在shutdown()执行之前提交的任务都会被执行。</p><p>如果我们想立即关闭ExecutorService，我们可以调用ExecutorService.shutdownNow()方法。这个动作将跳过所有正在执行的任务和被提交还没有执行的任务。但是它并不对正在执行的任务做任何保证，有可能它们都会停止，也有可能执行完成。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p><a href="https://www.cnblogs.com/Transkai/p/11230734.html">Java 线程池ExecutorService详解</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ExecutorService</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PermissionsDispatcher</title>
    <link href="/2020/12/03/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/PermissionsDispatcher/"/>
    <url>/2020/12/03/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/PermissionsDispatcher/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PermissionsDispatcher是一个基于注解、帮助开发者简单处理Android 6.0系统中的运行时权限的开源库。避免了开发者编写大量繁琐的样板代码。</p><h2 id="注解列表"><a href="#注解列表" class="headerlink" title="注解列表"></a>注解列表</h2><div class="table-container"><table><thead><tr><th style="text-align:left">注解</th><th style="text-align:left">必须</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">@RuntimePermissions</td><td style="text-align:left">是</td><td style="text-align:left">注解在其内部需要使用运行时权限的Activity或Fragment上</td></tr><tr><td style="text-align:left">@NeedsPermission</td><td style="text-align:left">是</td><td style="text-align:left">注解在需要调用运行时权限的方法上，当用户给予权限时会执行该方法</td></tr><tr><td style="text-align:left">@OnShowRationale</td><td style="text-align:left">否</td><td style="text-align:left">注解在用于向用户解释为什么需要调用该权限的方法上，只有当第一次请求权限被用户拒绝，下次请求权限之前会调用</td></tr><tr><td style="text-align:left">@OnPermissionDenied</td><td style="text-align:left">否</td><td style="text-align:left">注解在当用户拒绝了权限请求时需要调用的方法上</td></tr><tr><td style="text-align:left">@OnNeverAskAgain</td><td style="text-align:left">否</td><td style="text-align:left">注解在当用户选中了授权窗口中的不再询问复选框后并拒绝了权限请求时需要调用的方法，一般可以向用户解释为何申请此权限，并根据实际需求决定是否再次弹出权限请求对话框</td></tr></tbody></table></div><p><em>注意：私有方法不能被注解！</em></p><h2 id="简单使用方法（以相机权限为例）"><a href="#简单使用方法（以相机权限为例）" class="headerlink" title="简单使用方法（以相机权限为例）"></a>简单使用方法（以相机权限为例）</h2><ol><li>打开bulid.gradle(Module)添加依赖</li></ol><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">dependencies</span> &#123;<br>  <span class="hljs-attribute">implementation</span> <span class="hljs-string">&quot;org.permissionsdispatcher:permissionsdispatcher:<span class="hljs-variable">$&#123;latest.version&#125;</span>&quot;</span><br>  annotationProcessor <span class="hljs-string">&quot;org.permissionsdispatcher:permissionsdispatcher-processor:<span class="hljs-variable">$&#123;latest.version&#125;</span>&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ol><li><p>AndroidManifest.xml中添加权限<br><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201203123324.png" alt="添加权限">  </p></li><li><p>在需要运行权限的Activity上添加@RuntimePermissions<br><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201203123501.png" alt="@RuntimePermissions"></p></li><li><p>在需要调用运行时权限的方法上添加@NeedsPermission并标注所需权限</p></li></ol><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201203123613.png" alt="@NeedsPermission"></p><ol><li>使用MainActivityPermissionsDispatcher.startCameraWithPermissionCheck(this)来调用第四步中创建的方法。其中，startCameraWithPermissionCheck中的startCamera需与第四步中的方法名一致。即调用XXX方法使用MainActivityPermissionsDispatcher.XXXWithPermissionCheck(this)</li></ol><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201203123840.png" alt="调用"></p><ol><li>重写该Activity的onRequestPermissionsResult()方法，其方法内调用MainActivityPermissionsDispatcher的onRequestPermissionsResult()方法</li></ol><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@Override</span><br>public void onRequestPermissionsResult(int requestCode, <span class="hljs-variable">@NonNull</span> String[] permissions, <span class="hljs-variable">@NonNull</span> int[] grantResults) &#123;<br>    <span class="hljs-selector-tag">super</span><span class="hljs-selector-class">.onRequestPermissionsResult</span>(requestCode, permissions, grantResults);<br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> delegate the permission handling to generated method</span><br>    <span class="hljs-selector-tag">MainActivityPermissionsDispatcher</span><span class="hljs-selector-class">.onRequestPermissionsResult</span>(this, requestCode, grantResults);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h2><p><a href="https://github.com/permissions-dispatcher/PermissionsDispatcher">https://github.com/permissions-dispatcher/PermissionsDispatcher</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PermissionsDispatcher</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存原语</title>
    <link href="/2020/12/01/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%8E%9F%E8%AF%AD/"/>
    <url>/2020/12/01/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%8E%9F%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="C-内存原语"><a href="#C-内存原语" class="headerlink" title="C++内存原语"></a>C++内存原语</h1><h2 id="内存分配操作"><a href="#内存分配操作" class="headerlink" title="内存分配操作"></a>内存分配操作</h2><div class="table-container"><table><thead><tr><th>分配</th><th>释放</th><th>类属</th><th>可否重载</th></tr></thead><tbody><tr><td>malloc()</td><td>free()</td><td>C 函数</td><td>不可</td></tr><tr><td>new</td><td>delete</td><td>C++ 表达式</td><td>不可</td></tr><tr><td>::operator new()</td><td>::operator delete()</td><td>C++ 函数</td><td>可</td></tr><tr><td>allocator::allocate()</td><td>allocator::deallocate</td><td>C++ 标准库</td><td>可自由设计并予以搭配任何容器</td></tr></tbody></table></div><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>new实际上在内部执行了三个步骤：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">Complex *pc;<span class="hljs-comment">//实际上会执行以下三步</span><br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">/* 1 */</span> <span class="hljs-keyword">void</span> mem = <span class="hljs-keyword">operator</span> <span class="hljs-built_in"><span class="hljs-keyword">new</span></span> (<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Complex));  <span class="hljs-comment">// allocate 申请内存空间</span><br>    <span class="hljs-comment">/* 2 */</span> pc = <span class="hljs-built_in"><span class="hljs-keyword">static_cast</span></span>(mem);                      <span class="hljs-comment">// cast 类型转换</span><br>    <span class="hljs-comment">/* 3 */</span> pc-&gt;Complex::<span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);                 <span class="hljs-comment">// construct 调用构造函数</span><br>    <span class="hljs-comment">// 注意：只有编译器才可以像上面那样直接呼叫 ctor</span><br>&#125;<br><span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (std::bad_alloc) &#123;<br>    <span class="hljs-comment">// 若 allocation 失败，就不执行 constructor </span><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>在GCC只能由编译器调用构造函数，而VC6下可以自己调用构造函数。而析构函数没有这种限制。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br>    <span class="hljs-comment">//....</span><br>&#125;<br><br>A* pA = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>);<br>pA-&gt;A::<span class="hljs-built_in">A</span>(<span class="hljs-number">3</span>);                    <span class="hljs-comment">//in VC6 : ctor. this=000307A8 id=3</span><br>  <span class="hljs-comment">//in GCC : [Error] cannot call constructor </span><br><span class="hljs-keyword">delete</span> pA; <br></code></pre></div></td></tr></table></figure></li></ul><p><code>operator new</code> 的操作：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// ...\vc98\crt\src\newop2.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> std::<span class="hljs-keyword">nothrow_t</span> &amp;_THROW0())</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// try to allocate size bytes</span><br>    <span class="hljs-keyword">void</span> *p;<br>    <span class="hljs-keyword">while</span> ((p = <span class="hljs-built_in">malloc</span>(size)) == <span class="hljs-number">0</span>)<span class="hljs-comment">//当分配失败时</span><br>    &#123;<br>        <span class="hljs-comment">// buy more memory or return null pointer</span><br>        <span class="hljs-function">__TRY_BEGIN</span><br><span class="hljs-function">        <span class="hljs-title">if</span> <span class="hljs-params">(_callnewh(size) == <span class="hljs-number">0</span>)</span> <span class="hljs-keyword">break</span></span>;<br>        _CATCH(std::bad_alloc)  <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>        _CATCH_END<br>    &#125;   <br>&#125;<br></code></pre></div></td></tr></table></figure><p>在上面代码段中：</p><ul><li><code>const std::nothrow_t &amp;_THROW0()</code>：指示该函数应返回空指针以报告分配失败，而不是引发异常。</li><li><code>_callnewh()</code>：当分配失败时执行这个函数，这个函数由我们自己编写，让我们可以借此机会释放一些内存。</li></ul><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>delete实际上在内部执行了两个步骤：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">Complex *pc = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">delete</span> pc;<span class="hljs-comment">//实际上会执行以下两条代码</span><br><br>pc-&gt;~<span class="hljs-built_in">Complex</span>();         <span class="hljs-comment">// 调用析构函数</span><br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span> <span class="hljs-params">(pc)</span></span>;   <span class="hljs-comment">// 释放内存</span><br></code></pre></div></td></tr></table></figure><p><code>operator delete</code>：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// ...\vc98\crt\src\delop.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> __cdelc <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *p)</span> __<span class="hljs-title">THROW0</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// free an allocated object</span><br>    <span class="hljs-built_in">free</span>(p);<span class="hljs-comment">//实际上就调用了一个free</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="array-new-和-array-delete"><a href="#array-new-和-array-delete" class="headerlink" title="array new 和 array delete"></a>array new 和 array delete</h2><ul><li>所有编译器的malloc和free都会分配cookie。</li><li>一个类的析构函数<strong>没有意义</strong>的话，<strong>array new</strong>后不使用<strong>array delete</strong>也可以。</li></ul><h2 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h2><p><strong>作用：将对象构建在一个已经分配好的内存中</strong>。</p><p>没有所谓的<strong>placement delete</strong>，因为placement new根本没分配内存。或者说与<strong>placement new</strong>相对应的<strong>operator delete</strong>为<strong>placement delete</strong>。</p><p>用法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;new&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span>;</span><br><span class="hljs-keyword">char</span>* buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Complex)*<span class="hljs-number">3</span>];<br>Complex* pc = <span class="hljs-built_in"><span class="hljs-keyword">new</span></span>(buf) <span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">//placement new在此</span><br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">delete</span>[] buf;<br></code></pre></div></td></tr></table></figure><p>在<code>new(buf)Complex(1,2)</code>内部：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">/* 1 */</span> <span class="hljs-keyword">void</span> mem = <span class="hljs-keyword">operator</span> <span class="hljs-built_in"><span class="hljs-keyword">new</span></span> (<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Complex),buf);<br>    <span class="hljs-comment">/* 2 */</span> pc = <span class="hljs-keyword">static_cast</span>&lt;Complex*&gt;(mem);                  <br>    <span class="hljs-comment">/* 3 */</span> pc-&gt;Complex::<span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);             <br>&#125;<br><span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (std::bad_alloc) &#123;<br>    <span class="hljs-comment">// 若 allocation 失败，就不执行 constructor </span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>而上述代码中的<code>operator new</code> 的操作实际上就返回了一个指针。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span>,<span class="hljs-keyword">void</span>* loc)</span></span>&#123;<span class="hljs-keyword">return</span> loc;&#125;<br></code></pre></div></td></tr></table></figure><p>即<strong>指针pc</strong>和<strong>指针buf</strong>都指向同一个地址。</p><p>注意：<strong>placement new</strong>或指<code>new(p)</code>，或指<code>::operator new(size,void*)</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>不应该直接调用构造和析构函数，而是用<code>new</code>和<code>delete</code></li><li>虽然析构函数可以被直接调用，但是也不应该直接调用。若是析构函数中需要释放系统资源，那么析构函数被调用多次，资源也将被释放多次。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更新UI方法</title>
    <link href="/2020/11/23/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E6%9B%B4%E6%96%B0UI%E6%96%B9%E6%B3%95/"/>
    <url>/2020/11/23/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E6%9B%B4%E6%96%B0UI%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="view-post-Runnable-action"><a href="#view-post-Runnable-action" class="headerlink" title="view.post(Runnable action)"></a>view.post(Runnable action)</h2><p>假如该方法是在子线程中</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br>textView.post(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            textView.setText(<span class="hljs-string">&quot;更新textView&quot;</span>);<br>            <span class="hljs-comment">//还可以更新其他的控件</span><br>            imageView.setBackgroundResource(R.drawable.update);<br>        &#125;<br>    &#125;);<br><br></code></pre></div></td></tr></table></figure><p>这是view自带的方法，比较简单，如果你的子线程里可以得到要更新的view的话，可以用此方法进行更新。</p><p>view还有一个方法view.postDelayed(Runnable action, long delayMillis)用来延迟发送。</p><h2 id="activity-runOnUiThread-Runnable-action"><a href="#activity-runOnUiThread-Runnable-action" class="headerlink" title="activity.runOnUiThread(Runnable action)"></a>activity.runOnUiThread(Runnable action)</h2><p>假如该方法是在子线程中</p><p>注意：context 对象要是 主线程中的MainActivity，这样强转才可以。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateUI</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Context context)</span> </span>&#123;<br>        ((MainActivity) context).runOnUiThread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">//此时已在主线程中，可以更新UI了</span><br>            &#125;<br>        &#125;);<br>    &#125;<br><br></code></pre></div></td></tr></table></figure><p>如果没有上下文（context），试试下面的方法：<br>1.用view.getContext()可以得到上下文。<br>2.跳过context直接用new Activity().runOnUiThread(Runnable action)来切换到主线程。</p><h2 id="Handler机制"><a href="#Handler机制" class="headerlink" title="Handler机制"></a>Handler机制</h2><p>首先在主线程中定义Handler，Handler mainHandler = new Handler();（必须要在主线程中定义才能操作主线程，如果想在其他地方定义声明时要这样写Handler mainHandler = new Handler(Looper.getMainLooper())，来获取主线程的 Looper 和 Queue ）</p><p>获取到 Handler 后就很简单了，用handler.post(Runnable r)方法把消息处理放在该 handler 依附的消息队列中（也就是主线程消息队列）。</p><h3 id="1-假如该方法是在子线程中"><a href="#1-假如该方法是在子线程中" class="headerlink" title="1.假如该方法是在子线程中"></a>1.假如该方法是在子线程中</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br>Handler mainHandler = <span class="hljs-keyword">new</span> Handler(Looper.getMainLooper());<br>mainHandler.post(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//已在主线程中，可以更新UI</span><br>    &#125;<br>&#125;);<br><br></code></pre></div></td></tr></table></figure><p>Handler还有下面的方法：<br>1.postAtTime(Runnable r, long uptimeMillis); //在某一时刻发送消息<br>2.postAtDelayed(Runnable r, long delayMillis); //延迟delayMillis毫秒再发送消息</p><h3 id="2-假设在主线程中"><a href="#2-假设在主线程中" class="headerlink" title="2.假设在主线程中"></a>2.假设在主线程中</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br>Handler myHandler = <span class="hljs-keyword">new</span> Handler() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span>(msg.what) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                <span class="hljs-comment">//更新UI等</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                 <span class="hljs-comment">//更新UI等</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>之后可以把 mainHandler 当做参数传递在各个类之间，当需要更新UI时，可以调用sendMessage一系列方法来执行handleMessage里的操作。</p><p>假设现在在子线程了</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  *获取消息，尽量用obtainMessage()方法，查看源码发现，该方法节省内存。</span><br><span class="hljs-comment">  *不提倡用Messenger msg=new Messenger()这种方法，每次都去创建一个对象，肯定不节省内存啦！</span><br><span class="hljs-comment">  */</span><br>Message msg = myHandler.obtainMessage();<br>msg.what = <span class="hljs-number">0</span>; <span class="hljs-comment">//消息标识</span><br>myHandler.sendMessage(msg); <span class="hljs-comment">//发送消息</span><br></code></pre></div></td></tr></table></figure><p>如上代码，只是发送了个消息标识，并没有传其他参数。<br>如果想传递参数，可以这样：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br>msg.what = <span class="hljs-number">1</span>;  <span class="hljs-comment">//消息标识</span><br>msg.arg1=<span class="hljs-number">2</span>;   <span class="hljs-comment">//存放整形数据，如果携带数据简单，优先使用arg1和arg2，比Bundle更节省内存。</span><br>msg.arg2=<span class="hljs-number">3</span>;   <span class="hljs-comment">//存放整形数据</span><br>Bundle bundle=<span class="hljs-keyword">new</span> Bundle();<br>bundle.putString(<span class="hljs-string">&quot;dd&quot;</span>,<span class="hljs-string">&quot;adfasd&quot;</span>);<br>bundle.putInt(<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-number">5</span>);<br>msg.setData(bundle);<br>msg.obj=bundle;   <span class="hljs-comment">//用来存放Object类型的任意对象</span><br>myHandler.sendMessage(msg); <span class="hljs-comment">//发送消息</span><br><br></code></pre></div></td></tr></table></figure><p>总结： msg.obj它的功能比较强大一下，至于它和利用Bundle传递数据，那个会效率高一些，更节省内存一些。个人认为：从传递数据的复杂程度看，由简单到复杂依次使用，arg1， setData(), obj。会比较好一些。</p><p>当然可以用简化方法sendEmptyMessage(int what)来减少不必要的代码，这样写：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">myHandler.sendEmptyMessage(<span class="hljs-number">0</span>); <span class="hljs-comment">//其实内部实现还是和上面一样</span><br></code></pre></div></td></tr></table></figure><p>发送消息的其他方法有：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br>endEmptyMessageAtTime(<span class="hljs-keyword">int</span> what, <span class="hljs-keyword">long</span> uptimeMillis); <span class="hljs-comment">//定时发送空消息</span><br>sendEmptyMessageDelayed(<span class="hljs-keyword">int</span> what, <span class="hljs-keyword">long</span> delayMillis); <span class="hljs-comment">//延时发送空消息</span><br>sendMessageAtTime(Message msg, <span class="hljs-keyword">long</span> uptimeMillis); <span class="hljs-comment">//定时发送消息</span><br>sendMessageDelayed(Message msg, <span class="hljs-keyword">long</span> delayMillis); <span class="hljs-comment">//延时发送消息</span><br>sendMessageAtFrontOfQueue(Message msg); <span class="hljs-comment">//最先处理消息（慎用）</span><br><br></code></pre></div></td></tr></table></figure><h2 id="使用AsyncTask"><a href="#使用AsyncTask" class="headerlink" title="使用AsyncTask"></a>使用AsyncTask</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 该类中方法的执行顺序依次为：onPreExecute, doInBackground, onPostExecute</span><br><span class="hljs-comment">  */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAsyncTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AsyncTask</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">Integer</span>, <span class="hljs-title">String</span>&gt; </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 主线程中执行</span><br><span class="hljs-comment">         * 在execute()被调用后首先执行</span><br><span class="hljs-comment">         * 一般用来在执行后台任务前对UI做一些标记</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPreExecute</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.onPreExecute();<br>            System.out.println(<span class="hljs-string">&quot;MyAsyncTask.onPreExecute&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 子线程中执行，执行一些耗时操作，关键方法</span><br><span class="hljs-comment">         * 在执行过程中可以调用publishProgress(Progress... values)来更新进度信息。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">doInBackground</span><span class="hljs-params">(String... params)</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;MyAsyncTask.doInBackground&quot;</span>);<br>            <span class="hljs-comment">//只是模拟了耗时操作</span><br>            <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    count++;<br>                    publishProgress((count % <span class="hljs-number">100</span>) * <span class="hljs-number">10</span>);<br>                    Thread.sleep(<span class="hljs-number">3000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// publishProgress((int) ((count / (float) total) * 100));</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;耗时操作执行完毕&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 主线程中执行</span><br><span class="hljs-comment">         * 在调用publishProgress(Progress... values)时，此方法被执行，直接将进度信息更新到UI组件中</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onProgressUpdate</span><span class="hljs-params">(Integer... values)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.onProgressUpdate(values);<br>            progressBar.setProgress(values[<span class="hljs-number">0</span>]);<br>            textView.setText(<span class="hljs-string">&quot;loading...&quot;</span> + values[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;%&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;MyAsyncTask.onProgressUpdate&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 在主线程中，当后台操作结束时，此方法将会被调用</span><br><span class="hljs-comment">         * 计算结果将做为参数传递到此方法中，直接将结果显示到UI组件上。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPostExecute</span><span class="hljs-params">(String aVoid)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.onPostExecute(aVoid);<br>            System.out.println(<span class="hljs-string">&quot;MyAsyncTask.onPostExecute aVoid=&quot;</span> + aVoid);<br>            textView.setText(aVoid);<br>        &#125;<br><br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 主线程中执行</span><br><span class="hljs-comment">         * 当异步任务取消后的，会回调该函数。在该方法内可以更新UI</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCancelled</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.onCancelled();<br>            System.out.println(<span class="hljs-string">&quot;MyAsyncTask.onCancelled&quot;</span>);<br>            progressBar.setProgress(<span class="hljs-number">0</span>);<br>            textView.setText(<span class="hljs-string">&quot;0&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCancelled</span><span class="hljs-params">(String s)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.onCancelled(s);<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>注意：doInBackground方法是在子线程中，所以，我们在这个方法里面执行耗时操作。同时，由于其返回结果会传递到onPostExecute方法中，而onPostExecute方法工作在UI线程，这样我们就在这个方法里面更新ui，达到了异步更新ui的目的。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p><a href="https://blog.csdn.net/da_caoyuan/article/details/52931007">【Android】快速切换到主线程更新UI的几种方法</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>STL：其他</title>
    <link href="/2020/11/22/C++/STL/STL%EF%BC%9A%E5%85%B6%E4%BB%96/"/>
    <url>/2020/11/22/C++/STL/STL%EF%BC%9A%E5%85%B6%E4%BB%96/</url>
    
    <content type="html"><![CDATA[<h2 id="一个万用的哈希函数"><a href="#一个万用的哈希函数" class="headerlink" title="一个万用的哈希函数"></a>一个万用的哈希函数</h2><ul><li><p>哈希函数设计不好，哈希冲突的概率会很大</p></li><li><p>哈希函数可以写成下面几种形式：（以<code>class Customer&#123;&#125;;</code>为例）</p><ul><li><p>仿函数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerHash</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">std::<span class="hljs-keyword">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Customer&amp; c)</span> <span class="hljs-keyword">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> ...<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//使用</span><br>unordered_set&lt;Customer,CustomerHash&gt; custset;<br></code></pre></div></td></tr></table></figure></li><li><p>函数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">customer_hash_func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Cunstomer&amp; c)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> ...<br>&#125;;<br><br><span class="hljs-comment">//使用，相较于仿函数会麻烦些</span><br><span class="hljs-function">unordered_set&lt;Customer,<span class="hljs-title">size_t</span><span class="hljs-params">(*)</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Customer&amp;)</span>&gt;</span><br><span class="hljs-function"><span class="hljs-title">custset</span><span class="hljs-params">(<span class="hljs-number">20</span>,customer_hash_func)</span></span>;<br></code></pre></div></td></tr></table></figure></li><li><p>偏特化版本</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std <span class="hljs-comment">//必須放在 std 內 </span><br>&#123;<br><span class="hljs-keyword">template</span>&lt;&gt; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hash</span>&lt;</span>MyString&gt; <span class="hljs-comment">//這是為了 unordered containers </span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">size_t</span> </span><br><span class="hljs-function"><span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MyString&amp; s)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> hash&lt;string&gt;()(<span class="hljs-built_in">string</span>(s.<span class="hljs-built_in">get</span>()));  &#125;  <br>    <span class="hljs-comment">//借用現有的 hash&lt;string&gt; (in ...\include\c++\bits\basic_string.h)</span><br>&#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>一个万用的哈希函数：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f4bffe2eac8d6a071babb44115bb418e-86291.png"  /></p></li></ul><h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><h2 id="type-traits"><a href="#type-traits" class="headerlink" title="type traits"></a>type traits</h2><h2 id="moveable"><a href="#moveable" class="headerlink" title="moveable"></a>moveable</h2><ul><li>差距的多少和内存中的碎片情况息息相关</li><li>move操作是浅拷贝，速度很快，但是很危险。最好是在原来的元素不使用的时候再进行move操作</li><li>对于临时对象，编译器会自动查找move版本的copy。前提是有定义move的方法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL：迭代器</title>
    <link href="/2020/11/18/C++/STL/STL%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2020/11/18/C++/STL/STL%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>在标准库中，算法的形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> iterator&gt;</span><br><span class="hljs-function"><span class="hljs-title">Algorithm</span><span class="hljs-params">(iterator itr1,iterator itr2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> iterator,<span class="hljs-keyword">typename</span> Cmp&gt;</span><br><span class="hljs-function"><span class="hljs-title">Algorithm</span><span class="hljs-params">(iterator itr1,iterator itr2,Cmp comp)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="迭代器的作用"><a href="#迭代器的作用" class="headerlink" title="迭代器的作用"></a>迭代器的作用</h2><ul><li>在标准库中算法是个<strong>function template</strong>，而其他都是<strong>class template</strong><ul><li><strong>function template</strong>没有所谓特化，一般使用重载手法。</li></ul></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/fbd310e5be02fd856bced0cb146cd7c1-1025d.png"  /></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/275f8ff4e3f5caa867c4eb223ba08072-a54af.png"  /></p><ul><li><p>标准库中迭代器的分类不是靠枚举类型，而是靠对象</p><ul><li><p>迭代器的分类也影响到算法的效率</p></li><li><p>可根据继承关系来确定编译期模板参数的具体类型（泛化、特化）</p></li><li>算法内部可以根据具体对象<strong>强化</strong>算法。比如一个类中的成员变量不含指针类型，那么这个对象的Big-tree是不重要的，拷贝类型算法可以根据这个类的特点来强化算法。</li><li>在for循环中使用迭代器来终止循环会比较慢，而类似头尾指针相减的这种（和具体数比较）的方式会比较快</li></ul></li><li><p>由于<strong>output iterator</strong>(例ostream_itreator)是<strong>write-only</strong>，无法像<strong>forward iterator</strong>那般可以<strong>read</strong>，所以不能有类似<em>`result != </em>first`的动作，因此需设计出专属版本。</p></li><li><p>在算法的模板参数中，设计者只能用模板参数的名字来暗示使用者如何使用。</p></li></ul><h3 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9cf1875bf6956855508dcab5d3cdd2c9-8ae89.png"  /></p><ul><li>如果算法结构已经搭建好了，而对于不同的类型有不同的执行需求的话，可以考虑重载操作符。如下图：</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/22e5b15a7cbac739fa25ff314518f672-4f1f7.png"  /></p><p>还有一些特殊的迭代器适配器：<code>ostream_iterator</code>和<code>istream_iterator</code>。具体如下图：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9a6a41624ebdcfc3d59fba9f33bcb901-da2ce.png"  /></p><ul><li>ostream_iterator的迭代器会将值传到控制台</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/bc7706fc2c052df652c65f4f92cb3add-bd53c.png"  /></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/caecc79f3ad9b0120e62c2c2c4117971-c53c4.png"  /></p><ul><li>如果初始化<code>istream_iterator</code>没有参数，那么它就是一个<strong>end-of-stream-iterator</strong>，指向<strong>istream</strong>的最后位置，和容器的<code>end()</code>一个道理。</li><li>当一个含参的<code>istream_iterator</code>被创建时，它会立刻等待输入，即在<code>operator++</code>中阻塞。比如<code>istream_iterator&lt;int&gt; iit(cin);</code>。</li></ul><h2 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h2><p><strong>STL中的仿函数只为算法服务。</strong></p><p>STL中的仿函数分为三大类：</p><ul><li>算术类（x-y）</li><li>逻辑运算类（x&amp;&amp;y）</li><li>相对关系类（x&gt;y）</li></ul><h3 id="可适配条件"><a href="#可适配条件" class="headerlink" title="可适配条件"></a>可适配条件</h3><p>STL规定每个Adaptable Function 都应该挑选适当者继承，因为Function Adapter将会提问。不然<strong>无法融入STL库</strong>。虽然说不继承也能编译成功运行成功，但是一些STL的操作就用不了。比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Arg</span>,<span class="hljs-keyword">class</span> <span class="hljs-title">Result</span>&gt;</span><span class="hljs-comment">//一个操作数</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">unary_function</span>&#123;</span><br><span class="hljs-keyword">typedef</span> Arg argument_type;<br><span class="hljs-keyword">typedef</span> Result result_type;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Arg1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title">Arg2</span>,<span class="hljs-keyword">class</span> <span class="hljs-title">Result</span>&gt;</span><span class="hljs-comment">//两个操作数</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binary_function</span>&#123;</span><br><span class="hljs-keyword">typedef</span> Arg1 first_argument_type;<br><span class="hljs-keyword">typedef</span> Arg2 second_argument_type;<br><span class="hljs-keyword">typedef</span> Result result_type;<br>&#125;<br><br><span class="hljs-comment">//例子（STL中的）</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">less</span>:</span><span class="hljs-keyword">public</span> binary_function&lt;T,T,<span class="hljs-keyword">bool</span>&gt;&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; x,<span class="hljs-keyword">const</span> T&amp; y)</span><span class="hljs-keyword">const</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> x&lt;y;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h3><ul><li>编译器会自动进行类型推导</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a13bd6f63f4103cfe8ba3535abf18a4a-bc003.png" alt="函数适配器"  /></p><ul><li>新版本中，bind已实现规范用法。如下图：</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/605c3141d262b9a9c14dfa75cd440707-f1e39.png"  /></p><ul><li>其中，_1，_2，_3为占位符。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL：容器</title>
    <link href="/2020/11/13/C++/STL/STL%EF%BC%9A%E5%AE%B9%E5%99%A8/"/>
    <url>/2020/11/13/C++/STL/STL%EF%BC%9A%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="STL六大部件"><a href="#STL六大部件" class="headerlink" title="STL六大部件"></a>STL六大部件</h2><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8fc0bded58b81b6d96a516528d6f8c41-af505.png" alt="关系"></p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>$O(1)或O(c)$：常数时间</li><li>$O(n)$：线性时间</li><li>$O(log_2{n})$：次线性时间</li><li>$O(n^2)$：平方时间</li><li>$O(n^3)$：立方时间</li><li>$O(2^n)$：指数时间</li><li>$O(nlog_2{n})$：介于线性及二次方成长的中间之行为模式</li></ul><h3 id="前闭后开区间"><a href="#前闭后开区间" class="headerlink" title="前闭后开区间"></a>前闭后开区间</h3><ul><li><p><code>begin</code>：指向第一个元素</p></li><li><p><code>end</code>：指向最后一个元素的下一个元素</p></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8a140f7be2e3e0c027357761ef6dd359-02bfc.png" alt="前闭后开区间"></p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="结构与分类"><a href="#结构与分类" class="headerlink" title="结构与分类"></a>结构与分类</h4><ul><li>Sequence Containers：循序式容器<ul><li>Array：数组</li><li>Vector：向量</li><li>Deque：双向队列</li><li>List：链表（双向环状链表）</li><li>Forward-List：单向链表</li></ul></li><li>Associative Containers：关联式容器<ul><li>Set/Multiset（底层是红黑树）</li><li>Map/Multimap（底层是红黑树）</li></ul></li><li>Unordered Containers：不定序容器<ul><li>Unordered  Set/Multiset</li><li>Unordered  Map/Multimap</li></ul></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6cfe93a4229328bde82237f6743d260a-a9f92.png" alt="结构与分类"></p><h4 id="使用经验"><a href="#使用经验" class="headerlink" title="使用经验"></a>使用经验</h4><ul><li>array：使用二分查找<code>bsearch()</code>之前需要用<code>qsort()</code>进行排序。</li><li>vector：使用二分查找<code>bsearch()</code>之前需要用<code>sort()</code>进行排序。</li><li>获取容器起始地址用<code>Container.data()</code>。</li><li>所有的算法都是全局的模板函数</li><li>标准库提供的算法如果在容器里也有提供，那么就用容器里的，会更快</li></ul><h3 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h3><p>普通使用不建议用分配器，对于分配和释放内存使用new、delete、malloc、free即可。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/3581061f0c009b1c3a4c3c6b0e58bde5-3c6c8.png" alt="分配器"></p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="OOP-vs-GP"><a href="#OOP-vs-GP" class="headerlink" title="OOP vs. GP"></a>OOP vs. GP</h3><ul><li><p>OOP：企图将datas和methods关联在一起</p></li><li><p>GP：是将datas和methods分开来</p><ul><li>Containers和Algorithms团队可各自闭门造车，其间以Iterator沟通即可。</li><li>Algorithms通过Iterator确定操作范围，并通过Iterator取用Containers元素。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/015e3b07b02f49daaa00064df2cfea0e-2ace9.png" alt="GP"></p></li><li><p>所有Algorithms，其内最终涉及元素本身的操作，无非就是比大小。</p></li><li><p>新版本的STL都遵循了Handle-Body的设计原则。</p></li></ul><h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><h4 id="须知"><a href="#须知" class="headerlink" title="须知"></a>须知</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a260b867c46971748bffeffdc042c0f8-dc287.png" alt="须知"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f674b93cc84802c5a067657e0ed40dc3-7b5dd.png" alt="须知"></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/c11eea35e05921569966c536db823441-a2260.png" alt="例子"></p><h3 id="分配器-1"><a href="#分配器-1" class="headerlink" title="分配器"></a>分配器</h3><ul><li>无论怎样的内存分配操作，最后都是malloc。malloc视环境而定，比如windows\linux。</li><li>调用malloc分配的内存会比我们原本意图中所需要的内存会大。我们要的内存越小，这些额外的内存占比越大。</li><li>VC6+、BC++、GCC2.9的<code>allocator</code>只是以<code>::operator new</code>和<code>::operator delete</code>完成<code>allocate()</code>和<code>deallocate()</code>，没有任何特殊设计。</li></ul><h3 id="容器，结构与分类"><a href="#容器，结构与分类" class="headerlink" title="容器，结构与分类"></a>容器，结构与分类</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8021b54cb711137f50fcf6b5a1a2664c-a318b.png" alt="容器，结构与分类"></p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="成员结构"><a href="#成员结构" class="headerlink" title="成员结构"></a>成员结构</h4><p><strong>G2.9版本：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b715fde3789a0501fdb5d3c9ae46944c-69fb2.png" alt=""></p><ul><li>结构体<code>_list_node</code>的<code>void_pointer</code>实际上指的就是自己这个类型。</li></ul><p><strong>G4.9版本：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/c934a9c4da75f69acb4d7ba487d83d4e-25388.png" alt="G4.9版本"></p><ul><li>List实际上没有大小，因为它继承的父类大小为8，所以List的大小才为8。</li><li><code>end()</code>指向的是<code>_List_impl</code>中的<code>_M_node</code>，<code>begin()</code>指向的是<code>_M_node</code>中的<code>_M_next</code>。</li></ul><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p><strong>G2.9版本：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/73e37be9941993b4030ca243f7274845-a87d0.png" alt="迭代器"></p><ul><li>除了Array和Vector的迭代器，其他容器的迭代器必须是class类型。只有class类型才能设计出”聪明“的动作。</li></ul><p><strong>G4.9版本：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5f7c225801940e0704568741c2a875fa-be049.png" alt="G4.9版本："></p><h4 id="前自增与后自增"><a href="#前自增与后自增" class="headerlink" title="前自增与后自增"></a>前自增与后自增</h4><p><strong>G2.9版本：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/150855421610ef9fbb5b5d7fbe6e1f35-97b34.png" alt="迭代器"></p><ul><li><p><code>*this</code>中的<strong>*</strong>作用的是指针，而迭代器中重载的<code>operator*</code>作用的是迭代器对象。</p></li><li><p>后自增<code>self operator++(int)</code>中的<code>int</code>的作用就是为了给编译器看，符合编译器的语法而已。</p></li><li>后自增一共调用了两次拷贝构造。</li><li>至于后自增返回值、前自增返回引用，是因为参照<code>int</code>类型而设计的规范。（图左下角）</li></ul><h4 id="迭代器的设计原则"><a href="#迭代器的设计原则" class="headerlink" title="迭代器的设计原则"></a>迭代器的设计原则</h4><p><strong>迭代器是容器和算法的桥梁。</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/4d92bd2d2d7a87367f42df3a009d0941-1439b.png" alt="**迭代器是容器和算法的桥梁。**"></p><p>在算法执行的时候，它需要知道迭代器中的：</p><ul><li><strong>分类</strong>（<code>iterator_category()</code>）。它想要知道迭代器的移动性质，比如有些迭代器只能往前走，有些迭代器能往后走。这样它才能采取最佳的移动方式。（图中序号1）</li><li><strong>距离</strong>（<code>difference_type</code>）。就是两个迭代器指针间的距离，应该用什么<strong>type</strong>来表现。（图中序号2）</li><li><strong>类型</strong>（<code>value_type</code>）。即迭代器指向的容器的类型。（图中序号3）</li><li><strong>指针</strong>。从未在C++标准库中被使用。</li><li><strong>引用</strong>。从未在C++标准库中被使用。</li></ul><p>关于这五种的<strong>迭代器关联类型</strong>，具体看下图：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/04d6adf9cc6b1a8ab5807b0356085659-656e3.png" alt="迭代器关联类型"></p><p>以上的方式只有迭代器为class类型时，算法才能获取<strong>迭代器关联类型</strong>。因为标准库的算法是个函数模板，传迭代器和指针都可以，所以当迭代器是指针类型时，以上的处理方式是错误的。为了能应对不同类型的迭代器，算法可以使用萃取机制（<code>iterator_traits</code>），来获取所需信息。</p><h5 id="萃取机制"><a href="#萃取机制" class="headerlink" title="萃取机制"></a>萃取机制</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5255bf7b118a98cb8fbc6e777ffe8c3f-8ffdd.png" alt="萃取机制"></p><p>萃取机中使用了模板偏特化统一了接口：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/fa0e9abfd730734cd7ed183ac9aa76ae-15879.png" alt="萃取机中使用了模板偏特化"></p><p>注意<strong>const指针</strong>的传入，具体看上图右下角。</p><h6 id="萃取机例子"><a href="#萃取机例子" class="headerlink" title="萃取机例子"></a>萃取机例子</h6><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/299e805e56c24b3f39926f39d1fa84a8-1aa6f.png" alt="萃取机例子"></p><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><ul><li><p>TR1是C++过渡版本</p></li><li><p>创建Array时必须指定Array大小 </p></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/0d80554f3f92f6215d591158ced0157b-a0c91.png" alt="必须指定大小"></p><p>和Vector一样，Array的指针也是<code>native pointer</code>。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/43a93960338ab9efbfe3c104646baf22-14cd4.png" alt="Array"></p><h3 id="Forward-List"><a href="#Forward-List" class="headerlink" title="Forward-List"></a>Forward-List</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/cf072de20e41d9542dbd366698ea944e-0bdc6.png" alt="Forward-List"></p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><h4 id="向量结构"><a href="#向量结构" class="headerlink" title="向量结构"></a>向量结构</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f2f9fb58f888ffc9ab8f7f330a6b5bef-40eb7.png" alt="容器"></p><ul><li>向量为倍增式扩容。mscv下是1.5倍扩容,gnu c上是2倍扩容</li><li>向量用三个指针（迭代器）控制整个容器，其中<ul><li><code>start</code>：指向向量起始位置</li><li><code>finish</code>：元素最后一个元素的下一个地址</li><li><code>end_of_storage</code>：指向向量的最后一个位置</li></ul></li><li>向量的一些量化指标：<ul><li><code>size</code>：向量中的元素个数</li><li><code>capacity</code>：向量的最大容量</li></ul></li><li><code>vector</code>需要注意迭代器失效，失效的时机出现在<code>vector</code>在<code>push_back</code>一个新元素后，可能发生的倍增扩容。所以当扩容发生时，由于<code>vector</code>更换了存放位置，指向原来位置的迭代器会失效。比如在更换位置之前，使用某个变量存储了迭代器。</li></ul><p>G4.9版本：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7900b61baeb08459c96f5ec131302b85-85010.png" alt="G4.9版本："></p><h4 id="向量扩容示范"><a href="#向量扩容示范" class="headerlink" title="向量扩容示范"></a>向量扩容示范</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/c0640655601dcb97f9b843aa79b75bfd-a5b6d.png" alt="向量扩容示范"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/fa25a0efee12df1a7217ba4c3dc8fc3e-b3b72.png" alt="向量扩容示范"></p><h4 id="向量的迭代器"><a href="#向量的迭代器" class="headerlink" title="向量的迭代器"></a>向量的迭代器</h4><p>向量的迭代器实际上就是个指针，因为向量在物理空间上连续，可以随机访问，指针完全能应付。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/4357a1735241c0f4cf7b3337675d956f-6790e.png" alt="向量的迭代器"></p><p><strong>向量迭代器实质：使用适配器模式包装了<code>_Tp*</code>。</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9c0c3d525067662be0409430e3292dc5-320b0.png" alt="向量的迭代器"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/bc3b907f33ed8b45e0e48b829e291481-a2259.png" alt="向量迭代器"></p><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9de2d27b24e5bb52cd08544ed87c55cf-1f51e.png" alt="deque"></p><p>注意：控制中心的map是指向vector的，以后也是2倍增长。（map左右两边一般留有剩余空间，用于前后插入元素）。</p><p>参考：<a href="https://blog.csdn.net/JMW1407/article/details/106930972">C++ 标准模板库（STL）_序列式容器—— deque(模拟连续空间)（侯捷老师）</a></p><ol><li><p>map在初始化时会预留前后两个节点，并将start和finish迭代器指向map的存放数据的头尾区域。</p></li><li><p>在元素插入/删除时如果越过缓冲区，那么下一个/该缓冲区将会被申请/释放。</p></li><li>deque主要使用迭代器来模拟连续空间，迭代器的主要参数为：</li></ol><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// 保持与容器的联结</span><br>  T* cur;       <span class="hljs-comment">// 此迭代器所指之缓冲区中的现行元素</span><br>  T* first;     <span class="hljs-comment">// 此迭代器所指之缓冲区的头</span><br>  T* last;      <span class="hljs-comment">// 此迭代器所指之缓冲区的尾（含备用空间）</span><br>  map_pointer node; <span class="hljs-comment">//指向管控中心</span><br></code></pre></div></td></tr></table></figure><ol><li>保持连续性的关键在于源代码中的迭代器做了大量的操作符重载。</li><li>插入操作若不在两端，那么将会计算插入点离前后的距离谁比较短，取短的区域进行位移。</li></ol><h4 id="stack和queue"><a href="#stack和queue" class="headerlink" title="stack和queue"></a>stack和queue</h4><ul><li><p>stack内含了一个deque底层容器，所有事情交由deque去做：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">tmpplate&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>,<span class="hljs-keyword">class</span> <span class="hljs-title">Sequence</span> =</span> deque&lt;T&gt;&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">stack</span>&#123;</span><br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>stack和queue都可以选择list或deque作为底层容器，但是默认的deque速度会比较快。原因是list需要执行new操作，这种操作是普通语句的两百倍左右的时间，所以用deque。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">stack&lt;string,list&lt;string&gt;&gt; c;<br>queue&lt;string,list&lt;string&gt;&gt; c;<br></code></pre></div></td></tr></table></figure></li><li><p>stack和queue都不允许遍历，也不提供iterator。</p></li><li><p>stack可选择vector作为底层结构，但是queue不可选择vector作为底层结构（虽然编译器会通过，但是当queue使用pop行为时，编译器会报错，因为编译器只会做局部检查，就是你用了什么编译器就会检查什么）。</p></li><li><p>stack和queue都不可以选择set或map做底层结构（编译器也会通过，但是不能用，原因同上）。</p></li></ul><h3 id="RB-TREE"><a href="#RB-TREE" class="headerlink" title="RB-TREE"></a>RB-TREE</h3><ul><li>我们不应使用红黑树的迭代器改变元素值（因为元素有严谨的排列规则）。编程层面并未阻止此事。如此设计是正确的，因为红黑树即将为set和map服务（作为其底部支持），而map允许元素的data被改变，只有元素的key才是不可以被改变的。</li><li>红黑树提供遍历操作以及迭代器，按正常规则++遍历，便能获得排序状态。</li><li>红黑树提供两种插入操作：<code>insert_unique()</code>和<code>insert_equal()</code>。<ul><li>insert_unique()：key一定在树中独一无二。</li><li>insert_equal()：key一定在树中可以重复。</li></ul></li><li>节点value包含了key和data。key为标识，data是数据的组合。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/98f547d907431f6fe65ca78692299d05-f4830.png"  /></p><ul><li><p>红黑树的初始化所需要的参数中：</p><ul><li><p>keyofvalue：告诉红黑树，key要怎么拿。</p></li><li><p>compare：两个元素怎么比大小。</p></li></ul></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7dc9204bb800fef539f165e869569856-1059b.png" alt="红黑树的结构中"></p><ul><li><p>红黑树的结构中：</p><ul><li><p>node_count：节点数量</p></li><li><p>header：红黑树的头节点</p></li><li><p>key_compare：key的大小比较规则，应该是各function object。注意：仿函数的理论大小为0，因为它没有任何的数据。但是编译器会把它的大小变为1。因为编译器对于大小为0的class，编译出来的大小永远为1。</p></li></ul></li></ul><h4 id="set和multiset"><a href="#set和multiset" class="headerlink" title="set和multiset"></a>set和multiset</h4><ul><li>set和multiset都以红黑树作为底层结构，因此有元素自动排序的特性。排序的依据是key，而set和multiset的value和key二合一，也就是说value就是key。</li><li>set和multiset提供遍历操作以及迭代器，按照正常规则++遍历，便能获得排序状态。</li><li>我们无法使用set和multiset的迭代器改变元素值（因为key有严谨的排序规则）。set和multiset的迭代器是const类型的迭代器，所以无法改变元素内容。</li><li>set元素的key必须独一无二，因此它的<code>insert()</code>是红黑树的<code>insert_unique()</code>。</li><li>multiset的key可以重复，因此它的<code>insert()</code>是红黑树的<code>insert_equal()</code>。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/226616eb2ac701fa588539126010962a-e27d3.png" alt="set和multiset"></p><h4 id="map和multimap"><a href="#map和multimap" class="headerlink" title="map和multimap"></a>map和multimap</h4><ul><li>map/multimap以红黑树为底层结构。因此有元素自动排序特性。排序的依据是key。</li><li>map/multimap提供遍历操作及迭代器。按照正常规则++遍历，就能获得排序状态。</li><li>我们无法使用map/multimap的迭代器改变元素的key，但可以用它来改变元素的data。因此map/multimap内部自动将user指定的key type设为const，如此便能禁止user对元素的key赋值。即map构造RB-Tree的过程中，将<code>Key</code>和<code>T</code>组成了<code>pair&lt;const Key,T&gt;</code>传入了RB-Tree。</li><li>set元素的key必须独一无二，因此它的<code>insert()</code>是红黑树的<code>insert_unique()</code>。</li><li>multimap的key可以重复，因此它的<code>insert()</code>是红黑树的<code>insert_equal()</code>。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/09daead3d61f70f9e1c77fffde7773dc-57418.png" alt="map和multimap"></p><ul><li>multimap无法使用<code>[]</code>做插入，但是map可以。map的<code>operator[]</code>的操作是：如果找到该元素，便返回。若没有找到，就在map中合适的地方创建一个。<img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/2ef03b91b6d7aa257b7b8e3b027eefb8-7dd08.png" alt="map"></li></ul><h3 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/76b4b14163eb272f541bfe777f2532f8-c19db.png" style="zoom:50%;" /></p><ul><li>如果挂的链表太长的话，就要把它们打散，变成散列表。</li><li>如果元素个数比桶的个数还要多，就很危险。这种情况下就把桶增加两倍。然后重新将元素放进桶里。 <strong>所以桶的数量永远大于元素个数。</strong></li><li>翻倍(<strong>rehash</strong>)的原则是：原来的桶数量为53，那么就先翻倍成106，再找到离106最近最小的质数97。</li><li>桶中元素越少，查找和插入速度越快。所以有时候需要翻倍处理。</li><li>桶的数量已经写死了。<img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/269af63212907508fb2d06d575a17b06-ffe8e.png" style="zoom: 50%;" /></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/c3f6b7978fec1d67994c72d1affb0968-13938.png" style="zoom:50%;" /></p><ul><li><code>ExtractKey</code>：如何获取存储数据的Key，即仿函数</li><li><code>EqualKey</code>：如何比较两个Key相等，即仿函数</li><li><p>标准库提供了针对基本类型的hash函数，实质上就是把传入的东西再返回。而<code>char*</code>和<code>string</code>会通过一些换算形成哈希值。</p></li><li><p><strong>unordered</strong>容器的底层就是<strong>hashtable</strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>腾讯云访问github</title>
    <link href="/2020/08/26/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AE%BF%E9%97%AEgithub/"/>
    <url>/2020/08/26/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AE%BF%E9%97%AEgithub/</url>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo vi /etc/hosts<br></code></pre></div></td></tr></table></figure><p>添加：</p><figure class="highlight accesslog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs accesslog"># github<br><span class="hljs-number">204.232.175.78</span> http://documentcloud.github.com<br><span class="hljs-number">207.97.227.239</span> http://github.com<br><span class="hljs-number">204.232.175.94</span> http://gist.github.com<br><span class="hljs-number">107.21.116.220</span> http://help.github.com<br><span class="hljs-number">207.97.227.252</span> http://nodeload.github.com<br><span class="hljs-number">199.27.76.130</span> http://raw.github.com<br><span class="hljs-number">107.22.3.110</span> http://status.github.com<br><span class="hljs-number">204.232.175.78</span> http://training.github.com<br><span class="hljs-number">207.97.227.243</span> http://www.github.com<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Picgo设置腾讯云COS图床</title>
    <link href="/2020/08/09/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Picgo%E8%AE%BE%E7%BD%AE%E8%85%BE%E8%AE%AF%E4%BA%91COS%E5%9B%BE%E5%BA%8A/"/>
    <url>/2020/08/09/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Picgo%E8%AE%BE%E7%BD%AE%E8%85%BE%E8%AE%AF%E4%BA%91COS%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="1-设置COS版本"><a href="#1-设置COS版本" class="headerlink" title="1. 设置COS版本"></a>1. 设置COS版本</h2><p>设置为v5</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-04_18-43-06.png" alt="设置COS版本"></p><h2 id="2-设置SecretId、SecretKey和APPID"><a href="#2-设置SecretId、SecretKey和APPID" class="headerlink" title="2. 设置SecretId、SecretKey和APPID"></a>2. 设置SecretId、SecretKey和APPID</h2><p>打开腾讯云COS控制台，进入API密钥管理。找到<strong>SecretId</strong>、<strong>SecretKey</strong>和<strong>APPID</strong>并填入。若无密钥请先新建。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-04_18-44-10.png" alt="密钥管理"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-04_18-45-34.png" alt="密钥管理"></p><h2 id="3-设置存储空间名和存储区域"><a href="#3-设置存储空间名和存储区域" class="headerlink" title="3. 设置存储空间名和存储区域"></a>3. 设置存储空间名和存储区域</h2><p>创建存储桶时，关键的一步是要将权限设置为公有读私有写。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-04_18-52-11.png" alt="创建存储桶"></p><p><strong>存储空间名</strong>填入<strong>存储桶名称</strong>，然后<strong>存储区域</strong>填入<strong>所属地域</strong>，后面括号里面的内容。比如我的是ap-shanghai。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-04_18-53-10.png" alt="存储桶列表"></p><h2 id="4-设置指定存储路径"><a href="#4-设置指定存储路径" class="headerlink" title="4. 设置指定存储路径"></a>4. 设置指定存储路径</h2><p>这个存储路径指的是，你上传的文件在COS存储桶中所存放的位置。比如我的存储桶名称是左上角的images-12577xxxxx，然后我在这个存储桶中创建了一个blogs文件夹。现在我想把我上传的图片放在blogs文件夹里，那PicGo中的存储路径就要填入<strong>blogs/</strong>(bilogs后面的<strong>/</strong>不能省略)。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-04_18-55-26.png" alt="设置指定存储路径"></p><h2 id="5-设定自定义域名"><a href="#5-设定自定义域名" class="headerlink" title="5. 设定自定义域名"></a>5. 设定自定义域名</h2><p>这个自定义域名与PicGo在你上传图片成功后返回的网址相关，格式为<strong><a href="https://存储桶名称.cos.存储区域.myqcloud.com">https://存储桶名称.cos.存储区域.myqcloud.com</a></strong>。</p><p>比如我的是<a href="https://images-1257780535.cos.ap-shanghai.myqcloud.com。">https://images-1257780535.cos.ap-shanghai.myqcloud.com。</a></p><p>当我上传图片以后，PicGo返回给我一个<strong><a href="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-04_18-55-26.png">https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-04_18-55-26.png</a></strong>这个网址，将这个网址粘贴到你写的markdown文件即可。</p><h2 id="6-最终效果"><a href="#6-最终效果" class="headerlink" title="6. 最终效果"></a>6. 最终效果</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210204192315.png" alt="最终效果1"  /></p><p>图片上传后，在腾讯云COS中的指定路径下能找到上传的图片，就说明成功了。</p>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图床</tag>
      
      <tag>腾讯云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Clion配置git</title>
    <link href="/2020/05/21/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Clion%E9%85%8D%E7%BD%AEgit/"/>
    <url>/2020/05/21/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Clion%E9%85%8D%E7%BD%AEgit/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文标题虽然是CLion配置Git，但是亲测全家桶下的其他软件也能按照同样的方法进行配置</p><p>在开始之前，需要确保你有Git账号且在本地环境已经配置好Git</p><h2 id="1-创建本地仓库"><a href="#1-创建本地仓库" class="headerlink" title="1. 创建本地仓库"></a>1. 创建本地仓库</h2><p>打开CLion，导航栏-&gt;VCS-&gt;Create Git Repository，选择你需要作为Git仓库的文件夹</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416141113.png" alt="选择文件夹"></p><p>之后打开我们选择的文件夹，发现已经被初始化</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416141350.png" alt="文件夹被初始化"></p><p>然后CLion的导航栏也相应发生了变化</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416141442.png" alt="导航栏变化"></p><h2 id="2-关联远程仓库"><a href="#2-关联远程仓库" class="headerlink" title="2. 关联远程仓库"></a>2. 关联远程仓库</h2><p>先复制我们Github上需要关联仓库的地址</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416142138.png" alt="点击复制"></p><p>接着打开CLion，依次Git-&gt;Manage Remotes</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416141653.png" alt="Manage Remotes"></p><p>点击加号，将刚才复制的git地址填入并确认</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416142253.png" alt="填入地址"></p><p>等待即可</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416142357.png" alt="等待"></p><h2 id="3-使用方法"><a href="#3-使用方法" class="headerlink" title="3. 使用方法"></a>3. 使用方法</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416155818.png" alt="提交"></p>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>IDE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>问题归纳</title>
    <link href="/2020/05/11/C++/%E9%97%AE%E9%A2%98%E5%BD%92%E7%BA%B3/"/>
    <url>/2020/05/11/C++/%E9%97%AE%E9%A2%98%E5%BD%92%E7%BA%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="引用的生命周期？"><a href="#引用的生命周期？" class="headerlink" title="引用的生命周期？"></a>引用的生命周期？</h2><h2 id="友元函数是类成员函数吗？"><a href="#友元函数是类成员函数吗？" class="headerlink" title="友元函数是类成员函数吗？"></a>友元函数是类成员函数吗？</h2><p>不是，友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。</p><p>参考：<a href="https://www.runoob.com/cplusplus/cpp-friend-functions.html">C++ 友元函数</a></p><h2 id="如何判断操作符重载放在类里还是类外？"><a href="#如何判断操作符重载放在类里还是类外？" class="headerlink" title="如何判断操作符重载放在类里还是类外？"></a>如何判断操作符重载放在类里还是类外？</h2><p>赋值（=）、下标（[]）、调用（()）和成员访问箭头（-&gt;）运算符必须是成员（函数）。</p><p>参考：<a href="https://blog.csdn.net/qq_29344757/article/details/78820189">为什么有的操作符重载函数只能是成员函数?</a></p><h2 id="初始化列表的优势体现在哪里？"><a href="#初始化列表的优势体现在哪里？" class="headerlink" title="初始化列表的优势体现在哪里？"></a>初始化列表的优势体现在哪里？</h2><ol><li>类成员中存在常量，如<code>const int a</code>,只能用初始化不能复制</li><li>类成员中存在引用，同样只能使用初始化不能赋值</li><li>提高效率</li></ol><p>参考：<a href="https://www.cnblogs.com/wuyepeng/p/9863763.html">使用初始化列表的好处</a></p><h2 id="为什么要虚的析构函数？"><a href="#为什么要虚的析构函数？" class="headerlink" title="为什么要虚的析构函数？"></a>为什么要虚的析构函数？</h2><p>这样做是为了当<strong>用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用</strong>。当然，<strong>并不是要把所有类的析构函数都写成虚函数</strong>。因为当类里面有虚函数的时候，编译器会给类添加一个虚函数表，里面来存放虚函数指针，这样就会增加类的存储空间。所以，只有<strong>当一个类被用来作为基类的时候，才把析构函数写成虚函数</strong>。</p><p>参考：<a href="https://blog.csdn.net/zhangjingyangguang/article/details/21549991">为什么要用虚析构函数</a></p><h2 id="什么叫做对象切割？"><a href="#什么叫做对象切割？" class="headerlink" title="什么叫做对象切割？"></a>什么叫做对象切割？</h2><h2 id="什么叫做编译转换？"><a href="#什么叫做编译转换？" class="headerlink" title="什么叫做编译转换？"></a>什么叫做编译转换？</h2><h2 id="返回值的生命周期"><a href="#返回值的生命周期" class="headerlink" title="返回值的生命周期"></a>返回值的生命周期</h2><h2 id="操作符重载作为成员函数和非成员函数时的优缺点"><a href="#操作符重载作为成员函数和非成员函数时的优缺点" class="headerlink" title="操作符重载作为成员函数和非成员函数时的优缺点"></a>操作符重载作为成员函数和非成员函数时的优缺点</h2><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><h2 id="为什么要用基类指针指向派生类？"><a href="#为什么要用基类指针指向派生类？" class="headerlink" title="为什么要用基类指针指向派生类？"></a>为什么要用基类指针指向派生类？</h2><p>在基类与派生类之间，有一个<strong>规定</strong>：派生类对象的地址可以赋给指向基类对象的指针变量（简称<strong>基类指针</strong>），即基类指针也可以指向派生类对象。为什么有这一规定呢？因为它可以实现<strong>多态性</strong>，即向不同的对象发送同一个消息，不同的对象在接受时会产生不同的行为。</p><p>基类指针可以指向基类对象；派生类指针可以指向派生类对象；基类指针可以指向派生类对象（无需强制转换），但只能引用基类中有的成员； 派生类指针指向基类对象，会引发语法错误。但派生类指针通过强制转换可指向基类对象。可是该动作很危险：若引用对象中不村在的派生类成员，会得到错误的结果。</p><p>参考：<a href="https://blog.csdn.net/hk121/article/details/81165391">为什么要用基类指针指向派生类对象？</a></p><h2 id="动态联编和静态联编"><a href="#动态联编和静态联编" class="headerlink" title="动态联编和静态联编"></a>动态联编和静态联编</h2><h2 id="向上转型和向下转型"><a href="#向上转型和向下转型" class="headerlink" title="向上转型和向下转型"></a>向上转型和向下转型</h2><h2 id="释放一个空指针会有什么问题"><a href="#释放一个空指针会有什么问题" class="headerlink" title="释放一个空指针会有什么问题"></a>释放一个空指针会有什么问题</h2><h2 id="c-类的内存模型"><a href="#c-类的内存模型" class="headerlink" title="c++类的内存模型"></a>c++类的内存模型</h2><h2 id="内存分配中的cookie"><a href="#内存分配中的cookie" class="headerlink" title="内存分配中的cookie"></a>内存分配中的cookie</h2><p>在malloc为用户分配内存的时候，除了分配用户本身的内存，还会在内存前后加上两个cookie，来记录分配了多少内存，这样在调用free函数的时候才能准确的回收内存。因此每次调用malloc函数都会产生cookie消耗。</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/338043328">C++内存管理（malloc和free中的cookie）</a></p><h2 id="Debug模式下多出来的内存空间干嘛用？Debugger-Header、no-man-land？"><a href="#Debug模式下多出来的内存空间干嘛用？Debugger-Header、no-man-land？" class="headerlink" title="Debug模式下多出来的内存空间干嘛用？Debugger Header、no man land？"></a>Debug模式下多出来的内存空间干嘛用？Debugger Header、no man land？</h2><h2 id="静态数据什么时候会被创建"><a href="#静态数据什么时候会被创建" class="headerlink" title="静态数据什么时候会被创建"></a>静态数据什么时候会被创建</h2><h2 id="纯虚函数的定义"><a href="#纯虚函数的定义" class="headerlink" title="纯虚函数的定义"></a>纯虚函数的定义</h2><h2 id="C-子类拥有和父类的同名非虚函数会发生什么情况？"><a href="#C-子类拥有和父类的同名非虚函数会发生什么情况？" class="headerlink" title="C++子类拥有和父类的同名非虚函数会发生什么情况？"></a>C++子类拥有和父类的同名非虚函数会发生什么情况？</h2><h2 id="C-函数签名"><a href="#C-函数签名" class="headerlink" title="C++函数签名"></a>C++函数签名</h2><h2 id="栈对象如何向上转型"><a href="#栈对象如何向上转型" class="headerlink" title="栈对象如何向上转型"></a>栈对象如何向上转型</h2><h2 id="C-中的原子对象"><a href="#C-中的原子对象" class="headerlink" title="C++中的原子对象"></a>C++中的原子对象</h2><h2 id="C-中的reorder"><a href="#C-中的reorder" class="headerlink" title="C++中的reorder"></a>C++中的reorder</h2><h2 id="C-的异常和底层机制"><a href="#C-的异常和底层机制" class="headerlink" title="C++的异常和底层机制"></a>C++的异常和底层机制</h2><h2 id="C-abort"><a href="#C-abort" class="headerlink" title="C++abort()"></a>C++abort()</h2><h2 id="C-List为什么会有maxsize"><a href="#C-List为什么会有maxsize" class="headerlink" title="C++List为什么会有maxsize?"></a>C++List为什么会有maxsize?</h2><h2 id="C-泛化指针"><a href="#C-泛化指针" class="headerlink" title="C++泛化指针"></a>C++泛化指针</h2><h2 id="C-的malloc详解"><a href="#C-的malloc详解" class="headerlink" title="C++的malloc详解"></a>C++的malloc详解</h2><h2 id="C-序列化"><a href="#C-序列化" class="headerlink" title="C++序列化"></a>C++序列化</h2><h2 id="C-访问级别底层原理？"><a href="#C-访问级别底层原理？" class="headerlink" title="C++访问级别底层原理？"></a>C++访问级别底层原理？</h2><h2 id="C-override"><a href="#C-override" class="headerlink" title="C++override?"></a>C++override?</h2><h2 id="C-如何充分利用CPU时间片？"><a href="#C-如何充分利用CPU时间片？" class="headerlink" title="C++如何充分利用CPU时间片？"></a>C++如何充分利用CPU时间片？</h2><h2 id="C-类中的typedef以及它的空间占用和底层实现？"><a href="#C-类中的typedef以及它的空间占用和底层实现？" class="headerlink" title="C++类中的typedef以及它的空间占用和底层实现？"></a>C++类中的typedef以及它的空间占用和底层实现？</h2><h2 id="C-引用折叠？"><a href="#C-引用折叠？" class="headerlink" title="C++引用折叠？"></a>C++引用折叠？</h2><h2 id="C-嵌入式指针？"><a href="#C-嵌入式指针？" class="headerlink" title="C++嵌入式指针？"></a>C++嵌入式指针？</h2><h2 id="C-类的静态函数能直接被调用吗？"><a href="#C-类的静态函数能直接被调用吗？" class="headerlink" title="C++类的静态函数能直接被调用吗？"></a>C++类的静态函数能直接被调用吗？</h2><p>答：可以。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符:: 就可以访问。 静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。 静态成员函数有一个类范围，他们不能访问类的this 指针。</p><h2 id="C-typename"><a href="#C-typename" class="headerlink" title="C++typename"></a>C++typename</h2><ul><li>typename在下面情况下禁止使用：<ul><li>模板定义之外，即typename只能用于模板的定义中</li><li>非限定类型，比如前面介绍过的<code>int</code>，<code>vector&lt;int&gt;</code>之类</li><li>基类列表中，比如<code>template &lt;class T&gt; class C1 : T::InnerType</code>不能在<code>T::InnerType</code>前面加typename</li><li>构造函数的初始化列表中</li></ul></li><li>如果类型是依赖于模板参数的限定名，那么在它之前<strong>必须</strong>加typename(除非是基类列表，或者在类的初始化成员列表中)</li><li>其它情况下typename是<strong>可选</strong>的，也就是说对于一个不是依赖名的限定名，该名称是可选的，例如<code>vector&lt;int&gt; vi;</code></li></ul><p>参考：<a href="https://feihu.me/blog/2014/the-origin-and-usage-of-typename/">知无涯之C++ typename的起源与用法</a></p><h2 id="C-volatile"><a href="#C-volatile" class="headerlink" title="C++volatile?"></a>C++volatile?</h2><p>一般说来，volatile用在如下的几个地方：</p><ul><li>中断服务程序中修改的供其它程序检测的变量需要加 volatile；</li><li>多任务环境下各任务间共享的标志应该加 volatile；</li><li>存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对它的读写都可能由不同意义；</li></ul><p>参考：<a href="https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777432.html">C/C++中volatile关键字详解</a></p><h2 id="C-创建对象用中括号"><a href="#C-创建对象用中括号" class="headerlink" title="C++创建对象用中括号{}"></a>C++创建对象用中括号{}</h2><h2 id="C-如何刷新缓冲区及其原理"><a href="#C-如何刷新缓冲区及其原理" class="headerlink" title="C++如何刷新缓冲区及其原理"></a>C++如何刷新缓冲区及其原理</h2><h2 id="在C-拷贝构造函数中使用初始化列表"><a href="#在C-拷贝构造函数中使用初始化列表" class="headerlink" title="在C++拷贝构造函数中使用初始化列表"></a>在C++拷贝构造函数中使用初始化列表</h2><p>参考：<a href="https://blog.csdn.net/justin12zhu/article/details/9174491">在C++拷贝构造函数中使用初始化列表</a></p><h2 id="C-释放一个空指针？"><a href="#C-释放一个空指针？" class="headerlink" title="C++释放一个空指针？"></a>C++释放一个空指针？</h2><h2 id="C-中进程的栈空间为多少？"><a href="#C-中进程的栈空间为多少？" class="headerlink" title="C++中进程的栈空间为多少？"></a>C++中进程的栈空间为多少？</h2><h2 id="C-中被调用函数如何被释放？返回值在什么时候被获取？"><a href="#C-中被调用函数如何被释放？返回值在什么时候被获取？" class="headerlink" title="C++中被调用函数如何被释放？返回值在什么时候被获取？"></a>C++中被调用函数如何被释放？返回值在什么时候被获取？</h2><h2 id="断言和异常的区别和使用场景"><a href="#断言和异常的区别和使用场景" class="headerlink" title="断言和异常的区别和使用场景?"></a>断言和异常的区别和使用场景?</h2>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows环境下的git配置</title>
    <link href="/2020/04/16/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84git%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/04/16/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84git%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="1-软件的安装"><a href="#1-软件的安装" class="headerlink" title="1.软件的安装"></a>1.软件的安装</h2><h3 id="1-1-软件下载"><a href="#1-1-软件下载" class="headerlink" title="1.1 软件下载"></a>1.1 软件下载</h3><p>下载地址：<a href="http://www.git-scm.com/download/">http://www.git-scm.com/download/</a></p><h3 id="1-2-软件安装"><a href="#1-2-软件安装" class="headerlink" title="1.2 软件安装"></a>1.2 软件安装</h3><p>配置详情：<a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html">https://www.cnblogs.com/xueweisuoyong/p/11914045.html</a></p><h2 id="2-SSH的配置"><a href="#2-SSH的配置" class="headerlink" title="2.SSH的配置"></a>2.SSH的配置</h2><h3 id="1-1-设置公钥私钥（若已有请跳过）"><a href="#1-1-设置公钥私钥（若已有请跳过）" class="headerlink" title="1.1 设置公钥私钥（若已有请跳过）"></a>1.1 设置公钥私钥（若已有请跳过）</h3><p>打开CMD，输入<strong>ssh-keygen -t rsa -C “你的邮箱地址”</strong>，按照提示输入并完成。</p><h3 id="1-2-设置Git"><a href="#1-2-设置Git" class="headerlink" title="1.2 设置Git"></a>1.2 设置Git</h3><p>打开Git CMD，输入<strong>git config —global user.name “用户名”</strong>，<strong>git config —global user.email “你的邮箱地址”</strong>。</p><h3 id="1-3-设置github"><a href="#1-3-设置github" class="headerlink" title="1.3 设置github"></a>1.3 设置github</h3><p>打开github个人主页，在右上角的头像里选择<strong>Settings</strong>，然后依次<strong>SSH and GPG keys</strong>-&gt;<strong>New SSH key</strong>。其中Title中写一个适当的标题，再将本地电脑<strong>C:\Users.ssh\id_rsa.pub</strong>中的内容复制到Key里面即可。</p>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存对齐</title>
    <link href="/2020/01/27/C++/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    <url>/2020/01/27/C++/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是内存对齐"><a href="#什么是内存对齐" class="headerlink" title="什么是内存对齐"></a>什么是内存对齐</h2><p>内存对齐（Memory alignment），也叫字节对齐。现代计算机中内存空间都是按照 Byte 划分的，CPU按照双字、字、字节访问存储内存，并通过总线进行传输（CPU把内存当成是一块一块的，块的大小可以是2、4、8、16字节大小，因此CPU在读取内存时是一块一块进行读取的。）。从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问<strong>特定类型变量</strong>(结构体、联合体等)的时候经常在<strong>特定的内存地址</strong>访问，这就需要各种类型数据按照<strong>一定的规则</strong>在空间上排列，而不是顺序的一个接一个的摆放。若未经一定规则的对齐，CPU的访址操作与总线的传输操作将会异常的复杂，所以现代编译器中都会对内存进行自动的对齐。</p><p><strong>假设</strong><br>在结构体里面有一个整型变量 a。CPU如果想取出结构体里面的变量a，首先装载结构体的首地址，然后根据偏移地址获得变量a：</p><ol><li>在内存对齐的情况下（如图1），由于变量a从偏移地址为 “0” 的位置开始，所以CPU获取a只需一步就能完成。</li><li>在内存未对齐的情况下（如图2），由于变量a从偏移地址 “2” 的位置开始，所以CPU需要先获取 “0” - “3” 内存地址里面的值，并取出其中的 “2” - “3” 中的内容。接着再获取 “4” - “7” 内存地址里面的值，并取出 “4” - “5” 中的内容。最后，将前后两次操作取得的最终值拼接，就获得了变量a。<br><img src="https://img-blog.csdnimg.cn/20200817155349568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkzOTQ4Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="内存"><br>显而易见，CPU在处理两种情况下的内存，效率和时间的差距是非常大的。</li></ol><h2 id="内存对齐的规则"><a href="#内存对齐的规则" class="headerlink" title="内存对齐的规则"></a>内存对齐的规则</h2><ol><li>数据成员对齐规则：第一个数据成员从<strong>特定类型变量</strong>的起始地址(即偏移量为0)开始存放。之后每个数据成员的偏移量K，由<strong>内存对齐系数</strong>和<strong>该数据成员长度</strong>之间最小的数值M的非负整数倍N决定。总结下来就是：K = M * N。如有需要，编译器会在数据成员之间加上填充字节(internal adding)。</li><li>特定类型变量对齐规则：在数据成员完成各自对齐之后，<strong>特定类型变量</strong>本身也要进行对齐。编译器会从<strong>内存对齐系数</strong>和<strong>该特定类型变量中，最大的数据成员的长度</strong>中取得最小值M。与数据成员对齐规则类似，整个特定类型变量的长度是M的非负整数倍N。即满足：sizeof(<em>特定类型变量</em>) = M * N。如有需要，编译器会在最后一个数据成员之后加上填充字节(trailing padding)。</li></ol><h2 id="内存对齐实例"><a href="#内存对齐实例" class="headerlink" title="内存对齐实例"></a>内存对齐实例</h2><h3 id="几个简单的例子"><a href="#几个简单的例子" class="headerlink" title="几个简单的例子"></a>几个简单的例子</h3><h4 id="类的内存对齐"><a href="#类的内存对齐" class="headerlink" title="类的内存对齐"></a>类的内存对齐</h4><h5 id="pragma-pack-n"><a href="#pragma-pack-n" class="headerlink" title="#pragma pack(n)"></a>#pragma pack(n)</h5><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">st1</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">char</span> a;<br><span class="hljs-keyword">int</span>  b;<br><span class="hljs-keyword">short</span> c;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">st2</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">short</span> c;<br><span class="hljs-keyword">char</span>  a;<br><span class="hljs-keyword">int</span>   b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;sizeof(st1) is &quot;</span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(st1) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sizeof(st2) is &quot;</span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(st2) &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(st1) is <span class="hljs-number">12</span><br><span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(st2) is <span class="hljs-number">8</span><br></code></pre></div></td></tr></table></figure><p>由上，我们发现两个问题：</p><ol><li>st1和st2两个结构体sizeof的值不应该都是1(char)+4(int)+2(short)=7byte吗？</li><li><p>st1和st2两个结构体的数据成员完全一样，只是它们的摆放(声明)顺序不一样，为什么最后sizeof出来的结果会不一样？</p><p>根据前文关于内存对齐的描述，我们可以这样解决(VC6默认内存对齐系数为8，以下未指定的内存对齐系数皆为8)：</p><p><strong>结构体st1内存分配过程（结果如下图）</strong></p></li><li>char a ：因为是第一个数据成员，所以它的偏移地址为”0”。</li><li>int b ：内存对齐系数为8，而sizeof(int)为4，两者最小为4。根据规则1，变量b的偏移地址应该为4的非负整数倍。此时该内存块可分配的偏移地址有效值为 “1”…，但是显然，”1”、”2”、”3” 这三个偏移地址并不是4的非负整数倍，只有偏移地址 “4” 符合要求。所以，变量b的偏移地址是 “4”，内存空间为 “4” - “7” 一共四个字节。</li><li>由于变量a从 “0” 开始只占了一个字节，而变量b是从 “4” 开始的，所以”1” - “3” 这三块内存是空闲的。此时编译器会自动填充(这里暂时用0代替填充的值，下文同)，填充的值由编译器来决定(这也就是为什么memcmp不能用来比较两个结构体，memcmp是逐个字节对比的，当字节对齐时，中间的填充部分是随机的，所以比较的结果是不正确的)。</li><li>short c：内存对齐系数为8，而sizeof(short)为2，两者最小为2。根据规则1，变量c的偏移地址应该为2的非负整数倍。此时该内存块可分配的偏移地址有效值为 “8”…，而 “8” 正好符合条件，所以变量c的偏移地址为 “8” ，内存空间为 “8” - “9” 一共两个字节。</li><li>至此，st1中的三个数据成员已经全部分配完毕，接下来就要考虑整体对齐。因为内存对齐系数为8，而st1中最大的数据成员b的长度为4，所以两者中最小为4。此时sizeof(st1)为10，而10并不是4的非负整数倍，不符合规则2，所以编译器会在 “10” - “11” 自动填充，使sizeof(st1)为12，符合规则2。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200817122054212.png#pic_center" alt="str1"></p><p><strong>结构体st2内存分配过程（结果如下图）</strong></p><ol><li>short c ：因为是第一个数据成员，所以它的偏移地址为”0”，内存地址为 “0” - “1” 一共两个字节。</li><li>char a ：内存对齐系数为8，而sizeof(char)为1，两者最小为1。根据规则1，变量a的偏移地址应该为1的非负整数倍。此时该内存块可分配的偏移地址有效值为 “2”…，而偏移地址 “2” 正好符合要求。所以，变量a的偏移地址是 “2”，内存地址为 “2” 一共一个字节。</li><li>int b：内存对齐系数为8，而sizeof(int)为4，两者最小为4。根据规则1，变量b的偏移地址应该为4的非负整数倍。此时该内存块可分配的偏移地址有效值为 “3”…，显然, “3” 并不符合要求，而 “4” 符合要求。所以，变量b的偏移地址为 “4”,内存地址为 “4” - “7” 一共4个字节。</li><li>由于变量a从 “2” 开始只占了一个字节，而变量b是从 “4” 开始的，所以 “3” 这块内存是空闲的，编译器会自动填充。</li><li><p>至此，st2中的三个数据成员已经全部分配完毕，接下来就要考虑整体对齐。因为内存对齐系数为8，而st2中最大的数据成员b的长度为4，所以两者中最小为4。此时sizeof(st2)为8，而8是4的非负整数倍，符合规则2，所以编译器不做任何处理。</p><p><img src="https://img-blog.csdnimg.cn/20200817151951314.png#pic_center" alt="st2"></p></li></ol><h2 id="修改内存对齐系数"><a href="#修改内存对齐系数" class="headerlink" title="修改内存对齐系数"></a>修改内存对齐系数</h2><p>若需修改内存对齐系数，需用：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> pack(n) <span class="hljs-comment">// n为内存对齐系数</span></span><br></code></pre></div></td></tr></table></figure></p><blockquote><p>参考资料：<br><a href="https://zhuanlan.zhihu.com/p/93822540">C/C++中内存对齐问题的一些理解</a><br><a href="https://songlee24.github.io/2014/09/20/memory-alignment/">C/C++内存对齐</a><br><a href="https://blog.csdn.net/N1neDing/article/details/80202103">内存对齐——规则及原因</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>桥模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%EF%BC%9A%E6%A1%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%EF%BC%9A%E6%A1%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度，乃至多个纬度的变化。</li><li>如何应对这种“多维度的变化”？如何利用面向对象技术来使得类型可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>将抽象部分(业务功能)与实现部分(平台实现)分离，使它们都可以独立地变化。 ——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用桥模式之前：</strong></p><p><code>Messager</code>类为父类，由父类派生出来的类用来实现不同平台，而这些<strong>平台类</strong>派生出来的<strong>业务类</strong>，用于完善<strong>平台类</strong>。但是站在<code>Messager</code>的角度来看，<strong>平台类</strong>和<strong>业务类</strong>都是用来完善<code>Messager</code>类。所以<code>Messager</code>类中声明了<strong>平台类</strong>和<strong>业务类</strong>所需的纯虚函数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Messager</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(string username, string password)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(string message)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span></span>=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Messager</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//平台实现 个数n</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerBase</span> :</span> <span class="hljs-keyword">public</span> Messager&#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//**********</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//**********</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//**********</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//**********</span><br>    &#125;<br>&#125;;<br><span class="hljs-comment">//平台实现</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerBase</span> :</span> <span class="hljs-keyword">public</span> Messager&#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//==========</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//==========</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//==========</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//==========</span><br>    &#125;<br>&#125;;<br><br><br><span class="hljs-comment">//业务抽象 个数m</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerLite</span> :</span> <span class="hljs-keyword">public</span> PCMessagerBase &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(string username, string password)</span></span>&#123;<br>        <br>        PCMessagerBase::<span class="hljs-built_in">Connect</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(string message)</span></span>&#123;<br>        <br>        PCMessagerBase::<span class="hljs-built_in">WriteText</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span></span>&#123;<br>        <br>        PCMessagerBase::<span class="hljs-built_in">DrawShape</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerPerfect</span> :</span> <span class="hljs-keyword">public</span> PCMessagerBase &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(string username, string password)</span></span>&#123;<br>        <br>        PCMessagerBase::<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        PCMessagerBase::<span class="hljs-built_in">Connect</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(string message)</span></span>&#123;<br>        <br>        PCMessagerBase::<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        PCMessagerBase::<span class="hljs-built_in">WriteText</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span></span>&#123;<br>        <br>        PCMessagerBase::<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        PCMessagerBase::<span class="hljs-built_in">DrawShape</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerLite</span> :</span> <span class="hljs-keyword">public</span> MobileMessagerBase &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(string username, string password)</span></span>&#123;<br>        <br>        MobileMessagerBase::<span class="hljs-built_in">Connect</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(string message)</span></span>&#123;<br>        <br>        MobileMessagerBase::<span class="hljs-built_in">WriteText</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span></span>&#123;<br>        <br>        MobileMessagerBase::<span class="hljs-built_in">DrawShape</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerPerfect</span> :</span> <span class="hljs-keyword">public</span> MobileMessagerBase &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(string username, string password)</span></span>&#123;<br>        <br>        MobileMessagerBase::<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        MobileMessagerBase::<span class="hljs-built_in">Connect</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(string message)</span></span>&#123;<br>        <br>        MobileMessagerBase::<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        MobileMessagerBase::<span class="hljs-built_in">WriteText</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span></span>&#123;<br>        <br>        MobileMessagerBase::<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        MobileMessagerBase::<span class="hljs-built_in">DrawShape</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//所有类的个数：1+n+m*n</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//编译时装配</span><br>        Messager *m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MobileMessagerPerfect</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>分析以上代码可得：</p><ul><li><p>由于<code>MobileMessagerBase</code>和<code>PCMessagerBase</code>有未实现的虚函数，所以它们依然是纯虚基类，无法实例化</p></li><li><p>分析<code>Messager</code>以及它派生出来的类，会发现实际上<code>Messager</code>这个类设计得不合理，主要功能应该分为两大块：</p><ul><li>由<code>Messager</code>派生的<code>XXXMessagerBase</code>实现的：<code>Login</code>、<code>SendMessage</code>、<code>SendPicture</code></li><li>由<code>XXXMessagerBase</code>派生的<code>XXXMessagerPerfect/Lite</code>实现的：<code>PlaySound</code>、<code>DrawShape</code>、<code>WriteText</code>、<code>Connect</code></li></ul></li><li><p>在本例中，变化方向有两个：</p><ul><li>平台实现：PC端、Mobile端，以后可能还有会Watch端….</li><li>业务抽象：Perfect版、Lite版，同样以后可能还有会EE版….</li></ul><p>所以这两个不同的变化方向，带动了行为的多态实现，也应该往两个方向走，而不应该放在同一个类里。</p></li></ul><p><strong>运用桥模式之后：</strong></p><ul><li>根据变化的维度，分离原先父类里的纯虚函数。此例中，根据<strong>平台实现</strong>和<strong>业务抽象</strong>进行分离。</li><li>参考装饰模式的方法，提取子类中相同类型的变量，往上提出</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Messager</span>&#123;</span><br><span class="hljs-keyword">protected</span>:<br>     MessagerImp* messagerImp;<span class="hljs-comment">//...</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">Messager</span>(MessagerImp* messagerImp)&#123;<span class="hljs-comment">//......</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(string username, string password)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(string message)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span></span>=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Messager</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerImp</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">MessagerImp</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><br><br><span class="hljs-comment">//平台实现 n</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerImp</span> :</span> <span class="hljs-keyword">public</span> MessagerImp&#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//**********</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//**********</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//**********</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//**********</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerImp</span> :</span> <span class="hljs-keyword">public</span> MessagerImp&#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//==========</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//==========</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//==========</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//==========</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//业务抽象 m</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerLite</span> :</span><span class="hljs-keyword">public</span> Messager &#123;<br><br>    <br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(string username, string password)</span></span>&#123;<br>        <br>        messagerImp-&gt;<span class="hljs-built_in">Connect</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(string message)</span></span>&#123;<br>        <br>        messagerImp-&gt;<span class="hljs-built_in">WriteText</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span></span>&#123;<br>        <br>        messagerImp-&gt;<span class="hljs-built_in">DrawShape</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerPerfect</span>  :</span><span class="hljs-keyword">public</span> Messager &#123;<br>      <br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(string username, string password)</span></span>&#123;<br>        <br>        messagerImp-&gt;<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        messagerImp-&gt;<span class="hljs-built_in">Connect</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(string message)</span></span>&#123;<br>        <br>        messagerImp-&gt;<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        messagerImp-&gt;<span class="hljs-built_in">WriteText</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span></span>&#123;<br>        <br>        messagerImp-&gt;<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        messagerImp-&gt;<span class="hljs-built_in">DrawShape</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//类的数目：1+n+m</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//运行时装配</span><br>    MessagerImp* mImp=<span class="hljs-keyword">new</span> <span class="hljs-built_in">PCMessagerImp</span>();<br>    Messager *m =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Messager</span>(mImp);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5d5d18da351868d348b7ed3f2df29f44-16294.png" alt="稳定部分"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>Bridge</strong>模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们。</li><li><strong>Bridge</strong>模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（<strong>即一个类只有一个变化的原因</strong>），复用性比较差。 Bridge模式是比多继承方案更好的解决方法。</li><li>Bridge模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单一职责</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%9A%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%9A%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件系统中，经常面临着”某些结构复杂的对象“的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是它们却拥有比较稳定一致的接口。</li><li>如何应对这种变化？如何向”客户程序（使用这些对象的程序）“隔离出”这些易变对象“，从而使得”依赖这些易变对象的客户程序“不随着需求改变而改变？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象</p><p> ——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用原型模型前：</strong>（借用<strong>工厂模式</strong>的代码，需求和工厂模式一样，只是在本例中，ISplitter的派生类除了有稳定的部分，假设也有剧烈改动的部分）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//抽象类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ISplitter</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//工厂基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SplitterFactory</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">SplitterFactory</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//具体类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySplitter</span> :</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-comment">//具体工厂</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinarySplitter</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TxtSplitter</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">PictureSplitter</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">VideoSplitter</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//mainform</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form<br>&#123;<br>    SplitterFactory*  factory;<span class="hljs-comment">//工厂</span><br><br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">MainForm</span>(SplitterFactory*  factory)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;factory=factory;<br>    &#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span></span>&#123;<br><br>ISplitter * splitter=<br>            factory-&gt;<span class="hljs-built_in">CreateSplitter</span>(); <span class="hljs-comment">//多态new</span><br>        <br>        splitter-&gt;<span class="hljs-built_in">split</span>();<br><br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>但是假设<code>ISplitter</code>派生类构造时需要非常多的资源，比如硬件资源和数据资源，而现在的需求场景又需要不断的创建派生类。这种把资源花费在创建开销上非常的奢侈（比如频繁创建一个数据库实例），所以由此引出一种可以克隆原来已有实例的原型模式，通过克隆降低频繁构造时带来的影响。</p><p><strong>运用原型模式后：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//抽象类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>; <span class="hljs-comment">//通过克隆自己来创建对象</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ISplitter</span>()&#123;&#125;<br><br>&#125;;<br><br><span class="hljs-comment">//具体类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySplitter</span> :</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinarySplitter</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TxtSplitter</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">PictureSplitter</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">VideoSplitter</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form<br>&#123;<br>    ISplitter*  prototype;<span class="hljs-comment">//原型对象</span><br><br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">MainForm</span>(ISplitter*  prototype)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;prototype=prototype;<br>    &#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span></span>&#123;<br><br>ISplitter * splitter=<br>            prototype-&gt;<span class="hljs-built_in">clone</span>(); <span class="hljs-comment">//克隆原型</span><br>        <br>        splitter-&gt;<span class="hljs-built_in">split</span>();<br>        <br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/910596454b87a89a0dd626669ff6d942-d51ba.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>通过克隆自己来创建对象</li><li><strong>Prototype</strong>模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类“拥有”稳定的接口“。</li><li><strong>Prototype</strong>模式对于”如何创建易变类的实体对象“采用”原型克隆“的方法来做，它使得我们可以非常灵活地动态创建”拥有某些稳定接口“的新对象，所需工作仅仅是注册一个新类的对象（即原型），然后在任何需要的地方Clone。</li><li><strong>Prototype</strong>模式中的Clone方法可以利用某些框架中的序列化来实现深拷贝。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对象创建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工厂模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件系统中，经常面临着创建对象的工作；由于需求的变化， 需要创建的对象的具体类型经常变化</li><li>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一 种“封装机制”来避免客户程序和这种“具体对象创建工作”的紧耦合？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。 Factory Method使得一个类的实例化延迟（目的：解耦；手段：虚函数）到子类。 ——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>假设现在有个文件分割器，并且按照需求派生了不同的子类</p><p><strong>运用工厂模式之前：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ISplitter</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySplitter</span> :</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form<br>&#123;<br>TextBox* txtFilePath;<br>TextBox* txtFileNumber;<br>ProgressBar* progressBar;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span></span>&#123;<br><br>ISplitter * splitter=<br>            <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinarySplitter</span>();<span class="hljs-comment">//依赖具体类，编译时绑定，与BinarySplitter为紧耦合</span><br><br>        splitter-&gt;<span class="hljs-built_in">split</span>();<br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>此时的<code>MainForm</code>里面，由于指定了<code>BinarySplitter</code>，导致了编译时绑定。</li><li><code>BinarySplitter</code>为<code>ISplitter</code>的派生类，而业务需求的变动实际上是对<code>BinarySplitter</code>的改变，即<code>ISplitter</code>的派生类为改动范围。所以根据依赖倒置原则，可以把<code>ISplitter</code>的派生类的<code>new</code>操作向上提取成一个抽象类。</li></ul><p><strong>运用工厂模式之后：</strong></p><ul><li>在代码中创建一个工厂，这个工厂的作用是：你需要什么类，我就把什么类返回给你</li><li>抽象这个工厂<code>SplitterFactory</code>，并且将它在<code>MainForm</code>中以组合的形式封装。对于<code>SplitterFactory</code>，由于它是抽象类的指针，所以在<code>MainForm</code>属于运行时绑定。</li><li>需要什么样的<code>ISplitter</code>派生类，就创建一个生产该类的工厂，并在<code>MainForm</code>中赋值。当<code>MainForm</code>需要该派生类时，就从<code>MainForm</code>中的工厂取。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//抽象类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ISplitter</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//工厂基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SplitterFactory</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">SplitterFactory</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//具体类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySplitter</span> :</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-comment">//具体工厂</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinarySplitter</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TxtSplitter</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">PictureSplitter</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">VideoSplitter</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//mainform</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form<br>&#123;<br>    SplitterFactory*  factory;<span class="hljs-comment">//工厂</span><br><br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">MainForm</span>(SplitterFactory*  factory)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;factory=factory;<br>    &#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span></span>&#123;<br><br>ISplitter * splitter=<br>            factory-&gt;<span class="hljs-built_in">CreateSplitter</span>(); <span class="hljs-comment">//多态new</span><br>        <br>        splitter-&gt;<span class="hljs-built_in">split</span>();<br><br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a76e6c6e79c2e106686805f7d28c8b05-b8379.png" alt="结构"></p><p>上图中：</p><ul><li><strong>Product</strong>：代表<code>ISplitter</code></li><li><strong>ConcreteProuct</strong>：代表<code>ISplitter</code>派生类</li><li><strong>Creator</strong>：代表<code>SplitterFactory</code></li><li><strong>ConcreteCreator</strong>：代表<code>SplitterFactory</code>派生类</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>Factory Method</strong>模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导致软件的脆弱。</li><li><strong>Factory Method</strong>模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。</li><li><strong>Factory Method</strong>模式解决“单个对象”的需求变化。<strong>缺点在于要求创建方法/参数相同</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对象创建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象工厂模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%9A%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%9A%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作。</li><li>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一 种“封装机制”来避免客户程序和这种“多系列具体对象创建工作” 的紧耦合？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。</p><p> ——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>现在的需求是：创建一个数据库的初始化类，数据库选择SQL Server，其中有三个方法：</p><ul><li><code>ConnectionString()</code></li><li><code>CommandText(...)</code></li><li><code>ExecuteReader()</code></li></ul><p>假设不管初始化哪种数据库，都需要通过这三个方法</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeDAO</span>&#123;</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;EmployeeDO&gt; <span class="hljs-title">GetEmployees</span><span class="hljs-params">()</span></span>&#123;<br>        SqlConnection* connection =<br>            <span class="hljs-keyword">new</span> <span class="hljs-built_in">SqlConnection</span>();<br>        connection-&gt;<span class="hljs-built_in">ConnectionString</span>(...);<br><br>        SqlCommand* command =<br>            <span class="hljs-keyword">new</span> <span class="hljs-built_in">SqlCommand</span>();<br>        command-&gt;<span class="hljs-built_in">CommandText</span>(...);<br>        command-&gt;<span class="hljs-built_in">SetConnection</span>(connection);<br><br>        SqlDataReader* reader = command-&gt;<span class="hljs-built_in">ExecuteReader</span>();<br>        <span class="hljs-keyword">while</span> (reader-&gt;<span class="hljs-built_in">Read</span>())&#123;<br><br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>虽然说这样写能够实现，但是如果要更换数据库的时候，比如更换成MySql时，就需要按照上面的代码重新再写一遍。而且现实中，对于同样类型的业务操作一般都提供了对外的接口，所以需要重构代码，将数据库的调用方式以多态的方式实现。</p><p>所以现在可以尝试使用工厂模式。</p><p><strong>运用工厂模式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//数据库访问有关的基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBConnection</span>&#123;</span><br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBConnectionFactory</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBConnection* <span class="hljs-title">CreateDBConnection</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBCommand</span>&#123;</span><br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBCommandFactory</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBCommand* <span class="hljs-title">CreateDBCommand</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDataReader</span>&#123;</span><br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDataReaderFactory</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDataReader* <span class="hljs-title">CreateDataReader</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><br><br><span class="hljs-comment">//支持SQL Server</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlConnection</span>:</span> <span class="hljs-keyword">public</span> IDBConnection&#123;<br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlConnectionFactory</span>:</span><span class="hljs-keyword">public</span> IDBConnectionFactory&#123;<br>    <br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlCommand</span>:</span> <span class="hljs-keyword">public</span> IDBCommand&#123;<br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlCommandFactory</span>:</span><span class="hljs-keyword">public</span> IDBCommandFactory&#123;<br>    <br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDataReader</span>:</span> <span class="hljs-keyword">public</span> IDataReader&#123;<br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDataReaderFactory</span>:</span><span class="hljs-keyword">public</span> IDataReaderFactory&#123;<br>    <br>&#125;;<br><br><span class="hljs-comment">//支持Oracle</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleConnection</span>:</span> <span class="hljs-keyword">public</span> IDBConnection&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleCommand</span>:</span> <span class="hljs-keyword">public</span> IDBCommand&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleDataReader</span>:</span> <span class="hljs-keyword">public</span> IDataReader&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeDAO</span>&#123;</span><br>    IDBConnectionFactory* dbConnectionFactory;<br>    IDBCommandFactory* dbCommandFactory;<br>    IDataReaderFactory* dataReaderFactory;<br>    <br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;EmployeeDO&gt; <span class="hljs-title">GetEmployees</span><span class="hljs-params">()</span></span>&#123;<br>        IDBConnection* connection =<br>            dbConnectionFactory-&gt;<span class="hljs-built_in">CreateDBConnection</span>();<br>        connection-&gt;<span class="hljs-built_in">ConnectionString</span>(<span class="hljs-string">&quot;...&quot;</span>);<br><br>        IDBCommand* command =<br>            dbCommandFactory-&gt;<span class="hljs-built_in">CreateDBCommand</span>();<br>        command-&gt;<span class="hljs-built_in">CommandText</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>        command-&gt;<span class="hljs-built_in">SetConnection</span>(connection); <span class="hljs-comment">//关联性</span><br><br>        IDBDataReader* reader = command-&gt;<span class="hljs-built_in">ExecuteReader</span>(); <span class="hljs-comment">//关联性</span><br>        <span class="hljs-keyword">while</span> (reader-&gt;<span class="hljs-built_in">Read</span>())&#123;<br><br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>虽然说对于<code>EmployeeDAO</code>类已经解除了静态绑定，通过三个指针转换成了更灵活的动态绑定，但是分析后发现：</p><ul><li>有了对象的接口，也有对象对应的工厂接口</li><li>这三个对象是同组的可以搭配的，有关联性，比如都是SQL Server的</li></ul><p>通过工厂模式的处理固然是好的，但是并不是最好的。虽然<code>EmployeeDAO</code>更灵活了，但是牺牲的是对于三个指针以及他们类型的处理。既然三个指针的类型实际上都是关联操作，那么可以将他们再进一步的抽象</p><p><strong>运用抽象工厂模式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//数据库访问有关的基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBConnection</span>&#123;</span><br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBCommand</span>&#123;</span><br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDataReader</span>&#123;</span><br>    <br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBFactory</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBConnection* <span class="hljs-title">CreateDBConnection</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBCommand* <span class="hljs-title">CreateDBCommand</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDataReader* <span class="hljs-title">CreateDataReader</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <br>&#125;;<br><br><br><span class="hljs-comment">//支持SQL Server</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlConnection</span>:</span> <span class="hljs-keyword">public</span> IDBConnection&#123;<br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlCommand</span>:</span> <span class="hljs-keyword">public</span> IDBCommand&#123;<br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDataReader</span>:</span> <span class="hljs-keyword">public</span> IDataReader&#123;<br>    <br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDBFactory</span>:</span><span class="hljs-keyword">public</span> IDBFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBConnection* <span class="hljs-title">CreateDBConnection</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBCommand* <span class="hljs-title">CreateDBCommand</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDataReader* <span class="hljs-title">CreateDataReader</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br> <br>&#125;;<br><br><span class="hljs-comment">//支持Oracle</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleConnection</span>:</span> <span class="hljs-keyword">public</span> IDBConnection&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleCommand</span>:</span> <span class="hljs-keyword">public</span> IDBCommand&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleDataReader</span>:</span> <span class="hljs-keyword">public</span> IDataReader&#123;<br>    <br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeDAO</span>&#123;</span><br>    IDBFactory* dbFactory;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;EmployeeDO&gt; <span class="hljs-title">GetEmployees</span><span class="hljs-params">()</span></span>&#123;<br>        IDBConnection* connection =<br>            dbFactory-&gt;<span class="hljs-built_in">CreateDBConnection</span>();<br>        connection-&gt;<span class="hljs-built_in">ConnectionString</span>(<span class="hljs-string">&quot;...&quot;</span>);<br><br>        IDBCommand* command =<br>            dbFactory-&gt;<span class="hljs-built_in">CreateDBCommand</span>();<br>        command-&gt;<span class="hljs-built_in">CommandText</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>        command-&gt;<span class="hljs-built_in">SetConnection</span>(connection); <span class="hljs-comment">//关联性</span><br><br>        IDBDataReader* reader = command-&gt;<span class="hljs-built_in">ExecuteReader</span>(); <span class="hljs-comment">//关联性</span><br>        <span class="hljs-keyword">while</span> (reader-&gt;<span class="hljs-built_in">Read</span>())&#123;<br><br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>将三个关联性强的对象封装到工厂类里，也就是把三个容易变化的东西关在笼子里。这样一来，不管是后续再增加何种类型的数据库，都能灵活应对。但是这种方法，却无法解决对新需求的变动。比如，无法在</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDBFactory</span>:</span><span class="hljs-keyword">public</span> IDBFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBConnection* <span class="hljs-title">CreateDBConnection</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBCommand* <span class="hljs-title">CreateDBCommand</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDataReader* <span class="hljs-title">CreateDataReader</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br> <span class="hljs-comment">//无法添加.</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p><code>SqlDBFactory</code>类里添加新的方法，因为这样会打破稳定。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/dbdf13cd830891883ced46289edb0fbf-ded07.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>一个模式稳定的部分，就是它的缺点</li><li>工厂模式是抽象工厂模式的特例</li><li>如果没有应对“多系列对象构建”的需求变化，则没有必要使用Abstract Factory**模式，这时候使用简单的工厂完全可以。</li><li>“系列对象”指的是在某一特定系列下的对象之间有相互依赖、 或作用的关系。不同系列的对象之间不能相互依赖。</li><li><strong>Abstract Factory</strong>模式主要在于应对“新系列”的需求变动。其缺点在于难以应对“新对象”的需求变动</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对象创建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构建器</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%9A%E6%9E%84%E5%BB%BA%E5%99%A8/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%9A%E6%9E%84%E5%BB%BA%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定</li><li>如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>将一个复杂对象的构建与其表示相分离，使得同样的构建过程(稳定)可以创建不同的表示(变化)。</p><p> ——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>建房子一般的流程都是一样的，从地基开始，等等….假设流程固定，但是整个流程却很庞大，如果把房子的属性和创建过程放在同一个类里，整个类会非常的臃肿。所以可以尝试将构建过程提取出来。</p><p><strong>运用构建器模式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//House：显示的部分</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">House</span>&#123;</span><br>    <span class="hljs-comment">//....</span><br>&#125;;<br><span class="hljs-comment">//HouseBuilder:创建细节</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HouseBuilder</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">House* <span class="hljs-title">GetResult</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> pHouse;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">HouseBuilder</span>()&#123;&#125;<br><span class="hljs-keyword">protected</span>:<br>    <br>    House* pHouse;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart1</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart2</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart3</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart4</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart5</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StoneHouse</span>:</span> <span class="hljs-keyword">public</span> House&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StoneHouseBuilder</span>:</span> <span class="hljs-keyword">public</span> HouseBuilder&#123;<br><span class="hljs-keyword">protected</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//pHouse-&gt;Part1 = ...;</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart2</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart3</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart4</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart5</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-comment">//HouseDirector：具体构造过程</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HouseDirector</span>&#123;</span><br>    <br><span class="hljs-keyword">public</span>:<br>    HouseBuilder* pHouseBuilder;<br>    <br>    <span class="hljs-built_in">HouseDirector</span>(HouseBuilder* pHouseBuilder)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;pHouseBuilder=pHouseBuilder;<br>    &#125;<br>    <br>    <span class="hljs-function">House* <span class="hljs-title">Construct</span><span class="hljs-params">()</span></span>&#123;<br>        <br>        pHouseBuilder-&gt;<span class="hljs-built_in">BuildPart1</span>();<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br>            pHouseBuilder-&gt;<span class="hljs-built_in">BuildPart2</span>();<br>        &#125;<br>        <br>        <span class="hljs-keyword">bool</span> flag=pHouseBuilder-&gt;<span class="hljs-built_in">BuildPart3</span>();<br>        <br>        <span class="hljs-keyword">if</span>(flag)&#123;<br>            pHouseBuilder-&gt;<span class="hljs-built_in">BuildPart4</span>();<br>        &#125;<br>        <br>        pHouseBuilder-&gt;<span class="hljs-built_in">BuildPart5</span>();<br>        <br>        <span class="hljs-keyword">return</span> pHouseBuilder-&gt;<span class="hljs-built_in">GetResult</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//实现（以伪代码形式）</span><br><span class="hljs-comment">//初始化House子类...添加属性等</span><br><span class="hljs-comment">//初始化HouseBuilder子类...在之前需实现创建过程中的具体细节...</span><br><span class="hljs-comment">//实例化HouseDirector，即HouseDirector(HouseBuilder)</span><br><span class="hljs-comment">//让HouseDirector执行创建流程Construct，并返回House类型</span><br><span class="hljs-comment">//至此一个House类型对象被创建出来</span><br></code></pre></div></td></tr></table></figure><p>注意：<code>HouseBuilder</code>和<code>HouseDirector</code>有些时候可以合并，依据实际业务场景或者类的设计。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6822e8f448c550326024214c80d01abd-c01d0.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p><strong>父类构造函数中调用虚函数是静态绑定，是不会去调用子类实现的虚函数的。</strong>若为动态绑定，那么子类构造时先调用父类的构造函数，父类的构造函数又调用子类实现的虚函数，这样做违背”伦理“。因为子类并没有构造出来，却被调用了其中的方法。</p></li><li><p>构建过程太过复杂，导致类变得很肥大。可以考虑将构建过程提取出来</p></li><li>Builder模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。</li><li>变化点在哪里，封装哪里—— Builder模式主要在于应对“复杂对象各个部分”的频繁需求变动。其缺点在于难以应对“分步骤构建算法”的需求变动。</li><li>在Builder模式中，要注意不同语言中构造器内调用虚函数的差别 （C++ vs. C#) 。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对象创建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>享元模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E6%80%A7%E8%83%BD%EF%BC%9A%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E6%80%A7%E8%83%BD%EF%BC%9A%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件系统采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行时代价：主要指内存需求方面的代价。</li><li>如何在避免大量细粒度对象问题的同时，让外部客户程序仍然能够透明地使用面向对象的方式来进行操作？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>运用共享技术有效地支持大量细粒度的对象</p><p>——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用享元模式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Font</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-comment">//unique object key</span><br>    string key;<br>    <br>    <span class="hljs-comment">//object state</span><br>    <span class="hljs-comment">//....</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Font</span>(<span class="hljs-keyword">const</span> string&amp; key)&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;;<br>ß<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FontFactory</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//使用map存放，可以根据实际情况更换数据结构</span><br>    map&lt;string,Font* &gt; fontPool;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Font* <span class="hljs-title">GetFont</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp; key)</span></span>&#123;<br><br>        map&lt;string,Font*&gt;::iterator item=fontPool.<span class="hljs-built_in">find</span>(key);<br>        <br>        <span class="hljs-keyword">if</span>(item!=footPool.<span class="hljs-built_in">end</span>())&#123;<span class="hljs-comment">//如果有</span><br>            <span class="hljs-keyword">return</span> fontPool[key];<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果没有</span><br>            Font* font = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Font</span>(key);<span class="hljs-comment">//创建一个新的对象</span><br>            fontPool[key]= font;<br>            <span class="hljs-keyword">return</span> font;<br>        &#125;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/74b3290484036b5227b72f08956d1b60-8f07f.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>用一种共享的方式创建对象，有就返回，没有就创建</li><li>一般来讲，对象的状态尽可能的实现只读的方式</li><li>面向对象很好地解决了抽象性的问题，但是作为一个运行在机器中的程序实体，我们需要考虑对象的代价问题。Flyweight主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。</li><li>Flyweight采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体实现方面，要注意对象状态的处理。</li><li>对象的数量太大从而导致对象内存开销加大，什么样的数量才算大？这需要我们仔细的根据具体应用情况进行评估，而不能凭空臆断。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对象性能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E6%80%A7%E8%83%BD%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E6%80%A7%E8%83%BD%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率。</li><li>如果绕过常规的构造器，提供一种机制来保证一个类只有一个实例？这应该是类设计者的责任，而不是使用者的责任。也就是说不应该规范使用者的使用方式，而是让类设计者在设计的时候就需要考虑。</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>保证一个类仅有一个实例，并提供一个该实例的全局访问点。</p><p>——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用单例模式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>();<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-keyword">const</span> Singleton&amp; other);<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">static</span> Singleton* m_instance;<br>&#125;;<br><br>Singleton* Singleton::m_instance=<span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-comment">//线程非安全版本</span><br><span class="hljs-function">Singleton* <span class="hljs-title">Singleton::getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (m_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>        m_instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> m_instance;<br>&#125;<br><br><span class="hljs-comment">//线程安全版本，但锁的代价过高</span><br><span class="hljs-function">Singleton* <span class="hljs-title">Singleton::getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    Lock lock;<br>    <span class="hljs-keyword">if</span> (m_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>        m_instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> m_instance;<br>&#125;<br><br><span class="hljs-comment">//双检查锁，但由于内存读写reorder不安全</span><br><span class="hljs-function">Singleton* <span class="hljs-title">Singleton::getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">if</span>(m_instance==<span class="hljs-literal">nullptr</span>)&#123;<br>        Lock lock;<br>        <span class="hljs-keyword">if</span> (m_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>            m_instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> m_instance;<br>&#125;<br><br><span class="hljs-comment">//C++ 11版本之后的跨平台实现 (volatile)</span><br>std::atomic&lt;Singleton*&gt; Singleton::m_instance;<br>std::mutex Singleton::m_mutex;<br><br><span class="hljs-function">Singleton* <span class="hljs-title">Singleton::getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    Singleton* tmp = m_instance.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>    std::<span class="hljs-built_in">atomic_thread_fence</span>(std::memory_order_acquire);<span class="hljs-comment">//获取内存fence</span><br>    <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mutex)</span></span>;<br>        tmp = m_instance.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>        <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span>) &#123;<br>            tmp = <span class="hljs-keyword">new</span> Singleton;<br>            std::<span class="hljs-built_in">atomic_thread_fence</span>(std::memory_order_release);<span class="hljs-comment">//释放内存fence</span><br>            m_instance.<span class="hljs-built_in">store</span>(tmp, std::memory_order_relaxed);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里需要特别注意双检查锁会发生的reorder问题：<br><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//双检查锁，但由于内存读写reorder不安全</span><br><span class="hljs-function">Singleton* <span class="hljs-title">Singleton::getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">if</span>(m_instance==<span class="hljs-literal">nullptr</span>)&#123;<span class="hljs-comment">//1</span><br>        Lock lock;<br>        <span class="hljs-keyword">if</span> (m_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>            m_instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<span class="hljs-comment">//2</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> m_instance;<span class="hljs-comment">//3</span><br>&#125;<br></code></pre></div></td></tr></table></figure></p><p>假设此时有两个线程A和B，且没有<code>Singleton</code>实例。</p><p>当A执行到<strong>代码行2</strong>时，由于编译器的优化，<strong>可能</strong>会将<code>new</code>本来的内部执行顺序从<strong>开辟内存-&gt;执行构造-&gt;赋予指针</strong>转变为<strong>开辟内存-&gt;赋予指针-&gt;执行构造</strong>，那么当A执行完<strong>赋予指针</strong>（即此时的<code>m_instance</code>已经被赋予地址了），并处于即将<strong>执行构造</strong>的时刻，B开始了。B执行到<strong>代码行1</strong>时，由于此时<code>m_instance</code>不是<code>nullptr</code>，所以B会直接执行<strong>代码行3</strong>，返回一块什么东西都没有的内存。若此时B中对<code>m_instance</code>进行操作，将会报错。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>构造和拷贝构造设置为私有的</li><li>Singleton模式中的实例构造器可以设置为protected以允许子类派生。</li><li>Singleton模式一般不要支持拷贝构造函数和Clone接口，因为这有可能导致多个对象实例，与Singleton模式的初衷违背。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对象性能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中介者模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，经常会出现多个对象相互关联交互的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。</li><li>在这种情况下，我们可以使用一个”中介对象“来管理对象间的关联关系，避免互相交互的对象之间的紧耦合引用关系，从而更好地抵御变化。</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>用一个中介对象来封装（封装变化）一系列的对象交互。中介者使各对象不需要显示的互相引用（编译时依赖-&gt;运行时依赖），从而使其耦合松散（管理变化），而且可以独立地改变它们之间的交互。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/c847ecd4609b6c48b916c0e25874ff44-15be6.png" alt="实例"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6c5c6f834db0f241439220930281478b-39b5b.png" alt="实例"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>与门面模式的区别：<ul><li>门面模式：系统内部和系统外部的隔离</li><li>中介者模式：系统内部的隔离</li></ul></li><li>将多个对象间复杂的关联关系解耦，Mediator模式将多个对象间的控制逻辑进行集中管理，变“多个对象互相关联”为“多个对象和一个中介者关联”，简化了系统的维护，抵御了可能的变化。</li><li>随着控制逻辑的复杂化，Mediator模式具体对象的实现可能相当复杂。这时候可以对Mediator模式对象进行分解处理。</li><li>Facade模式是解耦系统间（单项）的对象关联关系；Mediator模式是解耦系统内各个对象之间（双向）的关联关系。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口隔离</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在面向对象系统中，有些对象由于某种原因（比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等），直接访问会给使用者、或者系统结构带来很多麻烦。</li><li>如何在不失透明操作对象的同时来管理/控制这些对象特有的复杂性？增加一层间接层是软件开发中常见的解决方式</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>为其他对象提供一种代理以控制（隔离，使用接口）对这个对象的访问 </p><p>——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>使用代理模式之前：</strong></p><p>直接使用功能类</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISubject</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-comment">//功能类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealSubject</span>:</span> <span class="hljs-keyword">public</span> ISubject&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//....</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientApp</span>&#123;</span><br>    <br>    ISubject* subject;<br>    <br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">ClientApp</span>()&#123;<br>        subject=<span class="hljs-keyword">new</span> <span class="hljs-built_in">RealSubject</span>();<span class="hljs-comment">//直接使用</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoTask</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>        subject-&gt;<span class="hljs-built_in">process</span>();<br>        <br>        <span class="hljs-comment">//....</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>使用代理模式之后：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISubject</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><br><span class="hljs-comment">//Proxy的设计，添加了一层间接层</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubjectProxy</span>:</span> <span class="hljs-keyword">public</span> ISubject&#123;<br>    <br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//对RealSubject的一种间接访问，在其中可以进行安全控制等.</span><br>        <span class="hljs-comment">//....</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientApp</span>&#123;</span><br>    <br>    ISubject* subject;<br>    <br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">ClientApp</span>()&#123;<br>        subject=<span class="hljs-keyword">new</span> <span class="hljs-built_in">SubjectProxy</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoTask</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>        subject-&gt;<span class="hljs-built_in">process</span>();<br>        <br>        <span class="hljs-comment">//....</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/70792f3a5d1deb63a5ead7eca014ebc9-550f9.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>”增加一层间接层“是软件系统中对许多复杂问题的一种常见解决方法。在面向对象系统中，直接使用某些对象会带来很多问题，作为间接层的Proxy对象便是解决这一问题的常用手段。</li><li>具体Proxy设计模式的实现方法、实现粒度都相差很大，有些可能对单个对象做细粒度的控制，如copy-on-write技术，有些可能对组件模块提供抽象代理层，在架构层次对对象做proxy。</li><li><strong>Proxy并不一定要求保持接口完整的一致性，只要能够实现间接控制，有时候损及一些透明性是可以接受的。</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口隔离</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>适配器模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件系统中，由于应用环境的变化，常常需要将”一些现存的对象“放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。</li><li>如何应对这种”迁移的变化“？如何既能利用现有对象的良好实现，同时又满足新的应用环境所要求的接口？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用适配器模式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//目标接口（新接口）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ITarget</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">//遗留接口（老接口）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IAdaptee</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">//遗留类型</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OldClass</span>:</span> <span class="hljs-keyword">public</span> IAdaptee&#123;<br>    <span class="hljs-comment">//....</span><br>&#125;;<br><br><span class="hljs-comment">//对象适配器</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span>:</span> <span class="hljs-keyword">public</span> ITarget&#123; <span class="hljs-comment">//继承</span><br><span class="hljs-keyword">protected</span>:<br>    IAdaptee* pAdaptee;<span class="hljs-comment">//组合</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">Adapter</span>(IAdaptee* pAdaptee)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;pAdaptee=pAdaptee;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> data=pAdaptee-&gt;<span class="hljs-built_in">bar</span>();<br>        pAdaptee-&gt;<span class="hljs-built_in">foo</span>(data);<br>        <br>    &#125;<br>    <br>    <br>&#125;;<br><br><span class="hljs-comment">//类适配器</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span>:</span> <span class="hljs-keyword">public</span> ITarget,<br>               <span class="hljs-keyword">protected</span> OldClass&#123; <span class="hljs-comment">//多继承</span><br>               <br>               <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//实例化一个老版本的类</span><br>    IAdaptee* pAdaptee=<span class="hljs-keyword">new</span> <span class="hljs-built_in">OldClass</span>();<br>    <br>    <span class="hljs-comment">//利用适配器对这个老版本的类进行适配</span><br>    ITarget* pTarget=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Adapter</span>(pAdaptee);<br>    pTarget-&gt;<span class="hljs-built_in">process</span>();<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/75286f661f0eec847beeb6ccf5239ff3-fd5be.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Adapter模式主要应用于”希望复用一些现存的类，但是接口又与复用环境要求不一致的情况“，在遗留代码复用、类库迁移等方面非常有用。</li><li>GoF23定义了两种Adapter模式的实现结构：对象适配器和类适配器。但类适配器采用”多继承“的实现方式，一般不推荐使用。对象适配器采用”对象组合“的方式，更符合松耦合精神。</li><li>Adapter模式可以实现的非常灵活，不必拘泥于GoF23中定义的两种结构。例如，完全可以将Adapter模式中的”现存对象“作为新的接口方法参数，来达到适配的目的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口隔离</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>门面模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7a3928dde4ef2752ff9b4bb248907763-21c79.png" alt="动机"></p><ul><li>上述A方案的问题在于组件的客户和组件中各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。</li><li>如何简化外部客户程序和系统间的交互接口？如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解耦？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>为子系统中的一组接口提供一个一致（稳定）的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用（复用）。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/aaeb3252ee3997fa8d7ddb24e46ea28c-49978.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>门面模式实际上是一种开发素养，在考虑问题时需要一种边界的划分。面向使用者需要表示稳定，面向设计者需要快速的迭代</li><li>从客户程序的角度来看,Facade模式简化了整个组件系统的接口，对于组件内部与外部客户程序来说，达到一种”解耦“的效果。内部子系统的任何变化不会影响到Facade接口的变化。</li><li>Facade设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Facade很多时候更是一种<strong>架构设计模式</strong>。</li><li>Facade设计模式并非一个集装箱，可以任意地放进任何多个对象。Facade模式中组件的内部应该是”相互耦合关系比较大的一系列组件“，而不是一个简单的功能集合。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口隔离</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件的某些情况下，客户代码过多地依赖于对象容器复杂的内部实现结构，对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。</li><li>如何将”客户代码与复杂的对象容器结构“解耦？让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>将对象组合成树形结构以表示”部分-整体“的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性（稳定）。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>内部呈现一种树状结构，可以想象成文件系统，把<code>Composite</code>视为文件目录，<code>Leaf</code>视为文件。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Component</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//树节点</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Composite</span> :</span> <span class="hljs-keyword">public</span> Component&#123;<br>    <br>    string name;<br>    list&lt;Component*&gt; elements;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Composite</span>(<span class="hljs-keyword">const</span> string &amp; s) : <span class="hljs-built_in">name</span>(s) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Component* element)</span> </span>&#123;<br>        elements.<span class="hljs-built_in">push_back</span>(element);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Component* element)</span></span>&#123;<br>        elements.<span class="hljs-built_in">remove</span>(element);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>&#123;<br>        <br>        <span class="hljs-comment">//1. process current node</span><br>        <br>        <br>        <span class="hljs-comment">//2. process leaf nodes</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;e : elements)<br>            e-&gt;<span class="hljs-built_in">process</span>(); <span class="hljs-comment">//多态调用</span><br>         <br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//叶子节点</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leaf</span> :</span> <span class="hljs-keyword">public</span> Component&#123;<br>    string name;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Leaf</span>(string s) : <span class="hljs-built_in">name</span>(s) &#123;&#125;<br>            <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//process current node</span><br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Invoke</span><span class="hljs-params">(Component &amp; c)</span></span>&#123;<br>    <span class="hljs-comment">//...</span><br>    c.<span class="hljs-built_in">process</span>();<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-function">Composite <span class="hljs-title">root</span><span class="hljs-params">(<span class="hljs-string">&quot;root&quot;</span>)</span></span>;<br>    <span class="hljs-function">Composite <span class="hljs-title">treeNode1</span><span class="hljs-params">(<span class="hljs-string">&quot;treeNode1&quot;</span>)</span></span>;<br>    <span class="hljs-function">Composite <span class="hljs-title">treeNode2</span><span class="hljs-params">(<span class="hljs-string">&quot;treeNode2&quot;</span>)</span></span>;<br>    <span class="hljs-function">Composite <span class="hljs-title">treeNode3</span><span class="hljs-params">(<span class="hljs-string">&quot;treeNode3&quot;</span>)</span></span>;<br>    <span class="hljs-function">Composite <span class="hljs-title">treeNode4</span><span class="hljs-params">(<span class="hljs-string">&quot;treeNode4&quot;</span>)</span></span>;<br>    <span class="hljs-function">Leaf <span class="hljs-title">leat1</span><span class="hljs-params">(<span class="hljs-string">&quot;left1&quot;</span>)</span></span>;<br>    <span class="hljs-function">Leaf <span class="hljs-title">leat2</span><span class="hljs-params">(<span class="hljs-string">&quot;left2&quot;</span>)</span></span>;<br>    <br>    root.<span class="hljs-built_in">add</span>(&amp;treeNode1);<br>    treeNode1.<span class="hljs-built_in">add</span>(&amp;treeNode2);<br>    treeNode2.<span class="hljs-built_in">add</span>(&amp;leaf1);<br>    <br>    root.<span class="hljs-built_in">add</span>(&amp;treeNode3);<br>    treeNode3.<span class="hljs-built_in">add</span>(&amp;treeNode4);<br>    treeNode4.<span class="hljs-built_in">add</span>(&amp;leaf2);<br>    <br>    <span class="hljs-built_in">process</span>(root);<br>    <span class="hljs-built_in">process</span>(leaf2);<br>    <span class="hljs-built_in">process</span>(treeNode3);<br>  <br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/0abe476e99639c4f5f496e3e26560435-14578.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>组合模式的核心是多态的递归调用</strong></li><li>Composite模式采用树形结构来实现普遍存在的对象容器，从而将”一对多“的关系转化为”一对一“的关系，使得客户代码可以一致地（复用）处理对象和对象容器，无需关心处理的是单个的对象，还是组合的对象容器。<ul><li>一对多：即上例的，若<code>Leaf</code>也实现父类的虚函数，然后<code>Composite</code>的成员函数<code>process</code>中的<code>for</code>循环去掉或改写，对于客户而言，直接面对的就是这两个类型。</li><li>一对一：即上例。对于客户而言，客户仅需要使用<code>Component</code>类型即可，且不知道内部的数据是按照何种的数据结构组装。</li></ul></li><li>将”客户代码与复杂的对象容器结构“解耦是Composite的核心思想，解耦之后，客户代码将与纯粹的抽象接口，而非对象容器的内部实现结构发生依赖，从而更能”应对变化“。（比如上例的<code>invoke</code>方法）</li><li>Composite模式在具体实现中，可以让父对象中的子对象反向追溯；如果父对象有频繁的遍历需求，可使用缓存技巧来改善效率。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>职责链</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%81%8C%E8%B4%A3%E9%93%BE/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%81%8C%E8%B4%A3%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，一个请求可能被多个对象处理，但是每个请求在运行时只能有一个接收者，如果显示指定，将必不可少地带来请求发送者与接收者的紧耦合。</li><li>如何使请求的发送者不需要指定具体的接收者？让请求的接受者自己在运行时决定来处理请求，从而使两者解耦？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>类似于安卓中的事件分发机制</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//请求类型</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RequestType</span></span><br><span class="hljs-class">&#123;</span><br>    REQ_HANDLER1,<br>    REQ_HANDLER2,<br>    REQ_HANDLER3<br>&#125;;<br><span class="hljs-comment">//请求</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reqest</span></span><br><span class="hljs-class">&#123;</span><br>    string description;<br>    RequestType reqType;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Reqest</span>(<span class="hljs-keyword">const</span> string &amp; desc, RequestType type) : <span class="hljs-built_in">description</span>(desc), <span class="hljs-built_in">reqType</span>(type) &#123;&#125;<br>    <span class="hljs-function">RequestType <span class="hljs-title">getReqType</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> reqType; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">const</span> string&amp; <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> description; &#125;<br>&#125;;<br><span class="hljs-comment">//接受请求的类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChainHandler</span>&#123;</span><br>    <br>    <span class="hljs-comment">//设置下一个接受节点</span><br>    ChainHandler *nextChain;<br>    <span class="hljs-comment">//发送请求到下一个节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendReqestToNextHandler</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (nextChain != <span class="hljs-literal">nullptr</span>)<br>            nextChain-&gt;<span class="hljs-built_in">handle</span>(req);<br>    &#125;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">//判断是否接受请求</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">canHandleRequest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//请求处理</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ChainHandler</span>() &#123; nextChain = <span class="hljs-literal">nullptr</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setNextChain</span><span class="hljs-params">(ChainHandler *next)</span> </span>&#123; nextChain = next; &#125;<br>    <br>   <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">canHandleRequest</span>(req))<br>            <span class="hljs-built_in">processRequest</span>(req);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">sendReqestToNextHandler</span>(req);<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler1</span> :</span> <span class="hljs-keyword">public</span> ChainHandler&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canHandleRequest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> req.<span class="hljs-built_in">getReqType</span>() == RequestType::REQ_HANDLER1;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Handler1 is handle reqest: &quot;</span> &lt;&lt; req.<span class="hljs-built_in">getDescription</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;;<br>        <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler2</span> :</span> <span class="hljs-keyword">public</span> ChainHandler&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canHandleRequest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> req.<span class="hljs-built_in">getReqType</span>() == RequestType::REQ_HANDLER2;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Handler2 is handle reqest: &quot;</span> &lt;&lt; req.<span class="hljs-built_in">getDescription</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler3</span> :</span> <span class="hljs-keyword">public</span> ChainHandler&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canHandleRequest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> req.<span class="hljs-built_in">getReqType</span>() == RequestType::REQ_HANDLER3;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Handler3 is handle reqest: &quot;</span> &lt;&lt; req.<span class="hljs-built_in">getDescription</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Handler1 h1;<br>    Handler2 h2;<br>    Handler3 h3;<br>    h1.<span class="hljs-built_in">setNextChain</span>(&amp;h2);<br>    h2.<span class="hljs-built_in">setNextChain</span>(&amp;h3);<br>    <br>    <span class="hljs-function">Reqest <span class="hljs-title">req</span><span class="hljs-params">(<span class="hljs-string">&quot;process task ... &quot;</span>, RequestType::REQ_HANDLER3)</span></span>;<br>    h1.<span class="hljs-built_in">handle</span>(req);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5e3f3c6bc4af6c127e12ad584fccf3cf-63458.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Chain of Responsibility模式的应用场合在于”一个请求可能有多个接受者，但是最后真正的接受者只有一个“，这时候请求发送者就接受者的耦合有可能出现”变化脆弱“的症状，职责链的目的就是将二者解耦，从而更好地应对变化。</li><li>应用了Chain of Responsibility模式后，对象的职责分派将更具灵活性。我们可以在运行时动态添加/修改请求的职责。</li><li>如果请求传递到职责链的末尾仍得不到处理，应该有一个合理的缺省机制。这也是每一个接受对象的责任，而不是发出请求的对象的责任。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迭代器</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构：迭代器"><a href="#数据结构：迭代器" class="headerlink" title="数据结构：迭代器"></a>数据结构：迭代器</h1><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素；同时这种”透明遍历“也为”同一种算法在多种集合对象上进行操作“提供了可能。</li><li>使用面向对象技术将这种遍历机制抽象为”迭代器对象“为”应对变化中的集合对象“提供了一种优雅的fan</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露（稳定）该对象的内部表示。</p><p>——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Iterator</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">first</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T&amp; <span class="hljs-title">current</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCollection</span>&#123;</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function">Iterator&lt;T&gt; <span class="hljs-title">GetIterator</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectionIterator</span> :</span> <span class="hljs-keyword">public</span> Iterator&lt;T&gt;&#123;<br>    MyCollection&lt;T&gt; mc;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">CollectionIterator</span>(<span class="hljs-keyword">const</span> MyCollection&lt;T&gt; &amp; c): <span class="hljs-built_in">mc</span>(c)&#123; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">first</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function">T&amp; <span class="hljs-title">current</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyAlgorithm</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    MyCollection&lt;<span class="hljs-keyword">int</span>&gt; mc;<br>    <br>    Iterator&lt;<span class="hljs-keyword">int</span>&gt; iter= mc.<span class="hljs-built_in">GetIterator</span>();<br>    <br>    <span class="hljs-keyword">for</span> (iter.<span class="hljs-built_in">first</span>(); !iter.<span class="hljs-built_in">isDone</span>(); iter.<span class="hljs-built_in">next</span>())&#123;<br>        cout &lt;&lt; iter.<span class="hljs-built_in">current</span>() &lt;&lt; endl;<br>    &#125;<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/2c55fc126b3e7f7a0938bd54ea0af498-feb82.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>迭代器模式在C++已经过时了<ul><li>缺点是面向对象的迭代器的虚函数调用（动态绑定）需要性能成本，而泛型编程的多态是静态绑定。</li><li>有了泛型编程的迭代器，就没有了面向对象的迭代器了。</li></ul></li><li>迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示</li><li>迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。</li><li>迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备忘录模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%EF%BC%9A%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%EF%BC%9A%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，某些对象的状态在转换过程中，可能由于某种需要，要求程序能够回溯到对象之前处于某个点时的状态。如果使用一些公有接口来让其他对象得到对象的状态，便会暴露对象的细节实现。</li><li>如何实现对象状态的良好保存与恢复？但同时又不会因此而破坏对象本身的封装性？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原本保存的状态。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Memento</span></span><br><span class="hljs-class">&#123;</span><br>    string state;<br>    <span class="hljs-comment">//..</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Memento</span>(<span class="hljs-keyword">const</span> string &amp; s) : <span class="hljs-built_in">state</span>(s) &#123;&#125;<br>    <span class="hljs-function">string <span class="hljs-title">getState</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> state; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp; s)</span> </span>&#123; state = s; &#125;<br>&#125;;<br><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Originator</span></span><br><span class="hljs-class">&#123;</span><br>    string state;<br>    <span class="hljs-comment">//....</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Originator</span>() &#123;&#125;<br>    <span class="hljs-function">Memento <span class="hljs-title">createMomento</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">Memento <span class="hljs-title">m</span><span class="hljs-params">(state)</span></span>;<br>        <span class="hljs-keyword">return</span> m;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setMomento</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Memento &amp; m)</span> </span>&#123;<br>        state = m.<span class="hljs-built_in">getState</span>();<br>    &#125;<br>&#125;;<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Originator orginator;<br>    <br>    <span class="hljs-comment">//捕获对象状态，存储到备忘录</span><br>    Memento mem = orginator.<span class="hljs-built_in">createMomento</span>();<br>    <br>    <span class="hljs-comment">//... 改变orginator状态</span><br>    <br>    <span class="hljs-comment">//从备忘录中恢复</span><br>    orginator.<span class="hljs-built_in">setMomento</span>(memento);<br>   <br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a8c463389b28bf24c925f7dd4b745f7f-b47ff.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>备忘录(Memento)存储原发器(Originator)对象的内部状态，在需要时恢复原发器状态。</li><li>Memento模式的核心是信息隐藏，即Originator需要向外界隐藏信息，保持其封装性。但同时又需要将状态保持到外界（Memento）。</li><li>由于现代语言运行时（如C#、JAVA等）都具有相当的对象序列化支持，因此往往采用效率较高、又较容易正确实现的序列化方案来实现Memento模式。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>状态变化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状态模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%EF%BC%9A%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%EF%BC%9A%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，某些对象的状态如果改变，其行为也会随之而发生变化，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。</li><li>如何在运行时根据对象的状态透明地更改对象的行为，而不会为对象操作和状态转化之间引入紧耦合？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>允许一个对象在其内部状态改变时改变它的行为。从而使对象看起来似乎修改了行为。</p><p>——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用状态模式之前：</strong>（出现大量的if-else）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NetworkState</span></span><br><span class="hljs-class">&#123;</span><br>    Network_Open,<br>    Network_Close,<br>    Network_Connect,<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkProcessor</span>&#123;</span><br>    <br>    NetworkState state;<br><br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (state == Network_Open)&#123;<br><br>            <span class="hljs-comment">//**********</span><br>            state = Network_Close;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == Network_Close)&#123;<br><br>            <span class="hljs-comment">//..........</span><br>            state = Network_Connect;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == Network_Connect)&#123;<br><br>            <span class="hljs-comment">//$$$$$$$$$$</span><br>            state = Network_Open;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span> (state == Network_Open)&#123;<br>            <br>            <span class="hljs-comment">//**********</span><br>            state = Network_Connect;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == Network_Close)&#123;<br><br>            <span class="hljs-comment">//.....</span><br>            state = Network_Open;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == Network_Connect)&#123;<br><br>            <span class="hljs-comment">//$$$$$$$$$$</span><br>            state = Network_Close;<br>        &#125;<br>    <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>运用状态模式之后：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkState</span>&#123;</span><br><br><span class="hljs-keyword">public</span>:<br>    NetworkState* pNext;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">NetworkState</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//结合单例模式</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenState</span> :</span><span class="hljs-keyword">public</span> NetworkState&#123;<br>    <br>    <span class="hljs-keyword">static</span> NetworkState* m_instance;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> NetworkState* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (m_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>            m_instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">OpenState</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> m_instance;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span></span>&#123;<br>        <br>        <span class="hljs-comment">//**********</span><br>        pNext = CloseState::<span class="hljs-built_in">getInstance</span>();<span class="hljs-comment">//更改下一个状态</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span></span>&#123;<br>        <br>        <span class="hljs-comment">//..........</span><br>        pNext = ConnectState::<span class="hljs-built_in">getInstance</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span></span>&#123;<br>        <br>        <span class="hljs-comment">//$$$$$$$$$$</span><br>        pNext = OpenState::<span class="hljs-built_in">getInstance</span>();<br>    &#125;<br>    <br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloseState</span>:</span><span class="hljs-keyword">public</span> NetworkState&#123; &#125;<br><span class="hljs-comment">//...</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkProcessor</span>&#123;</span><br>    <br>    NetworkState* pState;<br>    <br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">NetworkProcessor</span>(NetworkState* pState)&#123;<br>        <br>        <span class="hljs-keyword">this</span>-&gt;pState = pState;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>        pState-&gt;<span class="hljs-built_in">Operation1</span>();<br>        pState = pState-&gt;pNext;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>        pState-&gt;<span class="hljs-built_in">Operation2</span>();<br>        pState = pState-&gt;pNext;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>        pState-&gt;<span class="hljs-built_in">Operation3</span>();<br>        pState = pState-&gt;pNext;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/be1b2752ed766f77c6f6f53a5dff29f9-c8dc1.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>状态模式倾向于结合单例模式</li><li>虚函数的本质实际上是运行时的if-else</li><li>State模式将所有与一个特定状态相关的行为都放入一个State的子类对象中，在对象状态切换的时候，切换相应的对象；但同时维持State的接口，这样实现了具体操作与状态转换之间的解耦。</li><li>为不同的状态引入不同的对象使得状态转换变得更加明确，而且可以保证不会出现状态不一致的情况，因为转换是原子性的，即要么彻底转换过来，要么不转换。</li><li>如果State对象没有实例变量，那么各个上下文可以共享同一个State对象，从而节省对象开销。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>状态变化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板方法</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>定义一个操作中的算法的骨架(稳定)，而将一些步骤延迟(变化)到子类中。Template Method使得子类可以不改变(复用)一个算法的结构即可重定义(override重写)该算法的某些特定步骤。——《设计模式》GoF</p></blockquote><p><strong>注意：除了可以灵活应对子步骤的变化外，“不要调用我，让我来调用你”的反向控制结构是Template Method的典型应用。</strong></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用模板方法之前：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//lib.cpp</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Library</span>&#123;</span><br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step1</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//...</span><br>&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step3</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step5</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//main.cpp</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//由应用开发人员来编写流程</span><br><span class="hljs-function">Library <span class="hljs-title">lib</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">Application <span class="hljs-title">app</span><span class="hljs-params">()</span></span>;<br><br>lib.<span class="hljs-built_in">Step1</span>();<br><br><span class="hljs-keyword">if</span> (app.<span class="hljs-built_in">Step2</span>())&#123;<br>lib.<span class="hljs-built_in">Step3</span>();<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br>app.<span class="hljs-built_in">Step4</span>();<br>&#125;<br><br>lib.<span class="hljs-built_in">Step5</span>();<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210708102904.png" alt="运用模板方法之前"></p><p><strong>运用模板方法之后：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//lib</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Library</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//稳定 template method</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span></span>&#123;<br>        <br>        <span class="hljs-built_in">Step1</span>();<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Step2</span>()) &#123; <span class="hljs-comment">//支持变化 ==&gt; 虚函数的多态调用</span><br>            <span class="hljs-built_in">Step3</span>(); <br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br>            <span class="hljs-built_in">Step4</span>(); <span class="hljs-comment">//支持变化 ==&gt; 虚函数的多态调用</span><br>        &#125;<br><br>        <span class="hljs-built_in">Step5</span>();<br><br>    &#125;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Library</span>()&#123; &#125;<br><br><span class="hljs-keyword">protected</span>:<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//稳定</span><br>        <span class="hljs-comment">//.....</span><br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step3</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//稳定</span><br>        <span class="hljs-comment">//.....</span><br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step5</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//稳定</span><br><span class="hljs-comment">//.....</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-comment">//变化</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>=<span class="hljs-number">0</span>; <span class="hljs-comment">//变化</span><br>&#125;;<br><br><span class="hljs-comment">//main</span><br><span class="hljs-comment">//应用程序开发人员</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> :</span> <span class="hljs-keyword">public</span> Library &#123;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//... 子类重写实现</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//... 子类重写实现</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Library* pLib=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Application</span>();<br>    lib-&gt;<span class="hljs-built_in">Run</span>();<br><br><span class="hljs-keyword">delete</span> pLib;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210708110113.png" alt="应用模板方法后"></p><p>在前后的对比中，实质上是运用了虚函数来推迟具体步骤（变化）的实现，但是总体的流程（稳定）是已经事先写好的。运用虚函数的机制将绑定延迟，交由子类实现</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210708110317.png" alt="早绑定与晚绑定"></p><p>早绑定实际上就是在日常开发中，我们调用别人事先写好的库。晚绑定则相反</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>可以通过寻找稳定点来设计并运用模式</li><li>在具体实现方面，被Template Method调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将它们设置为protected方法。</li><li>任何一个基类的析构函数都应该写成虚的</li><li>大多数的设计模式实质上都是“稳定中有变化”</li><li>如果结构中所有的东西都在变化，那么不建议使用设计模式，因为设计模式假设结构中至少有一个稳定点。同样，若是结构中的所有东西都是稳定的，那么运用设计模式也是没有意义的，因为设计模式是在稳定和变化中寻找隔离点。</li><li>稳定是相对的，考量相对的方法也是不一样的。比如A和B，A一年一次变化，而B一周一次变化，那么A对于B是稳定的。</li><li>Template Method模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制（虚函数的多态性）为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组件协作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>策略模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂； 而且有时候支持不使用的算法也是一个性能负担。</p><p>如何在运行时根据需要透明地更改对象的算法？将算法与对象本 身解耦，从而避免上述问题？</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程 序(稳定)而变化（扩展，子类化）。 ——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>运用策略模式之前：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TaxBase</span> &#123;</span><br>CN_Tax,<br>US_Tax,<br>DE_Tax,<br>FR_Tax       <span class="hljs-comment">//更改</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span>&#123;</span><br>    TaxBase tax;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>        <br>        <span class="hljs-keyword">if</span> (tax == CN_Tax)&#123;<br>            <span class="hljs-comment">//CN***********</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tax == US_Tax)&#123;<br>            <span class="hljs-comment">//US***********</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tax == DE_Tax)&#123;<br>            <span class="hljs-comment">//DE***********</span><br>        &#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tax == FR_Tax)&#123;  <span class="hljs-comment">//更改</span><br><span class="hljs-comment">//...</span><br>&#125;<br><br>        <span class="hljs-comment">//....</span><br>     &#125;<br>    <br>&#125;;<br></code></pre></div></td></tr></table></figure><p>运用策略模式之后：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaxStrategy</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">TaxStrategy</span>()&#123;&#125;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CNTax</span> :</span> <span class="hljs-keyword">public</span> TaxStrategy&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span></span>&#123;<br>        <span class="hljs-comment">//***********</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">USTax</span> :</span> <span class="hljs-keyword">public</span> TaxStrategy&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span></span>&#123;<br>        <span class="hljs-comment">//***********</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DETax</span> :</span> <span class="hljs-keyword">public</span> TaxStrategy&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span></span>&#123;<br>        <span class="hljs-comment">//***********</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//扩展</span><br><span class="hljs-comment">//*********************************</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FRTax</span> :</span> <span class="hljs-keyword">public</span> TaxStrategy&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span></span>&#123;<br><span class="hljs-comment">//.........</span><br>&#125;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    TaxStrategy* strategy;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SalesOrder</span>(StrategyFactory* strategyFactory)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;strategy = strategyFactory-&gt;<span class="hljs-built_in">NewStrategy</span>();<br>    &#125;<br>    ~<span class="hljs-built_in">SalesOrder</span>()&#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;strategy;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-function">Context <span class="hljs-title">context</span><span class="hljs-params">()</span></span>;<br>        <br>        <span class="hljs-keyword">double</span> val = <br>            strategy-&gt;<span class="hljs-built_in">Calculate</span>(context); <span class="hljs-comment">//多态调用</span><br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <br>&#125;;<br></code></pre></div></td></tr></table></figure><p>即：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5191ec8f720daee9fb5a2cdf2f6819c4-c2caee.png" alt="结构"></p><p>运用策略模式之前，代码违反开闭原则，不停的修改if-else。</p><p><strong>问题：</strong>if-else虽然更改了，但是更改的也只是在后面添加，前面的if-else不是也被复用了吗？</p><p><strong>答：</strong>复用性一般讲的是编译方面二进制的复用性。虽然只在后面添加，但是代码需要重新编译。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>面向过程的分而治之一般可以用面向对象的抽象来解决</p></li><li><p>当控制语句（if-else或switch）出现的时候，若出现控制语句会不停的修改，那么就可以考虑应用设计模式。相反的，绝对稳定不变的（比如一周有七天，周一干什么周二干什么…）可以保留控制语句</p></li><li>Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。</li><li>Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需 要Strategy模式。</li><li>如果Strategy对象没有实例变量，那么各个上下文可以共享同一个 Strategy对象，从而节省对象开销。（单例模式）</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组件协作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>观察者模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%EF%BC%9A%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%EF%BC%9A%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系” ——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密， 将使软件不能很好地抵御变化。——《设计模式》GoF</li><li>使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>以下代码为文件分割器。主要流程是<code>MainForm</code>调用<code>FileSplitter</code>来分割文件，<code>FileSplitter</code>在分割文件的过程中将计算出来的进度传给<code>MainForm</code>，由<code>MainForm</code>在界面上显示具体进度。</p><p>运用观察者模式之前：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span></span><br><span class="hljs-class">&#123;</span><br>string m_filePath;<br><span class="hljs-keyword">int</span> m_fileNumber;<br>ProgressBar* m_progressBar;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">FileSplitter</span>(<span class="hljs-keyword">const</span> string&amp; filePath, <span class="hljs-keyword">int</span> fileNumber, ProgressBar* progressBar) :<br><span class="hljs-built_in">m_filePath</span>(filePath), <br><span class="hljs-built_in">m_fileNumber</span>(fileNumber),<br><span class="hljs-built_in">m_progressBar</span>(progressBar)&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span></span>&#123;<br><br><span class="hljs-comment">//1.读取大文件</span><br><br><span class="hljs-comment">//2.分批次向小文件中写入</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++)&#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">float</span> progressValue = m_fileNumber;<br>progressValue = (i + <span class="hljs-number">1</span>) / progressValue;<br>m_progressBar-&gt;<span class="hljs-built_in">setValue</span>(progressValue);<br>&#125;<br><br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form<br>&#123;<br>TextBox* txtFilePath;<br>TextBox* txtFileNumber;<br>ProgressBar* progressBar;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span></span>&#123;<br><br>string filePath = txtFilePath-&gt;<span class="hljs-built_in">getText</span>();<br><span class="hljs-keyword">int</span> number = <span class="hljs-built_in">atoi</span>(txtFileNumber-&gt;<span class="hljs-built_in">getText</span>().<span class="hljs-built_in">c_str</span>());<br><br><span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number, progressBar)</span></span>;<br><br>splitter.<span class="hljs-built_in">split</span>();<br><br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>运用观察者模式之后：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IProgress</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span></span>=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IProgress</span>()&#123;&#125;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span></span><br><span class="hljs-class">&#123;</span><br>string m_filePath;<br><span class="hljs-keyword">int</span> m_fileNumber;<br><br>List&lt;IProgress*&gt;  m_iprogressList; <span class="hljs-comment">// 抽象通知机制，支持多个观察者</span><br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">FileSplitter</span>(<span class="hljs-keyword">const</span> string&amp; filePath, <span class="hljs-keyword">int</span> fileNumber) :<br><span class="hljs-built_in">m_filePath</span>(filePath), <br><span class="hljs-built_in">m_fileNumber</span>(fileNumber)&#123;<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span></span>&#123;<br><br><span class="hljs-comment">//1.读取大文件</span><br><br><span class="hljs-comment">//2.分批次向小文件中写入</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++)&#123;<br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">float</span> progressValue = m_fileNumber;<br>progressValue = (i + <span class="hljs-number">1</span>) / progressValue;<br><span class="hljs-built_in">onProgress</span>(progressValue);<span class="hljs-comment">//发送通知</span><br>&#125;<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addIProgress</span><span class="hljs-params">(IProgress* iprogress)</span></span>&#123;<br>m_iprogressList.<span class="hljs-built_in">push_back</span>(iprogress);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeIProgress</span><span class="hljs-params">(IProgress* iprogress)</span></span>&#123;<br>m_iprogressList.<span class="hljs-built_in">remove</span>(iprogress);<br>&#125;<br><br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span></span>&#123;<br><br>List&lt;IProgress*&gt;::iterator itor=m_iprogressList.<span class="hljs-built_in">begin</span>();<br><br><span class="hljs-keyword">while</span> (itor != m_iprogressList.<span class="hljs-built_in">end</span>() )<br>(*itor)-&gt;<span class="hljs-built_in">DoProgress</span>(value); <span class="hljs-comment">//更新进度条</span><br>itor++;<br>&#125;<br>&#125;<br>&#125;;<br><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form, <span class="hljs-keyword">public</span> IProgress<br>&#123;<br>TextBox* txtFilePath;<br>TextBox* txtFileNumber;<br><br>ProgressBar* progressBar;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span></span>&#123;<br><br>string filePath = txtFilePath-&gt;<span class="hljs-built_in">getText</span>();<br><span class="hljs-keyword">int</span> number = <span class="hljs-built_in">atoi</span>(txtFileNumber-&gt;<span class="hljs-built_in">getText</span>().<span class="hljs-built_in">c_str</span>());<br><br>ConsoleNotifier cn;<br><br><span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;<br><br>splitter.<span class="hljs-built_in">addIProgress</span>(<span class="hljs-keyword">this</span>); <span class="hljs-comment">//订阅通知</span><br>splitter.<span class="hljs-built_in">addIProgress</span>(&amp;cn)； <span class="hljs-comment">//订阅通知</span><br><br>splitter.<span class="hljs-built_in">split</span>();<br><br>splitter.<span class="hljs-built_in">removeIProgress</span>(<span class="hljs-keyword">this</span>);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span></span>&#123;<br>progressBar-&gt;<span class="hljs-built_in">setValue</span>(value);<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsoleNotifier</span> :</span> <span class="hljs-keyword">public</span> IProgress &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;.&quot;</span>;<br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>比较上面两段代码，在运用观察者模式之前：</p><ul><li><code>MainForm</code>与<code>FileSplitter</code>高耦合，从两者的初始化过程和相互之间捆绑的<code>ProgressBar</code>类型指针就可看出，牵一发而动全身。</li><li>对于<code>ProgressBar</code>，这种设计思路十分不妥。如果客户需求更改，使用其他的形式来显示进度，那么<code>ProgressBar</code>需要更换成其他的实现类。可以看出，此例违反了依赖倒置原则。</li></ul><p>在运用观察者模式之后：</p><ul><li>将<code>ProgressBar</code>抽象成一个父类，作为接口<code>IProgress</code>。经过这样的处理，不仅将<code>MainForm</code>和<code>FileSplitter</code>从紧耦合优化成了松耦合，还可以灵活的支持不同的进度显示。</li><li>对于<code>FileSplitter</code>来说，<code>MainForm</code>是接收<code>FileSplitter</code>通知（上例的通知就是进度）的一份子。只要在<code>FileSplitter</code>中注册过，那么每当<code>FileSplitter</code>发送通知，所有已经注册过的<code>MainForm</code>就会接收（继承的接口中实现的虚函数<code>DoProgress</code>被调用）到通知。此处，<code>FileSplitter</code>为<strong>“被观察者”</strong>，<code>MainForm</code>为<strong>“观察者”</strong>。</li><li>对于观察者而言：只要你注册了，就可以接收到通知。</li><li>对于被观察者而言：发送通知时，只要在被观察者内部注册过，都会进行发送</li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/26a238c797118c47e2d6c9190cac73dd-8d1f4c.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>C++虽然有多继承，但是不推荐使用，因为会带来耦合。而如果继承的是一个父类加上多个接口就可以。</li><li>对于现实需求有变化的实体，比如本文的进度条。有很多种方式可以表示进度，比如直接用数字表示。对于这种情况一般可以把容易变化的对象进行更深层次的抽象。对于本文中未运用观察者模式之前的代码，已经违反了依赖倒置原则。</li><li>有些框架是把Observer的注册、删除、通知放在一个基类里。</li><li>使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合。</li><li>目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。</li><li>观察者自己决定是否需要订阅通知，目标对象对此一无所知。</li><li>Observer模式是基于事件的UI框架中非常常用的设计模式，也是 MVC模式的一个重要组成部分。</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组件协作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%8F%98%E5%8C%96%EF%BC%9A%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%8F%98%E5%8C%96%EF%BC%9A%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，”行为请求者“与”行为实现者“通常呈现一种”紧耦合“。但在某些场合，比如需要对行为进行”记录、撤销/重(undo/redo)、事务“等处理，这种无法抵御变化的紧耦合是不合适的。</li><li>在这种情况下，如何将”行为请求者“与”行为实现者“解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>将一个请求（行为）封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Command</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteCommand1</span> :</span> <span class="hljs-keyword">public</span> Command<br>&#123;<br>    string arg;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ConcreteCommand1</span>(<span class="hljs-keyword">const</span> string &amp; a) : <span class="hljs-built_in">arg</span>(a) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt; <span class="hljs-string">&quot;#1 process...&quot;</span>&lt;&lt;arg&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteCommand2</span> :</span> <span class="hljs-keyword">public</span> Command<br>&#123;<br>    string arg;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ConcreteCommand2</span>(<span class="hljs-keyword">const</span> string &amp; a) : <span class="hljs-built_in">arg</span>(a) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt; <span class="hljs-string">&quot;#2 process...&quot;</span>&lt;&lt;arg&lt;&lt;endl;<br>    &#125;<br>&#125;;<br>        <br>        <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MacroCommand</span> :</span> <span class="hljs-keyword">public</span> Command<br>&#123;<br>    vector&lt;Command*&gt; commands;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addCommand</span><span class="hljs-params">(Command *c)</span> </span>&#123; commands.<span class="hljs-built_in">push_back</span>(c); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c : commands)<br>        &#123;<br>            c-&gt;<span class="hljs-built_in">execute</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br>                <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-function">ConcreteCommand1 <span class="hljs-title">command1</span><span class="hljs-params">(receiver, <span class="hljs-string">&quot;Arg ###&quot;</span>)</span></span>;<br>    <span class="hljs-function">ConcreteCommand2 <span class="hljs-title">command2</span><span class="hljs-params">(receiver, <span class="hljs-string">&quot;Arg $$$&quot;</span>)</span></span>;<br>    <br>    MacroCommand macro;<br>    macro.<span class="hljs-built_in">addCommand</span>(&amp;command1);<br>    macro.<span class="hljs-built_in">addCommand</span>(&amp;command2);<br>    <br>    macro.<span class="hljs-built_in">execute</span>();<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/54df981e468227d271d5f54e9d39c869-77569.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Command模式的根本目的在于将”行为请求者“与”行为实现者“解耦，在面向对象语言中，常见的实现手段是”将行为抽象为对象“。</li><li>实现<code>Command</code>接口的具体命令对象<code>ConcreteCommand</code>有时候根据需要可能会保存一些额外的状态信息。通过使用Composite模式，可以将多个”命令“封装为一个”复合命令“<code>MacroCommand</code>。</li><li>Command模式与C++中的函数对象有些类似。但两者定义行为接口的规范有所区别：Command以面向对象中的”接口-实现“来定义行为接口规范，更严格，但有性能损失；C++函数对象以函数签名来定义行为接口规范，更灵活，性能更高。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>行为变化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>访问器模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%8F%98%E5%8C%96%EF%BC%9A%E8%AE%BF%E9%97%AE%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%8F%98%E5%8C%96%EF%BC%9A%E8%AE%BF%E9%97%AE%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，由于需求的改变，某些类层次结构中常常需要增加新的行为（方法），如果在基类中做这样的更改，将会给子类带来很繁重的变更负担，甚至破坏原有设计。</li><li>如何在不改变类层次结构的前提下，在运行时根据需要透明地为类层次结构上的各个类动态添加新的操作，从而避免上述问题？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>表示一个作用于某对象结构中的各元素的操作。使得可以在不改变（稳定）各元素的类的前提下定义（扩展）作用于这些元素的新操作（变化）。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用访问器模式之前：</strong></p><p>如果后期需求的变动，需要<code>Element</code>派生类需要添加功能，那么不仅在<code>Element</code>中需要添加，同时<code>Element</code>派生类中也需要添加，违反了开闭原则。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visitor</span>;</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Element</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Func1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Func3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//...</span><br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Element</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementA</span> :</span> <span class="hljs-keyword">public</span> Element<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func1</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementB</span> :</span> <span class="hljs-keyword">public</span> Element<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func1</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <span class="hljs-comment">//***</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">//***</span><br>    &#125;<br>    <br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>运用访问器模式之后：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visitor</span>;</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Element</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor&amp; visitor)</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//第一次多态辨析</span><br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Element</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementA</span> :</span> <span class="hljs-keyword">public</span> Element<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor &amp;visitor)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        visitor.<span class="hljs-built_in">visitElementA</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <br><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementB</span> :</span> <span class="hljs-keyword">public</span> Element<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor &amp;visitor)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        visitor.<span class="hljs-built_in">visitElementB</span>(*<span class="hljs-keyword">this</span>); <span class="hljs-comment">//第二次多态辨析</span><br>    &#125;<br><br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visitor</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitElementA</span><span class="hljs-params">(ElementA&amp; element)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitElementB</span><span class="hljs-params">(ElementB&amp; element)</span> </span>= <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Visitor</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//==================================</span><br><br><span class="hljs-comment">//扩展1</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visitor1</span> :</span> <span class="hljs-keyword">public</span> Visitor&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visitElementA</span><span class="hljs-params">(ElementA&amp; element)</span> <span class="hljs-keyword">override</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Visitor1 is processing ElementA&quot;</span> &lt;&lt; endl;<br>    &#125;<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visitElementB</span><span class="hljs-params">(ElementB&amp; element)</span> <span class="hljs-keyword">override</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Visitor1 is processing ElementB&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br>     <br><span class="hljs-comment">//扩展2</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visitor2</span> :</span> <span class="hljs-keyword">public</span> Visitor&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visitElementA</span><span class="hljs-params">(ElementA&amp; element)</span> <span class="hljs-keyword">override</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Visitor2 is processing ElementA&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visitElementB</span><span class="hljs-params">(ElementB&amp; element)</span> <span class="hljs-keyword">override</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Visitor2 is processing ElementB&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br>        <br>    <br><br>        <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Visitor2 visitor;<br>    ElementB elementB;<br>    elementB.<span class="hljs-built_in">accept</span>(visitor);<span class="hljs-comment">// double dispatch</span><br>    <br>    ElementA elementA;<br>    elementA.<span class="hljs-built_in">accept</span>(visitor);<br><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果此时需要为Element派生类添加新功能，只需要将Visitor再派生出一个子类出来，让这个子类来解决即可。</p><p>但是这个模式看起来会比较不灵活，原因是Element必须是稳定的，在设计之初就应该确定好，后期不能再更改了；同样的Element派生类的数量也需要稳定不变。</p><p>用白话解释就是：将我交给别人执行，只是别人很懒，不愿意我有任何改动。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/2c641454658042ce3af98cbf658b4bc2-476f4.png" alt="结构"></p><p>从整体看感觉有点像在代码层面模仿类的虚函数实现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Visitor存在的前提是Element派生类的个数确定。也就是说当Element的派生数量不稳定，剧烈变化，访问器模式就不适用了。</li><li>Visitor模式通过所谓的双重分发（double dispatch）来实现在不更改（不添加新的操作-编译时）Element类层次结构的前提下，在运行时透明地为类层次结构上的各个类动态添加新的操作（支持变化）。</li><li>所谓双重分发即Visitor模式中间包括了两个多态分发（注意其中的多态机制）：第一个为accept方法的多态辨析；第二个为visitElementX方法的多态辨析。</li><li>Visitor模式的最大缺点在于扩展类层次结构（增添新的Element子类），会导致Visitor模式的改变。因此Visitor模式适用于”Element类层次结构稳定，而其中的操作却经常面临频繁改动”。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>行为变化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象设计原则</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h2 id="依赖倒置（DIP）"><a href="#依赖倒置（DIP）" class="headerlink" title="依赖倒置（DIP）"></a>依赖倒置（DIP）</h2><ul><li>高层模块(稳定)不应该依赖于低层模块（变化），二者应依赖于抽象（稳定）</li><li>抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）</li></ul><p><strong>注：这里所说的依赖是编译式依赖</strong></p><p>现在需要我们写一个能画指定图形的方法，我们通常在脑海里会有如下思路：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">line</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">line</span>();<br>~<span class="hljs-built_in">line</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">rect</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">rect</span>();<br>~<span class="hljs-built_in">rect</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawShape</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string type)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;line&quot;</span>)<br>&#123;<br>line l;<br>l.<span class="hljs-built_in">draw</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;rect&quot;</span>)<br>&#123;<br>rect r;<br>r.<span class="hljs-built_in">draw</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">drawShape</span>(<span class="hljs-string">&quot;line&quot;</span>);<span class="hljs-comment">/*画直线*/</span><br><span class="hljs-built_in">drawShape</span>(<span class="hljs-string">&quot;rect&quot;</span>);<span class="hljs-comment">/*画矩形*/</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><br>这时候，需求变了，需要再添加一个画圆形的方法，那么上面的代码需要改成：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">line</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">line</span>();<br>~<span class="hljs-built_in">line</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">rect</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">rect</span>();<br>~<span class="hljs-built_in">rect</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">circle</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">circle</span>();<br>~<span class="hljs-built_in">circle</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawShape</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string type)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;line&quot;</span>)<br>&#123;<br>line l;<br>l.<span class="hljs-built_in">draw</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;rect&quot;</span>)<br>&#123;<br>rect r;<br>r.<span class="hljs-built_in">draw</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;circle&quot;</span>)<span class="hljs-comment">/*此处改动*/</span><br>&#123;<br>circle c;<br>c.<span class="hljs-built_in">draw</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">drawShape</span>(<span class="hljs-string">&quot;line&quot;</span>);<span class="hljs-comment">/*画直线*/</span><br><span class="hljs-built_in">drawShape</span>(<span class="hljs-string">&quot;rect&quot;</span>);<span class="hljs-comment">/*画矩形*/</span><br><span class="hljs-built_in">drawShape</span>(<span class="hljs-string">&quot;circle&quot;</span>);<span class="hljs-comment">/*画圆形*/</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​        看起来没毛病，逻辑上符合我们的需求。在实际应用场景中，高层模块通常调用低层模块。在上述代码里，我们可以把main函数看成高层模块，line，rect，circle等具体实现类看成低层模块。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道在开发中，需求是不断在变化的。今天让你添加一个画圆形的需求，明天又让你添加一个画梯形的需求。从需求的角度看，低层模块不断在变化，这是其一。其二，代码修改的原因不仅限于需求变更。从低层模块的内部出发，不同的平台，不同的硬件，不同的API或者调用方法，都会导致低层模块的实现随时更改。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据这两点，我们可以得出低层模块是不稳定的，是随时会更改的。此时我们再来看上面的代码，会发现高层模块直接依赖于低层模块，这将导致高层模块也变得不稳定，不符合依赖倒置原则。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210415173908.png" alt="不符合依赖倒置原则"><br>        为了满足依赖倒置原则，我们从面向对象设计的一个核心出发：抽象。我们把低层模块抽象成一个基类，即shape，并让所有需求实现接口draw()。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shape</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">shape</span>();<br>~<span class="hljs-built_in">shape</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">line</span>:</span><span class="hljs-keyword">public</span> shape<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">line</span>();<br>~<span class="hljs-built_in">line</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">rect</span> :</span><span class="hljs-keyword">public</span> shape<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">rect</span>();<br>~<span class="hljs-built_in">rect</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>shape* s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">rect</span>();<br>s-&gt;<span class="hljs-built_in">draw</span>();<span class="hljs-comment">/*画矩形*/</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​        如果再添加一个画圆形的需求，和line、rect这两个类一样，我们只要负责实现circle这个类就行，而我们抽象出来的shape这个类是不需要改变的，也就是说这个抽象类是稳定的，通过接口隔离了高低两个模块。此时高层模块依赖于抽象，低层模块也依赖于抽象。</p><p>​        若此时我们需要修改画直线的方法，只要修改line类中的draw方法即可，抽象出来的shape我们无需改动。也就是说，抽象不关心你是如何实现的（抽象不依赖于实现细节），但是你要实现什么，由抽象来决定（实现细节应该依赖于抽象）。<br><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210415180439.png" alt="图2"></p><h2 id="开放封闭原则（OCP）"><a href="#开放封闭原则（OCP）" class="headerlink" title="开放封闭原则（OCP）"></a>开放封闭原则（OCP）</h2><ul><li>对扩展开放，对更改封闭</li><li>类模块应该是可扩展的，但是不可修改</li></ul><p>依旧是这段代码，只是稍加修改：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">line</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">line</span>();<br>~<span class="hljs-built_in">line</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">rect</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">rect</span>();<br>~<span class="hljs-built_in">rect</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">drawShape</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">drawShape</span>();<br>~<span class="hljs-built_in">drawShape</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string type)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;line&quot;</span>)<br>&#123;<br>line l;<br>l.<span class="hljs-built_in">draw</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;rect&quot;</span>)<br>&#123;<br>rect r;<br>r.<span class="hljs-built_in">draw</span>();<br>&#125;<br>&#125;<br><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>drawShape d;<br>d.<span class="hljs-built_in">draw</span>(<span class="hljs-string">&quot;line&quot;</span>);<span class="hljs-comment">/*画直线*/</span><br>d.<span class="hljs-built_in">draw</span>(<span class="hljs-string">&quot;rect&quot;</span>);<span class="hljs-comment">/*画矩形*/</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><br>此时同样新增了一个画圆形的需求：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">line</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">line</span>();<br>~<span class="hljs-built_in">line</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">rect</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">rect</span>();<br>~<span class="hljs-built_in">rect</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">circle</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">circle</span>();<br>~<span class="hljs-built_in">circle</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">drawShape</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">drawShape</span>();<br>~<span class="hljs-built_in">drawShape</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string type)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;line&quot;</span>)<br>&#123;<br>line l;<br>l.<span class="hljs-built_in">draw</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;rect&quot;</span>)<br>&#123;<br>rect r;<br>r.<span class="hljs-built_in">draw</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;circle&quot;</span>)<span class="hljs-comment">/*此处更改*/</span><br>&#123;<br>circle c;<br>c.<span class="hljs-built_in">draw</span>();<br>&#125;<br>&#125;<br><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>drawShape ds;<br>ds.<span class="hljs-built_in">draw</span>(<span class="hljs-string">&quot;line&quot;</span>);<span class="hljs-comment">/*画直线*/</span><br>ds.<span class="hljs-built_in">draw</span>(<span class="hljs-string">&quot;rect&quot;</span>);<span class="hljs-comment">/*画矩形*/</span><br>ds.<span class="hljs-built_in">draw</span>(<span class="hljs-string">&quot;circle&quot;</span>);<span class="hljs-comment">/*画圆形*/</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​        这样的写法在逻辑上没有任何问题，也符合我们的需求。但是当有新的需求不断出现，drawShape类中的draw方法就得不停的修改。这种做法不仅会让开发效率低下，而且还违反了开放封闭原则（对更改封闭）。<br>​        为了满足开放封闭原则，我们同样采取抽象的办法：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shape</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">shape</span>();<br>~<span class="hljs-built_in">shape</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">line</span> :</span><span class="hljs-keyword">public</span> shape<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">line</span>();<br>~<span class="hljs-built_in">line</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">rect</span> :</span><span class="hljs-keyword">public</span> shape<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">rect</span>();<br>~<span class="hljs-built_in">rect</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">circle</span>:</span><span class="hljs-keyword">public</span> shape<br>&#123;<br><span class="hljs-built_in">circle</span>();<br>~<span class="hljs-built_in">circle</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">drawShape</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">drawShape</span>();<br>~<span class="hljs-built_in">drawShape</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(shape* s)</span></span><br><span class="hljs-function"></span>&#123;<br>s-&gt;<span class="hljs-built_in">draw</span>();<br>&#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>drawShape ds;<br>ds.<span class="hljs-built_in">draw</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">rect</span>());<span class="hljs-comment">/*画矩形*/</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​        我们添加了一个shape抽象类，原有的drawShape中的draw方法重写，修改成依赖于shape提供的接口draw。这时你的需求无论怎么添加（对扩展开放），drawShape这个类始终不用修改（对更改封闭）。<br>​        开放封闭原则和依赖倒置原则，在抽象这个角度上都有一定的相似性。借用另外一位博主的话：“开放封闭原则通过抽象来避免代码发生更改，而依赖倒置原则更偏向于层和层之间的解耦”。</p><h2 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h2><ul><li>一个类应该仅有一个引起它变化的原因</li><li>变化的方向隐含着类的责任</li></ul><p>字面意思，说白了就是一个类应该只有一种职责，避免责任太多导致的代码臃肿（比如上帝类）。</p><h2 id="Liskov替换原则（LSP）"><a href="#Liskov替换原则（LSP）" class="headerlink" title="Liskov替换原则（LSP）"></a>Liskov替换原则（LSP）</h2><ul><li>子类必须能够替换它们的基类（IS-A）</li><li>继承表达类型抽象<br>所有需要父类的地方，子类都可以传过去。</li></ul><h2 id="GOF模式分类"><a href="#GOF模式分类" class="headerlink" title="GOF模式分类"></a>GOF模式分类</h2><p>从目的来看：</p><ol><li>创建型</li><li>结构型</li><li>行为型</li></ol><p>从范围来看：</p><ol><li>类模式处理类与子类的静态关系</li><li>对象模式处理对象间的动态关系</li></ol><hr><h3 id="从封装变化角度对模式分类"><a href="#从封装变化角度对模式分类" class="headerlink" title="从封装变化角度对模式分类"></a>从封装变化角度对模式分类</h3><div class="table-container"><table><thead><tr><th style="text-align:left">类别</th><th>模式</th></tr></thead><tbody><tr><td style="text-align:left">组件协作</td><td>Template Method,Strategy,Observer/Event</td></tr><tr><td style="text-align:left">单一职责</td><td>Decoraror,Bridge</td></tr><tr><td style="text-align:left">对象创建</td><td>Factory Method,Abstract Factory,Prototype,Builder</td></tr><tr><td style="text-align:left">对象性能</td><td>Singleton,Flyweight</td></tr><tr><td style="text-align:left">接口隔离</td><td>Facade,Proxy,Mediator, Adapter</td></tr><tr><td style="text-align:left">状态变化</td><td>Memento,State</td></tr><tr><td style="text-align:left">数据结构</td><td>Composite,Iterator,Chain of Resposibility</td></tr><tr><td style="text-align:left">行为变化</td><td>Command,Visitor</td></tr><tr><td style="text-align:left">领域问题</td><td>Interpreter</td></tr></tbody></table></div><ul><li>组件协作：现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过晚期绑定，来实现框架与应用程序之 间的松耦合，是二者之间协作时常用的模式。</li><li>单一职责：在软件组件的设计中，如果责任划分的不清晰，使用继承得到的 结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。</li><li>对象创建：通过“对象创建” 模式绕开new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。</li><li>对象性能：面向对象很好地解决了”抽象“的问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面对对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。</li><li>接口隔离：在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。</li><li>状态变化：在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？”状态变化“模式为这一问题提供了一种解决方案。</li><li>数据结构：常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。</li><li>行为变化：在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。”行为变化“模式将组件的行为和组件本身进行解耦，从而支持组件行为的变化，实现两者之间的松耦合。</li><li>领域规则：在特定领域中，某些变化虽然频繁，但可以抽象为某种规则。这时候，结合特定领域，将问题抽象为语法规则，将问题抽象为语法规则，从而给出在该领域下的一般性解决方案。</li></ul><h2 id="重构获得模式"><a href="#重构获得模式" class="headerlink" title="重构获得模式"></a>重构获得模式</h2><p>即通过修正来得到一种良好的解决方案</p><p>重构技巧：（以下五点实际上是同一回事）</p><ul><li>静态-&gt;动态</li><li>早绑定-&gt;晚绑定</li><li>继承-&gt;组合</li><li>编译时依赖-&gt;运行时依赖</li><li>紧耦合-&gt;松耦合</li></ul><p>重构要点：</p><ol><li>寻找变化点，在变化点处应用设计模式。将变化和稳定分离开</li></ol><h2 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h2><ul><li>不要为了模式而模式</li><li>关注抽象类&amp;接口</li><li>理清变化点和稳定点</li><li>审视依赖关系</li><li>要有Framework和Application的区隔思维</li><li>良好的设计是演化的结果</li></ul><h2 id="什么时候不用模式"><a href="#什么时候不用模式" class="headerlink" title="什么时候不用模式"></a>什么时候不用模式</h2><ul><li>代码可读性很差时</li><li>需求理解还很浅时</li><li>变化没有显现时</li><li>不是系统的关键依赖点</li><li>项目没有复用价值时</li><li>项目将要发布时</li></ul><blockquote><p>参考：<br><a href="https://blog.csdn.net/tjiyu/article/details/76551307">面向对象设计原则（三）：里氏替换原则（LSP）</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解释器模式</title>
    <link href="/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%A2%86%E5%9F%9F%E8%A7%84%E5%88%99%EF%BC%9A%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%A2%86%E5%9F%9F%E8%A7%84%E5%88%99%EF%BC%9A%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，如果某一特定领域的问题比较复杂，类似的结构不断重复出现，如果使用普通的编程方式来实现将面临非常频繁的变化。</li><li>在这种情况下，将特定领域的问题表达为某种语法规则下的句子，然后构建一个解释器来解释这样的句子，从而达到解决问题的目的。</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表达来解释语言中的句子。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>以下模拟计算算术表达式（只有加法和减法）：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Expression</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; var)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Expression</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//变量表达式</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VarExpression</span>:</span> <span class="hljs-keyword">public</span> Expression &#123;<br>    <br>    <span class="hljs-keyword">char</span> key;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">VarExpression</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>&amp; key)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;key = key;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; var)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> var[key];<br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-comment">//符号表达式</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SymbolExpression</span> :</span> <span class="hljs-keyword">public</span> Expression &#123;<br>    <br>    <span class="hljs-comment">// 运算符左右两个参数</span><br><span class="hljs-keyword">protected</span>:<br>    Expression* left;<br>    Expression* right;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SymbolExpression</span>( Expression* left,  Expression* right):<br>        <span class="hljs-built_in">left</span>(left),<span class="hljs-built_in">right</span>(right)&#123;<br>        <br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-comment">//加法运算</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddExpression</span> :</span> <span class="hljs-keyword">public</span> SymbolExpression &#123;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">AddExpression</span>(Expression* left, Expression* right):<br>        <span class="hljs-built_in">SymbolExpression</span>(left,right)&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; var)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> left-&gt;<span class="hljs-built_in">interpreter</span>(var) + right-&gt;<span class="hljs-built_in">interpreter</span>(var);<br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-comment">//减法运算</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubExpression</span> :</span> <span class="hljs-keyword">public</span> SymbolExpression &#123;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SubExpression</span>(Expression* left, Expression* right):<br>        <span class="hljs-built_in">SymbolExpression</span>(left,right)&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; var)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> left-&gt;<span class="hljs-built_in">interpreter</span>(var) - right-&gt;<span class="hljs-built_in">interpreter</span>(var);<br>    &#125;<br>    <br>&#125;;<br><br><br><br><span class="hljs-function">Expression*  <span class="hljs-title">analyse</span><span class="hljs-params">(string expStr)</span> </span>&#123;<br>    <br>    stack&lt;Expression*&gt; expStack;<br>    Expression* left = <span class="hljs-literal">nullptr</span>;<br>    Expression* right = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;expStr.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>(expStr[i])<br>        &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                <span class="hljs-comment">// 加法运算</span><br>                left = expStack.<span class="hljs-built_in">top</span>();<br>                right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">VarExpression</span>(expStr[++i]);<br>                expStack.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">AddExpression</span>(left, right));<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                <span class="hljs-comment">// 减法运算</span><br>                left = expStack.<span class="hljs-built_in">top</span>();<br>                right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">VarExpression</span>(expStr[++i]);<br>                expStack.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">SubExpression</span>(left, right));<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-comment">// 变量表达式</span><br>                expStack.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">VarExpression</span>(expStr[i]));<br>        &#125;<br>    &#125;<br>   <br>    Expression* expression = expStack.<span class="hljs-built_in">top</span>();<br><br>    <span class="hljs-keyword">return</span> expression;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">(Expression* expression)</span></span>&#123;<br>    <br>    <span class="hljs-comment">//释放表达式树的节点内存...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;<br>    <br>    <br>    string expStr = <span class="hljs-string">&quot;a+b-c+d-e&quot;</span>;<br>    map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; var;<br>    var.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">5</span>));<br>    var.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">2</span>));<br>    var.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">1</span>));<br>    var.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-number">6</span>));<br>    var.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">10</span>));<br><br>    <br>    Expression* expression= <span class="hljs-built_in">analyse</span>(expStr);<br>    <br>    <span class="hljs-keyword">int</span> result=expression-&gt;<span class="hljs-built_in">interpreter</span>(var);<br>    <br>    cout&lt;&lt;result&lt;&lt;endl;<br>    <br>    <span class="hljs-built_in">release</span>(expression);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a81690cc50fbd0dc2f1b5dbf2208a81e-ad92d.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Interpreter模式的应用场合是Interpreter模式应用中的难点，只有满足”业务规则频繁变化，且类似的结构不断重复出现，并且容易抽象为语法规则的问题“才适合使用Interpreter模式。</li><li>使用Interpreter模式来表示文法规则，从而可以使用面向对象技巧来方便地”扩展“文法。</li><li>Interpreter模式比较适合简单的文法表示，对于复杂的文法表示，Interpreter模式会产生比较大的类层次结构，需要求助于语法分析生成器这样的标准工具。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>领域规则</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
