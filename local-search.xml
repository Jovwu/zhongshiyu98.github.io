<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>1137. 第 N 个泰波那契数</title>
    <link href="/2021/10/02/LeetCode/1137.%20%E7%AC%AC%20N%20%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <url>/2021/10/02/LeetCode/1137.%20%E7%AC%AC%20N%20%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/">本题链接</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tribonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            <br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>,dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>,dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>;i &lt;= n;++i)<br>            dp[i] = dp[i<span class="hljs-number">-3</span>] + dp[i<span class="hljs-number">-2</span>] + dp[i<span class="hljs-number">-1</span>];<br>        <br><br>        <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和斐波那契数列一个思路，很容易求出状态转移方程：</p><script type="math/tex; mode=display">dp[i]=dp[i-3]+dp[i-2]+dp[i-1]</script><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>405. 数字转换为十六进制数</title>
    <link href="/2021/10/02/LeetCode/405.%20%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
    <url>/2021/10/02/LeetCode/405.%20%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/">本题链接</a></p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">toHex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        <br>        <span class="hljs-comment">//16进制对应的表示方式</span><br>        string hex = <span class="hljs-string">&quot;0123456789abcdef&quot;</span>;<br>        <span class="hljs-comment">//表示每个字节对应的位</span><br>        <span class="hljs-keyword">int</span> arr[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>&#125;;<br>        string ans;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">8</span>;++i)&#123;<span class="hljs-comment">//每8个字节</span><br>            <br>            <span class="hljs-keyword">int</span> cur_x = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-number">4</span>;++j)&#123;<span class="hljs-comment">//每四位（即一个字节）</span><br><br>                cur_x += ((num &amp; <span class="hljs-number">0x1</span>) * arr[j]);<br>                num &gt;&gt;= <span class="hljs-number">1</span>;<br>            &#125;<br><br>            ans.<span class="hljs-built_in">push_back</span>(hex[cur_x]);<br><br>        &#125;<br><br>        <span class="hljs-comment">//删除前导0</span><br>        <span class="hljs-keyword">while</span>(ans.<span class="hljs-built_in">back</span>() == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            ans.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-comment">//反转</span><br>        <span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>,hi = ans.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(lo &lt;= hi)&#123;<br>            <span class="hljs-built_in">swap</span>(ans[lo],ans[hi]);<br>            ++lo,--hi;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>投机取巧，直接将目标数的二进制数转换成十六进制的字符串表示形式。</p><ul><li>时间复杂度：O(n)，n为32</li><li>空间复杂度：O(1)</li></ul><p>贴上精选评论中的解法，思路一样，但是更加简洁：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">toHex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>    string hex = <span class="hljs-string">&quot;0123456789abcdef&quot;</span>, ans = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">while</span>(num &amp;&amp; ans.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">8</span>)&#123;<br>        ans = hex[num &amp; <span class="hljs-number">0xf</span>] + ans;<br>        num &gt;&gt;=  <span class="hljs-number">4</span>; <br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14. 最长公共前缀</title>
    <link href="/2021/10/01/LeetCode/14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <url>/2021/10/01/LeetCode/14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/">本题链接</a></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;<br><br>        <span class="hljs-comment">//如果只有一个，直接返回</span><br>        <span class="hljs-keyword">if</span>(strs.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-comment">//保存上一次的最长公共前缀</span><br>        string last = strs[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//依次遍历每个字符串</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; strs.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            <span class="hljs-comment">//如果有空字符串，直接返回&quot;&quot;</span><br>            <span class="hljs-keyword">if</span>(strs[i].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>            <br>            <span class="hljs-keyword">int</span> minSize = <span class="hljs-built_in">min</span>(last.<span class="hljs-built_in">size</span>(),strs[i].<span class="hljs-built_in">size</span>());<br>            <span class="hljs-keyword">int</span> j  = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//依次比较同个位置的字符</span><br>            <span class="hljs-keyword">for</span>(;j &lt; minSize;++j)<br>                <span class="hljs-comment">//如果找到一个不同的字符</span><br>                <span class="hljs-keyword">if</span>(last[j] != strs[i][j])&#123;<br>                    <span class="hljs-comment">//如果没有任何的公共字符，直接返回&quot;&quot;</span><br>                    <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <br>            <br>            <span class="hljs-comment">//记录此次的最长公共前缀</span><br>            last = strs[i].<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,j);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一开始还想用字典树，后面感觉使用字典树大材小用。</p><p>依次遍历每个字符串，然后每次只要用上一次的最长公共前缀和当前的字符串比较就行。</p><ul><li>时间复杂度：O(nm)，n为字符串数量，m为字符串的平均长度</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1436. 旅行终点站</title>
    <link href="/2021/10/01/LeetCode/1436.%20%E6%97%85%E8%A1%8C%E7%BB%88%E7%82%B9%E7%AB%99/"/>
    <url>/2021/10/01/LeetCode/1436.%20%E6%97%85%E8%A1%8C%E7%BB%88%E7%82%B9%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/destination-city/">本题链接</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">destCity</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; paths)</span> </span>&#123;<br><br>        <span class="hljs-comment">//存放所有的起点</span><br>        unordered_set&lt;string&gt; hash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;vec : paths)&#123;<br>            hash.<span class="hljs-built_in">insert</span>(vec[<span class="hljs-number">0</span>]);<br>        &#125;<br><br>        <span class="hljs-comment">//找出唯一的终点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;vec : paths)&#123;<br>            <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">find</span>(vec[<span class="hljs-number">1</span>]) == hash.<span class="hljs-built_in">end</span>())&#123;<br>                <span class="hljs-keyword">return</span> vec[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>       <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于题目已经给出不会出现环路，所以可以直接找终点就行，因为终点不可能出现在局部的起点中。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(n)$</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7. 整数反转</title>
    <link href="/2021/09/12/LeetCode/7.%20%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <url>/2021/09/12/LeetCode/7.%20%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/reverse-integer/">本题链接</a></p><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(x != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//res  = (res += x % 10) * 10;</span><br>            res = res * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>;<br>            x /= <span class="hljs-number">10</span>; <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)res == res ? (<span class="hljs-keyword">int</span>)res : <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本来还想着用字符串来判断溢出，其实多此一举，直接使用范围比int大的类型即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 47. 礼物的最大价值</title>
    <link href="/2021/09/01/LeetCode/%E5%89%91%E6%8C%87%20Offer%2047.%20%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/"/>
    <url>/2021/09/01/LeetCode/%E5%89%91%E6%8C%87%20Offer%2047.%20%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">本题链接</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(grid.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;(grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;r &lt; grid.<span class="hljs-built_in">size</span>();++r)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;c &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();++c)&#123;<br><br>                dp[r + <span class="hljs-number">1</span>][c + <span class="hljs-number">1</span>] = grid[r][c] + <span class="hljs-built_in">max</span>(dp[r][c+<span class="hljs-number">1</span>],dp[r + <span class="hljs-number">1</span>][c]);<br><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[grid.<span class="hljs-built_in">size</span>()][grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()];<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据题意只能往下或者往右走，那么就转化为：每当遍历到一个元素，就判断从它上面的元素过来更大还是从它左边的元素过来更大，再加上自己原有的值即可。状态转移方程为：</p><script type="math/tex; mode=display">dp[r][c]=grid[r][c]+max(dp[r][c-1],dp[r-1][c])</script><p>其中，$dp[r$​][c]表示走到r行c列的元素时最大的路径，grid为原数组</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>矩阵</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 46. 把数字翻译成字符串</title>
    <link href="/2021/09/01/LeetCode/%E5%89%91%E6%8C%87%20Offer%2046.%20%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2021/09/01/LeetCode/%E5%89%91%E6%8C%87%20Offer%2046.%20%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">本题链接</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">translateNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br><br>        <span class="hljs-comment">//将数字转换成字符串</span><br>        string str_num = <span class="hljs-built_in">to_string</span>(num);<br>        <span class="hljs-comment">//dp数组</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(str_num.size()+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//预处理</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ; i &lt; str_num.<span class="hljs-built_in">size</span>(); ++i)&#123;<br><br>            string s = str_num.<span class="hljs-built_in">substr</span>(i<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>);<br>            <br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;10&quot;</span>) &gt;=<span class="hljs-number">0</span> &amp;&amp; s.<span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;25&quot;</span>) &lt;= <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//若组合合法</span><br><br>                dp[i+<span class="hljs-number">1</span>] = dp[i] + dp[i<span class="hljs-number">-1</span>];<br><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                dp[i+<span class="hljs-number">1</span>] = dp[i];<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[dp.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题和青蛙跳台阶一个思路，很容易得到状态转移方程：</p><script type="math/tex; mode=display">dp[i] = dp[i-1]+dp[i-2]</script><p>注意相邻字符组成”00”或者大于”25”的情况。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>动态规划</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 45. 把数组排成最小的数</title>
    <link href="/2021/09/01/LeetCode/%E5%89%91%E6%8C%87%20Offer%2045.%20%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
    <url>/2021/09/01/LeetCode/%E5%89%91%E6%8C%87%20Offer%2045.%20%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">本题链接</a></p><h2 id="字符串1"><a href="#字符串1" class="headerlink" title="字符串1"></a>字符串1</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        string a_dig,b_dig;<br><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; a,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; b)&#123;<br><br>            <span class="hljs-keyword">if</span>(a == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>            a_dig = <span class="hljs-built_in">to_string</span>(a) + <span class="hljs-built_in">to_string</span>(b);<br>            b_dig = <span class="hljs-built_in">to_string</span>(b) + <span class="hljs-built_in">to_string</span>(a);<br><br>            <span class="hljs-keyword">return</span> a_dig.<span class="hljs-built_in">compare</span>(b_dig) &lt;= <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span> ;<br><br>        &#125;);<br><br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; dig : nums)&#123;<br>            res+=<span class="hljs-built_in">to_string</span>(dig);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接让局部呈最优即可，但是不知道为何用例：</p><p><strong>[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</strong></p><p>一直会报内存越界的错误。</p><h2 id="字符串2"><a href="#字符串2" class="headerlink" title="字符串2"></a>字符串2</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">//先创建字符串数组</span><br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">str_vec</span><span class="hljs-params">(nums.size(),<span class="hljs-string">&quot;&quot;</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>            str_vec[i] = <span class="hljs-built_in">to_string</span>(nums[i]);<br>        &#125;<br>        <span class="hljs-comment">//排序 让局部最优</span><br>        <span class="hljs-built_in">sort</span>(str_vec.<span class="hljs-built_in">begin</span>(),str_vec.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">const</span> string&amp; a,<span class="hljs-keyword">const</span> string&amp; b)&#123;<br>            <span class="hljs-keyword">return</span> a + b &lt; b + a;<br>        &#125;);<br>        <span class="hljs-comment">//构造结果</span><br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> string&amp; str : str_vec)&#123;<br>            res+=str;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>思路与<strong>字符串1</strong>一致，就是不知道为什么这个写法能过那个全是0的用例…</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 40. 最小的k个数</title>
    <link href="/2021/08/23/LeetCode/%E5%89%91%E6%8C%87%20Offer%2040.%20%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
    <url>/2021/08/23/LeetCode/%E5%89%91%E6%8C%87%20Offer%2040.%20%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">本题链接</a></p><h2 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-comment">//快速选择</span><br>        <span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> hi = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> target = k - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(lo &lt; hi)&#123;<br><br>            <span class="hljs-keyword">int</span> pviot = <span class="hljs-built_in">partition</span>(arr,lo,hi);<span class="hljs-comment">//获取轴点</span><br>            <span class="hljs-keyword">if</span>(target == pviot)&#123;<br>                <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt;(arr.<span class="hljs-built_in">begin</span>(),arr.<span class="hljs-built_in">begin</span>() + k);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &lt; pviot)&#123;<br>                hi = pviot - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pviot &lt; target)&#123;<br>                lo = pviot + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt;(arr.<span class="hljs-built_in">begin</span>(),arr.<span class="hljs-built_in">begin</span>() + k);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> lo,<span class="hljs-keyword">int</span> hi)</span></span>&#123;<br><br>        <span class="hljs-keyword">int</span> left = lo,right = hi;<br>        <span class="hljs-built_in">swap</span>(nums[lo],nums[lo + <span class="hljs-built_in">rand</span>() % (hi - lo)]);<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br><br>            <span class="hljs-keyword">while</span>(left &lt;= hi &amp;&amp; nums[left] &lt;= nums[lo]) ++left;<br><br>            <span class="hljs-keyword">while</span>(lo &lt; right &amp;&amp; nums[lo] &lt; nums[right]) --right;<br><br>            <span class="hljs-keyword">if</span>(left &lt; right) <span class="hljs-built_in">swap</span>(nums[left],nums[right]);<br><br>        &#125;<br>        <span class="hljs-built_in">swap</span>(nums[lo],nums[left - <span class="hljs-number">1</span>]);<span class="hljs-comment">//轴点归位</span><br>        <span class="hljs-keyword">return</span> left - <span class="hljs-number">1</span>;<br>    &#125;   <br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>借用快排思想，每次对一个区域排序。然后根据快排返回的轴点，与k进行比较，缩小轴点可能的范围，直到轴点刚好是k-1，此时就可以返回前k个元素。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>剑指Offer</tag>
      
      <tag>快速选择</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题 17.14. 最小K个数</title>
    <link href="/2021/08/23/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98%2017.14.%20%E6%9C%80%E5%B0%8FK%E4%B8%AA%E6%95%B0/"/>
    <url>/2021/08/23/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98%2017.14.%20%E6%9C%80%E5%B0%8FK%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="面试题-17-14-最小K个数"><a href="#面试题-17-14-最小K个数" class="headerlink" title="面试题 17.14. 最小K个数"></a><a href="https://leetcode-cn.com/problems/smallest-k-lcci/">面试题 17.14. 最小K个数</a></h1><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">smallestK</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(k,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-keyword">int</span>&amp; a,<span class="hljs-keyword">int</span>&amp; b)&#123;<span class="hljs-keyword">return</span> a &gt; b;&#125;;<br>        priority_queue&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;,<span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">p_q</span>(cmp);<span class="hljs-comment">//优先级队列:小顶</span><br><br>        <span class="hljs-comment">//将原数组的元素放入小顶堆排序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>();++i)&#123;<br>            p_q.<span class="hljs-built_in">push</span>(arr[i]);<br>        &#125;<br><br>        <span class="hljs-comment">//从小顶堆堆顶取出K个元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k;++i)&#123;<br>            res[i] = p_q.<span class="hljs-built_in">top</span>();<br>            p_q.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将原数组的元素放入小顶堆排序，然后再从小顶堆堆顶取出K个元素即可。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">smallestK</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(),arr.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt;(arr.<span class="hljs-built_in">begin</span>(),arr.<span class="hljs-built_in">begin</span>()+k);<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>直接使用STL排序算法，然后返回前K个就行…</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">smallestK</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>,hi = arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">quick</span>(lo,hi,arr,k);<br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt;(arr.<span class="hljs-built_in">begin</span>(),arr.<span class="hljs-built_in">begin</span>()+k);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">quick</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; lo,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; hi,vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; k)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(lo &gt;= hi) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-built_in">swap</span>(arr[lo],arr[lo+<span class="hljs-built_in">rand</span>()%(hi - lo)]);<span class="hljs-comment">//交换点</span><br>        <span class="hljs-keyword">int</span> target = arr[lo];<span class="hljs-comment">//目标</span><br>        <span class="hljs-keyword">int</span> left = lo,right = hi;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br><br>            <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt;= target)&#123;<br>                ++left;<br>            &#125;<br><br>            <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; target &lt; arr[right])&#123;<br>                --right;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(left &lt; right) <span class="hljs-built_in">swap</span>(arr[left],arr[right]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">swap</span>(arr[--left],arr[lo]);<br><br>        <span class="hljs-keyword">if</span>(left == k)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">quick</span>(lo,left,arr,k) || <span class="hljs-built_in">quick</span>(left+<span class="hljs-number">1</span>,hi,arr,k)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>只要确定第k个轴点就可以退出，并确保数组中前k个元素最小。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>优先级队列</tag>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 39. 数组中出现次数超过一半的数字</title>
    <link href="/2021/08/22/LeetCode/%E5%89%91%E6%8C%87%20Offer%2039.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2021/08/22/LeetCode/%E5%89%91%E6%8C%87%20Offer%2039.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">本题链接</a></p><h2 id="摩尔投票法-栈"><a href="#摩尔投票法-栈" class="headerlink" title="摩尔投票法+栈"></a>摩尔投票法+栈</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        stack&lt;<span class="hljs-keyword">int</span>&gt; istack;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            <span class="hljs-keyword">if</span>(istack.<span class="hljs-built_in">empty</span>() || istack.<span class="hljs-built_in">top</span>() == nums[i])<span class="hljs-comment">//如果当前元素与栈顶的元素相等</span><br>                istack.<span class="hljs-built_in">push</span>(nums[i]);<span class="hljs-comment">//放入栈中</span><br>            <span class="hljs-keyword">else</span> istack.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//将栈顶元素出栈</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> istack.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用摩尔投票法，极限一换一</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(n)$</li></ul><h2 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            <span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//说明已经抵消了</span><br>                res = nums[i];<br>                ++cnt;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果res没被抵消</span><br>                res == nums[i] ? ++cnt : --cnt;<br>            &#125;<br>            <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>使用摩尔投票法，极限一换一</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(1)$</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>该题还可以使用快速排序的思路，如果一个数是众数，那么这个数同时也是中位数，并经过快排后处于数组中间。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>栈</tag>
      
      <tag>剑指Offer</tag>
      
      <tag>摩尔投票法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 38. 字符串的排列</title>
    <link href="/2021/08/18/LeetCode/%E5%89%91%E6%8C%87%20Offer%2038.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <url>/2021/08/18/LeetCode/%E5%89%91%E6%8C%87%20Offer%2038.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">本题链接</a></p><h2 id="哈希表-递归-回溯"><a href="#哈希表-递归-回溯" class="headerlink" title="哈希表+递归+回溯"></a>哈希表+递归+回溯</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    unordered_set&lt;string&gt; res_hash;<span class="hljs-comment">//借哈希表去重</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">permutation</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-built_in">func</span>(s,<span class="hljs-number">0</span>,s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<span class="hljs-comment">//全排列</span><br><br>        <span class="hljs-comment">//创建结果数组</span><br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">res</span><span class="hljs-params">(res_hash.size(),<span class="hljs-string">&quot;&quot;</span>)</span></span>;<br>        <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; p:res_hash)&#123;<span class="hljs-comment">//将哈希表中的值写入结果数组</span><br>            res[pos++] = p;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(string&amp; s,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; lo,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; hi)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(lo &gt;= hi)&#123;<br>            res_hash.<span class="hljs-built_in">insert</span>(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//确定一个字符</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = lo;i &lt;= hi;++i)&#123;<br><br>            <span class="hljs-built_in">swap</span>(s[lo],s[i]);<span class="hljs-comment">//交换</span><br>            <span class="hljs-built_in">func</span>(s,lo + <span class="hljs-number">1</span>,hi);<br>            <span class="hljs-built_in">swap</span>(s[lo],s[i]);<span class="hljs-comment">//复原</span><br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>把字符串看成区间，然后每次迭代都把区间的第一个字符与剩下的字符逐一交换，并不停的缩小区间，且继续将缩小的区间的第一个字符与剩下的字符逐一的交换…直到最后一个区间的大小为1，就保存结果。</p><p>使用递归模仿回溯的流程。当字符串中有重复的字母时，排列也会出现重复的情况。此时使用哈希表去重即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>递归</tag>
      
      <tag>字符串</tag>
      
      <tag>回溯法</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 36. 二叉搜索树与双向链表</title>
    <link href="/2021/08/17/LeetCode/%E5%89%91%E6%8C%87%20Offer%2036.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/08/17/LeetCode/%E5%89%91%E6%8C%87%20Offer%2036.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">本题链接</a></p><h2 id="中序遍历1"><a href="#中序遍历1" class="headerlink" title="中序遍历1"></a>中序遍历1</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* left;</span><br><span class="hljs-comment">    Node* right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node() &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        left = NULL;</span><br><span class="hljs-comment">        right = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val, Node* _left, Node* _right) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        left = _left;</span><br><span class="hljs-comment">        right = _right;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    vector&lt;Node*&gt; node_vec;<span class="hljs-comment">//保存所有节点</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br><br>        <span class="hljs-comment">//中序遍历序列</span><br>        <span class="hljs-built_in">inOrder</span>(root);<br>        <span class="hljs-keyword">if</span>(node_vec.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-comment">//逐一串接相邻两个节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; node_vec.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;++i)&#123;<br>            node_vec[i]-&gt;right = node_vec[i+<span class="hljs-number">1</span>];<br>            node_vec[i+<span class="hljs-number">1</span>]-&gt;left = node_vec[i];<br>        &#125;<br><br>        <span class="hljs-comment">//将头尾节点串接</span><br>        node_vec[<span class="hljs-number">0</span>]-&gt;left = node_vec[node_vec.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>        node_vec[node_vec.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]-&gt;right = node_vec[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">return</span> node_vec[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(Node* root)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-built_in">inOrder</span>(root-&gt;left);<br>        node_vec.<span class="hljs-built_in">emplace_back</span>(root);<span class="hljs-comment">//保存当前节点</span><br>        <span class="hljs-built_in">inOrder</span>(root-&gt;right);<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先将二叉搜索树的节点按照中序遍历保存起来，然后再依次串接即可。借助了一个数组作为辅助空间，存放中序遍历的结果。</p><h2 id="中序遍历2"><a href="#中序遍历2" class="headerlink" title="中序遍历2"></a>中序遍历2</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* left;</span><br><span class="hljs-comment">    Node* right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node() &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        left = NULL;</span><br><span class="hljs-comment">        right = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val, Node* _left, Node* _right) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        left = _left;</span><br><span class="hljs-comment">        right = _right;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    Node* pre = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//代表中序遍历中的上次被操作的节点,在递归结束后指向最后一个节点</span><br>    Node* head = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//双向链表的第一个点</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-comment">//中序遍历</span><br>        <span class="hljs-built_in">inOrder</span>(root);<br><br>        <span class="hljs-comment">//头尾相连</span><br>        head-&gt;left = pre;<br>        pre-&gt;right = head;<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(Node* cur_node)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!cur_node) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-built_in">inOrder</span>(cur_node-&gt;left);<span class="hljs-comment">//转向左孩子</span><br><br>        <span class="hljs-keyword">if</span>(!head) head = cur_node;<span class="hljs-comment">//设置第一个点</span><br>        <span class="hljs-comment">//和上次的点串接</span><br>        cur_node-&gt;left = pre;<span class="hljs-comment">//设置当前节点的左边节点为上次的节点</span><br>        <span class="hljs-keyword">if</span>(pre) pre-&gt;right = cur_node;<span class="hljs-comment">//如果pre存在的话(pre初始化为nullptr)</span><br>        pre = cur_node;<span class="hljs-comment">//将pre设置为当前的节点</span><br><br>        <span class="hljs-built_in">inOrder</span>(cur_node-&gt;right);<span class="hljs-comment">//转向右孩子</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>相比<strong>中序遍历1</strong>少了辅助数组，直接就地解决。在中序遍历的过程中，当前节点和上次遍历的节点串接起来即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>中序遍历</tag>
      
      <tag>二叉搜索树</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 35. 复杂链表的复制</title>
    <link href="/2021/08/16/LeetCode/%E5%89%91%E6%8C%87%20Offer%2035.%20%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
    <url>/2021/08/16/LeetCode/%E5%89%91%E6%8C%87%20Offer%2035.%20%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">本题链接</a></p><h2 id="就地算法"><a href="#就地算法" class="headerlink" title="就地算法"></a>就地算法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* random;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">        random = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> head;<br>        <br>        <span class="hljs-comment">//就地算法</span><br><br>        <span class="hljs-comment">//在每个节点后面添加一份它自己的复制</span><br>        Node* cur_node = head;<br>        <span class="hljs-keyword">while</span>(cur_node)&#123;<br>            <br>            <span class="hljs-comment">//创建复制</span><br>            Node* cur_node_cpy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(cur_node-&gt;val);<br>            <span class="hljs-comment">//串接新节点</span><br>            cur_node_cpy-&gt;next = cur_node-&gt;next;<br>            cur_node-&gt;next = cur_node_cpy;<br>            <span class="hljs-comment">//cur_node前进</span><br>            cur_node = cur_node_cpy-&gt;next;<br>        &#125;<br><br>        <span class="hljs-comment">//遍历每个新创建的节点</span><br>        cur_node = head;<br>        Node* new_node;<br>        <span class="hljs-keyword">while</span>(cur_node)&#123;<br><br>            <span class="hljs-comment">//新节点等于原节点的下一个</span><br>            new_node = cur_node-&gt;next;<br>            <span class="hljs-comment">//新节点的random等于它原节点的random的复制</span><br>            new_node-&gt;random = cur_node-&gt;random ? cur_node-&gt;random-&gt;next : cur_node-&gt;random;<br>            <span class="hljs-comment">//前进</span><br>            cur_node = new_node-&gt;next;<br>        &#125;<br><br>        <span class="hljs-comment">//将新节点从原节点分离</span><br>        cur_node = head;<br>        <span class="hljs-function">Node <span class="hljs-title">dummy</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>        Node* res_node = &amp;dummy;<br><br>        <span class="hljs-keyword">while</span>(cur_node)&#123;<br>            <br>            <span class="hljs-comment">//提取新链表</span><br>            res_node-&gt;next = cur_node-&gt;next;<br>            res_node = res_node-&gt;next;<br>            <span class="hljs-comment">//还原旧链表</span><br>            cur_node-&gt;next = res_node-&gt;next;<br>            cur_node = cur_node-&gt;next;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>先遍历一次原链表，每遍历到一个原节点，就在原节点后面添加一个原节点的复制</li><li>第二次遍历链表，将所有新节点的random指针指向它对应原节点的random的复制</li><li>第三次遍历链表，将新的节点和旧的节点分离，返回新的链表，并同时将旧链表恢复原样</li></ol>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>就地算法</tag>
      
      <tag>链表</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>234. 回文链表</title>
    <link href="/2021/08/13/LeetCode/234.%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/08/13/LeetCode/234.%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">本题链接</a></p><h2 id="数组-双指针"><a href="#数组-双指针" class="headerlink" title="数组+双指针"></a>数组+双指针</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        <span class="hljs-comment">//存储到数组中</span><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br>        <span class="hljs-keyword">while</span>(head)&#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(head-&gt;val);<br>            head = head-&gt;next;<br>        &#125;<br><br>        <span class="hljs-comment">//双指针从头尾向中间遍历</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = tmp.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-keyword">if</span>(tmp[left++] != tmp[right--])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>   <br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于是单向链表，所以使用能够双向遍历的数组存储链表的值，然后再判断是否回文。</p><h2 id="快慢指针-链表反转"><a href="#快慢指针-链表反转" class="headerlink" title="快慢指针+链表反转"></a>快慢指针+链表反转</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(!head-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-comment">//使用快慢指针找到中点</span><br>        ListNode* slow = head;ListNode* fast = head;<br>        <span class="hljs-keyword">while</span>(fast)&#123;<br>            slow = slow-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">break</span>;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <br><br>        <span class="hljs-comment">//反转后半部分链表 从slow开始</span><br>        ListNode* node_tmp;<br>        ListNode* back_head = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(slow)&#123;<br><br>            node_tmp = slow-&gt;next;<br>            slow-&gt;next = back_head;<br>            back_head = slow;<br>            slow = node_tmp;<br>            <br>        &#125;<br><br>        <span class="hljs-comment">//逐一对比</span><br>        <span class="hljs-keyword">while</span>(back_head &amp;&amp; head)&#123;<br><br>            <span class="hljs-keyword">if</span>(back_head-&gt;val == head-&gt;val)&#123;<br>                back_head = back_head-&gt;next;<br>                head = head-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>先使用快慢指针找到中点，然后反转从中点开始的后半段的链表，最后重新逐个比对即可，</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>链表</tag>
      
      <tag>快慢指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 32 - I. 从上到下打印二叉树</title>
    <link href="/2021/08/11/LeetCode/%E5%89%91%E6%8C%87%20Offer%2032%20-%20I.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2021/08/11/LeetCode/%E5%89%91%E6%8C%87%20Offer%2032%20-%20I.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">本题链接</a></p><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>        queue&lt;TreeNode*&gt; node_queue;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br><br>        node_queue.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!node_queue.<span class="hljs-built_in">empty</span>())&#123;<br><br>            <span class="hljs-keyword">if</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;left) node_queue.<span class="hljs-built_in">push</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;left);<br>            <span class="hljs-keyword">if</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;right) node_queue.<span class="hljs-built_in">push</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;right);<br>            res.<span class="hljs-built_in">emplace_back</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;val);<br>                <br>            node_queue.<span class="hljs-built_in">pop</span>();<br>            <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>就是简单的层序遍历…</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>层序遍历</tag>
      
      <tag>二叉树</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 29. 顺时针打印矩阵</title>
    <link href="/2021/08/07/LeetCode/%E5%89%91%E6%8C%87%20Offer%2029.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <url>/2021/08/07/LeetCode/%E5%89%91%E6%8C%87%20Offer%2029.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">本题链接</a></p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">int</span> r_dirc = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> c_dirc = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> dirc[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//右 下 左 上</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>        <span class="hljs-comment">//存放节点是否被遍历</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">statue</span>(matrix.<span class="hljs-built_in">size</span>(),vector&lt;<span class="hljs-keyword">bool</span>&gt;(matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(),<span class="hljs-literal">false</span>));<br>        <span class="hljs-comment">//结果</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(matrix.size() * matrix[<span class="hljs-number">0</span>].size(),<span class="hljs-number">0</span>)</span></span>;<br><br>        <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> c = <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">//从[0,-1]开始</span><br>        <span class="hljs-comment">//遍历方向从右开始</span><br>        <span class="hljs-keyword">while</span>(pos &lt; res.<span class="hljs-built_in">size</span>())&#123;<br><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isLegal</span>(r + dirc[r_dirc],c + dirc[c_dirc],matrix,statue))&#123;<span class="hljs-comment">//如果下一个合法</span><br><br>                <span class="hljs-comment">//走到下一个</span><br>                r += dirc[r_dirc];<br>                c += dirc[c_dirc];<br>                res[pos++] = matrix[r][c];<span class="hljs-comment">//放入结果</span><br>                statue[r][c] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//标记自己不能再被访问</span><br><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">changeDirc</span>();<span class="hljs-comment">//改变方向</span><br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">//改变方向</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">changeDirc</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(r_dirc == <span class="hljs-number">3</span>)&#123;<br>            r_dirc = <span class="hljs-number">0</span>;<br>            c_dirc = <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            ++r_dirc;<br>            ++c_dirc;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">//判断能不能走</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isLegal</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; r,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; c,<span class="hljs-keyword">const</span> vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix,<span class="hljs-keyword">const</span> vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt;&amp; statue)</span> <span class="hljs-keyword">const</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= r &amp;&amp; r &lt; matrix.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-number">0</span> &lt;= c &amp;&amp; c &lt; matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp; !statue[r][c]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>想象遍历方向类似贪吃蛇的运动，贪吃蛇如果下一步碰到边界或者碰到自己就会改变方向，而方向只有<strong>右下左上</strong>这四种，且不停的重复。所以可以判断下一步能不能走，不能走的话就改变贪吃蛇的方向。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(n)$</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二维数组</tag>
      
      <tag>矩阵</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 27. 二叉树的镜像</title>
    <link href="/2021/08/05/LeetCode/%E5%89%91%E6%8C%87%20Offer%2027.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
    <url>/2021/08/05/LeetCode/%E5%89%91%E6%8C%87%20Offer%2027.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">本题链接</a></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-built_in">inOrder</span>(root);<br>        <span class="hljs-keyword">return</span> root;<br>        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">//将左右孩子交换</span><br>        TreeNode* tmp = root-&gt;left;<br>        root-&gt;left = root-&gt;right;<br>        root-&gt;right = tmp;<br><br>        <span class="hljs-built_in">inOrder</span>(root-&gt;left);<br>        <span class="hljs-built_in">inOrder</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一棵二叉树的镜像实际上就是对每个节点交换左右孩子的引用。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 26. 树的子结构</title>
    <link href="/2021/08/03/LeetCode/%E5%89%91%E6%8C%87%20Offer%2026.%20%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <url>/2021/08/03/LeetCode/%E5%89%91%E6%8C%87%20Offer%2026.%20%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">本题链接</a></p><h2 id="迭代-递归"><a href="#迭代-递归" class="headerlink" title="迭代+递归"></a>迭代+递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!A || !B) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        vector&lt;TreeNode*&gt; imp_vec;<span class="hljs-comment">//存放可能的A树子树根节点</span><br>        queue&lt;TreeNode*&gt; node_queue;<span class="hljs-comment">//用于层序遍历</span><br>        TreeNode* cur_node;<span class="hljs-comment">//临时节点</span><br><br>        node_queue.<span class="hljs-built_in">push</span>(A);<span class="hljs-comment">//将A树入队</span><br>        <span class="hljs-keyword">while</span>(!node_queue.<span class="hljs-built_in">empty</span>())&#123;<br><br>            cur_node = node_queue.<span class="hljs-built_in">front</span>();node_queue.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//获取队头的节点</span><br>            <span class="hljs-keyword">if</span>(cur_node-&gt;val == B-&gt;val) imp_vec.<span class="hljs-built_in">push_back</span>(cur_node);<span class="hljs-comment">//找到一个可能的节点</span><br><br>            <span class="hljs-keyword">if</span>(cur_node-&gt;left) node_queue.<span class="hljs-built_in">push</span>(cur_node-&gt;left);<span class="hljs-comment">//放入左孩子</span><br>            <span class="hljs-keyword">if</span>(cur_node-&gt;right) node_queue.<span class="hljs-built_in">push</span>(cur_node-&gt;right);<span class="hljs-comment">//放入右孩子</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(imp_vec.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果没有可能的节点,直接返回</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p : imp_vec)&#123;<span class="hljs-comment">//遍历每一个可能的节点</span><br>            TreeNode* B_node = B;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(p,B_node)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//A的子树和B树同时递归</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!B) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(!A) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(A-&gt;val != B-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(A-&gt;left,B-&gt;left) &amp;&amp; <span class="hljs-built_in">dfs</span>(A-&gt;right,B-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先找到A树中所有可能的节点，判断依据就是当这个节点和B树的根节点的值相同时，那么这个节点就是一个可能的节点。之后再遍历所有的可能节点，让可能的节点和B树根节点同时深入，只要发现某一时刻两个节点的值不相同就返回<code>false</code>。</p><h2 id="双重递归"><a href="#双重递归" class="headerlink" title="双重递归"></a>双重递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!A || !B) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSubStructure</span>(A-&gt;left,B) || <span class="hljs-built_in">isSubStructure</span>(A-&gt;right,B) || <span class="hljs-built_in">dfs</span>(A,B);<br>    &#125;<br><br>    <span class="hljs-comment">//A的子树和B树同时递归</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!B) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(!A) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(A-&gt;val != B-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(A-&gt;left,B-&gt;left) &amp;&amp; <span class="hljs-built_in">dfs</span>(A-&gt;right,B-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>在<code>isSubStructure</code>函数中，可以同时对它的左右孩子进行<code>isSubStructure</code>，即在双重递归的思路下，A树中所有的节点都可能成为与B树相对应的那个子结构的根节点。虽然双重递归简洁明了，但是时间复杂度显而易见的高。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代</tag>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
      <tag>双重递归</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 22. 链表中倒数第k个节点</title>
    <link href="/2021/08/01/LeetCode/%E5%89%91%E6%8C%87%20Offer%2022.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <url>/2021/08/01/LeetCode/%E5%89%91%E6%8C%87%20Offer%2022.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">本题链接</a></p><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span>(k &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-comment">//快慢指针</span><br>        ListNode* p1 = head;<br>        ListNode* p2 = head;<br><br>        <span class="hljs-comment">//让p1先走k步</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; k &amp;&amp; p1;++i)&#123;<span class="hljs-comment">//i &lt; k &amp;&amp; p1为了避免k超过链表的长度</span><br>            p1 = p1-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(!p1) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//避免k超过链表的长度</span><br><br>        <span class="hljs-comment">//两个指针一起走</span><br>        <span class="hljs-keyword">while</span>(p1-&gt;next)&#123;<br>            p1 = p1-&gt;next;<br>            p2 = p2-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> p2;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义两个节点指针p1和p2，两个指针一开始都指向头。先让p1走k-1步，然后p1和p2再一起走。直到p1到达链表的最后一个，那么p2指向的就是倒数第k个节点。实际上就是保持p1和p2之间的节点数量为k-1。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>快慢指针</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</title>
    <link href="/2021/07/30/LeetCode/%E5%89%91%E6%8C%87%20Offer%2021.%20%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
    <url>/2021/07/30/LeetCode/%E5%89%91%E6%8C%87%20Offer%2021.%20%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">本题链接</a></p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">exchange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums;<br><br>        <span class="hljs-keyword">int</span> odd_index = <span class="hljs-number">0</span>;<span class="hljs-comment">//指向下一个奇数存放的地方</span><br>  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>();++i)<br>            <span class="hljs-keyword">if</span>(nums[i] &amp; <span class="hljs-number">0x1</span>)&#123;<span class="hljs-comment">//当前为奇数</span><br>                <span class="hljs-built_in">swap</span>(nums[odd_index++],nums[i]);<br>            <br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>只需要维护一根指向下一个奇数存放的地方的指针，然后每当遍历到奇数，就把当前的奇数放到这个指针指向的位置就行，接着这个指针再前进到下一次存放奇数的地方。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(1)$</li></ul><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">exchange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left  &lt; right)&#123;<br><br>            <span class="hljs-keyword">while</span>(left &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[left] &amp; <span class="hljs-number">0x1</span>) ++left;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-number">0</span> &lt;= right &amp;&amp; !(nums[right] &amp; <span class="hljs-number">0x1</span>)) --right;<br><br>            <span class="hljs-keyword">if</span>(left  &lt; right) <span class="hljs-built_in">swap</span>(nums[left],nums[right]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>维护两根指针，左指针从数组第一个元素开始，右指针从数组最后一个元素开始。左指针遇到偶数就停下，右指针遇到奇数就停下，然后两者交换即可。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(1)$</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>迭代</tag>
      
      <tag>双指针</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 18. 删除链表的节点</title>
    <link href="/2021/07/25/LeetCode/%E5%89%91%E6%8C%87%20Offer%2018.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2021/07/25/LeetCode/%E5%89%91%E6%8C%87%20Offer%2018.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">本题链接</a></p><h2 id="链表遍历"><a href="#链表遍历" class="headerlink" title="链表遍历"></a>链表遍历</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br><br>        <span class="hljs-function">ListNode <span class="hljs-title">dummy</span><span class="hljs-params">(<span class="hljs-number">0</span>,head)</span></span>;<br>        ListNode* node = &amp;dummy;<br><br>        <span class="hljs-keyword">while</span>(node-&gt;next &amp;&amp; node-&gt;next-&gt;val != val)<span class="hljs-comment">//找到要删除的节点</span><br>            node = node-&gt;next;<br>        <span class="hljs-comment">//将被删除节点的前后节点接起来</span><br>        node-&gt;next = node-&gt;next-&gt;next;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>亦步亦趋的遍历，找到下一个节点为目标的节点，然后将该节点与下一个节点的下一个节点串接即可。即使被删除的节点为链表的最后一个节点也不会有错。注意需要在头节点的前面再添加一个节点，以防止删除头节点的情况出现。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 16. 数值的整数次方</title>
    <link href="/2021/07/18/LeetCode/%E5%89%91%E6%8C%87%20Offer%2016.%20%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
    <url>/2021/07/18/LeetCode/%E5%89%91%E6%8C%87%20Offer%2016.%20%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">本题链接</a></p><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//任何数的0次方都为1,即使0的0次方没有意义</span><br>        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//1的任何次方都为0</span><br><br>        <span class="hljs-comment">//快速幂</span><br>        <span class="hljs-keyword">long</span> n_tmp = <span class="hljs-built_in">abs</span>(n);<span class="hljs-comment">//设置为long防止n为边界值</span><br>        <span class="hljs-keyword">double</span> res = <span class="hljs-number">1</span>;<br> <br><br>        <span class="hljs-keyword">while</span>(n_tmp)&#123;<span class="hljs-comment">//若n_tmp的比特位还有1</span><br><br>            <span class="hljs-keyword">if</span>(n_tmp &amp; <span class="hljs-number">1</span>)<span class="hljs-comment">//若n_tmp当前位为1</span><br>                res = x * res;<br>          <br>            x *=  x;<span class="hljs-comment">//将自己累计</span><br>            n_tmp &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> ? res : <span class="hljs-number">1</span>/res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用快速幂，能让时间复杂度降低到$log_2(n)$。详见<a href="https://www.youtube.com/watch?v=GbDtCFhq20A">快速幂都能做什么？小小的算法也有大大的梦想</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>剑指Offer</tag>
      
      <tag>快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 12. 矩阵中的路径</title>
    <link href="/2021/07/17/LeetCode/%E5%89%91%E6%8C%87%20Offer%2012.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <url>/2021/07/17/LeetCode/%E5%89%91%E6%8C%87%20Offer%2012.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">本题链接</a></p><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(board.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">//保存节点访问状态</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">state</span>(board.<span class="hljs-built_in">size</span>(),vector&lt;<span class="hljs-keyword">bool</span>&gt;(board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(),<span class="hljs-literal">false</span>));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;r &lt; board.<span class="hljs-built_in">size</span>();++r)<span class="hljs-comment">//每一行</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;c &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();++c)<span class="hljs-comment">//每一列</span><br>                <span class="hljs-keyword">if</span>(board[r][c] == word[<span class="hljs-number">0</span>] &amp;&amp; <span class="hljs-built_in">dfs</span>(r,c,board,state,word,<span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; r,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; c,<span class="hljs-keyword">const</span> vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board,vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt;&amp; state,<span class="hljs-keyword">const</span> string&amp; word,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; str_pos)</span></span>&#123;<br>        <br>        <span class="hljs-keyword">if</span>(!(<span class="hljs-number">0</span> &lt;= r &amp;&amp; r &lt; board.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-number">0</span> &lt;= c &amp;&amp; c &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果点不合法</span><br>        <span class="hljs-keyword">if</span>(state[r][c]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果自己已被遍历过</span><br><br>        <span class="hljs-keyword">bool</span> res;<br>        <span class="hljs-keyword">if</span>(board[r][c] == word[str_pos])&#123;<span class="hljs-comment">//如果自己符合</span><br>        <br>            <span class="hljs-keyword">if</span>(str_pos == word.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//且到达字符串的最后一个</span><br>            state[r][c] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//设置自己已经被遍历过</span><br>            res = <span class="hljs-built_in">dfs</span>(r + <span class="hljs-number">1</span>,c,board,state,word,str_pos + <span class="hljs-number">1</span>) ||<span class="hljs-comment">//上</span><br>                  <span class="hljs-built_in">dfs</span>(r,c + <span class="hljs-number">1</span>,board,state,word,str_pos + <span class="hljs-number">1</span>) ||<span class="hljs-comment">//右</span><br>                  <span class="hljs-built_in">dfs</span>(r - <span class="hljs-number">1</span>,c,board,state,word,str_pos + <span class="hljs-number">1</span>) ||<span class="hljs-comment">//下</span><br>                  <span class="hljs-built_in">dfs</span>(r,c - <span class="hljs-number">1</span>,board,state,word,str_pos + <span class="hljs-number">1</span>) ; <span class="hljs-comment">//左</span><br><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        state[r][c] = <span class="hljs-literal">false</span>;<span class="hljs-comment">//返回前把自己设置为未访问</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>回溯法一般使用递归，因为在递归中函数栈能保存每个时刻的行为和变量。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵</tag>
      
      <tag>回溯法</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 13. 机器人的运动范围</title>
    <link href="/2021/07/17/LeetCode/%E5%89%91%E6%8C%87%20Offer%2013.%20%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <url>/2021/07/17/LeetCode/%E5%89%91%E6%8C%87%20Offer%2013.%20%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">本题链接</a></p><h2 id="回溯-dfs"><a href="#回溯-dfs" class="headerlink" title="回溯+dfs"></a>回溯+dfs</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">int</span> m_bak,n_bak,k_bak;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!m || !n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        m_bak = m;n_bak = n;k_bak = k;<br><br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">state</span>(m,vector&lt;<span class="hljs-keyword">bool</span>&gt;(n,<span class="hljs-literal">false</span>));<span class="hljs-comment">//是否已被遍历</span><br>        <br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,state);<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; r,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; c,vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt;&amp; state)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isLegal</span>(r,c,state)) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//如果不合法</span><br><br>        state[r][c] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//设置自己已被遍历</span><br>        ++res;<br>        <br>        <span class="hljs-comment">//dfs(r - 1,c,state);//上</span><br>        <span class="hljs-built_in">dfs</span>(r + <span class="hljs-number">1</span>,c,state);<span class="hljs-comment">//下</span><br>        <span class="hljs-comment">//dfs(r,c - 1,state);//左</span><br>        <span class="hljs-built_in">dfs</span>(r,c + <span class="hljs-number">1</span>,state);<span class="hljs-comment">//右</span><br>        <br>        <span class="hljs-comment">//state[r][c] = false;//设置自己未被遍历</span><br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isLegal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">const</span> vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt;&amp; state)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= r &amp;&amp; r &lt; m_bak &amp;&amp; <span class="hljs-number">0</span> &lt;= c &amp;&amp; c &lt; n_bak)&#123;<span class="hljs-comment">//如果点在合法范围内</span><br>            <br>            <span class="hljs-keyword">if</span>(state[r][c]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//若该点已经被遍历过</span><br><br>            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(r &gt; <span class="hljs-number">0</span>)&#123;<br>                sum += r % <span class="hljs-number">10</span>;<br>                r = r / <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(c &gt; <span class="hljs-number">0</span>)&#123;<br>                sum += c % <span class="hljs-number">10</span>;<br>                c = c / <span class="hljs-number">10</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//若数位之和小于等于给定的K,返回真</span><br>            <span class="hljs-keyword">return</span> sum &lt;= k_bak ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对每个节点做DFS即可，比较重要的是机器人的行走方向可以优化，具体见<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/ji-qi-ren-de-yun-dong-fan-wei-by-leetcode-solution/">官方解析</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度优先搜索</tag>
      
      <tag>回溯法</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 15. 二进制中1的个数</title>
    <link href="/2021/07/17/LeetCode/%E5%89%91%E6%8C%87%20Offer%2015.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2021/07/17/LeetCode/%E5%89%91%E6%8C%87%20Offer%2015.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">本题链接</a></p><h2 id="位运算1"><a href="#位运算1" class="headerlink" title="位运算1"></a>位运算1</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">uint32_t</span> flag = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(flag)&#123;<br><br>            <span class="hljs-keyword">if</span>(n &amp; flag) ++count;<br>            flag = flag &lt;&lt; <span class="hljs-number">1</span>;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>让flag中1的位置逐次向左移，再与n中各位置进行比较。</p><p>其实让n右移也是可以的，因为n为无符号的整型，右移n只会在最左端添加0，并不会造成死循环。</p><p>循环次数固定为32次，循环次数与输入数据的位数相同。</p><h2 id="位运算2"><a href="#位运算2" class="headerlink" title="位运算2"></a>位运算2</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n)&#123;<br>            n = (n - <span class="hljs-number">1</span>) &amp; n;<br>            ++cnt;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>把一个整数减去1，再和原来的整数做与运算，会把该整数最右边的1变成0。一直迭代到n为0即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 11. 旋转数组的最小数字</title>
    <link href="/2021/07/14/LeetCode/%E5%89%91%E6%8C%87%20Offer%2011.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <url>/2021/07/14/LeetCode/%E5%89%91%E6%8C%87%20Offer%2011.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">本题链接</a></p><h2 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;++i)<br>            <span class="hljs-keyword">if</span>(numbers[i] &gt; numbers[i+<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">return</span> numbers[i+<span class="hljs-number">1</span>];<br>            <br>        <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>暴力搜索简单明了，直接一遍搜索即可。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(1)$</li></ul><h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>,hi = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(lo &lt; hi)&#123;<br><br>            <span class="hljs-keyword">int</span> mid = lo + (hi - lo) / <span class="hljs-number">2</span>;<span class="hljs-comment">//避免lo+hi直接溢出</span><br><br>            <span class="hljs-keyword">if</span>(numbers[mid] &lt; numbers[hi])&#123;<span class="hljs-comment">//此时结果位于mid的左侧</span><br>                <br>                hi = mid;<br><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[mid] &gt; numbers[hi])&#123;<span class="hljs-comment">//此时结果位于mid的右侧</span><br><br>                lo = mid + <span class="hljs-number">1</span>;<br><br>            &#125;<span class="hljs-keyword">else</span> --hi;<span class="hljs-comment">//特殊情况</span><br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> numbers[lo];<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>详情见<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-by-leetcode-s/">官方解析</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>数组</tag>
      
      <tag>二分查找</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法整理</title>
    <link href="/2021/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <url>/2021/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><div class="table-container"><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:center">名称</th><th style="text-align:center">查找</th><th style="text-align:center">增加</th><th style="text-align:center">删除</th><th style="text-align:center">应用场景</th></tr></thead><tbody><tr><td style="text-align:center">线性</td><td style="text-align:center">向量</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">线性</td><td style="text-align:center">链表</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">队列</td><td style="text-align:center">（队首或队尾）$O(1)$​</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">栈</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">半线性</td><td style="text-align:center">二叉树</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">图</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">优先级队列</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><div class="table-container"><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:center">名称</th><th style="text-align:center">时间复杂度</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th><th style="text-align:center">应用场景</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">查找</td><td style="text-align:center"><a href="#binSearch">二分查找</a></td><td style="text-align:center">$O(log_2{n})$</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">单调序列</td><td style="text-align:center">采用<strong>减而治之</strong>的策略，<strong>避开</strong>无需查找的区间</td></tr><tr><td style="text-align:center">查找</td><td style="text-align:center"><a href="#fibSearch">斐波那契查找</a></td><td style="text-align:center">$O(log_2{n})$</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">单调序列</td><td style="text-align:center">消除二分查找的<strong>转向不均衡</strong>，常系数意义优于二分查找</td></tr><tr><td style="text-align:center">查找</td><td style="text-align:center"><a href="#interpolation">插值查找</a></td><td style="text-align:center">$O(log_2{log_2{n}})$</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">均匀且独立的随机分布单调序列</td><td style="text-align:center">通过<strong>盲猜</strong>轴点，极大地<strong>提高</strong>收敛速度。但是比较操作成本极高</td></tr><tr><td style="text-align:center">查找</td><td style="text-align:center">摩尔投票算法</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">寻找众数</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">排序</td><td style="text-align:center"><a href="#bubbleSort">起泡排序（跳跃版）</a></td><td style="text-align:center">最坏$O(n^2)$​</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td><td style="text-align:center">无序序列</td><td style="text-align:center">跳跃版可以直接避开对有序区间的扫描</td></tr><tr><td style="text-align:center">排序</td><td style="text-align:center"><a href="#merge">归并排序</a></td><td style="text-align:center">$O(nlog_2{n})$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">稳定</td><td style="text-align:center">无序序列</td><td style="text-align:center">排序所需要的时间和$nlog_2{n}$成正比，但是需要额外的辅助空间<strong>n</strong></td></tr><tr><td style="text-align:center">排序</td><td style="text-align:center"><a href="#selectionSort">选择排序</a></td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td><td style="text-align:center">无序序列</td><td style="text-align:center">算法简单直观，可以通过逆向降序遍历将算法变成稳定</td></tr><tr><td style="text-align:center">排序</td><td style="text-align:center"><a href="#partition">快速排序（LGU版）</a></td><td style="text-align:center">$O(nlog_2{n})$​​至$O(n^2)$​​​​​，平均$O(1.39*log_2{n})$​</td><td style="text-align:center">$O(log_2{n})$</td><td style="text-align:center">不稳定</td><td style="text-align:center">无序序列</td><td style="text-align:center">采用<strong>分而治之</strong>的策略，通常情况下有着优异性能。C++STL::sort()采用的就是快速排序</td></tr><tr><td style="text-align:center">排序</td><td style="text-align:center"><a href="#bucketsort">桶排序</a></td><td style="text-align:center">$O(n+n*(log_2{n}-log_2{k}))$​</td><td style="text-align:center">$O(n+k)$​</td><td style="text-align:center">稳定</td><td style="text-align:center">大规模无序序列</td><td style="text-align:center">如果相对于同样的n，桶数量k越大，其效率越高，最好的时间复杂度达到$O(n)$。当然桶排序的空间复杂度为$O(n+k)$</td></tr><tr><td style="text-align:center">排序</td><td style="text-align:center"><a href="#heapsort">堆排序</a></td><td style="text-align:center">$O(nlog_2{n})$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td><td style="text-align:center">无序序列</td><td style="text-align:center">只要将完全二叉堆和已排序的部分放在同一个向量里，那么空间复杂度就能做到常数级别</td></tr><tr><td style="text-align:center">排序</td><td style="text-align:center"><a href="#shellSort">希尔排序</a></td><td style="text-align:center">$O(nlog_2{n})$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td><td style="text-align:center">无序序列</td><td style="text-align:center">相对于任何一个固定间隔而言的有序性，在希尔排序的过程中，将会不断的保持，并且持续的积累下来。</td></tr><tr><td style="text-align:center">排序</td><td style="text-align:center"><a href="#countingSort">计数排序</a></td><td style="text-align:center">$O(n+k)$​（K为不重复的数字个数）​</td><td style="text-align:center">$O(n+k)$</td><td style="text-align:center">稳定</td><td style="text-align:center">无序序列</td><td style="text-align:center">适用于重复元素较多的无序序列</td></tr><tr><td style="text-align:center">排序</td><td style="text-align:center"><a href="#basesort">基数排序</a></td><td style="text-align:center">$O(n*k)$（K为最高位位数）</td><td style="text-align:center">$O(n*k)$</td><td style="text-align:center">稳定</td><td style="text-align:center">指定区间无序序列</td><td style="text-align:center">适用于给定元素范围的无序序列</td></tr></tbody></table></div><ul><li>对于查找算法:<ul><li>大规模：插值查找</li><li>中规模：二分查找</li><li>小规模：顺序查找</li></ul></li></ul><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a><a id='binSearch'>二分查找</a></h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// 二分查找算法（版本C）：在有序向量的区间[lo, hi)内查找元素e，0 &lt;= lo &lt;= hi &lt;= _size</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">static</span> Rank <span class="hljs-title">binSearch</span> <span class="hljs-params">( T* S, T <span class="hljs-keyword">const</span>&amp; e, Rank lo, Rank hi )</span> </span>&#123;<br>   <span class="hljs-keyword">while</span> ( lo &lt; hi ) &#123; <span class="hljs-comment">//每步迭代仅需做一次比较判断，有两个分支</span><br>      Rank mi = ( lo + hi ) &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">//以中点为轴点（区间宽度的折半，等效于宽度之数值表示的右移）</span><br>      ( e &lt; S[mi] ) ? hi = mi : lo = mi + <span class="hljs-number">1</span>; <span class="hljs-comment">//经比较后确定深入[lo, mi)或(mi, hi)</span><br>   &#125; <span class="hljs-comment">//成功查找不能提前终止</span><br>   <span class="hljs-keyword">return</span> lo - <span class="hljs-number">1</span>; <span class="hljs-comment">//循环结束时，lo为大于e的元素的最小秩，故lo - 1即不大于e的元素的最大秩</span><br>&#125; <span class="hljs-comment">//有多个命中元素时，总能保证返回秩最大者；查找失败时，能够返回失败的位置</span><br></code></pre></div></td></tr></table></figure><h3 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a><a id='fibSearch'>斐波那契查找</a></h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;fibonacci/Fib.h&quot;</span> <span class="hljs-comment">//引入Fib数列类</span></span><br><span class="hljs-comment">//在有序向量的区间[lo, hi)内查找元素e，0 &lt;= lo &lt;= hi &lt;= _size</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">static</span> Rank <span class="hljs-title">fibSearch</span> <span class="hljs-params">( T* S, T <span class="hljs-keyword">const</span>&amp; e, Rank lo, Rank hi )</span> </span>&#123;<br>   <span class="hljs-keyword">for</span>( Fib <span class="hljs-built_in">fib</span> ( hi - lo ); lo &lt; hi;  ) &#123; <span class="hljs-comment">//Fib数列制表备查</span><br>      <span class="hljs-keyword">while</span>( hi - lo &lt; fib.<span class="hljs-built_in">get</span>() ) fib.<span class="hljs-built_in">prev</span>(); <span class="hljs-comment">//自后向前顺序查找（分摊O(1)）</span><br>      Rank mi = lo + fib.<span class="hljs-built_in">get</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">//确定形如Fib(k) - 1的轴点</span><br>      ( e &lt; S[mi] ) ? hi = mi : lo = mi + <span class="hljs-number">1</span>; <span class="hljs-comment">//比较后确定深入前半段[lo, mi)或后半段(mi, hi)</span><br>   &#125; <span class="hljs-comment">//成功查找不能提前终止</span><br>   <span class="hljs-keyword">return</span> --lo; <span class="hljs-comment">//循环结束时，lo为大于e的元素的最小秩，故lo - 1即不大于e的元素的最大秩</span><br>&#125; <span class="hljs-comment">//有多个命中元素时，总能保证返回最秩最大者；查找失败时，能够返回失败的位置</span><br></code></pre></div></td></tr></table></figure><h3 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a><a id='interpolation'>插值查找</a></h3><p>在A序列中查找$[lo,hi)$​区间内是否存在e，轴点<code>mi</code>通过以下公式确定：</p><script type="math/tex; mode=display">mi\approx lo+(hi-lo)*\frac {e-A[lo]}{A[hi]-A[lo]}</script><h3 id="起泡排序（跳跃版）"><a href="#起泡排序（跳跃版）" class="headerlink" title="起泡排序（跳跃版）"></a><a id='bubbleSort'>起泡排序（跳跃版）</a></h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//向量的起泡排序（跳跃版）</span><br><span class="hljs-keyword">void</span> Vector&lt;T&gt;::<span class="hljs-built_in">bubbleSort</span>( Rank lo, Rank hi ) &#123; <span class="hljs-comment">//assert: 0 &lt;= lo &lt; hi &lt;= size</span><br>   <span class="hljs-keyword">for</span>( Rank last = --hi; lo &lt; hi; hi = last )<br>      <span class="hljs-keyword">for</span>( Rank i = last = lo; i &lt; hi; i++ )<br>         <span class="hljs-keyword">if</span>( _elem[i] &gt; _elem[i + <span class="hljs-number">1</span>] ) <span class="hljs-comment">//若逆序，则</span><br>            <span class="hljs-built_in">swap</span>( _elem[ last = i ], _elem[ i + <span class="hljs-number">1</span> ] ); <span class="hljs-comment">//经交换使局部有序</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><a id='merge'>归并排序</a></h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//有序向量（区间）的归并</span><br><span class="hljs-keyword">void</span> Vector&lt;T&gt;::<span class="hljs-built_in">merge</span> ( Rank lo, Rank mi, Rank hi ) &#123; <span class="hljs-comment">//[lo, mi)和[mi, hi)各自有序，lo &lt; mi &lt; hi</span><br>   Rank i = <span class="hljs-number">0</span>; T* A = _elem + lo; <span class="hljs-comment">//合并后的有序向量A[0, hi - lo) = _elem[lo, hi)，就地</span><br>   Rank j = <span class="hljs-number">0</span>, lb = mi - lo; T* B = <span class="hljs-keyword">new</span> T[lb]; <span class="hljs-comment">//前子向量B[0, lb) &lt;-- _elem[lo, mi)</span><br>   <span class="hljs-keyword">for</span> ( Rank i = <span class="hljs-number">0</span>; i &lt; lb; i++ ) B[i] = A[i]; <span class="hljs-comment">//复制自A的前缀</span><br>   Rank k = <span class="hljs-number">0</span>, lc = hi - mi; T* C = _elem + mi; <span class="hljs-comment">//后子向量C[0, lc) = _elem[mi, hi)，就地</span><br>   <span class="hljs-keyword">while</span> ( ( j &lt; lb ) &amp;&amp; ( k &lt; lc ) ) <span class="hljs-comment">//反复地比较B、C的首元素</span><br>      A[i++] = ( B[j] &lt;= C[k] ) ? B[j++] : C[k++]; <span class="hljs-comment">//将更小者归入A中</span><br>   <span class="hljs-keyword">while</span> ( j &lt; lb ) <span class="hljs-comment">//若C先耗尽，则</span><br>      A[i++] = B[j++]; <span class="hljs-comment">//将B残余的后缀归入A中——若B先耗尽呢？</span><br>   <span class="hljs-keyword">delete</span> [] B; <span class="hljs-comment">//释放临时空间</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//向量归并排序</span><br><span class="hljs-keyword">void</span> Vector&lt;T&gt;::<span class="hljs-built_in">mergeSort</span> ( Rank lo, Rank hi ) &#123; <span class="hljs-comment">//0 &lt;= lo &lt; hi &lt;= size</span><br>   <span class="hljs-keyword">if</span> ( hi - lo &lt; <span class="hljs-number">2</span> ) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//单元素区间自然有序，否则...</span><br>   <span class="hljs-keyword">int</span> mi = ( lo + hi ) / <span class="hljs-number">2</span>; <span class="hljs-comment">//以中点为界</span><br>   <span class="hljs-built_in">mergeSort</span> ( lo, mi ); <span class="hljs-built_in">mergeSort</span> ( mi, hi ); <span class="hljs-comment">//分别排序</span><br>   <span class="hljs-built_in">merge</span> ( lo, mi, hi ); <span class="hljs-comment">//归并</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><a id='selectionSort'>选择排序</a></h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//向量选择排序</span><br><span class="hljs-keyword">void</span> Vector&lt;T&gt;::<span class="hljs-built_in">selectionSort</span> ( Rank lo, Rank hi ) &#123; <span class="hljs-comment">//0 &lt;= lo &lt; hi &lt;= size</span><br>   <span class="hljs-comment">/*DSA*/</span><span class="hljs-built_in">printf</span> ( <span class="hljs-string">&quot;\tSELECTIONsort [%3d, %3d)\n&quot;</span>, lo, hi );<br>   <span class="hljs-keyword">while</span> ( lo &lt; --hi )<br>      <span class="hljs-built_in">swap</span> ( _elem[ <span class="hljs-built_in">maxItem</span> ( lo, hi ) ], _elem[ hi ] ); <span class="hljs-comment">//将[hi]与[lo, hi]中的最大者交换</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>Rank Vector&lt;T&gt;::<span class="hljs-built_in">maxItem</span> ( Rank lo, Rank hi ) &#123; <span class="hljs-comment">//在[lo, hi]内找出最大者</span><br>   Rank mx = hi;<br>   <span class="hljs-keyword">while</span> ( lo &lt; hi-- ) <span class="hljs-comment">//逆向扫描</span><br>      <span class="hljs-keyword">if</span> ( _elem[ hi ] &gt; _elem[ mx ] ) <span class="hljs-comment">//且严格比较</span><br>         mx = hi; <span class="hljs-comment">//故能在max有多个时保证后者优先，进而保证selectionSort稳定</span><br>   <span class="hljs-keyword">return</span> mx;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="快速排序（LGU版）"><a href="#快速排序（LGU版）" class="headerlink" title="快速排序（LGU版）"></a><a id='partition'>快速排序（LGU版）</a></h3><p>轴点构造算法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//轴点构造算法：通过调整元素位置构造区间[lo, hi)的轴点，并返回其秩</span><br>Rank Vector&lt;T&gt;::<span class="hljs-built_in">partition</span> ( Rank lo, Rank hi ) &#123; <span class="hljs-comment">//LGU版</span><br>   <span class="hljs-built_in">swap</span> ( _elem[lo], _elem[ lo + <span class="hljs-built_in">rand</span>() % ( hi - lo ) ] ); <span class="hljs-comment">//任选一个元素与首元素交换</span><br>   T pivot = _elem[lo]; <span class="hljs-comment">//以首元素为候选轴点——经以上交换，等效于随机选取</span><br>   <span class="hljs-keyword">int</span> mi = lo;<br>   <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> k = lo + <span class="hljs-number">1</span>; k &lt; hi; k++ ) <span class="hljs-comment">//自左向右扫描</span><br>      <span class="hljs-keyword">if</span> ( _elem[k] &lt; pivot ) <span class="hljs-comment">//若当前元素_elem[k]小于pivot，则</span><br>         <span class="hljs-built_in">swap</span> ( _elem[++mi], _elem[k] ); <span class="hljs-comment">//将_elem[k]交换至原mi之后，使L子序列向右扩展</span><br>   <span class="hljs-built_in">swap</span> ( _elem[lo], _elem[mi] ); <span class="hljs-comment">//候选轴点归位</span><br>   <span class="hljs-keyword">return</span> mi; <span class="hljs-comment">//返回轴点的秩</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a><a id='bucketsort'>桶排序</a></h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DIFFERENCE_VALUE 1000 <span class="hljs-comment">//桶中的元素以1000来分隔</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">//桶排序</span><br>        map&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;*&gt; t_map;<br>        <br>        <span class="hljs-comment">//入桶</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">int</span> key = <span class="hljs-built_in">get_key</span>(nums[i]);<br>            <span class="hljs-keyword">if</span>(t_map.<span class="hljs-built_in">find</span>(key) == t_map.<span class="hljs-built_in">end</span>()) t_map.<span class="hljs-built_in">insert</span>(&#123;key,<span class="hljs-keyword">new</span> vector&#123;nums[i]&#125;&#125;);<br>            <span class="hljs-keyword">else</span> ((vector&lt;<span class="hljs-keyword">int</span>&gt;*)t_map[key])-&gt;<span class="hljs-built_in">push_back</span>(nums[i]);<br>        &#125;<br><br>        <span class="hljs-comment">//桶排序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; bucket:t_map)<br>            <span class="hljs-built_in">sort</span>(((vector&lt;<span class="hljs-keyword">int</span>&gt;*)bucket.second)-&gt;<span class="hljs-built_in">begin</span>(),((vector&lt;<span class="hljs-keyword">int</span>&gt;*)bucket.second)-&gt;<span class="hljs-built_in">end</span>());<br>        <br>        <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//出桶</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; bucket:t_map)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; digit:*((vector&lt;<span class="hljs-keyword">int</span>&gt;*)bucket.second))<br>                nums[pos++] = digit;<br><br>            <span class="hljs-built_in"><span class="hljs-keyword">delete</span></span> (vector&lt;<span class="hljs-keyword">int</span>&gt;*)bucket.second;<br>        &#125;<br>            <br>        <span class="hljs-keyword">return</span> nums;   <br>    &#125;   <br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get_key</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; k)</span> <span class="hljs-keyword">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> k?k/DIFFERENCE_VALUE:<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><a id='heapsort'>堆排序</a></h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  Parent(i)         ( ( ( i ) - 1 ) &gt;&gt; 1 ) <span class="hljs-comment">//PQ[i]的父节点（floor((i-1)/2)，i无论正负）</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  LChild(i)         ( 1 + ( ( i ) &lt;&lt; 1 ) ) <span class="hljs-comment">//PQ[i]的左孩子</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  RChild(i)         ( ( 1 + ( i ) ) &lt;&lt; 1 ) <span class="hljs-comment">//PQ[i]的右孩子</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  InHeap(n, i)      ( ( ( -1 ) &lt; ( i ) ) &amp;&amp; ( ( i ) &lt; ( n ) ) ) <span class="hljs-comment">//判断PQ[i]是否合法</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  LChildValid(n, i) InHeap( n, LChild( i ) ) <span class="hljs-comment">//判断PQ[i]是否有一个（左）孩子</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  RChildValid(n, i) InHeap( n, RChild( i ) ) <span class="hljs-comment">//判断PQ[i]是否有两个孩子</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  Smaller(PQ, i, j)  ( !lt( PQ[i], PQ[j] ) ? j : i ) <span class="hljs-comment">//取大者（等时前者优先）</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  ProperParent(PQ, n, i) <span class="hljs-comment">/*父子（至多）三者中的大者*/</span> \</span><br><span class="hljs-meta">            ( RChildValid(n, i) ? Smaller( PQ, Smaller( PQ, i, LChild(i) ), RChild(i) ) : \</span><br><span class="hljs-meta">            ( LChildValid(n, i) ? Smaller( PQ, i, LChild(i) ) : i \</span><br><span class="hljs-meta">            ) \</span><br><span class="hljs-meta">            ) <span class="hljs-comment">//相等时父节点优先，如此可避免不必要的交换</span></span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">lt</span> <span class="hljs-params">( T&amp; a, T&amp; b )</span> </span>&#123; <span class="hljs-keyword">return</span> a &lt; b; &#125; <span class="hljs-comment">//less than</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(nums.size(),<span class="hljs-number">0</span>)</span></span>;<br><br>        <span class="hljs-comment">//堆排序</span><br>        <span class="hljs-comment">//先建堆 floyd算法(O(n)) 自下而上的进行下滤 排除叶子节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = nums.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<span class="hljs-number">0</span> &lt;= i;--i)<br>            <span class="hljs-built_in">percolateDown</span>(nums,i,nums.<span class="hljs-built_in">size</span>());<br>        <br>        <span class="hljs-comment">//自上而下的下滤</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; res.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            res[i] = nums[<span class="hljs-number">0</span>];<br>            nums[<span class="hljs-number">0</span>] = nums[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> - i];<br>            <span class="hljs-built_in">percolateDown</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>() - i - <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">//下滤操作 将较大的数进行下滤 O(logn)</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">percolateDown</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; num,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> numSize)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> j; <span class="hljs-comment">//i及其（至多两个）孩子中，堪为父者</span><br>        <span class="hljs-keyword">while</span> ( i != ( j = <span class="hljs-built_in">ProperParent</span> (num,numSize, i)))  <span class="hljs-comment">//只要i非j，则</span><br>            <span class="hljs-built_in">swap</span>(num[i], num[j] ); i = j; <span class="hljs-comment">//二者换位，并继续考查下降后的i</span><br>        <span class="hljs-keyword">return</span> i; <span class="hljs-comment">//返回下滤抵达的位置（亦i亦j）</span><br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a><a id='shellSort'>希尔排序</a></h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">//希尔排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = <span class="hljs-number">0x3FFFFFFF</span>; <span class="hljs-number">0</span> &lt; d; d &gt;&gt;= <span class="hljs-number">1</span> )&#123;<span class="hljs-comment">//构建素数&#123; 1, 3, 7, 15, ..., 1073741823 &#125;</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = d; j &lt; nums.<span class="hljs-built_in">size</span>(); j++ ) &#123;<br>                <span class="hljs-keyword">int</span> tmp = nums[j],i = j - d;<span class="hljs-comment">//tmp为当前数组值,i为该列的第一个值的下标</span><br>                <span class="hljs-keyword">while</span>(<span class="hljs-number">0</span> &lt;= i &amp;&amp; nums[i]&gt;tmp)&#123;<span class="hljs-comment">//从列的下方开始,若条件满足,则往上交换</span><br>                    nums[i+d] = nums[i];<br>                    i-=d;<br>                &#125; <br>                nums[i+d] = tmp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;   <br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a><a id='countingSort'>计数排序</a></h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">//计数排序</span><br>        map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; i_map;<br>        <span class="hljs-comment">//先存放数组到map中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">if</span>(i_map.<span class="hljs-built_in">find</span>(nums[i]) == i_map.<span class="hljs-built_in">end</span>()) i_map.<span class="hljs-built_in">insert</span>(&#123;nums[i],<span class="hljs-number">1</span>&#125;);<br>            <span class="hljs-keyword">else</span> ++i_map[nums[i]];<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;pair:i_map)&#123;<br><br>            <span class="hljs-keyword">while</span>(pair.second != <span class="hljs-number">0</span>)&#123;<br>                nums[pos++] = pair.first;<br>                --pair.second;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a><a id='basesort'>基数排序</a></h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br><span class="hljs-keyword">typedef</span> multimap&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;::iterator multimapit;<br><span class="hljs-keyword">typedef</span> pair&lt;multimapit,multimapit&gt; pairit;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        multimap&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; p_multimap;<br>        <br>        <span class="hljs-comment">//基数排序</span><br>        <span class="hljs-comment">//获得最大值</span><br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(nums[i]) &gt; max) max = <span class="hljs-built_in">abs</span>(nums[i]);<br>        &#125;<br>        <span class="hljs-comment">//获得最高的位数</span><br>        <span class="hljs-keyword">int</span> max_digit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">do</span>&#123;<br>            max = max/<span class="hljs-number">10</span>;<br>            ++max_digit;<br>        &#125;<span class="hljs-keyword">while</span>(max != <span class="hljs-number">0</span>);<br>       <br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> digit = <span class="hljs-number">1</span>;digit &lt;= max_digit;++digit)&#123;<br><br>            <span class="hljs-keyword">int</span> get_remainder = <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,digit);<span class="hljs-comment">//求余</span><br>            <span class="hljs-keyword">int</span> get_quotient = get_remainder/<span class="hljs-number">10</span>;<span class="hljs-comment">//求商</span><br>            <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<span class="hljs-comment">//数组索引</span><br><br>            <span class="hljs-comment">//遍历整个数组</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;index &lt; nums.<span class="hljs-built_in">size</span>();++index)<br>                p_multimap.<span class="hljs-built_in">insert</span>(&#123;nums[index]%get_remainder/get_quotient,nums[index]&#125;);<br><br>            <span class="hljs-comment">//从multimap取出到nums</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">-9</span>;i &lt;= <span class="hljs-number">9</span>;++i)&#123;<br><br>                <span class="hljs-keyword">if</span>(p_multimap.<span class="hljs-built_in">find</span>(i) == p_multimap.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">continue</span>;<br><br>                <span class="hljs-comment">//获得key</span><br>                pairit pit = p_multimap.<span class="hljs-built_in">equal_range</span>(i);<br>                <span class="hljs-keyword">for</span>(multimapit mit = pit.first;mit!=pit.second;++mit)&#123;<br>                    nums[pos++] = mit-&gt;second;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">//清空</span><br>            p_multimap.<span class="hljs-built_in">clear</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums;   <br>    &#125;   <br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/pange1991/article/details/85460755">排序算法时间复杂度、空间复杂度、稳定性比较</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图</tag>
      
      <tag>优先级队列</tag>
      
      <tag>链表</tag>
      
      <tag>二分查找</tag>
      
      <tag>快速排序</tag>
      
      <tag>队列</tag>
      
      <tag>计数排序</tag>
      
      <tag>归并排序</tag>
      
      <tag>起泡排序</tag>
      
      <tag>堆排序</tag>
      
      <tag>选择排序</tag>
      
      <tag>基数排序</tag>
      
      <tag>桶排序</tag>
      
      <tag>希尔排序</tag>
      
      <tag>树</tag>
      
      <tag>向量</tag>
      
      <tag>斐波那契查找</tag>
      
      <tag>插值查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 10- II. 青蛙跳台阶问题</title>
    <link href="/2021/07/06/LeetCode/%E5%89%91%E6%8C%87%20Offer%2010-%20II.%20%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"/>
    <url>/2021/07/06/LeetCode/%E5%89%91%E6%8C%87%20Offer%2010-%20II.%20%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">本题链接</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">int</span> p1 = <span class="hljs-number">1</span>,p2 = <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt; n;++i)&#123;<br>            p2 = p1 + p2;<br>            p1 = p2 - p1;<br>            p2 %= <span class="hljs-number">1000000007</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p2;<br><br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题实际上就是斐波那契数列…</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>数学</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 09. 用两个栈实现队列</title>
    <link href="/2021/07/05/LeetCode/%E5%89%91%E6%8C%87%20Offer%2009.%20%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2021/07/05/LeetCode/%E5%89%91%E6%8C%87%20Offer%2009.%20%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">本题链接</a></p><h2 id="栈1"><a href="#栈1" class="headerlink" title="栈1"></a>栈1</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CQueue</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br><br>        <span class="hljs-keyword">while</span>(!tail_s.<span class="hljs-built_in">empty</span>())&#123;<br>            head_s.<span class="hljs-built_in">push</span>(tail_s.<span class="hljs-built_in">top</span>());<br>            tail_s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        head_s.<span class="hljs-built_in">push</span>(value);<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(head_s.<span class="hljs-built_in">empty</span>() &amp;&amp; tail_s.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-built_in">peek</span>();<br>        tail_s.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">while</span>(!head_s.<span class="hljs-built_in">empty</span>())&#123;<br>            tail_s.<span class="hljs-built_in">push</span>(head_s.<span class="hljs-built_in">top</span>());<br>            head_s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> tail_s.<span class="hljs-built_in">top</span>();<br>    &#125;<br><br>    stack&lt;<span class="hljs-keyword">int</span>&gt; head_s;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; tail_s;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your CQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * CQueue* obj = new CQueue();</span><br><span class="hljs-comment"> * obj-&gt;appendTail(value);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;deleteHead();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>分别用两个栈的栈底模拟队列的头和尾即可</p><h2 id="栈2"><a href="#栈2" class="headerlink" title="栈2"></a>栈2</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CQueue</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        s1.<span class="hljs-built_in">push</span>(value);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">empty</span>() &amp;&amp; s2.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//若没有数据</span><br>     <br>        <span class="hljs-keyword">if</span>(s2.<span class="hljs-built_in">empty</span>())&#123;<span class="hljs-comment">//当s2为空时</span><br><br>            <span class="hljs-keyword">while</span>(!s1.<span class="hljs-built_in">empty</span>())&#123;<span class="hljs-comment">//将s1的所有数据放入s2中</span><br>                s2.<span class="hljs-built_in">push</span>(s1.<span class="hljs-built_in">top</span>());<br>                s1.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> res = s2.<span class="hljs-built_in">top</span>();<br>        s2.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    stack&lt;<span class="hljs-keyword">int</span>&gt; s1;<span class="hljs-comment">//优先存放元素</span><br>    stack&lt;<span class="hljs-keyword">int</span>&gt; s2;<span class="hljs-comment">//反转s1的元素</span><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your CQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * CQueue* obj = new CQueue();</span><br><span class="hljs-comment"> * obj-&gt;appendTail(value);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;deleteHead();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>s1存放正常入队顺序的元素，而由于出队时先进来的元素被放在s1的栈底，所以需要借由s2来获取s1的栈底元素。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 06. 从尾到头打印链表</title>
    <link href="/2021/07/04/LeetCode/%E5%89%91%E6%8C%87%20Offer%2006.%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/07/04/LeetCode/%E5%89%91%E6%8C%87%20Offer%2006.%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        stack&lt;<span class="hljs-keyword">int</span>&gt; tmp_s;<br><br>        <span class="hljs-comment">//加入栈</span><br>        <span class="hljs-keyword">while</span>(head)&#123;<br>            tmp_s.<span class="hljs-built_in">push</span>(head-&gt;val);<br>            head = head-&gt;next;<br>        &#125;<br><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-comment">//从栈取出</span><br>        <span class="hljs-keyword">while</span>(!tmp_s.<span class="hljs-built_in">empty</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(tmp_s.<span class="hljs-built_in">top</span>());<br>            tmp_s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将链表从头遍历到尾，并将过程中经历过的节点的值放入栈中。然后再依次从栈中取出元素放入结果数组。</p><h2 id="获得链表大小"><a href="#获得链表大小" class="headerlink" title="获得链表大小"></a>获得链表大小</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> list_size = <span class="hljs-number">0</span>;<br>        ListNode* node = head;<br><br>        <span class="hljs-comment">//获得链表的大小</span><br>        <span class="hljs-keyword">while</span>(node)&#123;<br>            ++list_size;<br>            node = node-&gt;next;<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(list_size,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">//链表从头到尾开始遍历,对应数组从尾到头填入数据</span><br>        <span class="hljs-keyword">while</span>(head)&#123;<br>            res[--list_size] = head-&gt;val;<br>            head = head-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先获得链表大小，然后根据这个大小开辟数组，接着再遍历一次链表，将值写入数组。这样做少了vector的扩容开销</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        <span class="hljs-built_in">getNext</span>(head);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-built_in">getNext</span>(head-&gt;next);<br>        res.<span class="hljs-built_in">push_back</span>(head-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>递归思路更加直观，当从递归基返回时才会将值加入数组，函数栈的返回正好对应链表的从尾到头。</p><blockquote><p>当链表非常长的时候，这会导致函数调用的层级很深，从而可能导致函数调用栈溢出。显然，基于用栈基于循环的代码鲁棒性比这个好。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>栈</tag>
      
      <tag>链表</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 05. 替换空格</title>
    <link href="/2021/07/02/LeetCode/%E5%89%91%E6%8C%87%20Offer%2005.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <url>/2021/07/02/LeetCode/%E5%89%91%E6%8C%87%20Offer%2005.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">本题链接</a></p><h2 id="字符串-双指针"><a href="#字符串-双指针" class="headerlink" title="字符串+双指针"></a>字符串+双指针</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        string res;<br>        res.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>()*<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">int</span> res_index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();++i,++res_index)&#123;<br><br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                res[res_index++] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>                res[res_index++] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                res[res_index] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                res[res_index] = s[i];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题如果用从头到尾的遍历，复杂度会很高，达到$O(n^2)$。原因是string在插入时会将插入后面的元素向后移动，该移动操作的平均复杂度为$O(n)$​。</p><p>如果用一个空的字符串来不停的<code>push_back()</code>也不是最好的办法，因为字符串和向量的行为上类似，当容量不足以存放元素时会发生扩容操作，这也是一笔不小的开销。</p><p>那么就直接将结果字符串设置为固定的大小，结果字符串的大小取值范围与原字符串的空格有关。那么就按照最坏的情况考虑，当原字符串的每个字符都为空格时，结果字符串的大小就是原字符串的三倍。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>543. 二叉树的直径</title>
    <link href="/2021/07/01/LeetCode/543.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    <url>/2021/07/01/LeetCode/543.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">本题链接</a></p><h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">int</span> max_len = <span class="hljs-number">0</span>;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">getLen</span>(root);<br>        <span class="hljs-keyword">return</span> max_len;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLen</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">int</span> left_len = <span class="hljs-built_in">getLen</span>(root-&gt;left);<span class="hljs-comment">//左子树的最大路径</span><br>        <span class="hljs-keyword">int</span> right_len = <span class="hljs-built_in">getLen</span>(root-&gt;right);<span class="hljs-comment">//右子树的最大路径</span><br><br>        <span class="hljs-comment">//结合自己与已有的结果对比</span><br>        max_len = <span class="hljs-built_in">max</span>(max_len,left_len + right_len);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(left_len,right_len);<span class="hljs-comment">//返回给上层最多的路径</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对每一个节点都求以它自己为准的最大路劲长度。实际上与求树的深度一样</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 03. 数组中重复的数字</title>
    <link href="/2021/06/30/LeetCode/%E5%89%91%E6%8C%87%20Offer%2003.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2021/06/30/LeetCode/%E5%89%91%E6%8C%87%20Offer%2003.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">本题链接</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        unordered_set&lt;<span class="hljs-keyword">int</span>&gt; hash;<br>        <span class="hljs-keyword">int</span> i;<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt;nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">find</span>(nums[i]) == hash.<span class="hljs-built_in">end</span>()) hash.<span class="hljs-built_in">insert</span>(nums[i]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>; <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums[i];<br>    &#125;   <br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>既然是找到重复的数字，很容易想到使用哈希表来判断元素是否重复出现。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(n)$</li></ul><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//排序</span><br><br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<span class="hljs-comment">//查找</span><br>            <span class="hljs-keyword">if</span>(nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums[i];<br>    &#125;   <br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>先对数组进行排序，然后查找是否有相邻元素相等。</p><ul><li><p>时间复杂度$O(n+nlog_2{n}) = O(nlog_2{n})$</p></li><li><p>空间复杂度$O(1)$</p></li></ul><h2 id="原地哈希"><a href="#原地哈希" class="headerlink" title="原地哈希"></a>原地哈希</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">while</span>(nums[i] != i)&#123;<br>                <span class="hljs-keyword">if</span>(nums[nums[i]] == nums[i]) <span class="hljs-keyword">return</span> nums[i];<br>                <span class="hljs-built_in">swap</span>(nums[nums[i]],nums[i]);<br>            &#125;  <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>每次遍历的时候都让下标对应的元素归位，比如下标0的地方存放0。只要发现当前元素所指向的下标已经存放该元素了，就代表发现了一个重复的元素。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>数组</tag>
      
      <tag>就地算法</tag>
      
      <tag>剑指Offer</tag>
      
      <tag>就地哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>332. 重新安排行程</title>
    <link href="/2021/06/02/LeetCode/332.%20%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B/"/>
    <url>/2021/06/02/LeetCode/332.%20%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/reconstruct-itinerary/">本题链接</a></p><h2 id="哈希表-栈"><a href="#哈希表-栈" class="headerlink" title="哈希表+栈"></a>哈希表+栈</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br><br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">res</span><span class="hljs-params">(tickets.size()+<span class="hljs-number">1</span>,<span class="hljs-string">&quot;&quot;</span>)</span></span>;<br>        unordered_map&lt;string,multiset&lt;string&gt;&gt; hash;<br>        <span class="hljs-comment">//将机票映射到hash中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; tickets.<span class="hljs-built_in">size</span>();++i)<br>            hash[tickets[i][<span class="hljs-number">0</span>]].<span class="hljs-built_in">insert</span>(tickets[i][<span class="hljs-number">1</span>]);<br>            <br>        stack&lt;string&gt; s;<br>        s.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;JFK&quot;</span>);<br>        <span class="hljs-keyword">int</span> pos = res.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())&#123;<br><br>            string next = s.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span>(!hash[next].<span class="hljs-built_in">empty</span>())&#123;<span class="hljs-comment">//如果非空,说明还能飞</span><br>                s.<span class="hljs-built_in">push</span>(*(hash[next].<span class="hljs-built_in">begin</span>()));<br>                hash[next].<span class="hljs-built_in">erase</span>(hash[next].<span class="hljs-built_in">begin</span>());<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果为空,说明已经没法继续飞了</span><br>                res[pos--] = s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先将每张机票的起点和终点设置映射关系，由于一个起点会对应多个终点，所以在<code>unordered_map</code>中使用<code>multiset&lt;string&gt;</code>存放多个终点。</p><p>之后维护一个栈，每次都寻找从栈顶元素出发的终点。若没有找到，说明这个栈顶元素已经无法继续飞了，就将栈顶元素弹出，存放到结果数组中。若还能继续飞，那么就将终点入栈，并把这个终点从映射表中删除。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>647. 回文子串</title>
    <link href="/2021/05/26/LeetCode/647.%20%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2021/05/26/LeetCode/647.%20%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/palindromic-substrings/">本题链接</a></p><h2 id="中心扩展"><a href="#中心扩展" class="headerlink" title="中心扩展"></a>中心扩展</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            res+= <span class="hljs-built_in">getMaxSub</span>(i,i+<span class="hljs-number">1</span>,s);<br>            res+= <span class="hljs-built_in">getMaxSub</span>(i,i,s);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMaxSub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lo,<span class="hljs-keyword">int</span> hi,string&amp; s)</span></span>&#123;<br><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">0</span> &lt;= lo &amp;&amp; hi &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[lo] == s[hi])&#123;<br>            ++count;<br>            --lo;<br>            ++hi;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每次遍历选择一个字母为轴心，然后逐步向左向右拓展，直到左右两边不相等。注意要分奇偶情况</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>中心扩展法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1337. 矩阵中战斗力最弱的 K 行</title>
    <link href="/2021/05/24/LeetCode/1337.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%88%98%E6%96%97%E5%8A%9B%E6%9C%80%E5%BC%B1%E7%9A%84%20K%20%E8%A1%8C/"/>
    <url>/2021/05/24/LeetCode/1337.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%88%98%E6%96%97%E5%8A%9B%E6%9C%80%E5%BC%B1%E7%9A%84%20K%20%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/">本题链接</a></p><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">kWeakestRows</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; mat, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(k,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">auto</span> cmp = [](pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&amp; a,pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&amp; b)&#123;<br>            <span class="hljs-keyword">if</span>(a.second == b.second) <span class="hljs-keyword">return</span> a.first &gt; b.first;<br>            <span class="hljs-keyword">return</span> a.second &gt; b.second;&#125;;<br>        priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;,<span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">p_q</span>(cmp);<span class="hljs-comment">//优先级队列:小顶</span><br><br>        <span class="hljs-comment">//计算每行的战斗力</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;r &lt; mat.<span class="hljs-built_in">size</span>();++r)&#123;<br>            <br>            <span class="hljs-keyword">int</span> atta = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;c &lt; mat[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();++c)&#123;<br>                <span class="hljs-keyword">if</span>(mat[r][c] == <span class="hljs-number">1</span>) ++atta;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            &#125;<br>            p_q.<span class="hljs-built_in">push</span>(&#123;r,atta&#125;);<span class="hljs-comment">//按照战斗力优先,行号次之的顺序放入到小顶堆</span><br>        &#125;<br><br>        <span class="hljs-comment">//从小顶堆中取出前K个</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; k;++i)&#123;<br>            res[i] = ((pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;)p_q.<span class="hljs-built_in">top</span>()).first;<br>            p_q.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先计算每行的战斗力，然后根据战斗力优先，行号次之的顺序放入到小顶堆。最后从堆顶取出k个元素即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>优先级队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>547. 省份数量</title>
    <link href="/2021/05/23/LeetCode/547.%20%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/"/>
    <url>/2021/05/23/LeetCode/547.%20%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/number-of-provinces/">本题链接</a></p><h2 id="DFS-栈"><a href="#DFS-栈" class="headerlink" title="DFS+栈"></a>DFS+栈</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;<br><br>        set&lt;<span class="hljs-keyword">int</span>&gt; city_set;<span class="hljs-comment">//存放已经遍历过的城市</span><br>        stack&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; city_stack;<span class="hljs-comment">//辅助栈 &lt;city,当前遍历的连接&gt;</span><br>        <span class="hljs-keyword">int</span> province = <span class="hljs-number">0</span>;<span class="hljs-comment">//省份数量</span><br>        <span class="hljs-keyword">int</span> city = <span class="hljs-number">0</span>;<span class="hljs-comment">//当前城市</span><br>        <span class="hljs-keyword">while</span>(city_set.<span class="hljs-built_in">size</span>() &lt; isConnected.<span class="hljs-built_in">size</span>())&#123;<br><br>            <span class="hljs-keyword">int</span> conn = <span class="hljs-number">0</span>;<span class="hljs-comment">//连接数</span><br><br>            <span class="hljs-keyword">if</span>(city_set.<span class="hljs-built_in">find</span>(city) != city_set.<span class="hljs-built_in">end</span>())&#123;<span class="hljs-comment">//如果该城市已经属于省份,跳过</span><br>                ++city;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                city_set.<span class="hljs-built_in">insert</span>(city);<span class="hljs-comment">//加入新城市,以该城市为起点</span><br>                ++province;<br>            &#125;<br>            <br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><br>                <span class="hljs-keyword">if</span>(isConnected[city][conn] == <span class="hljs-number">0</span> || city_set.<span class="hljs-built_in">find</span>(conn) != city_set.<span class="hljs-built_in">end</span>())&#123;<span class="hljs-comment">//跳过0,或自己,已连接的城市和有归属的城市</span><br>                    <span class="hljs-keyword">if</span>(++conn == isConnected.<span class="hljs-built_in">size</span>())&#123;<span class="hljs-comment">//到达边界</span><br>                        <span class="hljs-keyword">if</span>(city_stack.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//如果栈为空,退出</span><br>                        <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//状态回归</span><br>                            pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; city_state = city_stack.<span class="hljs-built_in">top</span>();<br>                            city_stack.<span class="hljs-built_in">pop</span>();<br>                            city = city_state.first;<br>                            conn = city_state.second;<br>                        &#125;<br>                    &#125; <br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//否则将当前城市和当前的连接入栈,并保存</span><br>                    city_stack.<span class="hljs-built_in">push</span>(&#123;city,conn&#125;);<br>                    city = conn;<br>                    conn = <span class="hljs-number">0</span>;<br>                    city_set.<span class="hljs-built_in">insert</span>(city);<br>                &#125; <br>            &#125;<br><br>            ++city;<br>        &#125;<br>        <span class="hljs-keyword">return</span> province;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>该题可看作一行为一个节点，然后这个节点中存储着与其他节点之间的连接关系。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度优先搜索</tag>
      
      <tag>栈</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>435. 无重叠区间</title>
    <link href="/2021/05/22/LeetCode/435.%20%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/"/>
    <url>/2021/05/22/LeetCode/435.%20%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">本题链接</a></p><h2 id="暴力-贪心"><a href="#暴力-贪心" class="headerlink" title="暴力+贪心"></a>暴力+贪心</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;<br><br>        <span class="hljs-comment">//异常处理</span><br>        <span class="hljs-keyword">if</span>(intervals.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">//预处理 排序</span><br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(),intervals.<span class="hljs-built_in">end</span>(),[](vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; a,vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; b)&#123; <br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>        &#125;);<br><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> hi = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>( intervals[i][<span class="hljs-number">0</span>] &lt; hi) <span class="hljs-comment">//重叠</span><br>                &#123;count+=<span class="hljs-number">1</span>;&#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                hi = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> count;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>思路：题目的意思其实就是让区间的数量最大。那么可以通过右边界排序，每次迭代让最小的右边界尽量靠左边，在右侧最大可能的腾出位置。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>贪心</tag>
      
      <tag>区间</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>232. 用栈实现队列</title>
    <link href="/2021/05/11/LeetCode/232.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2021/05/11/LeetCode/232.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">本题链接</a></p><h2 id="两个栈实现一个队列"><a href="#两个栈实现一个队列" class="headerlink" title="两个栈实现一个队列"></a>两个栈实现一个队列</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyQueue</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-comment">/** Push element x to the back of queue. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>       <br>        <span class="hljs-keyword">while</span>(!tail_s.<span class="hljs-built_in">empty</span>())&#123;<br>            head_s.<span class="hljs-built_in">push</span>(tail_s.<span class="hljs-built_in">top</span>());<br>            tail_s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        head_s.<span class="hljs-built_in">push</span>(x);<br>        <br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-built_in">peek</span>();<br>        tail_s.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get the front element. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">while</span>(!head_s.<span class="hljs-built_in">empty</span>())&#123;<br>            tail_s.<span class="hljs-built_in">push</span>(head_s.<span class="hljs-built_in">top</span>());<br>            head_s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> tail_s.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns whether the queue is empty. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> head_s.<span class="hljs-built_in">size</span>()+tail_s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><br>    stack&lt;<span class="hljs-keyword">int</span>&gt; head_s;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; tail_s;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue* obj = new MyQueue();</span><br><span class="hljs-comment"> * obj-&gt;push(x);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;peek();</span><br><span class="hljs-comment"> * bool param_4 = obj-&gt;empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>分别用两个栈的栈底模拟队列的头和尾即可</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>236. 二叉树的最近公共祖先</title>
    <link href="/2021/05/03/LeetCode/236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2021/05/03/LeetCode/236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">本题链接</a></p><h2 id="递归-中序遍历"><a href="#递归-中序遍历" class="headerlink" title="递归+中序遍历"></a>递归+中序遍历</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    TreeNode* res;  <br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br><br>        <span class="hljs-built_in">inOrder</span>(root,p,q);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;<br><br>        <span class="hljs-comment">//当节点为空或者已经有结果,就不再递归深入</span><br>        <span class="hljs-keyword">if</span>(!root || res) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">bool</span> left = <span class="hljs-built_in">inOrder</span>(root-&gt;left,p,q);<span class="hljs-comment">//左子树中是否存在</span><br>        <span class="hljs-keyword">bool</span> right = <span class="hljs-built_in">inOrder</span>(root-&gt;right,p,q);<span class="hljs-comment">//右子树中是否存在</span><br>        <span class="hljs-keyword">bool</span> self = root == p || root == q;<span class="hljs-comment">//自己是否符合条件</span><br><br>        <span class="hljs-comment">//1.如果自己符合条件且左右子树有一个符合条件</span><br>        <span class="hljs-comment">//2.如果左右子树都符合条件</span><br>        <span class="hljs-keyword">if</span>((self &amp;&amp; (left || right)) || (left &amp;&amp; right)) res = root;<br>        <br>        <span class="hljs-keyword">return</span> self || left || right;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接中序遍历递归，每当递归深入到一个节点时，判断它是否是两点之一，或者它的左右子树是否拥有两个点之一即可。返回true表示以这个节点为根节点的子树拥有两个点之一。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
      <tag>中序遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>102. 二叉树的层序遍历</title>
    <link href="/2021/05/02/LeetCode/102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2021/05/02/LeetCode/102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">本题链接</a></p><h2 id="层次遍历-迭代1"><a href="#层次遍历-迭代1" class="headerlink" title="层次遍历+迭代1"></a>层次遍历+迭代1</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        TreeNode* node;<br>        <span class="hljs-keyword">int</span> height;<br>    &#125;Elem;<br><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        <span class="hljs-keyword">int</span> val;<br>        <span class="hljs-keyword">int</span> height;<br>    &#125;Value;<br>    <br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>        vector&lt;Value&gt; tmp;<span class="hljs-comment">//存入&#123;节点的值,节点所在的层数&#125;</span><br>        queue&lt;Elem&gt; node_q;<span class="hljs-comment">//存入&#123;节点,节点所在的层数&#125;</span><br><br>        <span class="hljs-comment">//层次遍历 存入数组中</span><br>        node_q.<span class="hljs-built_in">push</span>(&#123;root,<span class="hljs-number">0</span>&#125;);<span class="hljs-comment">//存入第一个节点</span><br>        <span class="hljs-keyword">while</span>(!node_q.<span class="hljs-built_in">empty</span>())&#123;<span class="hljs-comment">//当队列非空</span><br><br>            TreeNode* loop_node = ((Elem)node_q.<span class="hljs-built_in">front</span>()).node;<span class="hljs-comment">//从队列头获取当前节点</span><br>            <span class="hljs-keyword">int</span> height = ((Elem)node_q.<span class="hljs-built_in">front</span>()).height;<span class="hljs-comment">//从队列头获取当前高度</span><br><br>            tmp.<span class="hljs-built_in">push_back</span>(&#123;loop_node-&gt;val,height&#125;);<span class="hljs-comment">//将节点的值和高度存入tmp数组</span><br>            <br>            <span class="hljs-keyword">if</span>(loop_node-&gt;left) node_q.<span class="hljs-built_in">push</span>(&#123;loop_node-&gt;left,height+<span class="hljs-number">1</span>&#125;);<span class="hljs-comment">//存入左孩子到队列</span><br>            <span class="hljs-keyword">if</span>(loop_node-&gt;right) node_q.<span class="hljs-built_in">push</span>(&#123;loop_node-&gt;right,height+<span class="hljs-number">1</span>&#125;);<span class="hljs-comment">//存入右孩子到队列</span><br>                <br>            node_q.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//将当前节点出队</span><br>        &#125;<br><br>        <span class="hljs-comment">//开辟结果数组,大小与最后一个节点的高度有关</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res = vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;(((Value)tmp[tmp.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]).height + <span class="hljs-number">1</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;&#125;);<br><br>        <span class="hljs-comment">//遍历tmp中的所有元素,存放到相应的数组中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; tmp.<span class="hljs-built_in">size</span>();++i)<br>            res[((Value)tmp[i]).height].<span class="hljs-built_in">push_back</span>(((Value)tmp[i]).val);<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>该题的关键就是如何保存每一层的高度，可以在层次遍历时记录每个节点的高度，然后将每个节点的值以及高度保存在数组里，最后再由这个数组构造结果。</p><h2 id="层次遍历-迭代2"><a href="#层次遍历-迭代2" class="headerlink" title="层次遍历+迭代2"></a>层次遍历+迭代2</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>        queue&lt;TreeNode*&gt; node_queue;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br><br>        node_queue.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!node_queue.<span class="hljs-built_in">empty</span>())&#123;<br><br>            <span class="hljs-keyword">int</span> size = node_queue.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//该层大小</span><br>            vector&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; size;++i)&#123;<br>                <br>                <span class="hljs-keyword">if</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;left) node_queue.<span class="hljs-built_in">push</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;left);<br>                <span class="hljs-keyword">if</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;right) node_queue.<span class="hljs-built_in">push</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;right);<br>                tmp.<span class="hljs-built_in">push_back</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;val);<br>                <br>                node_queue.<span class="hljs-built_in">pop</span>();<br>            &#125;   <br><br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>对比层序遍历1，无需保存层数，其实层数就隐藏在队列中…</p><h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br><br>        <span class="hljs-built_in">func</span>(root,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(TreeNode* root,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; depth)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">//若没有空间</span><br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>()  &lt; depth + <span class="hljs-number">1</span>)<br>            res.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;&#125;);<br>        <br>        res[depth].<span class="hljs-built_in">push_back</span>(root-&gt;val);<span class="hljs-comment">//将自己存入结果数组中</span><br><br>        <span class="hljs-built_in">func</span>(root-&gt;left,depth+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">func</span>(root-&gt;right,depth+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>关键点在于对一个节点的左右孩子进行递归深入时，深度记得累加就行。该递归其实就是先序遍历。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代</tag>
      
      <tag>层序遍历</tag>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>103. 二叉树的锯齿形层序遍历</title>
    <link href="/2021/05/02/LeetCode/103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2021/05/02/LeetCode/103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">本题链接</a></p><h2 id="迭代-层序遍历"><a href="#迭代-层序遍历" class="headerlink" title="迭代+层序遍历"></a>迭代+层序遍历</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>        queue&lt;TreeNode*&gt; node_queue;<br>        <span class="hljs-keyword">bool</span> dirc = <span class="hljs-literal">true</span>;<br>        TreeNode* node;<br><br>        node_queue.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!node_queue.<span class="hljs-built_in">empty</span>())&#123;<br><br>            <span class="hljs-keyword">int</span> size = node_queue.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(size,<span class="hljs-number">0</span>)</span></span>;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; size;++i)&#123;<br><br>                node = node_queue.<span class="hljs-built_in">front</span>();node_queue.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//获得节点</span><br>                <br>                <span class="hljs-keyword">if</span>(node-&gt;left) node_queue.<span class="hljs-built_in">push</span>(node-&gt;left);<span class="hljs-comment">//存入左孩子</span><br>                <span class="hljs-keyword">if</span>(node-&gt;right) node_queue.<span class="hljs-built_in">push</span>(node-&gt;right);<span class="hljs-comment">//存入右孩子</span><br><br>                <span class="hljs-keyword">if</span>(dirc) tmp[i] = node-&gt;val;<span class="hljs-comment">//正向</span><br>                <span class="hljs-keyword">else</span> tmp[size<span class="hljs-number">-1</span>-i] = node-&gt;val;<span class="hljs-comment">//反向</span><br><br>            &#125;<br><br>            dirc = !dirc;<span class="hljs-comment">//方向反转</span><br>            res.<span class="hljs-built_in">push_back</span>(tmp);<span class="hljs-comment">//保存结果</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>跟普通的层序遍历一样，就是每次存入一个结果时需要反转方向。用层数的奇偶也能表示是否反转。以上的代码可以继续优化，没必要在每个节点都判断一次反转方向，因为反转方向的单位是每层的元素。</p><p><code>while</code>更改：（使用代码冗余来换取速度）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><br><span class="hljs-keyword">while</span>(!node_queue.<span class="hljs-built_in">empty</span>())&#123;<br><br>    <span class="hljs-keyword">int</span> size = node_queue.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(size,<span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-keyword">if</span>(dirc)&#123;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; size;++i)&#123;<br><br>            node = node_queue.<span class="hljs-built_in">front</span>();node_queue.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//获得节点</span><br>        <br>            <span class="hljs-keyword">if</span>(node-&gt;left) node_queue.<span class="hljs-built_in">push</span>(node-&gt;left);<span class="hljs-comment">//存入左孩子</span><br>            <span class="hljs-keyword">if</span>(node-&gt;right) node_queue.<span class="hljs-built_in">push</span>(node-&gt;right);<span class="hljs-comment">//存入右孩子</span><br><br>            tmp[i] = node-&gt;val;<span class="hljs-comment">//正向</span><br><br>        &#125;<br>        <br>    &#125;<span class="hljs-keyword">else</span>&#123;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; size;++i)&#123;<br><br>            node = node_queue.<span class="hljs-built_in">front</span>();node_queue.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//获得节点</span><br>        <br>            <span class="hljs-keyword">if</span>(node-&gt;left) node_queue.<span class="hljs-built_in">push</span>(node-&gt;left);<span class="hljs-comment">//存入左孩子</span><br>            <span class="hljs-keyword">if</span>(node-&gt;right) node_queue.<span class="hljs-built_in">push</span>(node-&gt;right);<span class="hljs-comment">//存入右孩子</span><br><br>            tmp[size<span class="hljs-number">-1</span>-i] = node-&gt;val;<span class="hljs-comment">//反向</span><br><br>        &#125;<br>    &#125;<br>    dirc = !dirc;<span class="hljs-comment">//方向反转</span><br>    res.<span class="hljs-built_in">push_back</span>(tmp);<span class="hljs-comment">//保存结果</span><br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代</tag>
      
      <tag>层序遍历</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>413. 等差数列划分</title>
    <link href="/2021/05/01/LeetCode/413.%20%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/"/>
    <url>/2021/05/01/LeetCode/413.%20%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/arithmetic-slices/">本题链接</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">int</span> prevInt;<br>    <span class="hljs-keyword">int</span> midInt;<br>    <span class="hljs-keyword">int</span> pos;<br>&#125;num_pair;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numberOfArithmeticSlices</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <br>        <br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        vector&lt;num_pair&gt; dp;<br>        <br>        <span class="hljs-comment">//分离</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;++i)<br>            <span class="hljs-keyword">if</span>((nums[i<span class="hljs-number">-1</span>] - nums[i]) == (nums[i] - nums[i+<span class="hljs-number">1</span>]))<br>                dp.<span class="hljs-built_in">push_back</span>(num_pair&#123;nums[i],nums[i+<span class="hljs-number">1</span>],i+<span class="hljs-number">1</span>&#125;);<br><br>        <span class="hljs-comment">//合并</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; dp.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            <span class="hljs-keyword">if</span>(dp[i].pos == nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(dp[i].prevInt - dp[i].midInt == dp[i].midInt - nums[dp[i].pos+<span class="hljs-number">1</span>])<br>                dp.<span class="hljs-built_in">push_back</span>(num_pair&#123;dp[i].midInt,nums[dp[i].pos+<span class="hljs-number">1</span>],dp[i].pos+<span class="hljs-number">1</span>&#125;);<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">size</span>();<br>            <br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先将整个数组分离出<strong>最小</strong>的子数组，然后依次放入<strong>dp</strong>数组中。之后每次从<strong>dp</strong>数组拿出一个子数组，只要这个子数组的后两位与原数组中某个位置上的数组成等差数列，且这个位置正好是这个子数组中的最后一个数的下一位，那么又构成了一个新的子数组…..一直迭代，直到遍历到<strong>dp</strong>数组的最后一个。</p><p>观察后发现，每次迭代使用的数只有子数组的最后两位，还有就是子数组最后一位在原数组中的位置，那么只需要将这三个关键的点存储起来用于比较即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>384. 打乱数组</title>
    <link href="/2021/04/27/LeetCode/384.%20%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/"/>
    <url>/2021/04/27/LeetCode/384.%20%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/shuffle-an-array/">本题链接</a></p><h2 id="Fisher-Yates洗牌算法"><a href="#Fisher-Yates洗牌算法" class="headerlink" title="Fisher-Yates洗牌算法"></a>Fisher-Yates洗牌算法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; origin;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums):<span class="hljs-built_in">origin</span>(<span class="hljs-built_in">move</span>(nums)) &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-comment">/** Resets the array to its original configuration and return it. */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> origin;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns a random shuffling of the array. */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">shuffle</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(origin.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">shuffled</span><span class="hljs-params">(origin)</span></span>;<br><br>        <span class="hljs-comment">//正向</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; shuffled.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-built_in">swap</span>(shuffled[i],shuffled[<span class="hljs-built_in">rand</span>() % (i + <span class="hljs-number">1</span>)]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> shuffled;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Solution object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Solution* obj = new Solution(nums);</span><br><span class="hljs-comment"> * vector&lt;int&gt; param_1 = obj-&gt;reset();</span><br><span class="hljs-comment"> * vector&lt;int&gt; param_2 = obj-&gt;shuffle();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用Fisher-Yates洗牌算法，通过随机交换位置来实现随机打乱。正向遍历或反向遍历数组进行打乱皆可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fisher-Yates洗牌算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>695. 岛屿的最大面积</title>
    <link href="/2021/04/26/LeetCode/695.%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/"/>
    <url>/2021/04/26/LeetCode/695.%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/max-area-of-island/">本题链接</a></p><h2 id="DFS-递归"><a href="#DFS-递归" class="headerlink" title="DFS+递归"></a>DFS+递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    set&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; yet_set;<span class="hljs-comment">//已经被探寻过的地点</span><br>    pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; border;<span class="hljs-comment">//grid边界</span><br>    vector&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; direction_vec&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;<span class="hljs-comment">//方向 上右下左的顺序</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br><br>        <span class="hljs-keyword">this</span>-&gt;border = pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&#123;grid.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>,grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">int</span> max_land = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">//遍历所有能遍历到的点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;row &lt; grid.<span class="hljs-built_in">size</span>();++row)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>;col &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();++col)&#123;<br>                <br>                <span class="hljs-keyword">if</span>(grid[row][col] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果是0,直接跳过</span><br>                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;yet_set.<span class="hljs-built_in">find</span>(&#123;row,col&#125;) != <span class="hljs-keyword">this</span>-&gt;yet_set.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果已经探寻过,直接跳过</span><br>                <br>                pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; point&#123;row,col&#125;;<span class="hljs-comment">//创建一个点</span><br>                <span class="hljs-keyword">this</span>-&gt;yet_set.<span class="hljs-built_in">insert</span>(point);<span class="hljs-comment">//备份这个点</span><br>                max_land = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">getLand</span>(point,grid),max_land);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max_land;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLand</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; point,vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span></span>&#123;<br>        <br>        <span class="hljs-keyword">int</span> local_max = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;direction : <span class="hljs-keyword">this</span>-&gt;direction_vec)&#123;<span class="hljs-comment">//从上右下左的顺序遍历点</span><br><br>            pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; new_point&#123;point.first + direction.first,point.second + direction.second&#125;;<span class="hljs-comment">//获得新的点位置</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">inGrid</span>(new_point) &amp;&amp; (<span class="hljs-keyword">this</span>-&gt;yet_set.<span class="hljs-built_in">find</span>(new_point) == <span class="hljs-keyword">this</span>-&gt;yet_set.<span class="hljs-built_in">end</span>()) &amp;&amp; grid[new_point.first][new_point.second] == <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//如果这个点合法且没被遍历过而且值为1</span><br>                <span class="hljs-keyword">this</span>-&gt;yet_set.<span class="hljs-built_in">insert</span>(new_point);<br>                local_max += <span class="hljs-built_in">getLand</span>(new_point,grid);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//否则跳过</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> local_max;      <br>    &#125;<br><br>    <span class="hljs-comment">//判断点是否合法</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">inGrid</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; point)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= point.first &amp;&amp; point.first &lt;= <span class="hljs-keyword">this</span>-&gt;border.first)<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= point.second &amp;&amp; point.second &lt;= <span class="hljs-keyword">this</span>-&gt;border.second) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>需要保存被探寻过的地点，以免再次遍历；然后就是定义一个方向数组，用来保存不同方向的行走。注意要避开不存在的点。然后流程就是先遍历每一个点，在每次迭代中对当前符合题意的点进一步深入即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>75. 颜色分类</title>
    <link href="/2021/04/24/LeetCode/75.%20%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/"/>
    <url>/2021/04/24/LeetCode/75.%20%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/sort-colors/">本题链接</a></p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">//退化情况</span><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &gt; nums[<span class="hljs-number">1</span>]) <span class="hljs-built_in">swap</span>(nums[<span class="hljs-number">0</span>] , nums[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <br><br>        <span class="hljs-comment">//使用计数或堆排序或者是快排思想皆可</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,pos = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><br>            <span class="hljs-keyword">while</span>(left &lt;= nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[left] == <span class="hljs-number">0</span>)<span class="hljs-comment">//碰到非0停止</span><br>                ++left;<br>            <br>            <span class="hljs-keyword">while</span>(right &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[right] != <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//碰到0停止</span><br>                <span class="hljs-keyword">if</span>(nums[right] == <span class="hljs-number">2</span>) <span class="hljs-built_in">swap</span>(nums[right--],nums[pos--]);<br>                <span class="hljs-keyword">else</span> --right;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(left &gt;= right) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-built_in">swap</span>(nums[left],nums[right]);<br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>实际上是三指针，但是每次遍历只移动left和right指针。每次遍历需要保证[0,left]区间内的值为0，[right,pos]区间内的值为1，(pos,nums.size()-1]区间内为2。只要right指针表示的值为2，那么就和pos指针的值交换。虽然pos指向的是下次存放2的位置，但是pos此时的值为1，那么跟right交换也不会出错。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>94. 二叉树的中序遍历</title>
    <link href="/2021/04/19/LeetCode/94.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2021/04/19/LeetCode/94.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">本题链接</a></p><h2 id="迭代-栈-哈希表"><a href="#迭代-栈-哈希表" class="headerlink" title="迭代+栈+哈希表"></a>迭代+栈+哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>        unordered_set&lt;TreeNode*&gt; hash;<span class="hljs-comment">//防止左孩子重复入栈</span><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<span class="hljs-comment">//结果数组</span><br>        stack&lt;TreeNode*&gt; node_stack;<span class="hljs-comment">//节点栈</span><br>        TreeNode* cur_node;<br><br>        node_stack.<span class="hljs-built_in">push</span>(root);<span class="hljs-comment">//将第一个节点压栈</span><br>        <span class="hljs-keyword">while</span>(!node_stack.<span class="hljs-built_in">empty</span>())&#123;<br>            <br>            <span class="hljs-comment">//获得当前节点</span><br>            cur_node = node_stack.<span class="hljs-built_in">top</span>();<br><br>            <span class="hljs-keyword">if</span>(cur_node-&gt;left &amp;&amp; hash.<span class="hljs-built_in">find</span>(cur_node-&gt;left) == hash.<span class="hljs-built_in">end</span>())&#123;<span class="hljs-comment">//如果有左孩子</span><br>                node_stack.<span class="hljs-built_in">push</span>(cur_node-&gt;left);<span class="hljs-comment">//将左孩子入栈</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果没有左孩子</span><br>                res.<span class="hljs-built_in">push_back</span>(cur_node-&gt;val);<span class="hljs-comment">//保存结果</span><br>                hash.<span class="hljs-built_in">insert</span>(cur_node);<span class="hljs-comment">//标记自己</span><br>                node_stack.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//将自己出栈</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(cur_node-&gt;right) node_stack.<span class="hljs-built_in">push</span>(cur_node-&gt;right);<span class="hljs-comment">//右孩子入栈 </span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据中序遍历的性质，将每个时刻栈顶的左孩子优先入栈（实际上就是沿着左侧链持续下行），直到当前栈顶没有左孩子，此时就可以把自己的数据保存到结果中，然后将右孩子入栈。为了防止左孩子重复入栈，使用哈希表存储已经被取值的节点。</p><h2 id="迭代-栈1"><a href="#迭代-栈1" class="headerlink" title="迭代+栈1"></a>迭代+栈1</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<span class="hljs-comment">//结果数组</span><br>        stack&lt;TreeNode*&gt; node_stack;<span class="hljs-comment">//节点栈</span><br>        TreeNode* cur_node = root;<br><br>        <br>        <span class="hljs-comment">//先将左侧链入栈</span><br>        <span class="hljs-keyword">while</span>(cur_node)&#123;<br>            node_stack.<span class="hljs-built_in">push</span>(cur_node);<br>            cur_node = cur_node-&gt;left;<br>        &#125;   <br>        <br>        <span class="hljs-keyword">while</span>(!node_stack.<span class="hljs-built_in">empty</span>())&#123;<br><br>            <span class="hljs-comment">//获得当前节点,并将当前节点出栈</span><br>            cur_node = node_stack.<span class="hljs-built_in">top</span>();node_stack.<span class="hljs-built_in">pop</span>();<br><br>            res.<span class="hljs-built_in">push_back</span>(cur_node-&gt;val);<span class="hljs-comment">//保存结果</span><br><br>            cur_node = cur_node-&gt;right;<span class="hljs-comment">//将控制权交给右孩子</span><br><br>            <span class="hljs-comment">//沿着当前节点的左侧链下行</span><br>            <span class="hljs-keyword">while</span>(cur_node)&#123;<br>                node_stack.<span class="hljs-built_in">push</span>(cur_node);<br>                cur_node = cur_node-&gt;left;<br>            &#125;   <br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>既然中序遍历的实质就是沿着左侧链下行，那么每次就把当前节点左侧链放入栈中，栈顶为当前未被遍历的左侧链的最末端。</p><h2 id="迭代-栈2"><a href="#迭代-栈2" class="headerlink" title="迭代+栈2"></a>迭代+栈2</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>  <br>        stack&lt;TreeNode*&gt; node_stack;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        TreeNode* cur_node = root;<span class="hljs-comment">//获取当前节点</span><br><br>        <span class="hljs-keyword">while</span>(!node_stack.<span class="hljs-built_in">empty</span>() || cur_node)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur_node)&#123;<span class="hljs-comment">//沿着左侧链下行</span><br>                node_stack.<span class="hljs-built_in">push</span>(cur_node);<span class="hljs-comment">//将当前节点压栈</span><br>                cur_node = cur_node-&gt;left;<span class="hljs-comment">//将控制权交给左孩子</span><br>            &#125;   <br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//走到某条左侧链的最后,即当前节点为空</span><br>                cur_node = node_stack.<span class="hljs-built_in">top</span>();node_stack.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//将当前节点更新为栈顶节点</span><br>                res.<span class="hljs-built_in">push_back</span>(cur_node-&gt;val);<span class="hljs-comment">//保存结果</span><br>                cur_node = cur_node-&gt;right;<span class="hljs-comment">//将控制权交给右孩子</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>相比第一个版本的<strong>迭代+栈</strong>更加直观</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-built_in">inOrder</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-built_in">inOrder</span>(root-&gt;left);<span class="hljs-comment">//优先深入左孩子</span><br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<span class="hljs-comment">//再保存自己的数据</span><br>        <span class="hljs-built_in">inOrder</span>(root-&gt;right);<span class="hljs-comment">//接着深入右孩子</span><br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>递归思路很简单，而且代码简洁直观。根据中序遍历序列的性质，优先考虑左孩子即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>迭代</tag>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
      <tag>栈</tag>
      
      <tag>中序遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>215. 数组中的第K个最大元素</title>
    <link href="/2021/04/13/LeetCode/215.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <url>/2021/04/13/LeetCode/215.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">本题链接</a></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> target = nums.<span class="hljs-built_in">size</span>() - k;<br>        <span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>,hi = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(lo &lt; hi)&#123;<br>            <span class="hljs-keyword">int</span> mid = <span class="hljs-built_in">getFindPivot</span>(nums,lo,hi);<br>            <span class="hljs-keyword">if</span>(mid == target) <span class="hljs-keyword">return</span> nums[mid];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mid &lt; target) lo = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> hi = mid - <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums[lo];<br>    &#125;<br><br>    <span class="hljs-comment">//返回一个基准点,采用快排思想</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getFindPivot</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> lo,<span class="hljs-keyword">int</span> hi)</span></span>&#123;<br><br>        <span class="hljs-keyword">int</span> left = lo + <span class="hljs-number">1</span>,right = hi;<br>        <span class="hljs-built_in">swap</span>(nums[lo], nums[lo + <span class="hljs-built_in">rand</span>() % ( hi - lo )]);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><br>            <span class="hljs-comment">//划分小于等于nums[lo]的区间</span><br>            <span class="hljs-keyword">while</span>(left &lt; hi &amp;&amp; nums[left] &lt;= nums[lo]) ++left;<br>            <br>            <span class="hljs-comment">//划分大于于等于nums[lo]的区间</span><br>            <span class="hljs-keyword">while</span>(right &gt; lo &amp;&amp; nums[right] &gt;= nums[lo]) --right;<br>            <br>            <span class="hljs-keyword">if</span>(left &gt;= right) <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-built_in">swap</span>(nums[left],nums[right]);<br>        &#125;<br><br>        <span class="hljs-built_in">swap</span>(nums[lo],nums[right]);<span class="hljs-comment">//将基准归位</span><br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按照快排的策略，每次对一个基准点进行归位。一直归位到这个基准点的后面有k-1个元素，那么这个基准点就是第k大值所在的位置。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>域名解析教程</title>
    <link href="/2021/04/10/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Godaddy%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2021/04/10/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Godaddy%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在开始之前，需要一个域名和VPS。一开始我选择的是狗爹域名和腾讯云VPS。结果到后面网站需要备案的时候麻烦来了：国外域名注册商提供的域名无法在国内进行备案(将域名从狗爹转入到国内的域名注册商后就可以备案了)…一开始我买狗爹的域名是想绑定在搬瓦工VPS上，后面感觉在大多数的使用情况下使用国内的VPS，响应会比较快，就用了腾讯云。然后配置的时候一路通行，到备案的时候给卡住了…所以个人建议：</p><ol><li>如果你是做类似于外贸的网站，或是用的国外VPS，建议在国外域名注册商那儿注册域名。而且听说国外建站无需备案</li><li>如果只是做个人网站，而且在国内访问比较频繁的话，直接选择国内VPS+国内域名注册商，方便省心。</li></ol><p>本文也是写到备案这块发现了这个问题，所以后面干脆在腾讯云又买了个域名。感觉腾讯云会比狗爹便宜许多，墙裂推荐</p><p>虽然本文具体写的是<strong>Godaddy域名绑定到腾讯云服务器</strong>，但是除了Godaddy官网操作的那部分不一样之外，其他注册商购买的域名(比如腾讯云、阿里云)绑定到腾讯云的操作其实是一样的，直接看”<strong>2.2 添加解析</strong>“就好</p><hr><hr><h2 id="2-Godaddy域名绑定到腾讯云服务器"><a href="#2-Godaddy域名绑定到腾讯云服务器" class="headerlink" title="2. Godaddy域名绑定到腾讯云服务器"></a>2. Godaddy域名绑定到腾讯云服务器</h2><h3 id="2-1-DNS地址设置"><a href="#2-1-DNS地址设置" class="headerlink" title="2.1 DNS地址设置"></a>2.1 DNS地址设置</h3><p>进入腾讯云的DNS解析页面</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410170812.png" alt="进入设置页面"></p><p>进入DNSPod控制台</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410171019.png" alt="进入DNSPod控制台"></p><p>添加域名</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410171154.png" alt="添加域名"></p><p>此时会显示DNS不正确</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410171303.png" alt="DNS不正确"></p><p>鼠标移动到状态上面，此时会显示</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410171449.png" alt="查看详情1"></p><p>点击查看详情</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410171616.png" alt="查看详情2"></p><p>记住腾讯云提供的两个DNS服务器地址，然后打开<a href="https://dcc.godaddy.com/">Godaddy</a>，登录后点击需要修改DNS的域名，进入该域名的管理界面</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410171918.png" alt="点击域名"></p><p>进入页面后，拉至网页的最下方，找到<strong>Manage DNS</strong>，并点击进入下一个界面</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410172049.png" alt="点击Manage DNS"></p><p>进入页面后，找到<strong>Nameservers</strong>的<em>*Changes</em>，并点击进入下一个界面</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410172522.png" alt="Change"></p><p>接着点击<strong>Enter my own nameservers (advanced)</strong>进入下一个界面</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410172707.png" alt="Enter my own nameservers (advanced)"></p><p>在输入框输入刚才腾讯云提供的两个DNS地址，然后点击Save</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410173004.png" alt="输入地址并保存"></p><p>此时会跳出一个提示框，要是没什么问题直接勾选并继续即可</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410173117.png" alt="勾选并继续"></p><p>此时会发一个密码到你注册狗爹时使用的邮箱，点击发送密码</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410173326.png" alt="发送密码"></p><p>输入邮箱收到的密码，点击验证</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410173439.png" alt="输入密码并验证"></p><p>等待一会，在出现的页面中找到Nmaeservers，看看两个Nameserver是不是我们刚才更改的地址，如果是的话就可以</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410173614.png" alt="修改成功"></p><p>返回腾讯云，等待一段时间后点击重新验证。我这里是修改完DNS地址后直接重新验证就可以了</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410173839.png" alt="重新验证"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410173932.png" alt="验证结果"></p><hr><h3 id="2-2-添加解析"><a href="#2-2-添加解析" class="headerlink" title="2.2 添加解析"></a>2.2 添加解析</h3><p>在<strong>DNSPOD</strong>点击待解析的域名</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410194832.png" alt="待解析域名"></p><p>点击<strong>添加第一条记录</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410200036.png" alt="添加第一条记录"></p><p>根据自己的需要，按照提示填写，然后点击<strong>确认</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410200129.png" alt="按照提示填写"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410200321.png" alt=""></p><p>至此已经完成了，在浏览器中输入域名也可顺利的访问。但是由于我们的网站还未备案，所以没过一会就会出现让你备案的网页。想要好好的用，就老老实实的备案吧(备案之前需要先将域名从狗爹转入国内域名注册商)</p><hr><hr><h2 id="错误及问题记录"><a href="#错误及问题记录" class="headerlink" title="错误及问题记录"></a>错误及问题记录</h2><h3 id="1-DNS-PROBE-FINISHED-NXDOMAIN"><a href="#1-DNS-PROBE-FINISHED-NXDOMAIN" class="headerlink" title="1. DNS_PROBE_FINISHED_NXDOMAIN"></a>1. DNS_PROBE_FINISHED_NXDOMAIN</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410200903.png" alt="DNS_PROBE_FINISHED_NXDOMAIN"></p><p>这个问题是在我刚在宝塔面板给网站添加域名后访问出现的，然后等了大概两三分钟再打开就没问题了。</p><h3 id="2-This-Web-page-is-parked-FREE-courtesy-of-GoDaddy-未解决"><a href="#2-This-Web-page-is-parked-FREE-courtesy-of-GoDaddy-未解决" class="headerlink" title="2. This Web page is parked FREE, courtesy of GoDaddy.(未解决)"></a>2. This Web page is parked FREE, courtesy of GoDaddy.(未解决)</h3><p>当我满怀期待地在地址栏输入我的域名并回车后，结果眼前出现了一个神秘男子</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410201653.png" alt="神秘男子"></p><p>但是我从宝塔面板点击我的域名，网页却正常的显示</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410210330.png" alt="正常显示"></p><p>而我用另一台设备打开这个网页的时候，也是能正常的显示原本的内容。</p><p>后面猜想了一下，应该跟DNS服务器有关</p><p>这个是没法正常打开网页的设备的DNS服务器地址</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410210543.png" alt="DNS服务器"></p><p>这个是能够正常打开的设备的DNS服务器地址</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410210833.png" alt="另一台设备"></p><p>个人认为，可能因为是我刚在腾讯云添加了DNS解析，而一些DNS服务器的解析记录还没有更新，所以才会导致出现这种情况。</p><p>至于为什么在同一台机子上，直接用浏览器打开和用宝塔面板进入会出现两种情况，我想了一下，应该是因为宝塔面板是安装在我域名解析的那台服务器上。也就是说当我从宝塔面板进入时，宝塔面板把”<strong>自己</strong>“返回给了我让我进入，而没有经过域名解析…怪我才疏学浅，目前能想到的原因只有这个</p><hr><h3 id="3-该网站未根据工信部相关法律规则进行备案"><a href="#3-该网站未根据工信部相关法律规则进行备案" class="headerlink" title="3. 该网站未根据工信部相关法律规则进行备案"></a>3. 该网站未根据工信部相关法律规则进行备案</h3><p>网站多访问几次以后，出现了以下页面</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410202119.png" alt="网站未备案"></p><p>没有解决方法，在国内还是老老实实备案吧</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210410202344.png" alt="开始备案"></p><p>注意，Godaddy购买的域名在国内是无法进行备案的。如果一定要备案，需要把域名从狗爹转到国内的域名注册商。</p><hr><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://segmentfault.com/q/1010000002309400#">一个注册域名能分配多少子域名?</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>建站</category>
      
    </categories>
    
    
    <tags>
      
      <tag>godaddy</tag>
      
      <tag>腾讯云</tag>
      
      <tag>vps</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>135. 分发糖果</title>
    <link href="/2021/04/02/LeetCode/135.%20%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/"/>
    <url>/2021/04/02/LeetCode/135.%20%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/candy/">本题链接</a></p><h2 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;<br><br>        <span class="hljs-comment">//异常情况</span><br>        <span class="hljs-keyword">if</span>(ratings.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> ratings.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-comment">//预处理</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">( ratings.size(), <span class="hljs-number">1</span> )</span></span>;<br><br>        <span class="hljs-comment">//只处理上升区间</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; ratings.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(ratings[i+<span class="hljs-number">1</span>]&gt;ratings[i]) res[i+<span class="hljs-number">1</span>] = res[i] + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//处理下降区间</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = ratings.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span> ; i--)<br>        &#123;<br>            <span class="hljs-keyword">if</span>( ratings[i] &gt; ratings[i+<span class="hljs-number">1</span>] ) <br>            &#123;   <br>                res[i] = <span class="hljs-built_in">max</span>(res[i],res[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.<span class="hljs-built_in">size</span>(); i++) cnt += res[i];<br>        <span class="hljs-keyword">return</span> cnt;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题实际上分递增递减区间两种情况讨论，只要先完成递增区间即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>338. 比特位计数</title>
    <link href="/2021/03/29/LeetCode/338.%20%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/"/>
    <url>/2021/03/29/LeetCode/338.%20%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/counting-bits/">本题链接</a></p><h2 id="位运算-动态规划"><a href="#位运算-动态规划" class="headerlink" title="位运算+动态规划"></a>位运算+动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;++i)&#123;<br><br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//如果是偶数</span><br>                dp[i] = dp[i/<span class="hljs-number">2</span>];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果是奇数</span><br>                dp[i] = dp[i/<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于偶数，一个数乘2等同于它左移一位，比特位的1的个数不变。</p><p>对于奇数，等于比他小的第一个偶数再加上1。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>692. 前K个高频单词</title>
    <link href="/2021/03/28/LeetCode/692.%20%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D/"/>
    <url>/2021/03/28/LeetCode/692.%20%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/top-k-frequent-words/">本题链接</a></p><h2 id="哈希表-优先级队列"><a href="#哈希表-优先级队列" class="headerlink" title="哈希表+优先级队列"></a>哈希表+优先级队列</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">using</span> elem = pair&lt;string,<span class="hljs-keyword">int</span>&gt;;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span>&#123;</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> elem&amp; e1,<span class="hljs-keyword">const</span> elem&amp; e2)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(e1.second == e2.second)&#123;<span class="hljs-comment">//如果字符串的出现频率相同</span><br>                <span class="hljs-keyword">return</span> e1.first &lt; e2.first;<span class="hljs-comment">//字符序小的在前</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> e1.second &gt; e2.second;<br>        &#125;<br>    &#125;;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;string&gt;&amp; words, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        unordered_map&lt;string,<span class="hljs-keyword">int</span>&gt; hash;<br>        <span class="hljs-comment">//放入unordered_map中去重</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> string&amp; s : words)&#123;<br>            ++hash[s];<br>        &#125;<br><br>        priority_queue&lt;elem, vector&lt;elem&gt;,cmp&gt; heap;<span class="hljs-comment">//小顶堆</span><br>        <span class="hljs-comment">//放到堆里</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; [str,cnt] : hash)&#123;<br>            heap.<span class="hljs-built_in">emplace</span>(str,cnt);<br>            <span class="hljs-keyword">if</span>(heap.<span class="hljs-built_in">size</span>() &gt; k) heap.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//如果堆中元素大于K,就剔除堆顶元素</span><br>        &#125;<br><br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">res</span><span class="hljs-params">(heap.size(),<span class="hljs-string">&quot;&quot;</span>)</span></span>;<br>        <span class="hljs-comment">//从堆中取出元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = k - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;--i)&#123;<br>            res[i] = heap.<span class="hljs-built_in">top</span>().first;<br>            heap.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>       <br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先让数组中的所有元素放入哈希表统计次数，然后将哈希表的元素按照题目要求的顺序放入小顶堆里，让堆保持每时每刻都是最大的k个元素，最后再将堆中的元素放到结果数组中返回即可。</p><blockquote><ul><li><p>时间复杂度：$O(l \times n + m \times l \log k)$​，其中 n 表示给定字符串序列的长度，m 表示实际字符串种类数，l 表示字符串的平均长度。我们需要 $l×n$​ 的时间将字符串插入到哈希表中，以及每次插入元素到优先队列中都需要 $l*logk$​ 的时间，共需要插入 m 次。</p></li><li><p>空间复杂度：$O(l×(m+k))$，其中 ll表示字符串的平均长度，m 表示实际字符串种类数。哈希表空间占用为 $O(l×m)$，优先队列空间占用为 $O(l×k)$。</p></li></ul><p>来自：LeetCode-Solution</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>优先级队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建wordpress</title>
    <link href="/2021/03/26/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BAWordPress/"/>
    <url>/2021/03/26/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%90%AD%E5%BB%BAWordPress/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-VPS"><a href="#1-VPS" class="headerlink" title="1.VPS"></a>1.VPS</h2><p>搭建WordPress需要一个VPS，对于VPS这部分就不详细描述了，毕竟作为程序员都会有一两个vps吧。</p><h2 id="2-宝塔面板"><a href="#2-宝塔面板" class="headerlink" title="2.宝塔面板"></a>2.宝塔面板</h2><p>使用宝塔面板会比较方便管理VPS</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323115100.png" alt="宝塔面板"></p><p>Linux下安装宝塔面板只需要一句话</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh<br></code></pre></div></td></tr></table></figure><p>如果是国内云服务商提供的VPS（腾讯云、阿里云、华为云等），需要先开端口：<a href="https://www.bt.cn/bbs/thread-19376-1-1.html">https://www.bt.cn/bbs/thread-19376-1-1.html</a></p><p>安装完成后，使用<code>bt</code>命令查看登录方式</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323125207.png" alt="查看宝塔信息"></p><p>在浏览器地址栏输入<strong>外网面板地址</strong>，然后在登录页面输入<strong>username</strong>和<strong>password</strong>即可进入宝塔面板</p><p>这里先讲一下宝塔面板的两个功能：</p><ol><li>安全</li><li>软件商店</li></ol><p>安全用来放行端口，只有在这里把端口放行了，外网才能使用这个端口</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323130008.png" alt="端口放心"></p><p>软件商店用来安装一些环境，这边推荐安装以下内容：</p><ul><li>Nginx 1.18.0</li><li>MySQL 5.7.33</li><li>PHP-7.4</li><li>Pure-Ftpd 1.0.49</li><li>phpMyAdmin 4.4</li></ul><p>其中包括<strong>wordpress</strong>需要用到的环境，还有一些方便管理的工具，安装步骤如下：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323125634.png" alt="软件商店"></p><p>选择编译安装</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323130341.png" alt="选择编译安装"></p><h2 id="3-wordpress"><a href="#3-wordpress" class="headerlink" title="3.wordpress"></a>3.wordpress</h2><h3 id="3-1-wordpress下载"><a href="#3-1-wordpress下载" class="headerlink" title="3.1 wordpress下载"></a>3.1 wordpress下载</h3><ul><li>中文版：<a href="https://cn.wordpress.org/latest-zh_CN.zip">https://cn.wordpress.org/latest-zh_CN.zip</a></li><li>英文版：<a href="https://wordpress.org/latest.zip">https://wordpress.org/latest.zip</a></li></ul><p>复制上面的连接，然后打开宝塔面板中的<strong>文件</strong>，进入<strong>/www/wwwroot</strong>目录，选择<strong>远程下载</strong>，把刚才复制的链接填到<strong>URL地址</strong>中并确认</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323131605.png" alt="远程下载"></p><p>等待下载</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323131742.png" alt="等待下载"></p><p>下载完成后解压文件</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323131900.png" alt="解压1"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323131938.png" alt="解压2"></p><p>解压完成</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323132025.png" alt="解压完成"></p><h3 id="3-2-wordpress数据库创建"><a href="#3-2-wordpress数据库创建" class="headerlink" title="3.2 wordpress数据库创建"></a>3.2 wordpress数据库创建</h3><p>打开宝塔面板的<strong>网站</strong>，点击添加站点，输入域名(如果没有域名，可以用VPS的外网IP代替)，然后根目录选择我们刚才解压的文件，接着提交即可。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323132906.png" alt="添加网站"></p><p>接下来配置数据库，打开宝塔面板的<strong>数据库</strong>，点击<strong>添加数据库</strong>，输入<strong>数据库名</strong>、<strong>用户名</strong>、<strong>密码</strong>，这三条信息需要记住，后面会用到。然后提交即可</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323133242.png" alt="创建数据库"></p><h3 id="3-3-wordpress数据库配置"><a href="#3-3-wordpress数据库配置" class="headerlink" title="3.3 wordpress数据库配置"></a>3.3 wordpress数据库配置</h3><p>进入宝塔面板的网站，点击刚才我们创建网站的根目录</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323141336.png" alt="点击根目录"></p><p>找到<strong>wp-config-sample.php</strong>这个文件，点击<strong>编辑</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323141443.png" alt="编辑文件"></p><p>找到图中所示，填入刚才我们数据库创建时的<strong>数据库名</strong>、<strong>用户名</strong>、<strong>密码</strong>，并保存</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323141638.png" alt="编辑前"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323141757.png" alt="编辑后"></p><p>然后重命名<strong>wp-config-sample.php</strong>为<strong>wp-config.php</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323141914.png" alt="重命名1"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323141937.png" alt="重命名2"></p><h3 id="3-4-wordpress的安装"><a href="#3-4-wordpress的安装" class="headerlink" title="3.4 wordpress的安装"></a>3.4 wordpress的安装</h3><p>在浏览器地址栏中输入：<strong><a href="http://域名/wp-admin">http://域名/wp-admin</a></strong>，如果前面配置成功的话，会出现以下页面：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323142211.png" alt="wordpress安装页面"></p><p>填入信息后点击安装，安装成功如下：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323142326.png" alt="安装成功"></p><p>点击登录</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323142415.png" alt="登录"></p><p>登录成功后进入wordpress的后台管理界面</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323142518.png" alt="后台管理界面"></p><p>至此，wordpress安装成功</p>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wordpress</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web版SSH搭建</title>
    <link href="/2021/03/23/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/web%E7%89%88SSH%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/03/23/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/web%E7%89%88SSH%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>目前web版的SSH很多，但是走的都是别人的服务器，会比较不安全。正好最近看到了<strong>Sshwifty</strong>，可以部署到自己的服务器并用外网访问</p><p><a href="https://github.com/nirui/sshwifty">Sshwifty项目地址</a></p><hr><h2 id="2-Sshwifty"><a href="#2-Sshwifty" class="headerlink" title="2. Sshwifty"></a>2. Sshwifty</h2><h3 id="2-1-安装Sshwifty"><a href="#2-1-安装Sshwifty" class="headerlink" title="2.1 安装Sshwifty"></a>2.1 安装Sshwifty</h3><p>使用docker安装（没安装docker的先安装docker）：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker run --detach \<br>  --restart always \<br>  --publish 8182:8182 \<br>  --name sshwifty \<br>  niruix/sshwifty:latest<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323162439.png" alt="安装成功"></p><hr><h3 id="2-2-安装证书"><a href="#2-2-安装证书" class="headerlink" title="2.2 安装证书"></a>2.2 安装证书</h3><p>先<code>docker ps</code>查看一下Sshwifty有没有在运行，如果出现下图说明有在运行，我们需要先停止Sshwifty</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323165435.png" alt="在运行"></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker stop CONTAINER ID<br>docker rm CONTAINER ID<br></code></pre></div></td></tr></table></figure><p>然后再安装证书<br><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">openssl req -newkey rsa:4096 -nodes -keyout domain.key -x509 -days 90 -out domain.crt<br></code></pre></div></td></tr></table></figure></p><p>输入信息，随便填写即可</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323163708.png" alt="ssl"></p><p>接着执行</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker run --detach \<br>  --restart always \<br>  --publish 8182:8182 \<br>  --env SSHWIFTY_DOCKER_TLSCERT=&quot;$(cat domain.crt)&quot; \<br>  --env SSHWIFTY_DOCKER_TLSCERTKEY=&quot;$(cat domain.key)&quot; \<br>  --name sshwifty \<br>  niruix/sshwifty:latest<br></code></pre></div></td></tr></table></figure><h3 id="2-3-使用Sshwifty"><a href="#2-3-使用Sshwifty" class="headerlink" title="2.3 使用Sshwifty"></a>2.3 使用Sshwifty</h3><p>浏览器地址栏输入：<strong>服务器IP地址:8182</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-03-23_16-57-04.png" alt="等待"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323170246.png" alt="使用1"></p><p>点击左上角的加号添加</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323170449.png" alt="添加"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323170535.png" alt="IDO"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323170559.png" alt="输入密码"></p><h2 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h2><h3 id="1-Unable-to-initialize-client-application-TypeError-Cannot-read-property-‘importKey’-of-undefined"><a href="#1-Unable-to-initialize-client-application-TypeError-Cannot-read-property-‘importKey’-of-undefined" class="headerlink" title="1.  Unable to initialize client application: TypeError: Cannot read property ‘importKey’ of undefined"></a>1.  Unable to initialize client application: TypeError: Cannot read property ‘importKey’ of undefined</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323163039.png" alt="错误1"></p><p>在访问地址前加上<strong>https</strong>即可</p><h3 id="2-ssh-handshake-failed-ssh-unable-to-authenticate-attempted-methods-none-password-no-supported-methods-remain"><a href="#2-ssh-handshake-failed-ssh-unable-to-authenticate-attempted-methods-none-password-no-supported-methods-remain" class="headerlink" title="2. ssh: handshake failed: ssh: unable to authenticate, attempted methods [none password], no supported methods remain"></a>2. ssh: handshake failed: ssh: unable to authenticate, attempted methods [none password], no supported methods remain</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210323171046.png" alt="错误2"></p>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>242. 有效的字母异位词</title>
    <link href="/2021/03/22/LeetCode/242.%20%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
    <url>/2021/03/22/LeetCode/242.%20%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/valid-anagram/">本题链接</a></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() != t.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">int</span> arr[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-comment">//memset(arr,0,sizeof(arr));</span><br>        <br>        <span class="hljs-comment">//同时遍历两个数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();++i)&#123;<br>            ++arr[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            --arr[t[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br><br>        <span class="hljs-comment">//遍历结果</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">26</span>;++i)<br>            <span class="hljs-keyword">if</span>(arr[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果有非0出现,说明两个字符串中出现的字符数量不对等</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>该题主要是统计两个字符串中字母出现的频次，也可以用哈希表进行对比。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>540. 有序数组中的单一元素</title>
    <link href="/2021/03/21/LeetCode/540.%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0/"/>
    <url>/2021/03/21/LeetCode/540.%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">本题链接</a></p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNonDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span> , right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> mid;<br><br>        <span class="hljs-comment">//总是保持l和r之间为奇数个元素</span><br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <br>            mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">//如果left和mid之间为偶数个</span><br>            <span class="hljs-keyword">if</span>((mid - left) % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<br><br>                <span class="hljs-keyword">if</span>( nums[mid] ==  nums[mid + <span class="hljs-number">1</span>]) right = mid - <span class="hljs-number">1</span>;<span class="hljs-comment">//说明这个数在left与mid之间</span><br>                <span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//说明这个数在mid与right之间</span><br><br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果left和mid之间为奇数个</span><br><br>                <span class="hljs-keyword">if</span>( nums[mid] ==  nums[mid + <span class="hljs-number">1</span>]) left = mid;<span class="hljs-comment">//说明这个数在mid与right之间</span><br>                <span class="hljs-keyword">else</span>  right = mid;<span class="hljs-comment">//说明这个数在left与mid之间</span><br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums[left];<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>观察题目给的例子发现，只要这个唯一数存在于某个区间内，那么这个区间的元素个数一定为奇数个。那么只要通过二分查找把区间保持在奇数个即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>128. 最长连续序列</title>
    <link href="/2021/03/19/LeetCode/128.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
    <url>/2021/03/19/LeetCode/128.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">本题链接</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        unordered_set&lt;<span class="hljs-keyword">int</span>&gt; us;<br>        <span class="hljs-comment">//将数字存入哈希表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)<br>            us.<span class="hljs-built_in">insert</span>(nums[i]);<br>        <br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!us.<span class="hljs-built_in">empty</span>())&#123;<br><br>            <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//往前找</span><br>            <span class="hljs-keyword">int</span> cur = *(us.<span class="hljs-built_in">begin</span>());<br>            <span class="hljs-keyword">while</span>(us.<span class="hljs-built_in">find</span>(++cur) != us.<span class="hljs-built_in">end</span>())&#123;<br>                ++count;<br>                us.<span class="hljs-built_in">erase</span>(cur);<br>            &#125;<br>            <span class="hljs-comment">//往后找</span><br>            cur = *(us.<span class="hljs-built_in">begin</span>());<br>            <span class="hljs-keyword">while</span>(us.<span class="hljs-built_in">find</span>(--cur) != us.<span class="hljs-built_in">end</span>())&#123;<br>                ++count;<br>                us.<span class="hljs-built_in">erase</span>(cur);<br>            &#125;<br><br>            us.<span class="hljs-built_in">erase</span>(*(us.<span class="hljs-built_in">begin</span>()));<span class="hljs-comment">//删除自己</span><br>            res = <span class="hljs-built_in">max</span>(res,count);<span class="hljs-comment">//取最大值</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先将数组的值放入哈希表中，然后每次取出哈希表的第一个值，在哈希表中找这个值的之前和之后的数累计数量即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用搬瓦工实现科学上网</title>
    <link href="/2021/03/17/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E5%88%A9%E7%94%A8%E6%90%AC%E7%93%A6%E5%B7%A5%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <url>/2021/03/17/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E5%88%A9%E7%94%A8%E6%90%AC%E7%93%A6%E5%B7%A5%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="43687de479ec18220430f70d0b811df88430cea4dd77fb7c39e0a5d4c90c26a4">3872edc3adb321ce81613cfb0f45e53125b2a4b5907373760ad83eaad0a594f7f22e4107be05f7ef5b34119115e882c8aaf137c7414efc7bd4d445ac6f211f404e717142a9e3215b442d9f23ba3ef9202f7b83d0ac0763d6c603ed4e5d0f9d87f47046e61945aed37cc854817ffd6c9b6df4e4c36c0817fd90393db41eaa12c680e78e611ac4e8849cad31174a531c76fc229ada7293b94590455cd151197783e5c882761f9616c7fdef73ee8b090ac5b1d55edca615c4f0e2fca20b85977de09a8d9e5c1164ab13fdccf9163a2cb98b777a1ccfa0bc845a5c117e9b6e480bc4f93145e0d85097c55ba729c044625bad14ccf064e3feabf5933d133eeace87630dbf83219730a32363cd58f3e96710b9677f45ca41dc76c2ec5d0e26ec0614a7342c91f47bc150ff84c23b6fb7f70a8cd446f03db5e0a1e5a236460c6cb8011449705cf4f57671554622c97cb4e724b329713fac9158c6287908550fbb0da908f1a234e9b51a13771539075e8d29ff286872a74a6b61fc85cc3f0be1bbc66ae86f1459164ec3983abf7f3b38b7ed7365c44e99e1d86b186ed1e52132707bc35c46d163025d9cbe704fdf01c5ca8fedb5596c89d2b138567c236ff0fd8e68eb79b57425871082ab423c407311010a325344d42f8721314a516d7ce53a032e41b6b25fe9dce717366b37ac077f0756b4159c15efabfea6e81986f84aedf97d01a4add989678fc727a42d19bdfd1b12e7a60910e1f4b93049de4d71fb9c62b125de61b6bc168901c48f58bbacaf6077e9c7756e87feeec53f9b5e0ce6ea5580a7ae4b1918744392fcfcd93eeb0fbc32fba88debc33ab815877a35a97f328e58c5fa35892a491ce90cc0bcc593ff9b9d5ba2f667829936528fa0bb0e39904148acdf9acf3f1dd34fb4dad33c9a0bd3f978c7673e73d817421cc05bae0f9ba7b155c7676b292424582b7029332ff147d9ca392a42b4e63da0c8b9a6ff319338ec7dfe22e6e48385abc03be00dd0423ddbe05eb16ee0a26fbca122b38e63d96a63cc2506ab4953cabd1e0e57af17b562b09086c7dd2bc5b063eb21badf612eae192f28b01a12db5b16364a3b4cae4e5451eb3b2d0fac401eceec97b140d1403a69d8fac18f04947b8cbf13e5c3ec3c4a639004068e845dfcb982b4d71ff82606526377890b21473d08ed433bdb1db1e82dda189791850e76661f09a340e6c1f3f3d38d639e0d7096f71abcf00c6a6b3a936a08bd3c657a554e89d5d71f1e5671464c25a3b87818d3c31f51e56ed22823e87e97e6590023e858ea7c8c7e1b87c17d3360561e6e1e6c0eba8ba3859f5a1a7d5cffa5e0581c93cef6df7980f140774e963a46d25e0f55e38d1a20854cf337ee274c14c2c685c22dc7f3f009c7d062a375a274380771df0920d3ea057bcaaf8e2613b4e52e4ac2411e84fa35954e43ddb4f81a8532158dccae92142b993345a47274b1eb4c3e312f867108c2f1fbac463db9b4ffa2d745fa4425edf432f0ea121452da341e2ca5ba542e358bbd666c5ce31342b5190a2c143ea494d30d20b1f11185f3df15b088382267dcc6ec4732a4b4f524cf71c03425738e1f4375a8886f7e8fd9d23a66d6f0b616fb05ab815b4916f514f06785c2c9691e327c8e5960314ddc9451d54119cd6e70c859bcffb1ca8fc716d09e4ab42b83dc359225ed7a073d4be7a8e4f02b4fad6c2b513c56f7ff8f3c50ac58c150209b29ffc80aa4b1c002bd9d1d41ea71569f652adfaa906b6bb530888ebf58fc584f11725b3c2e00022183d959a0e3d87e6ce6362dd72e530e5e40550aae2e7499e8c6d3f705b0bcdc4f86e89f8fab894dcc19308eb26245ceae80065f242a752d851d2710b21d520f3f56f585b342a0206ccb05b2c81ded53a96bb82271a3ecfc6e935b52572eb6ce70d7429bf6cc1f3fab6e3a0804cd3acf0d08a2bbd4fcaf31b2ff1c9ff25c6db6d6b070e52235c7cc6f351224ff7d6775fe8f489bcd96032bd0373099ce90d8584caadcb858b32c509f1afc70881afa526c7cf0b95eeb17aed70f8b657620ab3fa2da15c496a5bfca2b8803538ce0189f8db01d099995eb4391c9a2a8259cdc84a3fc7750f4089ec36d5d76db9ea6e732c3cefff59848f7e913bbd3d8e9b1ba9d6d158dcb4e0b88dbce5474191b758cfd0ef0b48a6594a68ce6cd7b6919eab34b1a85f0bcb3e0525c982410cb7c92314a34574a777b6253072af2e9877fd88b8aa11d3eef79d963ef199fcdd18b17336038b10eb6d298acdbfdc6cacdf2d6573925867ef0ecf6cfed4b1c59775258d0f59ef585b738ff49e979e6dfeda3f39be43312f79f06f715ecee0f7e4393e4ceff80fcd2097711e59aee2396c98ed0cb2f93ab081749bf2f49e32654ee145ba833c370700727814d1dba96884c4fa7a691bc1c08aeea2c644600f53b5e4dbe2f3e4c35c4123cb969813eebca0f1020740e717686ff2c54792e93391f38862d46867a3151a5dafd3d9ab8cea43fd81c59279e003b50e031cfe7c388fe23be70f75d35f23edbfe5bc86cb2e0d5eeccb89446588bcf9c93f118be0ca913692525980aa8da154baa0f97e36d3572b9b60d3e2596d46727b49d083ad880919c53bce624c9ef24df07bfc12b9a331903c860214c12afdf59fcdfa228e507b3ce7adcb9f383cb3137b76a83dc614d084eaf0ff721f6eb8581df90ff134e3c555fd93b20eb852eaebb0900e9767f6e3a25a21d7f0aba6f8e38b35af3c926f9866f686bf8a03291af27505e9ffa1a260acd52b2808faa5a8f212c69750aa7a42690335ac51c6c3f53f0f08d3971f4b1f2610414bb5a821c5bd72ecf0d5299661fbd0c4f8362781ddaffdb1e47495f9d91303639af6e000ebb093325dfe5527723c3379eb0f113647bad1a6d651fbfb2637eda2c4f9ed657ac48d1db421f41a13bd4ed981679fb9f0010941e239d31ca7d43134d321302de37abacdc04041738c820410c2e7445b7bec6a3e84c44da83dbefd93e4c8ba2ccf410ecd130964ccc9eb22e19b0a0fc81c92e394be2127687bf6e4e6ddc168c782a0fa165985ce325c3c24b96fa16fb810b45f469251c4056374351a56fac4915677e7f28767f8bc7db650500633b652de99ea1f188ca23175b92bac08fe9c529b41fc1875f62188318e9e4b6a81e5114023a666b2a570e8ea5d6c8daa1784e8fdd8a17e6eaf3f08bbe0e1964d78fffac7ebfedb0f56e5ccb9af33efbbcc7ddc1f73617447520239a8fb704e486889163337da954e232f3a169da532f4f39e160cf644355fc3bf729d538acec9287437b207efbffcc488c46ba9731e092a575c6c11d32dd7e368096d2d9ce5e5957aff154b014d0a0be82fce72075606ce1cf6395ac9a227c97cac86afae3bcc58b9069e895c0703d85310d18f5e1946abff4ee3923caf75fc2481286143d7de044060d744682a9c2d62f04c3a03a51b30793056873155bccf75941e385170979fe6054cba2150c4632a1dd033083efba349424b0846d5d87a5cff884439cec4ed39b4199d8d3e63fdd34091e71060c505239f65b30bf8e19a1ba29d8e0777b6e7c96f1b3834c0dc56bdcb054000b395038518da32eb7528699ace13770412875dcce825af60863eec09eb6b6433932e6f5b1e40dad277d5f99e38d2317ff47fd03916bf5e8ac8715dd45d4d002e4c278266b3cd0cb6eab395d3f477c6479e20781d93416a0beba34e276f2d005933906af9f224f54bec6536e47a146e798adb3a091c733c59344370542a119c2b7d27d432f3fd6c38eee3987e4e3f06741fc82327cb2de9093593daf2d31ffa6176c6dd4c96c5e17e46a95e525b7ab0ad549828f56867f7e3bb0a57882610e3c25ce7588713d7e55fbd5636f54fcfdac7c3d944e63e80fc91ab6cbba938f24e60c35ccc618f65e3fadb22d07e3b916b0e8b749c437f188475cad1393aef3b04b71368c3369fafd14ce46fb06a26f7d550d97181a971946c1a1c4f5248e57a55020752fb03debae02734578955fe3b0b0b92e995ffb51ea7336dfdd2be2686a31146683ec44c832336f510f56badbd008c270f1f01ebf11296461c3989ad5e81edfb8624cd9215927cc45a4f6cdea39b147eea46291b7e9943ec246e79bd31bfd631537a93fb6045e4745f35df90c68ed43d0590d6f21f8abdf4bb4297f97229afeacb888ab76fc874460c74a399c8ecc23a1c2de91690a571f357f3d56226f90acda62b4b7d3069ca0b46417c85fb549c31b7ca30c61cbff77ba81a7e977b0d26285bfec3182d34e79db82ed9b17d0eecb32d809db3d12e7ab3ede3482ff31a768de72b5ce7fa0114eb017fff1bd4df0fbfd283fc1026a9d7a12de123ccbaf0c9b0c58032e0dd45bd7ef6b88755f3b03f17d5030a0987d2f10b06c7689c41b2078fe3268c0ebc1c0d6fd2e9dfa43885f5569e45a38b8e96daa98d65523cc046a97d88613593ee8f3dd22fad76ed0cf73395ccbe2a61e87999547f3ccaf840773416daf142d9111442051b7798b72d24ea3ab5d75e99e47977db5c52516f94d675ef407f24cdbcc3f720694676ddbd28604c5ef04baf70ef21fa4351c42ae486059c8aaccb33817a2e794b99df9a332b10a762d4d1307ac2e0615cb69ae8a58cc5bc27ec582913eef290ca95cd87e1eca4e090ebc2fcaf2c5ce1cec39cabfe9814e393011c81fb944bf1ef73356a3aea528753d550c9a0a8e3b8f09258ed002cee16e28fe3b63661405a40605c0a9828d8f89d8ef7da820b4bac389b95a4c168af5e0aef675b806da04c569dd7e76d488b583314f677b5840b2537dbd5b1ad47809483db3dc90fe56ab762cb98b513709096ddb8bb2afa55e2c26649b8b1b1f174160b47a368e4618916676d53d170bc541182691014098fe4a6beb48f450a484bd317a2ae5feedba6a8be7c8ce32bd1786dd1c2b4bc30e781d9d36029cd191b6128a9913b7e6f4f3bb4d22a6a06c0b5bc00d70c2715cd97e02d2ccd6975a0052ed02c72e1a677a251bd64f5e3b78917a8a69d855c5f4c3db97941399caa65164c138132792d1385fc73ddf55511a56e218932b93d06c7af091831ad76efbc9835743a3dee56a58146a61eb4426f74b73105b9f7907f9f0934441abe8152ba9cccedd8b55ccdff043f60d00aa17675c72a6429d32e9aa00d92696b4aca9ff9798a441c36f7e19cdd02a9ab018bb094b4456c09221ffc4aa5ce9b0f8d798ac1e853ef097ae9a4b3a57bcc57c747e51b9d1452cb716877bd964d24b5d40703affb0115e487726d5adf5edcaab5ad235a94d9fdf07f04bd1770a9ac842baf3d7d1c62a368357a625e409e96bed6289749d5e3b1c27e9d5f50820a904f1a23720633b559f56faf18b6046f3313d3504f642c4859809dad3513bece23b4854ede34933475f674f32ba1f4262752a4722599243b2411a67c3aae8307e7724287114c34ff242e10b0c30114932256f5855a89fff695996c73f1dfab9b296ae772ec55656e11381fa2e84ed672685318750535238403d9c44bd38338019c0e810ebdf6b82ac8a2533362d35cbb736d071ec1671fd3d41a121585241d59a3ad595cec861dac32ffea9ca35aacd0ed14198bac988e84f5529e5cc98f559a38be90709947be4bd2d74040e290b752a4d0002533f4ccd43f116a30aa94650a48995bb2a1fe5b15d14f8241be99d85cd080b751ebc85987dffbf813c5507eb3c9a89f6ba55a902529401a4bbefb683cf2489af62cdf1c7729349a5e783ae3e31df21da539f3779d1a6f21f7a4d807fae7f839cbfb4e437a607df33768bcc2531ecca528b30702423c265a460fb1b9113bcd23206b64a1fd48d10fafe0ceabc25ec18ada5110383f909d0a1781f805e3a97234cb625823a64f8aa00494f23f60601db6e37c65571b897a41d0286b29f8426024ed06d76dff226a040aff018196cad486905e015291648ca77fb58fd9e084a34870e4dfa6f4c361d02848f010b186caaa8254df0d33c40ae137d0cbdad7186a3a8c0ec6bea93b0ece6061dc7e25e3409514425adfd01d5a12bc22834309d3e02a48becdf935f81d0a6e5b8bc26dce5a760c873be08637746cb1fd4733d530bb3f280946b0a1982de0448fa63bf4acd8d44bd34a7cdc5cf72f2671c92a6848dc9ac2c7aa00eef9d34819de060ed2e24d6d89ec9b1e66f50a00e4b3f77fe062bf8a21def407d32f15fd695ac0d1fcff184b62ff47699eeb67220dfef8d4c5c31e9d491d39597179c35c7be2fc6378ceafbc04495dd660d744cf184a5945687b1605a62a494b13b1905df6df89915f850851108645bee94e2d098996caa8a33c78065a0ca590bb88c17a037ca9e37bd372971a3a39e3270b0b9508d2f575f07fee112f8ba46e492ad9c7a0deb2286ef2b5fc8669f08f37493a363485927a858fc682b5ecfb455c338f3ab733c1ee90d8f77f075bd1fb2f57559b6f5f7641a213cb5947ca8b7336bc5867b92414e9da993adf53555ec6de9e483e3ade17b62db6950610a174a673164212bdcee845a94dc01b8a828ce6d1c12213d775fc8fe678353c68eb6c4d6a7f94bfece786da41d8a1761e6a0efecf45c8967bde122330492f193b8c50973a1bfcfbd126251a5318ccf2bc27c3818f3ceefb58f7504db233a08e517f088d288e34d308621fcc708c559f470e49e8c2e482e2a7f8eaa7afc98009c2b9c8558c7270f1178ec77edf8c44f83ac41ad22849c02d2b91041d1e1c918a483ff8458742b9ee31db86289c527133680979aaabcf151c72b61ed068a222d36e565c889e962d919d82d6b4c1336f8cd3580056f6093917b2a1cbb2d839b89400b86d3120a02b9bc3151c12a5175d8a2ded4646ae5732b68bb193f1f28082db325044b9868526fad41153baa4dd1a1b122f9983b764a05c08a165b93b1fe2fe2645615ffb376fc219652ba9a7a672c136e9778ccd307d22d162799a44f270e19e1ae66c60c0463f05b2b2214328751e7b216f449ef940d7c481464c1e0ba9019d65378ba9eb30461727e5666a5f0b644b9ec52066ca35996124c9f5affa70ffa55dcc05a4d5929479e1941c451f76de6f10b8f62ef8015c128f5817f2ece10d50521fd48a7748062190304a6a14943d1247b43515924ab50165b9c9f8e25c0996bb66b68b50732fd343bd36bb377fe84406b0a1e834a5f1f8812c4d1b01e1264ac5a16a2ff93510a61a07a1401403b24e28721dd0c2191ab94f2189db3344055da7bec9697182c7100e9fa47f6c3b7bf38e1f2eed63363a4fe9dcaba9061aff068979bd886a14f38774c1da640990a03ecc08e561c06f6b72b0d5b311b60117650def33b645b239fd2f21863ba0d570235ebaf4401210bc6c8fa714d9768408b8f2a08219ac29936323658e50da161253174f61a0e1478cf2073bb8270a91a97fb3cb0fc5d8a076a77958819363ad3b5b4501508cc664c0adf07069f4bc32cc9d09020d678415a64bf1c04ff8c7311e48a8f1b230ea62bc6e68af895f9bb850d8fa679c76e01a24f60495f869550add64e2c47a5905a9ab174a3277d75265053d382ae0d7e37cc22567e351c244621dfa72bbd177dc11aefd7f35171ddb121ec9c5e97830076da25d05bae10998bd35ef5b10025be2d8c5644140ce150c77715ac319fe892f072f752b62bb571e163d052db6b9a8f254b025c98ca5afa5bf6d3ea250973b969d6fb614867da8e638848c852456392399f7f083f4839a7f277572aa4df70f615bf56ee7774c29eeff387bda10843e4c7c4bd34ad623c571a6e2e7c93ad70762ae6f09f2e9d4919d344b209e93a2f9197b2d8b4142569c8fa8cdcd916ea188fc757a55980a18da66496790b1a7c0d0a4f7c769a277adfe607b316eb2d7f2bfcd388e3c425064edb76c330156918534c81528131511b6c79907e6d3a96e60636f362708933</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码以阅读这篇私密文章。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VPN</tag>
      
      <tag>搬瓦工</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>437. 路径总和 III</title>
    <link href="/2021/03/11/LeetCode/437.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III/"/>
    <url>/2021/03/11/LeetCode/437.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/path-sum-iii/">本题链接</a></p><h2 id="层次遍历-dfs"><a href="#层次遍历-dfs" class="headerlink" title="层次遍历+dfs"></a>层次遍历+dfs</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    queue&lt;TreeNode*&gt; node_tree;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> count;<br>        node_tree.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!node_tree.<span class="hljs-built_in">empty</span>())&#123;<span class="hljs-comment">//层次遍历</span><br><br>            TreeNode* node = node_tree.<span class="hljs-built_in">front</span>();<br>            <span class="hljs-keyword">if</span>(node-&gt;left) node_tree.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            <span class="hljs-keyword">if</span>(node-&gt;right) node_tree.<span class="hljs-built_in">push</span>(node-&gt;right);<br><br>            <span class="hljs-built_in">dfs</span>(node_tree.<span class="hljs-built_in">front</span>(),targetSum);<br><br>            node_tree.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-comment">//深度优先搜索</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; target)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(target == root-&gt;val) ++count;<br>        <br>        <span class="hljs-built_in">dfs</span>(root-&gt;left,target - root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right,target - root-&gt;val);<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在层次遍历中，将每个节点都视作根节点，然后向下递归找到符合条件的节点。很直观，但是太慢了。</p><h2 id="双重递归"><a href="#双重递归" class="headerlink" title="双重递归"></a>双重递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">//从这里开始的节点视为根节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; targetSum)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pathSum</span>(root-&gt;left,targetSum) + <span class="hljs-comment">//以左孩子开始</span><br>        <span class="hljs-built_in">pathSum</span>(root-&gt;right,targetSum) + <span class="hljs-comment">//以右孩子开始</span><br>        <span class="hljs-built_in">sum</span>(root,targetSum);<span class="hljs-comment">//递归自己</span><br>               <br>    &#125;<br><br>    <span class="hljs-comment">//从这里开始的节点视作参与结果统计的节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; targetSum)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">return</span> (targetSum == root-&gt;val ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>) + <span class="hljs-comment">//判断自己是否符合</span><br>            <span class="hljs-built_in">sum</span>(root-&gt;left,targetSum - root-&gt;val) + <span class="hljs-comment">//将左孩子加入结果统计</span><br>            <span class="hljs-built_in">sum</span>(root-&gt;right,targetSum - root-&gt;val); <span class="hljs-comment">//将右孩子加入结果统计</span><br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>使用双重递归，思路更加的清晰，但是复杂度依旧很高</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>层序遍历</tag>
      
      <tag>二叉树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>双重递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git常见用法</title>
    <link href="/2021/03/09/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Git/"/>
    <url>/2021/03/09/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/Git/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Git在本地环境的使用"><a href="#1-Git在本地环境的使用" class="headerlink" title="1. Git在本地环境的使用"></a>1. Git在本地环境的使用</h2><h3 id="1-1-在本地初始化一个Git仓库"><a href="#1-1-在本地初始化一个Git仓库" class="headerlink" title="1.1 在本地初始化一个Git仓库"></a>1.1 在本地初始化一个Git仓库</h3><p>在本地新建一个文件夹，用于做Git的仓库。并在该目录下创建新文件</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304170419.png" alt="新建文件夹"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304170551.png" alt="新建文件"></p><p>接着<strong>初始化</strong>这个新建的目录。在该目录下打开命令行，键入</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git init<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304170804.png" alt="初始化新建文件夹"></p><hr><h3 id="1-2-查看本地仓库的状态"><a href="#1-2-查看本地仓库的状态" class="headerlink" title="1.2 查看本地仓库的状态"></a>1.2 查看本地仓库的状态</h3><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git status<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304174055.png" alt="查看状态"></p><p>其中，”<strong>On branch master</strong>“表示本地仓库默认在<strong>master</strong>分支，”<strong>Untracked files</strong>“表示”<strong>test.markdown</strong>“这个文件还没有被跟踪，还没有提交在git仓库里。并且下面会提示你可以使用”<strong>git add</strong>“去操作你想要提交的文件。</p><p>如果该目录没有被初始化，将会出现以下结果</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304200343.png" alt="没有初始化"></p><hr><h3 id="1-3-添加文件到Git暂存区"><a href="#1-3-添加文件到Git暂存区" class="headerlink" title="1.3 添加文件到Git暂存区"></a>1.3 添加文件到Git暂存区</h3><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git add 文件名<br></code></pre></div></td></tr></table></figure><p>添加文件后可以查看一下仓库此时的状态</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304174623.png" alt="提交Git到暂存区"></p><p>“<strong>Changes to be committed</strong>“表示”<strong>test.markdown</strong>“这个文件等待被提交，当然你可以使用</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git <span class="hljs-built_in">rm</span> -<span class="hljs-literal">-cached</span><br></code></pre></div></td></tr></table></figure><p>这个命令去移除这个缓存</p><hr><h3 id="1-4-提交暂存区里的文件"><a href="#1-4-提交暂存区里的文件" class="headerlink" title="1.4 提交暂存区里的文件"></a>1.4 提交暂存区里的文件</h3><p>在我们提交之前，需要先设置自己的用户名和邮箱。这些信息会出现在所有的commit记录里。</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git config -<span class="hljs-literal">-global</span> user.name <span class="hljs-string">&quot;你的名字&quot;</span><br>git config -<span class="hljs-literal">-global</span> user.email <span class="hljs-string">&quot;你的邮箱&quot;</span><br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309213610.png" alt="设置信息"></p><p>设置完后，就可以进行提交了</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git commit <span class="hljs-literal">-m</span> <span class="hljs-string">&#x27;first commit&#x27;</span><br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304204937.png" alt="提交"></p><p>其中，” <strong>-m ‘first commit’ </strong> “表示提交的时候附加信息，跟备注类似。此时再查看一下Git的状态</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304205137.png" alt="查看状态"></p><p>为什么要先”<strong>add</strong>“再”<strong>commit</strong>“呢？首先，”<strong>git add</strong>“是先把改动添加到一个”暂存区“，可以理解为是一个缓存区域，临时保存你的改动，而”<strong>git commit</strong>“才是最后真正的提交。这样做的好处就是防止误提交。</p><hr><h3 id="1-5-查看log"><a href="#1-5-查看log" class="headerlink" title="1.5 查看log"></a>1.5 查看log</h3><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git log<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304205500.png" alt="查看log"></p><p>“<strong>git log</strong>“命令可以查看所有产生的commit记录，其中，”<strong>first commit</strong>“为1.4步骤中我们提交时添加的附加信息，我们1.4节添加的用户名和邮箱也出现在里面</p><hr><h3 id="1-6-分支的查看、添加与切换"><a href="#1-6-分支的查看、添加与切换" class="headerlink" title="1.6 分支的查看、添加与切换"></a>1.6 分支的查看、添加与切换</h3><p>branch即分支的意思。在一个项目里，两个人负责不同的模块，就创建两个分支。两个人分别在各自的分支里对代码进行的改动，互相独立，互不影响。等到最后两个人的模块都完成了，再统一把分支合并起来。</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch</span><br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304205806.png" alt="查看分支"></p><p>我们有一个默认的master分支，前面的”*”号表示master是我们当前使用的分支。注意，当我们的Git仓库没有任何提交的话，直接查看分支情况会出现什么都没有的情况。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304210053.png" alt="空branch"></p><p>添加一个分支也很简单，只需要</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git branch 分支名<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304210244.png" alt="添加分支"></p><p>新建分支的命令是基于当前所在分支的基础上进行的，即以上是基于<strong>master</strong>分支新建了一个叫做<strong>_zhong</strong>的分支，此时<strong>_zhong</strong>分支跟<strong>master</strong>分支的内容完全一 样。如果你有 A、B、C三个分支，三个分支是三位同学的，各分支内容不一样，如果你当前 是在 B 分支，如果执行新建分支命令，则新建的分支内容跟 B 分支是一样的，同理如果当前 所在是 C 分支，那就是基于 C 分支基础上新建的分支。</p><p>但是当前分支并不是新建的”_zhong”分支，所以还需要通过一条命令切换当前分支</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git checkout 分支名<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304210451.png" alt="切换分支"></p><p>还有一条命令更方便，可以直接新建分支并直接切换</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git checkout <span class="hljs-literal">-b</span> 分支名<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304210652.png" alt="直接切换"></p><hr><h3 id="1-7-分支合并与删除"><a href="#1-7-分支合并与删除" class="headerlink" title="1.7 分支合并与删除"></a>1.7 分支合并与删除</h3><p>分支合并就是字面意思，当项目需要模块集成时就需要把各个分支合并到<strong>master</strong>这个主分支里面来。</p><p>合并分支前，要确保当前的分支是<strong>master</strong>，所以第一步就是切换到<strong>master</strong>这个主分支</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git checkout master<br>git merge 分支名<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304224904.png" alt="分支合并"></p><p>既然”<strong>_zhong</strong>“这个分支已经被我们合并到主分支里面去了，此时他已经没用了，就可以把他删除掉</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git branch <span class="hljs-literal">-d</span> 分支名<br>git branch <span class="hljs-literal">-D</span> 分支名<br></code></pre></div></td></tr></table></figure><p>上面两个命令选一个就可以，区别在于”<strong>-D</strong>“为强制删除。有些时候会删除失败，因为”<strong>_zhong</strong>“分支里面的代码可能还没有合并到master，使用”<strong>-d</strong>“是删除不了的，Git会提示你”<strong>_zhong</strong>“分支里还有未合并的代码，此时使用”<strong>-D</strong>“就可以强制删除</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304230029.png" alt="删除与强制删除"></p><hr><h3 id="1-8-添加版本"><a href="#1-8-添加版本" class="headerlink" title="1.8 添加版本"></a>1.8 添加版本</h3><p>我们在客户端开发的时候经常有版本的概念，比如v1.0、v1.1之类的，不同的版本肯定对应不 同的代码，所以我一般要给我们的代码加上标签，这样假设v1.1版本出了一个新bug，但是又 不晓得v1.0是不是有这个bug，有了标签就可以顺利切换到v1.0的代码，重新打个包测试了。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210313175008.png" alt="添加版本"></p><hr><hr><h2 id="2-向Github提交代码"><a href="#2-向Github提交代码" class="headerlink" title="2. 向Github提交代码"></a>2. 向Github提交代码</h2><h3 id="2-1-基本条件"><a href="#2-1-基本条件" class="headerlink" title="2.1 基本条件"></a>2.1 基本条件</h3><ol><li>Github账号</li><li>SSH及使用SSH连接到Github</li></ol><p>这些都是最基础的东西，就不再赘述</p><hr><h3 id="2-2-关联Github仓库"><a href="#2-2-关联Github仓库" class="headerlink" title="2.2 关联Github仓库"></a>2.2 关联Github仓库</h3><p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作。</p><p>在Github创建完仓库后，记住这个仓库名。然后进入你要关联的本地仓库，打开powershell</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git remote add origin git@github.com:你的Github名称/仓库名.git<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309171818.png" alt="关联"></p><p>也可以使用以下命令，查看我们当前项目有哪些远程仓库</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git remote <span class="hljs-literal">-v</span><br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309213054.png" alt="查看仓库"></p><hr><h3 id="2-3-将本地资源更新到Github"><a href="#2-3-将本地资源更新到Github" class="headerlink" title="2.3 将本地资源更新到Github"></a>2.3 将本地资源更新到Github</h3><p>现在我要将我本地仓库的文件更新到Github上的<strong>HelloWorld</strong>这个仓库</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git push origin master<br></code></pre></div></td></tr></table></figure><p>其中，远程库的名字就是<strong>origin</strong>，这是Git默认的也是大家公认的叫法，当然你也可以自己取个名字。<strong>master</strong>指的是在本地的master分支。</p><p>所以这条命令的意思就是把<strong>本地Git仓库</strong>的<strong>master</strong>分支，推送到<strong>Github</strong>中与本地<strong>Git仓库</strong>关联的<strong>Github仓库</strong>中。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309180525.png" alt="仓库"></p><p>推送完成，这时候可以打开Github仓库查看我们推送的内容。注意，需要选择<strong>master分支</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309182850.png" alt="查看推送情况"></p><hr><h3 id="2-4-从Github更新资源到本地"><a href="#2-4-从Github更新资源到本地" class="headerlink" title="2.4 从Github更新资源到本地"></a>2.4 从Github更新资源到本地</h3><p>如果别人提交代码到远程仓库，这个时候你需要把远程仓库的最新代码拉下来，然后保证两端代码的同步</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git pull origin master<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309205925.png" alt="pull"></p><p>一般我们在<strong>push</strong>之前都会先<strong>pull</strong> ，这样不容易冲突。</p><hr><h3 id="2-5-克隆"><a href="#2-5-克隆" class="headerlink" title="2.5 克隆"></a>2.5 克隆</h3><p>克隆可以理解为高级点的复制。将一个项目从Github克隆到本地，那么该项目在本地就已经是一个Git仓库了，不需要使用<code>git init</code>进行初始化，而且都已经关联好了远程仓库，我们只需要在本地的项目目录下任意修改或者添加文件，然后进行commit，之后就可以执行<code>git pull origin master</code>等相关操作。</p><p>在克隆之前，需要获取仓库地址</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309214931.png" alt="获取仓库地址"></p><p>然后打开本地项目所在的父目录，执行</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git clone git@github.com:你的Github/仓库名.git<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309215251.png" alt="仓库克隆"></p><p>进入本地项目，我们会发现目录中有个”<strong>.git</strong>“文件，有这个文件就说明这已经是个本地的Git仓库了。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309215354.png" alt="本地项目"></p><hr><hr><h2 id="3-Git进阶与技巧"><a href="#3-Git进阶与技巧" class="headerlink" title="3. Git进阶与技巧"></a>3. Git进阶与技巧</h2><h3 id="3-1-给命令起别名"><a href="#3-1-给命令起别名" class="headerlink" title="3.1 给命令起别名"></a>3.1 给命令起别名</h3><p>“<strong>alias</strong>“这个命令类似于Python里面的<code>import tensorflow as tf</code>，作用是给命令起个别名。我们每次都输入<code>git push origin master</code>就很繁琐，要是我们给这条命令起个别名，比如<code>git psm</code>，那我们就可以直接使用<code>git psm</code>来代替<code>git push origin master</code>。</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git config -<span class="hljs-literal">-global</span> alias.别名 <span class="hljs-string">&#x27;命令&#x27;</span><br></code></pre></div></td></tr></table></figure><p>当然，别名可以根据自己的习惯来取</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210310162622.png" alt="别名"></p><p>下面是一些比较好用的命令：</p><h4 id="3-1-1-高级日志"><a href="#3-1-1-高级日志" class="headerlink" title="3.1.1 高级日志"></a>3.1.1 高级日志</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git config -<span class="hljs-literal">-global</span> alias.lg <span class="hljs-string">&quot;log --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%</span><br><span class="hljs-string">d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit --date=relative&quot;</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="3-2-给终端设置颜色"><a href="#3-2-给终端设置颜色" class="headerlink" title="3.2 给终端设置颜色"></a>3.2 给终端设置颜色</h3><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git config -<span class="hljs-literal">-global</span> color.ui true<br></code></pre></div></td></tr></table></figure><hr><h3 id="3-3-设置Git编辑器"><a href="#3-3-设置Git编辑器" class="headerlink" title="3.3 设置Git编辑器"></a>3.3 设置Git编辑器</h3><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git config -<span class="hljs-literal">-global</span> core.editor <span class="hljs-string">&quot;vim&quot;</span> <br></code></pre></div></td></tr></table></figure><p>将编辑器设置为<strong>vim</strong>，当然也可以设置为其他的，但是前提是本机有安装。</p><hr><h3 id="3-4-对比文件差异"><a href="#3-4-对比文件差异" class="headerlink" title="3.4 对比文件差异"></a>3.4 对比文件差异</h3><p>我们经常在做代码改动，但是有的时候2天前的代码了，做了哪些改动都忘记了，在提交之前需要确认下，这个时候就可以用diff来查看你到底做了哪些改动。直接输入<code>git diff</code>只能比较当前文件和暂存区文件差异。</p><p>此时往<strong>test.markdown</strong>这个文件添加一行字”<strong>fefe</strong>“，然后执行<code>git diff</code>。我们会发现终端给出的信息是<strong>绿色</strong>的”<strong>+</strong>“号，然后后面跟着”<strong>fefe</strong>“，由此我们可知绿色加号表示的是增加的内容。</p><p>接着我们继续修改这个文件。我们先删除第一次添加的”<strong>fefe</strong>“，然后敲入”<strong>新增加的行</strong>“，并再次执行<code>git diff</code>。我们会发现增加的”<strong>新增加的行</strong>“显示出来了，但是我们删除的”<strong>fefe</strong>“并没有显示。这是因为我们并没有执行<code>git add</code>将文件放入暂存区。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210313171234.png" alt="还未进入暂存区"></p><p>我们先将文件加入暂存区，然后将里面的”<strong>新增加的行</strong>“删除，接着添加”<strong>第二次新增加的行</strong>“。这次我们再<code>git diff</code>就会发现，添加和删除的改动同时给了我们提示。没错，相对应地，绿色”<strong>+</strong>“号为增加，红色”<strong>-</strong>“号为删除。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210313172009.png" alt="放入暂存区"></p><h4 id="3-4-1-比较两次提交之间的差异"><a href="#3-4-1-比较两次提交之间的差异" class="headerlink" title="3.4.1 比较两次提交之间的差异"></a>3.4.1 比较两次提交之间的差异</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git <span class="hljs-built_in">diff</span> &lt;<span class="hljs-variable">$id1</span>&gt; &lt;<span class="hljs-variable">$id2</span>&gt;<br></code></pre></div></td></tr></table></figure><h4 id="3-4-2-在两个分支之间比较"><a href="#3-4-2-在两个分支之间比较" class="headerlink" title="3.4.2 在两个分支之间比较"></a>3.4.2 在两个分支之间比较</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git <span class="hljs-built_in">diff</span> &lt;branch1&gt;..&lt;branch2&gt;<br></code></pre></div></td></tr></table></figure><h4 id="3-4-3-比较暂存区和版本库差异"><a href="#3-4-3-比较暂存区和版本库差异" class="headerlink" title="3.4.3 比较暂存区和版本库差异"></a>3.4.3 比较暂存区和版本库差异</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git <span class="hljs-built_in">diff</span> -<span class="hljs-literal">-staged</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="3-5-checkout命令的拓展"><a href="#3-5-checkout命令的拓展" class="headerlink" title="3.5 checkout命令的拓展"></a>3.5 checkout命令的拓展</h3><p>“<strong>checkout</strong>“一般用作切换分支使用，比如切换到develop分支，可以执行：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git checkout develop<br></code></pre></div></td></tr></table></figure><h4 id="3-5-1-切换tag"><a href="#3-5-1-切换tag" class="headerlink" title="3.5.1 切换tag"></a>3.5.1 切换tag</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git checkout v1.<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h4 id="3-5-2-切换到某次commit"><a href="#3-5-2-切换到某次commit" class="headerlink" title="3.5.2 切换到某次commit"></a>3.5.2 切换到某次commit</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git checkout  ffd9f2dd68f1eb21d36cee50dbdd504e95d9c8f7<br></code></pre></div></td></tr></table></figure><p>后面的一长串是<strong>commit_id</strong>，是每次<strong>commit</strong>的SHA1值，可以根据<code>git log</code>看到。</p><h4 id="3-5-3-撤销文件"><a href="#3-5-3-撤销文件" class="headerlink" title="3.5.3 撤销文件"></a>3.5.3 撤销文件</h4><p>假设我们在一个分支开发 一个小功能，刚写完一半，这时候需求变了，而且是大变化，之前写的代码完全用不了了，好在你刚写，甚至都没有 git add 进暂存区，这个时候很简单的一个操作就直接把原文件还原</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git checkout a.md<br></code></pre></div></td></tr></table></figure><p>注意：只能撤销还没有<strong>add</strong>进暂存区的文件。</p><hr><h3 id="3-6-代码的临时保存"><a href="#3-6-代码的临时保存" class="headerlink" title="3.6 代码的临时保存"></a>3.6 代码的临时保存</h3><p>设想一个场景，假设我们正在一个新的分支做新的功能，这个时候突然有一个紧急的bug需要 修复，而且修复完之后需要立即发布。当然你说我先把刚写的一点代码进行提交不就行了 么？这样理论上当然是ok的，但是这会产品垃圾<strong>commit</strong>，原则上我们每次的<strong>commit</strong>都要有<strong>实际的意义</strong>，你的代码只是刚写了一半，还没有什么实际的意义是不建议就这样commit的，那 么有没有一种比较好的办法，可以让我暂时切到别的分支，修复完bug再切回来，而且代码也 能保留的呢？</p><p>这个时候 stash 命令就大有用处了，前提是我们的代码<strong>没有</strong>进行<strong>commit</strong> ，哪怕你执行了<strong>add</strong>也没关系</p><h4 id="3-6-1-保存代码"><a href="#3-6-1-保存代码" class="headerlink" title="3.6.1 保存代码"></a>3.6.1 保存代码</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git stash<br></code></pre></div></td></tr></table></figure><p>意思就是把当前分支所有没有<strong>commit</strong>的代码先暂存起来，这个时候你再执行<code>git status</code>你会发现当前分支很干净，几乎看不到任何改动，你的代码改动也看不见了，但其实是暂存起来了。</p><h4 id="3-6-3-查询保存记录"><a href="#3-6-3-查询保存记录" class="headerlink" title="3.6.3 查询保存记录"></a>3.6.3 查询保存记录</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git stash list<br></code></pre></div></td></tr></table></figure><h4 id="3-6-4-还原代码"><a href="#3-6-4-还原代码" class="headerlink" title="3.6.4 还原代码"></a>3.6.4 还原代码</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git stash apply<br></code></pre></div></td></tr></table></figure><p>之前的代码全部又回来了，就好像一切都没发生过一样</p><h4 id="3-6-5-删除记录"><a href="#3-6-5-删除记录" class="headerlink" title="3.6.5 删除记录"></a>3.6.5 删除记录</h4><p>紧接着你最好需要把暂存区的这次<strong>stash</strong>记录删除</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git stash drop<br></code></pre></div></td></tr></table></figure><p>当然后面可以跟<strong>stash_id</strong>参数来删除指定的某条记录，不跟参数就是删除最近的</p><h4 id="3-6-6-还原并删除记录"><a href="#3-6-6-还原并删除记录" class="headerlink" title="3.6.6 还原并删除记录"></a>3.6.6 还原并删除记录</h4><p>其实还有更方便的指令</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git stash pop<br></code></pre></div></td></tr></table></figure><p>来代替<strong>apply</strong>命令，<strong>pop</strong>跟<strong>apply</strong>的唯一区别就是<strong>pop</strong>不但会帮你把代码还原，还自动帮你把这条<strong>stash</strong>记录删除，省的自己再<strong>drop</strong>一次了</p><h4 id="3-6-7-清空记录"><a href="#3-6-7-清空记录" class="headerlink" title="3.6.7 清空记录"></a>3.6.7 清空记录</h4><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git stash <span class="hljs-built_in">clear</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="3-7-另一种合并"><a href="#3-7-另一种合并" class="headerlink" title="3.7 另一种合并"></a>3.7 另一种合并</h3><p>我们知道<strong>merge</strong>是用来合并分支的命令，同时，<strong>rebase</strong>命令也是合并的意思，操作起来也和<strong>merge</strong>命令一样</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git checkout master <br>git rebase featureA<br></code></pre></div></td></tr></table></figure><p><strong>rebase</strong>跟<strong>merge</strong>的区别可以理解成有两个书架，你需要把两个书架的书整理到一起 去，第一种做法是<strong>merge</strong> ，比较粗鲁暴力，就直接腾出一块地方把另一个书架的书全部放进去，虽然暴力，但是这种做法你可以知道哪些书是来自另一个书架的；第二种做法就是<strong>rebase</strong> ，他会把两个书架的书先进行比较，按照购书的时间来给他重新排序，然后重新放置好，这样做的好处就是合并之后的书架看起来很有逻辑，但是你很难清晰的知道哪些书来自哪个书架的。 </p><p>只能说各有好处的，不同的团队根据不同的需要以及不同的习惯来选择就好。</p><hr><h3 id="3-8-解决冲突"><a href="#3-8-解决冲突" class="headerlink" title="3.8 解决冲突"></a>3.8 解决冲突</h3><p>假设这样一个场景，A和B两位同学各自开了两个分支来开发不同的功能，大部分情况下都会 尽量互不干扰的，但是有一个需求A需要改动一个基础库中的一个类的方法，不巧B这个时候 由于业务需要也改动了基础库的这个方法，因为这种情况比较特殊，A和B都认为不会对地方 造成影响，等两人各自把功能做完了，需要合并的到主分支<strong>master</strong>的时候，我们假设先合并A的分支，这个时候没问题的，之后再继续合并B的分支，这个时候想想也知道就有冲突了， 因为A和B两个人同时更改了同一个地方，Git 本身他没法判断你们两个谁更改的对，但是这个时候他会智能的提示有<strong>conflicts</strong> ，需要手动解决这个冲突之后再重新进行一次<strong>commit</strong>提交。以下是一个例子：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210313183311.png" alt="冲突例子"></p><p>以上截图里就是冲突的示例，冲突的地方由 == == 分出了上下两个部分，上部分一个叫<strong>HEAD</strong>的字样代表是我当前所在分支的代码，下半部分是一个叫<strong>baidu_activity</strong>分支的代 码，可以看到HEAD对gradle插件进行了升级，同时新增了一个插件，所以我们很容易判断哪些代码该保留，哪些代码该删除，我们只需要移除掉那些老旧代码，而且同也要把那些 &lt;&lt;&lt; HEAD、==== 以及 &gt;&gt;&gt;&gt;&gt;&gt;baidu_activity 这些标记符号也一并删除，最后进行一次 commit 就ok了。</p><p>我们在开发的过程中一般都会约定尽量大家写的代码不要彼此影响，以减少出现冲突的可 能，但是冲突总归无法避免的，我们需要了解并掌握解决冲突的方法。</p><hr><hr><h2 id="4-Git-Flow"><a href="#4-Git-Flow" class="headerlink" title="4.Git Flow"></a>4.Git Flow</h2><p><strong>Git Flow</strong>是一种比较成熟的分支管理流程，我们先看一张能清晰的描述他整个工作流程的图</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210316151643.png" alt="Git Flow"></p><p>一般开发来说，大部分情况下都会拥有两个分支<strong>master</strong>和<strong>develop</strong>，他们的职责分别是：</p><ul><li>master：永远处在即将发布(production-ready)状态</li><li>develop：最新的开发状态</li></ul><p>确切的说<strong>master</strong>、<strong>develop</strong>分支大部分情况下都会保持一致，只有在上线前的测试阶段<strong>develop</strong>比<strong>master</strong>的代码要多，一旦测试没问题，准备发布了，这时候会将<strong>develop</strong>合并到<strong>master</strong>上。 但是我们发布之后又会进行下一版本的功能开发，开发中间可能又会遇到需要紧急修复 bug ，一个功能开发完成之后突然需求变动了等情况，所以<strong>Git Flow</strong>除了以上<strong>master</strong>和<strong>develop</strong>两个主要分支以外，还提出了以下三个辅助分支：</p><ul><li>feature: 开发新功能的分支, 基于develop, 完成后merge回develop</li><li>release: 准备要发布版本的分支, 用来修复bug，基于develop，完成后merge回develop和master</li><li>hotfix: 修复master上的问题, 等不及 release 版本就必须马上上线. 基于 master, 完成后 merge 回 master 和 develop</li></ul><p>举个例子，假设我们已经有 master 和 develop 两个分支了，这个时候我们准备做一个功能 A，第一步我们要做的，就是基于 develop 分支新建个分支：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git branch feature/A<br></code></pre></div></td></tr></table></figure><p>看到了吧，其实就是一个规范，规定了所有开发的功能分支都以 feature 为前缀。 但是这个时候做着做着发现线上有一个紧急的 bug 需要修复，那赶紧停下手头的工作，立刻切换master 分支，然后再此基础上新建一个分支：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git branch hotfix/B<br></code></pre></div></td></tr></table></figure><p>代表新建了一个紧急修复分支，修复完成之后直接合并到develop和master ，然后发布。</p><p>然后再切回我们的 feature/A 分支继续着我们的开发，如果开发完了，那么合并回develop分 支，然后在develop分支属于测试环境，跟后端对接并且测试的差不多了，感觉可以发布到正式环境了，这个时候再新建一个 release 分支：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">git branch release/<span class="hljs-number">1.0</span><br></code></pre></div></td></tr></table></figure><p>这个时候所有的 api、数据等都是正式环境，然后在这个分支上进行最后的测试，发现 bug 直 接进行修改，直到测试 ok 达到了发布的标准，最后把该分支合并到 develop 和 master 然后 进行发布。</p><hr><hr><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h3 id="1-Enter-passphrase-for-key"><a href="#1-Enter-passphrase-for-key" class="headerlink" title="1. Enter passphrase for key"></a>1. Enter passphrase for key</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309182939.png" alt="需要密码"></p><p>这个问题出现在每次使用ssh连接Github都需要输入密码，所以删除掉之前的密码即可</p><figure class="highlight cmd"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmd">ssh-keygen -p<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309183534.png" alt="删除密码"></p><p>注意，”<strong>Enter file in which the key is (C:\Users\15606/.ssh/id_rsa):</strong>“这条语句后面只需按回车键。</p><p>这时候再push一下就不需要再次输入密码了</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309183847.png" alt="再次push"></p><hr><h3 id="2-“仓库名”-does-not-appear-to-be-a-git-repository"><a href="#2-“仓库名”-does-not-appear-to-be-a-git-repository" class="headerlink" title="2. “仓库名” does not appear to be a git repository"></a>2. “仓库名” does not appear to be a git repository</h3><p>这个问题是由于本地仓库和远程仓库没有进行关联，只需按照本文的2.2节进行处理。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309171953.png" alt="失败"></p><hr><h3 id="3-Access-has-been-restricted"><a href="#3-Access-has-been-restricted" class="headerlink" title="3. Access has been restricted"></a>3. Access has been restricted</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309172509.png" alt="滥用检测机制"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210309172547.png" alt="滥用2"></p><p>这个问题….不知道怎么解决</p><hr><h3 id="4-不同目录下的同名文件的提交（未解决）"><a href="#4-不同目录下的同名文件的提交（未解决）" class="headerlink" title="4.不同目录下的同名文件的提交（未解决）"></a>4.不同目录下的同名文件的提交（未解决）</h3><p>在使用CLion的Git模块时发生的错误，父目录为Learn，而子目录分别是A和B，A和B中分别有main.c这个文件。我先提交的A，后面再提交B，结果B的提交说明会覆盖掉A中main.c的提交说明。</p><p>参考：<a href="https://www.cnblogs.com/kevingrace/p/5690241.html">[Git忽略提交规则 - .gitignore配置运维总结]</a></p><hr><hr><h2 id="心得或经验"><a href="#心得或经验" class="headerlink" title="心得或经验"></a>心得或经验</h2><ol><li>每次的commit必须要有实际的意义</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《learn-github-from-zero》-作者：stormzhang，个人网站：<a href="http://stormzhang.com/">http://stormzhang.com/</a></li><li>“廖雪峰的官方网站”-作者：廖雪峰，个人网站：<a href="https://www.liaoxuefeng.com/sha">https://www.liaoxuefeng.com/sha</a></li><li>“菜鸟教程”：网站：<a href="https://www.runoob.com/git/git-tutorial.html">https://www.runoob.com/git/git-tutorial.html</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>303. 区域和检索 - 数组不可变</title>
    <link href="/2021/03/08/LeetCode/303.%20%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
    <url>/2021/03/08/LeetCode/303.%20%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">本题链接</a></p><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumArray</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NumArray</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums):<span class="hljs-built_in">res_vec</span>(nums)&#123;<br>       <span class="hljs-comment">//计算数组每个位置的总和</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>           res_vec[i] += res_vec[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; left, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; right)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> res_vec[right] - (left - <span class="hljs-number">0</span> ? res_vec[left<span class="hljs-number">-1</span>] : <span class="hljs-number">0</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res_vec;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumArray* obj = new NumArray(nums);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;sumRange(left,right);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><p>改进：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumArray</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NumArray</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums):<span class="hljs-built_in">res_vec</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;(nums.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>,<span class="hljs-number">0</span>))&#123;<br>       <span class="hljs-comment">//计算数组每个位置的前缀和</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>           res_vec[i + <span class="hljs-number">1</span>] = res_vec[i] + nums[i];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; left, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; right)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> res_vec[right+<span class="hljs-number">1</span>] - res_vec[left];<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res_vec;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumArray* obj = new NumArray(nums);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;sumRange(left,right);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于题目中的sumRange方法会大量调用，所以在sumRange中临时计算会非常耗时。所以可以事先求出数组中每个数的前缀和，在sumRange调用时返回就行。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>304. 二维区域和检索 - 矩阵不可变</title>
    <link href="/2021/03/08/LeetCode/304.%20%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
    <url>/2021/03/08/LeetCode/304.%20%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">本题链接</a></p><h2 id="积分图"><a href="#积分图" class="headerlink" title="积分图"></a>积分图</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumMatrix</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix) &#123;<br><br>        <span class="hljs-comment">//积分图初始化:在上面和左侧额外添加0,以避免额外的重复判断,空间复杂度依然为O(n)</span><br>        integral = vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;(matrix.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;(matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">1</span>;r &lt; integral.<span class="hljs-built_in">size</span>();++r)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">1</span>;c &lt; integral[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();++c)&#123;<br>                <span class="hljs-comment">//计算每个方块到[0,0]的积分</span><br>                integral[r][c] = integral[r<span class="hljs-number">-1</span>][c] + integral[r][c<span class="hljs-number">-1</span>] + matrix[r<span class="hljs-number">-1</span>][c<span class="hljs-number">-1</span>] - integral[r<span class="hljs-number">-1</span>][c<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; row1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; col1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; row2, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; col2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> integral[row2 + <span class="hljs-number">1</span>][col2 + <span class="hljs-number">1</span>] - integral[row1][col2 + <span class="hljs-number">1</span>] - integral[row2 + <span class="hljs-number">1</span>][col1] + integral[row1][col1];<br>    &#125;   <br><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; integral;<span class="hljs-comment">//积分图</span><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumMatrix object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumMatrix* obj = new NumMatrix(matrix);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;sumRegion(row1,col1,row2,col2);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在积分图中计算每个方块到$[0,0]$的积分，即当前积分=当前坐标的数字+上面长方形的数字和+左边长方形的数字和-上面长方形和左边长方形重合面积。求出某个区域的积分也是同理，只是前者求积分的逆过程。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二维数组</tag>
      
      <tag>矩阵</tag>
      
      <tag>积分图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>852. 山脉数组的峰顶索引</title>
    <link href="/2021/03/07/LeetCode/852.%20%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95/"/>
    <url>/2021/03/07/LeetCode/852.%20%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/">本题链接</a></p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">peakIndexInMountainArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>,r = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>,mid;<br><br>        <span class="hljs-keyword">while</span>((l + <span class="hljs-number">2</span>) != r)&#123;<br>            <br>            mid = (r + l)  / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(arr[mid] &gt; arr[mid - <span class="hljs-number">1</span>] &amp;&amp; arr[mid] &gt; arr[mid + <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid] &gt; arr[mid - <span class="hljs-number">1</span>] &amp;&amp; arr[mid] &lt; arr[mid + <span class="hljs-number">1</span>]) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid;<br>            <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> l + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>只要把峰值限制在左右边界之间即可</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标准归纳</title>
    <link href="/2021/03/03/C++/%E6%96%B0%E6%A0%87%E5%87%86%E5%BD%92%E7%BA%B3/"/>
    <url>/2021/03/03/C++/%E6%96%B0%E6%A0%87%E5%87%86%E5%BD%92%E7%BA%B3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Variadic-Templates"><a href="#Variadic-Templates" class="headerlink" title="Variadic Templates"></a>Variadic Templates</h2><ul><li>可以有任意多个参数数量，同时参数类型也可以是任意多个</li><li>可变参数模板可以用于递归操作。所以需要同时写一个处理最后情况，即没有参数的函数。否则编译出错。</li></ul><p>比如常见的操作有：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span>... Types&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printX</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; firstArg,<span class="hljs-keyword">const</span> Type&amp;... args)</span></span>&#123;<span class="hljs-comment">//将会被递归调用</span><br>    cout&lt;&lt;firstArg&lt;&lt;endl;<br>    <span class="hljs-keyword">sizeof</span>...(args);<span class="hljs-comment">//可以获得args的数量</span><br>    <span class="hljs-built_in">printX</span>(args...);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printX</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//这个函数必须写，否则当args的个数为0时会报错</span><br><br><span class="hljs-comment">//使用</span><br><span class="hljs-built_in">printX</span>(<span class="hljs-number">7.5</span>,<span class="hljs-string">&quot;hello&quot;</span>,bitset&lt;<span class="hljs-number">16</span>&gt;(<span class="hljs-number">377</span>),<span class="hljs-number">42</span>);<br></code></pre></div></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>tuple：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/2e28effd572df93c0a3d7d35ce0f9f9b-3954c.png"  /></p><h2 id="Initializer-list"><a href="#Initializer-list" class="headerlink" title="Initializer-list"></a>Initializer-list</h2><p>C++新标准的语法糖之一，可以接受个数不定的参数。</p><p>基本用法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i&#123;&#125;;<span class="hljs-comment">//i被初始化为0</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; vec&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-comment">//动态数组vec中有两个值0和1</span><br><span class="hljs-comment">//...</span><br></code></pre></div></td></tr></table></figure><p>它的背后支撑是 <code>initializer_list&lt;T&gt;</code>，而 <code>initializer_list&lt;T&gt;</code>里面其实就是<code>array</code>。</p><p>所以也可以使用它来作为函数的形参：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(initializer_list&lt;<span class="hljs-keyword">int</span>&gt; initlist)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : initlist)&#123;<br>        <span class="hljs-comment">//....</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="for-loop"><a href="#for-loop" class="headerlink" title="for-loop"></a>for-loop</h2><p>新标准的<strong>for-loop</strong>会被编译器解释为如下的代码：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/70b905fedc4141555829534729444a7e-7a7fd.png"  /></p><p>其中，<code>begin()</code>和 <code>end()</code>成为新标准的全局函数。</p><h3 id="错误使用"><a href="#错误使用" class="headerlink" title="错误使用"></a>错误使用</h3><p>对于以下情况，<strong>for-loop</strong>无法正常编译：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp; s)</span></span>;<span class="hljs-comment">//禁止隐式转换</span><br><span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">//...</span><br>vectot&lt;string&gt; vec;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> C&amp; elem : vec)&#123;<span class="hljs-comment">//错误！因为没有定义string转C类型的类型转换函数</span><br>cout&lt;&lt;elem&lt;&lt;endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="delete和-default"><a href="#delete和-default" class="headerlink" title="=delete和=default"></a>=delete和=default</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7b2b1face664b066dc6d68ae9abd9eee-58f42.png"  /></p><h3 id="big-five"><a href="#big-five" class="headerlink" title="big-five"></a>big-five</h3><ul><li>默认的<strong>big-five</strong>只有在需要的时候（被调用）才会被编译器合成</li><li>所有的<strong>big-five</strong>都是<code>public</code>且<code>inline</code>的</li><li>如果class没有pointer member，用默认的<strong>big-five</strong>就够了。反例：比如C++中的<code>string</code>，由于它里面的成员变量有指针，所以使用默认的big-five容易出错。另外，对于<code>string</code>类，里面有引用计数，感觉应该是为了实现写时复制读时共享。</li><li>如果一个类只允许让友元类或家族成员拷贝，那么可以把拷贝控制放到<code>private</code>里，且不能定义。在<strong>boost</strong>库中有一个类<code>noncopyable</code>，这个类就是把拷贝控制放到<code>private</code>里，而且从它派生的子类也会继承它的性质。</li></ul><h3 id="delete"><a href="#delete" class="headerlink" title="=delete"></a>=delete</h3><ul><li><code>=delete</code>可用于任何函数身上</li><li>一个比较典型的例子：为了让某类型的对象只有一份，可以把该类的拷贝构造和拷贝赋值设置为<code>=delete</code>，让使用者禁止调用拷贝构造和拷贝赋值。</li></ul><h3 id="default"><a href="#default" class="headerlink" title="=default"></a>=default</h3><ul><li><code>=default</code>只能用于<strong>big-five</strong></li></ul><h2 id="Alias-Template"><a href="#Alias-Template" class="headerlink" title="Alias Template"></a>Alias Template</h2><p>化名可以带参数，比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> Vec = std:vector&lt;T,MyAlloc&lt;T&gt;&gt;;<span class="hljs-comment">//使用自己的内存分配器代替标准库的内存分配器</span><br><br>Vec&lt;<span class="hljs-keyword">int</span>&gt; coll;<span class="hljs-comment">//别名可以含参，等同于下面</span><br>std:vector&lt;T,MyAlloc&lt;T&gt;&gt; coll;<br></code></pre></div></td></tr></table></figure><p>注意：虽然说别名可以带参数，但是无法对别名进行特化，只能对它代替的本体进行特化。</p><p>但是使用<strong>macro</strong>无法达到同样的效果：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Vec<span class="hljs-meta-string">&lt;T&gt;</span> template<span class="hljs-meta-string">&lt;typename T&gt;</span> std:vector<span class="hljs-meta-string">&lt;T,MyAlloc&lt;T&gt;</span>&gt;;<span class="hljs-comment">//如果使用宏定义</span></span><br><br><span class="hljs-comment">//对于Vec&lt;int&gt; coll;会变成如下的样子</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> <span class="hljs-keyword">int</span>&gt; std:vector&lt;<span class="hljs-keyword">int</span>,MyAlloc&lt;<span class="hljs-keyword">int</span>&gt;&gt;;<span class="hljs-comment">//不是我们想要的效果</span><br></code></pre></div></td></tr></table></figure><p>而且，使用 <code>typedef</code>也无法达到相同的效果，因为 <code>typedef</code>是不接受参数的。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>若想实现一个函数，这个函数的实参是容器+数据类型，比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">func</span>(list,string);<span class="hljs-comment">//希望该函数在内部组装成list&lt;string&gt;</span><br></code></pre></div></td></tr></table></figure><p>如果使用以下的方法不可取：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/0e3e4da418ba56a8d09599e81084e714-2c4e3.png" alt=""></p><p>解决方法1：使用模板+迭代器+萃取机制。</p><p>可以使用萃取机取出元素类型，比如：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9b118fa0855d9281180f42badcfabda8-bb430.png"  /></p><p>解决方法2：使用模板别名和模板模板参数。如下：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/269cad0f9f8e281a3c0a082393cc68c3-c4a7c.png"  /></p><h3 id="别名的其他用法"><a href="#别名的其他用法" class="headerlink" title="别名的其他用法"></a>别名的其他用法</h3><p>除了用于模板的<strong>别名</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">charT</span>&gt;</span> <br><span class="hljs-keyword">using</span> mystring = std::basic_string&lt;CharT,std::char_traits&lt;CharT&gt;&gt;;<br><span class="hljs-comment">//...</span><br>mystring&lt;<span class="hljs-keyword">char</span>&gt; str;<br></code></pre></div></td></tr></table></figure><p>还能用于模板的参数：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Container</span>&#123;</span><br><span class="hljs-keyword">using</span> value_type = T;<br>&#125;;<br><span class="hljs-comment">//上下代码等同效果</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Cntr&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fn2</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Cntr&amp; c)</span></span>&#123;<br>    <span class="hljs-keyword">typename</span> Cntr::value_type n;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>也能用于函数：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> func = <span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(*)(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>);<span class="hljs-comment">//等效于typedef void(*func)(int,int);</span><br><span class="hljs-comment">//...</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">example</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span></span>&#123;&#125;<br>func fn = example;<br></code></pre></div></td></tr></table></figure><p><code>typedef</code>和<strong>别名</strong>实际上的差别并不大，但是<strong>别名</strong>的灵活性更胜一筹。</p><h2 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h2><p>在函数后头添加这个关键字，表示这个函数保证不会发生异常。比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></div></td></tr></table></figure><p>也可以对 <code>noexcept</code>添加条件，比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span></span>;<span class="hljs-comment">//可以添加条件，表示符合这个条件就不会发生异常</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Type&amp; x,Type&amp; y)</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-keyword">noexcept</span>(x.swap(y)))</span></span>&#123;<br>    x.<span class="hljs-built_in">swap</span>(y);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意：如果发生异常，没有及时处理，那么这个异常就会进入 <code>std::terminate()</code>，并且调用 <code>std::abort()</code>结束程序。</p><p>另外，对于用户自定义类的移动函数，也需要在后面添加 <code>noexcept</code>关键字。如果没有添加，特别是使用容器 <code>vector</code>时，<code>vector</code>只会调用开销更大的拷贝函数，而不会去调用移动函数。（能够生长的容器只有 <code>vector</code>和 <code>deque</code>）</p><p>使用 <code>noexcept</code>可以让编译器对代码进行优化。</p><h2 id="override"><a href="#override" class="headerlink" title="override"></a>override</h2><p>这个关键字只是为了让编译器帮助检查，避免重写过程中的错误，不一定需要使用。但是感觉写了也增加了程序的可读性。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Base</span>&#123;</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfunc</span><span class="hljs-params">(<span class="hljs-keyword">float</span>)</span></span>&#123;&#125;  <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test1</span>:</span>Base&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>&#123;&#125;  <span class="hljs-comment">//本意是重写Base的vfunc函数，但是由于失误更改了形参类型</span><br>     <span class="hljs-comment">//编译器会认为定义了一个新函数</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test2</span>:</span>Base&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vfunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-keyword">override</span></span>&#123;&#125;  <span class="hljs-comment">//本意是重写Base的vfunc函数，但是由于失误更改了形参类型</span><br>       <span class="hljs-comment">//不过有override关键字的存在，编译器发现了错误</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>这个关键字和 <code>override</code>一样，也是为了让编译器帮助检查。</p><p>这个关键字可用于类身上，它的作用就是告诉编译器：我是这个继承体系之下的最后一个，不能再有类继承我了。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Base</span> <span class="hljs-keyword">final</span>&#123;</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test</span>:</span>Base&#123;&#125;;<span class="hljs-comment">//错误！不能继承一个final类</span><br></code></pre></div></td></tr></table></figure><p>也可以用于虚函数身上，作用同上。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">strcuct Base&#123;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span></span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test</span>:</span>Base&#123;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//错误！不能重写一个final虚函数</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p>使用 <code>decltype</code>关键字可以找到一个表达式的类型，相当于 <code>typeof</code>。比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">map&lt;string,<span class="hljs-keyword">float</span>&gt; coll;<br><span class="hljs-keyword">decltype</span>(coll)::value_type elem;<span class="hljs-comment">//可以使用decltype获得容器的类型</span><br><span class="hljs-comment">//等同于以下</span><br><span class="hljs-comment">//before C++11</span><br>map&lt;string,<span class="hljs-keyword">float</span>&gt;::value_type elem;<br></code></pre></div></td></tr></table></figure><p>它可以用来声明一个 <code>return type</code>：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T1 x,T2 y)</span>-&gt;<span class="hljs-title">decltype</span><span class="hljs-params">(x+y)</span></span>&#123;&#125;;<br></code></pre></div></td></tr></table></figure><p>也可以用于模板元编程：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T obj)</span></span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> <span class="hljs-title">decltype</span><span class="hljs-params">(obj)</span>::iterator iType</span>;<span class="hljs-comment">//取迭代器，当然前提是T有迭代器</span><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>还可以用于 <code>lambda</code>：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-keyword">const</span> Person&amp; p1,<span class="hljs-keyword">const</span> Person&amp; p2)&#123;<br>    <span class="hljs-comment">//....</span><br>&#125;;<br><span class="hljs-function">std::set&lt;Person,<span class="hljs-title">decltype</span><span class="hljs-params">(cmp)</span>&gt; <span class="hljs-title">coll</span><span class="hljs-params">(cmp)</span></span>;<span class="hljs-comment">//常用于对容器的排序</span><br></code></pre></div></td></tr></table></figure><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p><code>lambda</code>有点像<strong>inline function</strong>，它可以被当作函数参数或一个局部object。</p><p>它有很多形式：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">[]&#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;hello&quot;</span>&lt;&lt;std::endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">[]&#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;hello&quot;</span>&lt;&lt;std::endl;<br>&#125;();<span class="hljs-comment">//注意这个括号，表示直接调用，输出hello</span><br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> func = []&#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;hello&quot;</span>&lt;&lt;std::endl;<br>&#125;;<br><span class="hljs-built_in">func</span>();<span class="hljs-comment">//输出hello</span><br></code></pre></div></td></tr></table></figure><p>它的语法如下：</p><script type="math/tex; mode=display">[\ \ ]\ ()\ mutable_{opt}\ throwSpec_{opt}->retType_{opt}\{...\}</script><ul><li><p><strong>[ ]</strong>为捕获列表，可以为空，也可以写入变量。捕获方式可以是值传递，也可以是引用传递。</p><ul><li>[=]：全部都是值传递</li><li>[&amp;a]：a变量引用传递</li><li>[a]：a变量值传递</li><li>[&amp;a,=]：a变量引用传递，其他变量值传递</li></ul></li><li><strong>( )</strong>为形参列表</li><li>$mutable_{opt}$表示是否可以改动捕获列表中的变量。</li><li>$throwSpec_{opt}$表示是否丢出异常</li><li>$retType_{opt}$表示返回类型。</li><li>$mutable<em>{opt}$​、$throwSpec</em>{opt}$​、$retType_{opt}$可有可无。若三者都不存在，可以不写<strong>( )</strong>。但是若三者有一个出现，那么<strong>( )</strong>必须存在。</li><li><strong>{ }</strong>为函数本体</li></ul><h2 id="Rvalue-references"><a href="#Rvalue-references" class="headerlink" title="Rvalue references"></a>Rvalue references</h2><ul><li>左值：可以出现在等号的左侧</li><li>右值：只能出现在等号的右侧<ul><li>右值引用可以避免不必要的拷贝</li><li>临时对象也是右值</li><li>右值没有名称</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>206. 反转链表</title>
    <link href="/2021/03/01/LeetCode/206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/03/01/LeetCode/206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">本题链接</a></p><h2 id="迭代版1"><a href="#迭代版1" class="headerlink" title="迭代版1"></a>迭代版1</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        ListNode* node_res_first = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//指向结果中的头节点</span><br>        ListNode* node_res_first_tmp;<span class="hljs-comment">//备份结果中的头节点</span><br>        ListNode* next_begin = head;<span class="hljs-comment">//在原链表中指向开始操作的第一个节点</span><br>        ListNode* next_begin_tmp;<span class="hljs-comment">//在原链表中备份下一次遍历开始的节点</span><br>        <span class="hljs-function">ListNode <span class="hljs-title">assist</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">//辅助节点</span><br><br>        <span class="hljs-keyword">while</span>(next_begin != <span class="hljs-literal">nullptr</span>)&#123;<br><br>            <span class="hljs-keyword">if</span>(next_begin-&gt;next == <span class="hljs-literal">nullptr</span>)<span class="hljs-comment">//如果next_begin的下一个节点为空</span><br>                next_begin-&gt;next = &amp;assist;<span class="hljs-comment">//接上辅助节点</span><br>    <br>            <span class="hljs-comment">//临时存储</span><br>            next_begin_tmp = next_begin-&gt;next-&gt;next;<span class="hljs-comment">//存储下一次开始遍历的节点</span><br>            node_res_first_tmp = next_begin-&gt;next;<span class="hljs-comment">//存储下一次遍历时结果中的头节点</span><br>            <span class="hljs-comment">//反转</span><br>            next_begin-&gt;next-&gt;next = next_begin;<span class="hljs-comment">//将开始节点的下一个节点指向开始节点 反转</span><br>            next_begin-&gt;next = node_res_first;<span class="hljs-comment">//将开始节点指向结果中的头节点</span><br>            <span class="hljs-comment">//从临时存储取值</span><br>            node_res_first = node_res_first_tmp;<span class="hljs-comment">//更改下一次结果中的头节点</span><br>            next_begin = next_begin_tmp;<span class="hljs-comment">//更改下次开始的地方</span><br><br>        &#125;<br><br>        <span class="hljs-comment">//去除辅助节点</span><br>        <span class="hljs-keyword">if</span>(node_res_first == &amp;assist)<br>            node_res_first = node_res_first-&gt;next;<br>        <br>        <span class="hljs-keyword">return</span> node_res_first;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每次处理链表中的两个节点，将第二个节点的指向改成第一个节点。注意需要保存这个过程中的一些节点，不然会由于更改了指向会造成节点丢失。</p><h2 id="迭代版2"><a href="#迭代版2" class="headerlink" title="迭代版2"></a>迭代版2</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        ListNode* res_head = <span class="hljs-literal">nullptr</span>;<br>        ListNode* node_tmp;<br><br>        <span class="hljs-keyword">while</span>(head)&#123;<br>            node_tmp = head-&gt;next;<span class="hljs-comment">//node_tmp保存head的下一个</span><br>            head-&gt;next = res_head;<span class="hljs-comment">//更改head指向为结果的第一个节点</span><br>            res_head = head;<span class="hljs-comment">//更改结果的第一个节点为head</span><br>            head = node_tmp;<span class="hljs-comment">//将head复位</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res_head;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>更直观，每次就处理一个节点。</p><h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head,ListNode* prev = <span class="hljs-literal">nullptr</span>,ListNode* node = <span class="hljs-literal">nullptr</span>)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> prev;<span class="hljs-comment">//到最后就返回结果头节点</span><br>        <br>        node = head-&gt;next;<span class="hljs-comment">//node保存head的下一个节点</span><br>        head-&gt;next = prev;<span class="hljs-comment">//将head指向prev</span><br>        prev = head;<span class="hljs-comment">//更新结果头节点</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverseList</span>(node,prev,node);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>与迭代版2一样，每次就处理一个节点。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代</tag>
      
      <tag>递归</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用SSR实现局域网代理</title>
    <link href="/2021/03/01/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8SSR%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BB%A3%E7%90%86/"/>
    <url>/2021/03/01/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8SSR%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><h3 id="1-设置路由器"><a href="#1-设置路由器" class="headerlink" title="1. 设置路由器"></a>1. 设置路由器</h3><p>既然要实现局域网代理，那么首先，需要给作为代理服务器的设备设置静态IP地址。</p><p>我的代理服务器静态IP地址设置为192.168.3.9，在此举出以便于下文编写。</p><h4 id="1-1-从路由器关闭DHCP-不推荐"><a href="#1-1-从路由器关闭DHCP-不推荐" class="headerlink" title="1.1 从路由器关闭DHCP(不推荐)"></a>1.1 从路由器关闭DHCP(不推荐)</h4><p>打开路由器的设置页面，以华为路由器为例，找到DHCP相关设置，并关闭DHCP。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301091942.png" alt="关闭DHCP"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301091909.png" alt="提示"></p><p>该方法不推荐使用，原因如上图</p><h4 id="1-2-从路由器添加静态IP地址"><a href="#1-2-从路由器添加静态IP地址" class="headerlink" title="1.2 从路由器添加静态IP地址"></a>1.2 从路由器添加静态IP地址</h4><p>在路由器的DHCP页面找到添加静态IP地址的选项</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301092234.png" alt="添加"></p><p>选择需要作为代理服务器的设备即可</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301092321.png" alt="静态IP地址绑定"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301092447.png" alt="完成"></p><h4 id="1-3-直接在代理服务器上设置静态IP地址"><a href="#1-3-直接在代理服务器上设置静态IP地址" class="headerlink" title="1.3 直接在代理服务器上设置静态IP地址"></a>1.3 直接在代理服务器上设置静态IP地址</h4><p>打开代理服务器上的”<strong>网络连接</strong>“，找到连接到路由器的网卡，右键点击呼出上下文，选择属性并进入，IP地址相关不再赘述。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301092813.png" alt="设置静态IP"></p><h3 id="2-设置SSR"><a href="#2-设置SSR" class="headerlink" title="2. 设置SSR"></a>2. 设置SSR</h3><p>在Surface上右键小飞机-&gt;更多-&gt;选项设置</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301080311.png" alt="设置SSR"></p><p>勾选”<strong>允许来自局域网的连接</strong>“即可</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301080602.png" alt="选项设置"></p><h2 id="Windows客户端"><a href="#Windows客户端" class="headerlink" title="Windows客户端"></a>Windows客户端</h2><h4 id="1-PAC文件"><a href="#1-PAC文件" class="headerlink" title="1. PAC文件"></a>1. PAC文件</h4><p>右键小飞机找到PAC文件地址并复制</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210303210609.png" alt="PAC文件地址"></p><h4 id="2-设置windows代理"><a href="#2-设置windows代理" class="headerlink" title="2. 设置windows代理"></a>2. 设置windows代理</h4><p>在<strong>客户端</strong>，依次打开控制面板-&gt;网络和Internet-&gt;代理，在自动设置代理里面的脚本地址中填入刚才复制的PAC地址，其中，IP地址需要更换成代理服务器的地址</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210303211509.png" alt=""></p><h2 id="随记"><a href="#随记" class="headerlink" title="随记"></a>随记</h2><h3 id="1-自动代理和手动代理的区别"><a href="#1-自动代理和手动代理的区别" class="headerlink" title="1. 自动代理和手动代理的区别"></a>1. 自动代理和手动代理的区别</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210301091636.png" alt="自动代理和手动代理"></p><ol><li>自动代理：需要配置PAC(proxy auto-config)脚本文件，根据PAC文件流量会自动选择走代理还是直连。<a href="https://www.barretlee.com/blog/2016/08/25/pac-file/">详解代理自动配置 PAC</a></li><li>手动代理：除了指定的地址不走代理，流量会经代理访问剩余地址</li></ol>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>局域网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>739. 每日温度</title>
    <link href="/2021/02/28/LeetCode/739.%20%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
    <url>/2021/02/28/LeetCode/739.%20%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/daily-temperatures/">本题链接</a></p><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br><br>        stack&lt;<span class="hljs-keyword">int</span>&gt; d_stack;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(temperatures.size(),<span class="hljs-number">0</span>)</span></span>;<br><br>        <span class="hljs-comment">//维护temperatures对应的递增单调栈(存入下标)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = temperatures.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span> ;--i)&#123;<br>           <span class="hljs-comment">//如果栈非空且temperatures[栈顶元素]小于temperatures[当前元素]:将栈顶元素出栈</span><br>           <span class="hljs-keyword">while</span>(!d_stack.<span class="hljs-built_in">empty</span>() &amp;&amp; temperatures[d_stack.<span class="hljs-built_in">top</span>()] &lt;= temperatures[i]) d_stack.<span class="hljs-built_in">pop</span>();<br>           <span class="hljs-comment">//如果栈非空,计算当前元素到栈顶元素的距离(天数)</span><br>           <span class="hljs-keyword">if</span>(!d_stack.<span class="hljs-built_in">empty</span>()) res[i] = d_stack.<span class="hljs-built_in">top</span>() - i;<br>           <span class="hljs-comment">//将当前元素(下标)入栈</span><br>           d_stack.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>维护一个单调递增栈，其中的栈元素为temperatures数组的下标。其中，在栈非空的情况下需要保证栈顶元素所对应的值大于当前元素的值，就可计算出当前元素还需要多久会升温。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>46. 全排列</title>
    <link href="/2021/02/25/LeetCode/46.%20%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <url>/2021/02/25/LeetCode/46.%20%E5%85%A8%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/permutations/">本题链接</a></p><h2 id="回溯法-递归"><a href="#回溯法-递归" class="headerlink" title="回溯法+递归"></a>回溯法+递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br><br>        <span class="hljs-built_in">func</span>(nums,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> start)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(start == nums.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(nums);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = start;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-built_in">swap</span>(nums[i],nums[start]);<br>            <span class="hljs-built_in">func</span>(nums,start+<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">swap</span>(nums[i],nums[start]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在每一次递归函数内，当前递归函数所管理的数组区域的第一个元素，都会从起始位置start开始依次往后交换。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>递归</tag>
      
      <tag>回溯法</tag>
      
      <tag>排列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>47. 全排列 II</title>
    <link href="/2021/02/25/LeetCode/47.%20%E5%85%A8%E6%8E%92%E5%88%97%20II/"/>
    <url>/2021/02/25/LeetCode/47.%20%E5%85%A8%E6%8E%92%E5%88%97%20II/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/permutations-ii/">本题链接</a></p><h2 id="回溯-递归-set"><a href="#回溯-递归-set" class="headerlink" title="回溯+递归+set"></a>回溯+递归+set</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>    <br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br><br>        <span class="hljs-built_in">func</span>(nums,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; start)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(start == nums.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(nums);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        set&lt;<span class="hljs-keyword">int</span>&gt; digit_set;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = start;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <br>            <span class="hljs-keyword">if</span>(digit_set.<span class="hljs-built_in">find</span>(nums[i]) == digit_set.<span class="hljs-built_in">end</span>())&#123;<span class="hljs-comment">//如果当前数没有使用过</span><br>                digit_set.<span class="hljs-built_in">insert</span>(nums[i]);<br>                <span class="hljs-built_in">swap</span>(nums[i],nums[start]);<br>                <span class="hljs-built_in">func</span>(nums,start+<span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">swap</span>(nums[i],nums[start]);<br>            &#125;<br>            <br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>只需要在每次递归中跳过使用过的<strong>数</strong>就行</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>数组</tag>
      
      <tag>递归</tag>
      
      <tag>回溯法</tag>
      
      <tag>排列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>785. 判断二分图</title>
    <link href="/2021/02/24/LeetCode/785.%20%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <url>/2021/02/24/LeetCode/785.%20%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/is-graph-bipartite/">本题链接</a></p><h2 id="染色法"><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br><br>        <span class="hljs-comment">//对每个点进行广度优先遍历</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">color_vec</span><span class="hljs-params">(graph.size(),<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">//染色,0表示未遍历,1表示黑色,2表示白色</span><br><br>        queue&lt;<span class="hljs-keyword">int</span>&gt; node_queue;<br>        <span class="hljs-comment">//预处理</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; graph.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            <span class="hljs-keyword">if</span>(color_vec[i] == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//如果没有被染色</span><br>                <span class="hljs-comment">//统一设成黑色，只要节点之间连通就一定会入队，不连通的无所谓</span><br>                color_vec[i] = <span class="hljs-number">1</span>;<br>                node_queue.<span class="hljs-built_in">push</span>(i);<span class="hljs-comment">//将节点入队</span><br>            &#125;<br><br>            <span class="hljs-keyword">while</span>(!node_queue.<span class="hljs-built_in">empty</span>())&#123;<br>                <br>                <span class="hljs-keyword">int</span> pos = node_queue.<span class="hljs-built_in">front</span>();node_queue.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//获取当前节点</span><br><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; neig : graph[pos])&#123;<span class="hljs-comment">//遍历该节点的所有相邻节点 </span><br><br>                    <span class="hljs-keyword">if</span>(color_vec[neig] == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//如果没有被染色</span><br><br>                        color_vec[neig] = color_vec[pos] == <span class="hljs-number">1</span> ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<span class="hljs-comment">//染成和自己不一样的颜色</span><br>                        node_queue.<span class="hljs-built_in">push</span>(neig);<span class="hljs-comment">//将节点入队</span><br><br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(color_vec[neig] == color_vec[pos]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果和自己的颜色相同 </span><br>                          <br>                &#125;<br><br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>分辨图是否为二分图，使用染色法。详情见<a href="https://leetcode-cn.com/problems/is-graph-bipartite/solution/pan-duan-er-fen-tu-by-leetcode-solution/">官方解析</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图</tag>
      
      <tag>广度优先搜索</tag>
      
      <tag>染色法</tag>
      
      <tag>二分图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编</title>
    <link href="/2021/02/24/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96/"/>
    <url>/2021/02/24/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/zhongshiyu98/cdnrepo/pdf/AssemblyLanguage.pdf" width="100%" height="550" type="application/pdf"></div><hr><a class="btn" href="https://blog.zhongshiyu.xyz/pdf/mindmaster/AssemblyLanguage.pdf"  title="在新窗口打开" target="_blank">进入全屏</a>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>205. 同构字符串</title>
    <link href="/2021/02/19/LeetCode/205.%20%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2021/02/19/LeetCode/205.%20%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/isomorphic-strings/">本题链接</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isIsomorphic</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br><br>        unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">char</span>&gt; hashmap;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            <span class="hljs-keyword">if</span>(hashmap[s[i]] == <span class="hljs-string">&#x27;\0&#x27;</span>) hashmap[s[i]] = t[i];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(hashmap[s[i]] != t[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        &#125;<br><br>        hashmap.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            <span class="hljs-keyword">if</span>(hashmap[t[i]] == <span class="hljs-string">&#x27;\0&#x27;</span>) hashmap[t[i]] = s[i];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(hashmap[t[i]] != s[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>记录每个字符串对于另一个字符串的映射关系，由于是单射，所以遍历两次。也可以使用两个哈希表将遍历次数降至1。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>452. 用最少数量的箭引爆气球</title>
    <link href="/2021/02/15/LeetCode/452.%20%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/"/>
    <url>/2021/02/15/LeetCode/452.%20%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">本题链接</a></p><h2 id="暴力-贪心"><a href="#暴力-贪心" class="headerlink" title="暴力+贪心"></a>暴力+贪心</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br><br>        <span class="hljs-comment">//异常处理</span><br>        <span class="hljs-keyword">if</span>(points.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//预处理 排序</span><br>    <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(),points.<span class="hljs-built_in">end</span>(),[](vector&lt;<span class="hljs-keyword">int</span>&gt; x,vector&lt;<span class="hljs-keyword">int</span>&gt; y)&#123;<span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>] &lt; y[<span class="hljs-number">1</span>];&#125;);<br><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> hi = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; points.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(points[i][<span class="hljs-number">0</span>] &gt; hi)<br>            &#123;<br>                count +=<span class="hljs-number">1</span>;<br>                hi = points[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>画图得到只要多个气球的左边界集中在某个区域，那么就可以一箭射穿。那么就先按照气球的右边界进行排序，然后每次从最小右边界的气球开始，判断其他气球的左边界是否小于该气球的右边界即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>贪心</tag>
      
      <tag>区间</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>227. 基本计算器 II</title>
    <link href="/2021/02/11/LeetCode/227.%20%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8%20II/"/>
    <url>/2021/02/11/LeetCode/227.%20%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8%20II/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/basic-calculator-ii/">本题链接</a></p><h2 id="栈-延迟缓冲"><a href="#栈-延迟缓冲" class="headerlink" title="栈(延迟缓冲)"></a>栈(延迟缓冲)</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        stack&lt;<span class="hljs-keyword">char</span>&gt; op_s;<span class="hljs-comment">//操作符栈</span><br>        stack&lt;<span class="hljs-keyword">int</span>&gt; di_s;<span class="hljs-comment">//操作数栈</span><br>        string digit;<br>        unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; op_map&#123;&#123;<span class="hljs-string">&#x27;+&#x27;</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-string">&#x27;-&#x27;</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-string">&#x27;*&#x27;</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-number">1</span>&#125;&#125;;<span class="hljs-comment">//操作符优先级</span><br>        s.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;+&#x27;</span>);<span class="hljs-comment">//预处理</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            <span class="hljs-keyword">while</span>(op_map.<span class="hljs-built_in">find</span>(s[i]) == op_map.<span class="hljs-built_in">end</span>()) digit+=s[i++];<span class="hljs-comment">//找到一个操作数</span><br>            di_s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoi</span>(digit));<span class="hljs-comment">//将操作数入操作数栈 stoi已对空格情况进行处理</span><br>            digit = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//将操作数清空</span><br><br>            <span class="hljs-keyword">while</span>(!op_s.<span class="hljs-built_in">empty</span>() &amp;&amp; op_map[s[i]] &lt;= op_map[op_s.<span class="hljs-built_in">top</span>()])&#123;<span class="hljs-comment">//若栈非空且当前操作符优先级低于栈顶元素优先级</span><br><br>                <span class="hljs-comment">//将操作数栈中取出值计算</span><br>                <span class="hljs-keyword">int</span> right = di_s.<span class="hljs-built_in">top</span>();di_s.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//右操作数</span><br>                <span class="hljs-keyword">int</span> left = di_s.<span class="hljs-built_in">top</span>();di_s.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//左操作数</span><br>                di_s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">getRes</span>(left,right,op_s.<span class="hljs-built_in">top</span>()));<span class="hljs-comment">//结合操作符获得结果,并放入操作数栈中</span><br>                op_s.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//丢弃已经使用过的操作符</span><br><br>            &#125;<br><br>            op_s.<span class="hljs-built_in">push</span>(s[i]);<span class="hljs-comment">//将当前的操作符入栈</span><br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> di_s.<span class="hljs-built_in">top</span>();<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getRes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; left,<span class="hljs-keyword">int</span>&amp; right,<span class="hljs-keyword">char</span> op)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;+&#x27;</span>) <span class="hljs-keyword">return</span> left + right;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> left - right;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-keyword">return</span> left * right;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;/&#x27;</span>) <span class="hljs-keyword">return</span> left / right;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将操作数和操作符分别用栈保存，每次取到新的操作符，就与栈顶的操作符对比，若栈顶的操作符优先级更高或优先级相等，便取出两个操作数与栈顶的操作符结合。直到栈顶的操作符优先级低于当前的操作符，再将当前的操作符入栈。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows10环境使用Jekyll+github page搭建个人博客</title>
    <link href="/2021/02/05/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Windows10%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8Jekyll+github%20page%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/02/05/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Windows10%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8Jekyll+github%20page%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-搭建Jekyll"><a href="#1-搭建Jekyll" class="headerlink" title="1.搭建Jekyll"></a>1.搭建Jekyll</h2><h3 id="1-1-安装Ruby"><a href="#1-1-安装Ruby" class="headerlink" title="1.1 安装Ruby"></a>1.1 安装Ruby</h3><p>Ruby是一种类似于Python的面向对象的语言。</p><p><a href="https://rubyinstaller.org/downloads/">Ruby下载网址</a></p><p>根据自己的开发环境选择对应版本。注意，需要选择<strong>Ruby+Devkit</strong>。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205111003.png" alt="Ruby下载"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205114122.png" alt="License"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205114157.png" alt="Destination"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205114232.png" alt="Components"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205114344.png" alt="等待安装完成"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205114601.png" alt="安装完成"></p><p>等待一会，会跳出命令行界面。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-04-58.png" alt="RubyInstaller2"></p><p>直接按ENTER执行。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205114946.png" alt="正在安装"></p><p>安装完成后关闭窗口即可</p><hr><h3 id="1-2-安装Jekyll"><a href="#1-2-安装Jekyll" class="headerlink" title="1.2 安装Jekyll"></a>1.2 安装Jekyll</h3><p>打开CMD，输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">gem install jekyll bundler<br></code></pre></div></td></tr></table></figure><p>执行，然后等待安装完成。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205115635.png" alt="CMD安装"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205115733.png" alt="CMD安装完成"></p><p>现在验证Jekyll安装是否完成，只需在CMD中输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">jekyll -v<br></code></pre></div></td></tr></table></figure><p>若出现下图结果，表示Jekyll安装成功。若安装失败，重新启动系统，然后<strong>jekyll -v</strong>再次运行。如果错误仍然存在，请打开<a href="https://github.com/oneclick/rubyinstaller2/issues/new">RubyInstaller问题</a>。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205115903.png" alt="Jekyll安装完成" style="zoom:200%;" /></p><hr><h3 id="1-3-使用Jekyll创建网站"><a href="#1-3-使用Jekyll创建网站" class="headerlink" title="1.3 使用Jekyll创建网站"></a>1.3 使用Jekyll创建网站</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">jekyll new blog<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-12-25.png" alt="jekyll new blog"></p><p>完成后在C:\Users\你的用户名下会有个blog的文件夹，内容如下</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210206092035.png" alt="网站创建成功"></p><p><a id='target'>关键</a>:接着安装一些依赖</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">gem <span class="hljs-keyword">install</span> sdbm<br>gem <span class="hljs-keyword">install</span> webrick<br>gem <span class="hljs-keyword">install</span> net-telnet<br>gem <span class="hljs-keyword">install</span> xmlrpc<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-31-34.png" alt="安装依赖"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210206093914.png" alt="安装依赖"></p><p>然后进入blog目录，<strong>shift+鼠标右键</strong>呼出上下文菜单，打开<strong>Powershell窗口</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210206094145.png" alt="上下文菜单"></p><p>在Powershell中输入</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">bundle add webrick<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-36-13.png" alt="bundle add webrick"></p><p>最后运行Jekyll服务</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">jekyll server<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-36-43.png" alt="Jekyll服务"></p><p>打开本地浏览器，输入网址</p><figure class="highlight http"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs http">http://localhost:4000<br></code></pre></div></td></tr></table></figure><p>成功运行<img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-37-34.png" alt=""></p><h3 id="1-4-发布博客"><a href="#1-4-发布博客" class="headerlink" title="1.4 发布博客"></a>1.4 发布博客</h3><p>发布博客很简单，只需要根据Jekyll指定的格式发布即可</p><p>在blog目录下有个_posts文件夹，这个文件夹专门存放markdown文件。里面自带了一个标准的markdown</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304155824.png" alt="默认文件"></p><p>里面内容如下：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">---<br>layout: post    <br>title:  &quot;Welcome to Jekyll!&quot;<br>date:   2021-02-06 09:10:43 +0800<br>categories: jekyll update<br><br>---<br><br>您可以在“ <span class="hljs-emphasis">_posts”目录中找到此信息。继续进行编辑，然后重新构建站点以查看您的更改。您可以用许多不同的方法重建站点，但是最常见的方法是运行“ jekyll serve”，它会启动Web服务器并在文件更新时自动重新生成站点。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">Jekyll要求按照以下格式命名博客文章文件：</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">`YEAR-MONTH-DAY-title.MARKUP`</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">其中“YEAR”是四位数，“MONTH”和“DAY”都是两位数，“ MARKUP”是表示文件中使用的格式的文件扩展名。在那之后，包括必要的前题。查看这篇文章的来源，以了解其工作原理。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">Jekyll还为代码段提供了强大的支持：</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">&#123;% highlight ruby %&#125;</span><br><span class="hljs-emphasis">def print_</span>hi(name)<br>  puts &quot;Hi, #&#123;name&#125;&quot;<br>end<br>print<span class="hljs-emphasis">_hi(&#x27;Tom&#x27;)</span><br><span class="hljs-emphasis">#=&gt; prints &#x27;Hi, Tom&#x27; to STDOUT.</span><br><span class="hljs-emphasis">&#123;% endhighlight %&#125;</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">查看[Jekyll docs] [jekyll-docs]，以获取有关如何充分利用Jekyll的更多信息。在[Jekyll的GitHub存储库] [jekyll-gh]中提交所有错误/功能请求。如有疑问，可以在[Jekyll Talk] [jekyll-talk]上提问。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">[jekyll-docs]: https://jekyllrb.com/docs/home</span><br><span class="hljs-emphasis">[jekyll-gh]:   https://github.com/jekyll/jekyll</span><br><span class="hljs-emphasis">[jekyll-talk]: https://talk.jekyllrb.com/</span><br></code></pre></div></td></tr></table></figure><p>总结一下，就是发布博客最简单的方法就是在_posts目录下，按照它给定的格式创建一个markdown文件，然后在markdown文件的头部，添加一个<strong>front matter</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304160530.png" alt="创建markdown文件"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304160709.png" alt="编写markdown"></p><p>重新运行jekyll服务，然后进入主页</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304160815.png" alt="主页显示"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304161001.png" alt="进入博客"></p><h2 id="2-创建github-page"><a href="#2-创建github-page" class="headerlink" title="2. 创建github page"></a>2. 创建github page</h2><h3 id="2-1-创建仓库"><a href="#2-1-创建仓库" class="headerlink" title="2.1 创建仓库"></a>2.1 创建仓库</h3><p>首先需要一个Github账号，相信大家都有了吧</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210212191956.png" alt="创建仓库1"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210212193329.png" alt="创建仓库2"></p><p>仓库创建成功效果如下图</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210212193101.png" alt="创建成功"></p><h3 id="2-2-设置github-page"><a href="#2-2-设置github-page" class="headerlink" title="2.2 设置github page"></a>2.2 设置github page</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210212193442.png" alt="点击setting"></p><p>下拉找到github page，并点击<strong>Choose a theme</strong>选择一个主题</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210212193555.png" alt="github page选项"></p><h2 id="错误记录"><a href="#错误记录" class="headerlink" title="错误记录"></a>错误记录</h2><h3 id="1-jekyll-创建网站时卡住"><a href="#1-jekyll-创建网站时卡住" class="headerlink" title="1. jekyll 创建网站时卡住"></a>1. jekyll 创建网站时卡住</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210205154036.png" alt="jekyll 创建网站时卡住"></p><p>先卸载掉Jekyll</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">gem unistall jekyll <br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-00-22.png" alt="卸载Jekyll"></p><p>然后打开之前下载的rubyinstaller-devkit-xxx.exe可执行文件，按照之前的步骤安装，最重要的是到了这一步</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-04-58.png" alt="RubyInstaller2"></p><p>直接ENTER键安装全部，不需要选择1~3之间的任意选项。然后剩下的步骤照常即可。</p><h3 id="2-servlet-rb-3-in-require’-cannot-load-such-file-—-webrick-LoadError"><a href="#2-servlet-rb-3-in-require’-cannot-load-such-file-—-webrick-LoadError" class="headerlink" title="2. servlet.rb:3:in `require’: cannot load such file — webrick (LoadError)"></a>2. servlet.rb:3:in `require’: cannot load such file — webrick (LoadError)</h3><p>启动Jekyll服务时出错</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-06_09-29-39.png" alt="报错"></p><p>原因是启动服务前没有安装相应的依赖，并加入到bundle里面。<a href='#target'>解决方法</a>及<a href="https://github.com/jekyll/jekyll/issues/8523">参考</a></p><h2 id="随记"><a href="#随记" class="headerlink" title="随记"></a>随记</h2><h3 id="1-Jeklly"><a href="#1-Jeklly" class="headerlink" title="1. Jeklly"></a>1. Jeklly</h3><h4 id="1-1-config-yml文件"><a href="#1-1-config-yml文件" class="headerlink" title="1.1  _config.yml文件"></a>1.1  _config.yml文件</h4><p><strong>原始网页：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210304115655.png" alt="原始网页"></p><p><strong>原始文件：</strong></p><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-comment"># 欢迎来到 Jekyll!</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 此配置文件用于影响整个博客的设置和值</span><br><span class="hljs-comment"># 应该设置一次，以后很少编辑。如果你发现自己经常编辑此文件，请考虑使用Jekyll的数据文件功能用于您需要经常更新的数据。</span><br><span class="hljs-comment">#由于技术原因，当您使用&#x27;bundle exec jekyll serve&#x27;，不会自动重新加载该文件</span><br><span class="hljs-comment"># 如果更改此文件，请重新启动服务器进程。</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 如果您需要有关YAML语法的帮助，以下是一些快速参考: </span><br><span class="hljs-comment"># https://learn-the-web.algonquindesign.ca/topics/markdown-yaml-cheat-sheet/#yaml</span><br><span class="hljs-comment"># https://learnxinyminutes.com/docs/yaml/</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 网站设置</span><br><span class="hljs-comment"># 这些用于个性化您的新站点。如果您查看HTML文件，您将看到它们通过&#123;&#123;site.title&#125;&#125;，&#123;&#123;site.email&#125;&#125;等访问。</span><br><span class="hljs-comment"># 在模板中通过&#123;&#123;site.myvariable&#125;&#125;可以创建任何想要的自定义变量，并且可以访问它们</span><br><br><span class="hljs-attr">title:</span> <span class="hljs-string">Your</span> <span class="hljs-string">awesome</span> <span class="hljs-string">title</span> <span class="hljs-comment"># 此处修改网页标题</span><br><span class="hljs-attr">email:</span> <span class="hljs-string">your-email@example.com</span> <span class="hljs-comment"># 此处修改个人邮箱</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">&gt;-</span> <span class="hljs-comment"># 此处添加网页描述。这意味着忽略换行符，直到“baseurl：”为止</span><br>  <span class="hljs-string">Write</span> <span class="hljs-string">an</span> <span class="hljs-string">awesome</span> <span class="hljs-string">description</span> <span class="hljs-string">for</span> <span class="hljs-string">your</span> <span class="hljs-string">new</span> <span class="hljs-string">site</span> <span class="hljs-string">here.</span> <span class="hljs-string">You</span> <span class="hljs-string">can</span> <span class="hljs-string">edit</span> <span class="hljs-string">this</span><br>  <span class="hljs-string">line</span> <span class="hljs-string">in</span> <span class="hljs-string">_config.yml.</span> <span class="hljs-string">It</span> <span class="hljs-string">will</span> <span class="hljs-string">appear</span> <span class="hljs-string">in</span> <span class="hljs-string">your</span> <span class="hljs-string">document</span> <span class="hljs-string">head</span> <span class="hljs-string">meta</span> <span class="hljs-string">(for</span><br>  <span class="hljs-string">Google</span> <span class="hljs-string">search</span> <span class="hljs-string">results)</span> <span class="hljs-string">and</span> <span class="hljs-string">in</span> <span class="hljs-string">your</span> <span class="hljs-string">feed.xml</span> <span class="hljs-string">site</span> <span class="hljs-string">description.</span><br><span class="hljs-attr">baseurl:</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># 您网站的子路径，例如/blog</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># 您网站的基本主机名和协议，例如http://example.com</span><br><span class="hljs-attr">twitter_username:</span> <span class="hljs-string">jekyllrb</span><br><span class="hljs-attr">github_username:</span>  <span class="hljs-string">jekyll</span><br><br><span class="hljs-comment"># 构建设置</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">minima</span> <span class="hljs-comment"># 主题</span><br><span class="hljs-attr">plugins:</span> <span class="hljs-comment"># 插件</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">jekyll-feed</span><br><br><span class="hljs-comment"># 从进程中排除</span><br><span class="hljs-comment"># 默认情况下不会处理以下项目</span><br><span class="hljs-comment"># 此处“exclude：”下列出的任何项目都会自动添加到内部的“默认列表”。</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 排除的项目可以通过显式列出目录或在“ include：”列表中输入其条目的文件路径。</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># exclude:</span><br><span class="hljs-comment">#   - .sass-cache/</span><br><span class="hljs-comment">#   - .jekyll-cache/</span><br><span class="hljs-comment">#   - gemfiles/</span><br><span class="hljs-comment">#   - Gemfile</span><br><span class="hljs-comment">#   - Gemfile.lock</span><br><span class="hljs-comment">#   - node_modules/</span><br><span class="hljs-comment">#   - vendor/bundle/</span><br><span class="hljs-comment">#   - vendor/cache/</span><br><span class="hljs-comment">#   - vendor/gems/</span><br><span class="hljs-comment">#   - vendor/ruby/</span><br><br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://sspai.com/post/54608">GitHub Pages 搭建教程</a></li><li><a href="https://segmentfault.com/a/1190000011337349">Windows环境下Jekyll+Github搭建个人博客</a></li><li><a href="https://www.bilibili.com/video/BV1rC4y1878Y/?spm_id_from=333.788.recommend_more_video.0">十分钟搭建个人博客：Jekyll+GitHub Pages</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github page</tag>
      
      <tag>jekyll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>605. 种花问题</title>
    <link href="/2021/02/04/LeetCode/605.%20%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/"/>
    <url>/2021/02/04/LeetCode/605.%20%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/can-place-flowers/">本题链接</a></p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canPlaceFlowers</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; flowerbed, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <br>       <span class="hljs-comment">//预处理</span><br>       flowerbed.<span class="hljs-built_in">insert</span>(flowerbed.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">0</span>);<br>       flowerbed.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br><br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; flowerbed.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i++)<br>       &#123;<br>           <span class="hljs-keyword">if</span>(flowerbed[i<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span> &amp;&amp; flowerbed[i] == <span class="hljs-number">0</span> &amp;&amp; flowerbed[i+<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)<br>           &#123;<br>                flowerbed[i] = <span class="hljs-number">1</span>;<br>                n--;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> n &lt;= <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>判断连续三个0，才在中间种花。为了防止在迭代过程中数组越界，在算法开始时进行预处理：在数组头尾两端添加0。</li><li>使用贪心策略，只要有三个0就种花。</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>149. 直线上最多的点数</title>
    <link href="/2021/02/02/LeetCode/149.%20%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/"/>
    <url>/2021/02/02/LeetCode/149.%20%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/max-points-on-a-line/">本题链接</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxPoints</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (points.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> points.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//异常情况</span><br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">//两两求斜率</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> p1 = <span class="hljs-number">0</span>;p1 &lt; points.<span class="hljs-built_in">size</span>();++p1)&#123;<br><br>            <span class="hljs-comment">//如果大于点数的一半 说明已经是最大值</span><br>            <span class="hljs-keyword">if</span>(res &gt; points.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> res;<br>            unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; k_map;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> p2 = p1 + <span class="hljs-number">1</span>;p2 &lt; points.<span class="hljs-built_in">size</span>();++p2)&#123;<br><br>                <span class="hljs-keyword">int</span> x = points[p1][<span class="hljs-number">0</span>] - points[p2][<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">int</span> y = points[p1][<span class="hljs-number">1</span>] - points[p2][<span class="hljs-number">1</span>];<br><br>                <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) y = <span class="hljs-number">1</span>;<span class="hljs-comment">//两个点x相等,所处直线垂直x轴</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>) x = <span class="hljs-number">1</span>;<span class="hljs-comment">//两个点y相等,所处直线平行x轴</span><br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (y &lt; <span class="hljs-number">0</span>) &#123;<br>                        x = -x;<br>                        y = -y;<br>                    &#125;<br>                    <span class="hljs-keyword">int</span> gcdXY = <span class="hljs-built_in">gcd</span>(<span class="hljs-built_in">abs</span>(x), <span class="hljs-built_in">abs</span>(y));<br>                    x /= gcdXY, y /= gcdXY;<br>                &#125;<br>                ++k_map[y + x * <span class="hljs-number">20001</span>];<br>            &#125;<br><br>            <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; [_,num]:k_map)&#123;<br>                maxn = <span class="hljs-built_in">max</span>(maxn,num + <span class="hljs-number">1</span>);<span class="hljs-comment">//+1为p1自身</span><br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res,maxn);<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">//辗转相除法 求最大公约数</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b, a % b) : a;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>暴力算法对点进行两两求斜率很容易想到，为了把斜率保存到哈希表，对斜率的转化比较棘手。</p><p>具体看官方解析：<a href="https://leetcode-cn.com/problems/max-points-on-a-line/solution/zhi-xian-shang-zui-duo-de-dian-shu-by-le-tq8f/">直线上最多的点数</a>。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>693. 交替位二进制数</title>
    <link href="/2021/01/30/LeetCode/693.%20%E4%BA%A4%E6%9B%BF%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
    <url>/2021/01/30/LeetCode/693.%20%E4%BA%A4%E6%9B%BF%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/">本题链接</a></p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasAlternatingBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">while</span>(n)&#123;<br>            <br>            <span class="hljs-keyword">if</span>((n &amp; <span class="hljs-number">1</span>) == (n &gt;&gt; <span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            n&gt;&gt;=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每次拿n的最低位和次低位进行比较。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>451. 根据字符出现频率排序</title>
    <link href="/2021/01/28/LeetCode/451.%20%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/01/28/LeetCode/451.%20%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">本题链接</a></p><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">frequencySort</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-comment">//计数排序</span><br>        map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; i_map;<br>        <span class="hljs-comment">//先存放字符串中字符出现的次数到map中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">if</span>(i_map.<span class="hljs-built_in">find</span>(s[i]) == i_map.<span class="hljs-built_in">end</span>()) i_map.<span class="hljs-built_in">insert</span>(&#123;s[i],<span class="hljs-number">1</span>&#125;);<br>            <span class="hljs-keyword">else</span> ++i_map[s[i]];<br>        &#125;<br><br>        <span class="hljs-comment">//将i_map的key和value对调放入一个新的multimap</span><br>        multimap&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">char</span>&gt; res_map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; pair:i_map)&#123;<br>            res_map.<span class="hljs-built_in">insert</span>(&#123;pair.second,pair.first&#125;);<br>        &#125;<br><br>        string res_str;<br>        <span class="hljs-comment">//逆向</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i = res_map.<span class="hljs-built_in">rbegin</span>();i != res_map.<span class="hljs-built_in">rend</span>();++i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = (*i).first;k &gt; <span class="hljs-number">0</span>;--k)<br>                res_str.<span class="hljs-built_in">push_back</span>((*i).second);<br>            <br>        <span class="hljs-keyword">return</span> res_str;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先存放字符出现的次数到map中，然后将map的key和value对调存入multimap，利用multimap的性质从multimap的逆迭代器开始遍历构造结果字符串。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>计数排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>110. 平衡二叉树</title>
    <link href="/2021/01/26/LeetCode/110.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2021/01/26/LeetCode/110.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">本题链接</a></p><h2 id="递归版1"><a href="#递归版1" class="headerlink" title="递归版1"></a>递归版1</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">bool</span> res = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">dfs</span>(root,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root,<span class="hljs-keyword">bool</span>&amp; res)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">int</span> left_height = <span class="hljs-built_in">dfs</span>(root-&gt;left,res);<br>        <span class="hljs-keyword">int</span> right_height = <span class="hljs-built_in">dfs</span>(root-&gt;right,res);<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(left_height - right_height) &gt; <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//计算本节点是否平衡</span><br>            res = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(left_height,right_height);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于平衡二叉树的要求是对于树中的每个子树都是平衡的，所以只要其中一个子树不是平衡，就将结果设置为false。不过该方法可以优化，因为当res=false时，实际上已经没必要再去核对其他子树是否平衡了。</p><h2 id="递归版2-优化"><a href="#递归版2-优化" class="headerlink" title="递归版2(优化)"></a>递归版2(优化)</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">bool</span> res = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!res || !root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//此处判断res</span><br><br>        <span class="hljs-keyword">int</span> left_height = <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-keyword">int</span> right_height = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br><br>        <span class="hljs-keyword">if</span>(res &amp;&amp; <span class="hljs-built_in">abs</span>(left_height - right_height) &gt; <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//此处判断res</span><br>            res = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(left_height,right_height);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>对于递归版1，新增了在两个地方判断res，以避免不必要的开销。并且将res设置为类成员变量。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>406. 根据身高重建队列</title>
    <link href="/2021/01/26/LeetCode/406.%20%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/"/>
    <url>/2021/01/26/LeetCode/406.%20%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">本题链接</a></p><h2 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; people) &#123;<br><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>        <br>    <br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(),people.<span class="hljs-built_in">end</span>(),[](vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; a,vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; b)&#123;<br>            <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br>        &#125;);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; people.<span class="hljs-built_in">size</span>(); i++) <br>            res.<span class="hljs-built_in">insert</span>(res.<span class="hljs-built_in">begin</span>() + people[i][<span class="hljs-number">1</span>],people[i]);<br>            <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据题意，在对people数组排序的时候，让最高的并且前面人数最少的那个人，排在前面就行。然后根据people顺序依次插入数组即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>207. 课程表</title>
    <link href="/2021/01/23/LeetCode/207.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8/"/>
    <url>/2021/01/23/LeetCode/207.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/course-schedule/">本题链接</a></p><h2 id="拓扑排序-深度优先搜索"><a href="#拓扑排序-深度优先搜索" class="headerlink" title="拓扑排序+深度优先搜索"></a>拓扑排序+深度优先搜索</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; edges;<span class="hljs-comment">//邻接矩阵</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; state;<span class="hljs-comment">//节点状态表 0:未搜索 1:搜索中 2:已搜索</span><br>    <span class="hljs-keyword">bool</span> res = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br><br>        <span class="hljs-comment">//初始化状态表</span><br>        state.<span class="hljs-built_in">resize</span>(numCourses);<br>        <span class="hljs-comment">//初始化邻接矩阵</span><br>        edges.<span class="hljs-built_in">resize</span>(numCourses);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; info : prerequisites)&#123;<br>            edges[info[<span class="hljs-number">1</span>]].<span class="hljs-built_in">emplace_back</span>(info[<span class="hljs-number">0</span>]);<br>        &#125;<br><br>        <span class="hljs-comment">//遍历所有节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; state.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">if</span>(state[i] == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//若节点未被搜索</span><br>                <span class="hljs-built_in">dfs</span>(i);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!res) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//如果出现环路 结束遍历</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;<br><br>        <span class="hljs-comment">//开始时将自己设置为搜索中</span><br>        state[u] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//对自己的邻接节点进行遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; v : edges[u])&#123;<br><br>            <span class="hljs-keyword">if</span>(state[v] == <span class="hljs-number">0</span>) <span class="hljs-built_in">dfs</span>(v);<span class="hljs-comment">//如果相邻节点未被搜索</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(state[v] == <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//如果遍历到一个正在搜索的节点,说明出现环路</span><br>                res = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//结束后设置自己的状态为已搜索</span><br>        state[u] = <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路与&lt;&lt;<strong>210. 课程表 II</strong>&gt;&gt;一致</p><h2 id="拓扑排序-广度优先搜索"><a href="#拓扑排序-广度优先搜索" class="headerlink" title="拓扑排序+广度优先搜索"></a>拓扑排序+广度优先搜索</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; edges;<span class="hljs-comment">//邻接矩阵</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; indeg;<span class="hljs-comment">//入度表</span><br>    <br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br><br>        <span class="hljs-comment">//初始化入度表</span><br>        indeg.<span class="hljs-built_in">resize</span>(numCourses);<br>        <span class="hljs-comment">//初始化邻接矩阵</span><br>        edges.<span class="hljs-built_in">resize</span>(numCourses);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; info : prerequisites)&#123;<br>            edges[info[<span class="hljs-number">1</span>]].<span class="hljs-built_in">emplace_back</span>(info[<span class="hljs-number">0</span>]);<br>            ++indeg[info[<span class="hljs-number">0</span>]];<br>        &#125;<br><br>        <span class="hljs-comment">//将所有入度为0的节点放入队列中</span><br>        queue&lt;<span class="hljs-keyword">int</span>&gt; node_queue;<br>        <span class="hljs-keyword">int</span> find_node_cnt = <span class="hljs-number">0</span>;<span class="hljs-comment">//已找到的节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; indeg.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">if</span>(indeg[i] == <span class="hljs-number">0</span>) &#123;<br>                node_queue.<span class="hljs-built_in">push</span>(i);<br>                ++find_node_cnt;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(!node_queue.<span class="hljs-built_in">empty</span>())&#123;<br><br>            <span class="hljs-keyword">int</span> u = node_queue.<span class="hljs-built_in">front</span>();node_queue.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; v : edges[u])&#123;<span class="hljs-comment">//遍历每一个邻接节点</span><br>                <br>                --indeg[v];<span class="hljs-comment">//将邻接节点的入度-1</span><br>                <span class="hljs-keyword">if</span>(indeg[v] == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//若邻接节点的入度为0,将其加入队列</span><br>                    ++find_node_cnt;<br>                    node_queue.<span class="hljs-built_in">push</span>(v);<br>                &#125;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> find_node_cnt == numCourses;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>思路与&lt;&lt;<strong>210. 课程表 II</strong>&gt;&gt;一致</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度优先搜索</tag>
      
      <tag>图</tag>
      
      <tag>广度优先搜索</tag>
      
      <tag>拓扑排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>318. 最大单词长度乘积</title>
    <link href="/2021/01/23/LeetCode/318.%20%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/"/>
    <url>/2021/01/23/LeetCode/318.%20%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/">本题链接</a></p><h2 id="位运算-哈希表"><a href="#位运算-哈希表" class="headerlink" title="位运算+哈希表"></a>位运算+哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;<br><br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; hash;<br><br>        <span class="hljs-comment">//对每一个字符串建立在哈希表中的映射</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; s : words)&#123;<br>            <span class="hljs-comment">//mask用来表现字符串中出现过的字母</span><br>            <span class="hljs-keyword">int</span> mask = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> size = s.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; c : s)<br>                mask |= <span class="hljs-number">1</span> &lt;&lt; (c-<span class="hljs-string">&#x27;a&#x27;</span>);<br>            <span class="hljs-comment">//同个mask下选取一个最大的size</span><br>            <span class="hljs-comment">//比如aasd和asd中,选择aasd的size</span><br>            hash[mask] = <span class="hljs-built_in">max</span>(hash[mask],size);<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; [mask1,size1] : hash)<span class="hljs-comment">//选取第一个值</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; [mask2,size2] : hash)<span class="hljs-comment">//选取第二个值</span><br>                <span class="hljs-keyword">if</span>(!(mask1 &amp; mask2)) <span class="hljs-comment">//如果两者没有公共的字母</span><br>                    res = <span class="hljs-built_in">max</span>(res,size1*size2);<span class="hljs-comment">//那么选取一个最大的结果</span><br>            <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于题目已经约定都是小写字母，数量是26个，那么可以用一个32位的整数来表示在一个字符串中，哪些字符出现过。</p><script type="math/tex; mode=display">mask |= 1 << (c-'a')</script><p>其中，<code>c-&#39;a&#39;</code>表示1需要向左移动几位，1左移后，与mask相或，就可以在mask中的相应位置1。</p><p>之后在哈希表中对<code>size</code>两两相乘，选取一个最大的结果。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>340. 至多包含 K 个不同字符的最长子串</title>
    <link href="/2021/01/23/LeetCode/340.%20%E8%87%B3%E5%A4%9A%E5%8C%85%E5%90%AB%20K%20%E4%B8%AA%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2021/01/23/LeetCode/340.%20%E8%87%B3%E5%A4%9A%E5%8C%85%E5%90%AB%20K%20%E4%B8%AA%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-k-distinct-characters/">本题链接</a></p><h2 id="暴力-双指针-超时"><a href="#暴力-双指针-超时" class="headerlink" title="暴力+双指针(超时)"></a>暴力+双指针(超时)</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstringKDistinct</span><span class="hljs-params">(string s, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span> &amp;&amp; k &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> k;<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">int</span> org = <span class="hljs-number">0</span>,next = <span class="hljs-number">0</span>,cnt = k,max = <span class="hljs-number">0</span>;<br>        set&lt;<span class="hljs-keyword">char</span>&gt; c_set;<br><br>        <span class="hljs-keyword">for</span>(;org &lt; s.<span class="hljs-built_in">size</span>() - max &amp;&amp; next &lt;  s.<span class="hljs-built_in">size</span>(); ++next)&#123;<br>            <br>            <span class="hljs-keyword">if</span>( c_set.<span class="hljs-built_in">find</span>(s[next]) == c_set.<span class="hljs-built_in">end</span>() )<span class="hljs-comment">//不存在</span><br>            &#123;  <br>                <span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">0</span>)&#123;<br><br>                    <span class="hljs-keyword">if</span>((next  - org) &gt; max) max = next - org;<br>                    next = ++org;<br>                    next--;<br>                    c_set.<span class="hljs-built_in">clear</span>();<br>                    cnt = k;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                c_set.<span class="hljs-built_in">insert</span>(s[next]);<br>                cnt--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>((next  - org) &gt; max) max = next - org;<br><br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>保证在org和next指针之间的字符数量不会超过k，若超过便移动org指针。以此反复迭代查找最大字串。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>221. 最大正方形</title>
    <link href="/2021/01/22/LeetCode/221.%20%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <url>/2021/01/22/LeetCode/221.%20%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/maximal-square/">本题链接</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">int</span> row;<br>    <span class="hljs-keyword">int</span> col;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-comment">//初始化</span><br>        row = matrix.<span class="hljs-built_in">size</span>();<br>        col = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//初始化dp</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(row,vector&lt;<span class="hljs-keyword">int</span>&gt;(col,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;r &lt; row;++r)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;c &lt; col;++c)<br>                <span class="hljs-keyword">if</span>(matrix[r][c] == <span class="hljs-string">&#x27;1&#x27;</span>) dp[r][c] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//逐行逐列</span><br>        <span class="hljs-keyword">int</span> max_c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;r &lt; row;++r)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;c &lt; col;++c)<br>                <span class="hljs-keyword">if</span>(dp[r][c])&#123;<span class="hljs-comment">//非0</span><br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isLegal</span>(r,c<span class="hljs-number">-1</span>,dp) &amp;&amp; <span class="hljs-built_in">isLegal</span>(r<span class="hljs-number">-1</span>,c,dp) &amp;&amp; <span class="hljs-built_in">isLegal</span>(r<span class="hljs-number">-1</span>,c<span class="hljs-number">-1</span>,dp))&#123;<span class="hljs-comment">//如果该点能够合法的作为正方形的右下角  </span><br>                        dp[r][c] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(dp[r][c<span class="hljs-number">-1</span>],dp[r<span class="hljs-number">-1</span>][c<span class="hljs-number">-1</span>]),dp[r<span class="hljs-number">-1</span>][c]) + <span class="hljs-number">1</span>;<span class="hljs-comment">//获取min(左上,左边,右边)</span><br>                    &#125; <br>                    <span class="hljs-keyword">if</span>(max_c &lt; dp[r][c]) max_c = dp[r][c];<span class="hljs-comment">//判断哪个更大</span><br>                &#125;<br><br>        <span class="hljs-keyword">return</span> max_c * max_c;<br>    &#125;<br><br>    <span class="hljs-comment">//注意:单个1是个例外,无论判断与否都不影响结果 比如矩阵左上角的1</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isLegal</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; r,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; c,vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; dp)</span></span>&#123;<br>        <br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= r &amp;&amp; r &lt; row)<span class="hljs-comment">//如果在区间内</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= c &amp;&amp; c &lt; col)<span class="hljs-comment">//如果在区间内</span><br>                <span class="hljs-keyword">if</span>(!dp[r][c]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果值为0</span><br>                <span class="hljs-keyword">else</span>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>以当前遍历的元素作为正方形的右下角，可得状态方程：</p><script type="math/tex; mode=display">dp[r][c] = min(dp[r][c-1],dp[r-1][c-1],dp[r-1][c]) + 1;</script>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>524. 通过删除字母匹配到字典里最长单词</title>
    <link href="/2021/01/20/LeetCode/524.%20%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/"/>
    <url>/2021/01/20/LeetCode/524.%20%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">本题链接</a></p><h2 id="双指针-暴力"><a href="#双指针-暴力" class="headerlink" title="双指针+暴力"></a>双指针+暴力</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">findLongestWord</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; dictionary)</span> </span>&#123;<br><br>        <span class="hljs-comment">//异常情况</span><br>        <span class="hljs-keyword">if</span>(dictionary.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-built_in">sort</span>(dictionary.<span class="hljs-built_in">begin</span>(),dictionary.<span class="hljs-built_in">end</span>(),[](string&amp; a,string&amp; b)&#123;<br>               <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>() == b.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">compare</span>(b) &lt; <span class="hljs-number">0</span>;<br>               <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>() &gt; b.<span class="hljs-built_in">size</span>();<br>            &#125;);<br>        &#125;<br><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; str:dictionary)&#123;<br>            <br>            <span class="hljs-keyword">int</span> p_dic = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; p_dic != str.<span class="hljs-built_in">size</span>(); i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(s[i] == str[p_dic]) ++p_dic;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(p_dic == str.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> str;<br><br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> string&#123;<span class="hljs-string">&quot;&quot;</span>&#125;;<br>    &#125;<br><br><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>只要将字典按照字典序和长度排序，然后剩下的事情就是用两个指针，一个指针指向字符串，一个指针指向排序后的字符串就行。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>204. 计数质数</title>
    <link href="/2021/01/18/LeetCode/204.%20%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/"/>
    <url>/2021/01/18/LeetCode/204.%20%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/count-primes/">本题链接</a></p><h2 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">prime</span><span class="hljs-params">(n + <span class="hljs-number">1</span>,<span class="hljs-literal">true</span>)</span></span>;<span class="hljs-comment">//假设n之前的所有数都为质数</span><br>        <span class="hljs-keyword">int</span> cnt = n - <span class="hljs-number">2</span>;<span class="hljs-comment">//去掉不是质数的0和1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= n; ++i)&#123;<span class="hljs-comment">//从2开始对n遍历</span><br>            <span class="hljs-keyword">if</span>(prime[i])&#123;<span class="hljs-comment">//如果i是质数</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span> * i;j &lt; n;j += i)&#123;<span class="hljs-comment">//寻找i的倍数j</span><br>                    <span class="hljs-keyword">if</span>(prime[j])&#123;<span class="hljs-comment">//如果j依然被标记为质数</span><br>                        prime[j] = <span class="hljs-literal">false</span>;<span class="hljs-comment">//将j的质数标记去除</span><br>                        --cnt;<span class="hljs-comment">//计数-1</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>埃氏筛法是非常常用的，判断一个整数是否是质数的方法。并且它可以在判断一个整数n时，同时判断所小于n的整数。其原理也十分易懂：从1到n遍历，假设当前遍历到m，则把所有小于n的、且是m的倍数的整数标记为和数；遍历完成后，没有被标记为和数的数字即为质数。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>埃氏筛法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>665. 非递减数列</title>
    <link href="/2021/01/17/LeetCode/665.%20%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/"/>
    <url>/2021/01/17/LeetCode/665.%20%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/non-decreasing-array/">本题链接</a></p><h2 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">checkPossibility</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">//异常处理</span><br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt;<span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">//预处理</span><br>        nums.<span class="hljs-built_in">insert</span>(nums.<span class="hljs-built_in">begin</span>(),INT_MIN);<br><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span> &amp;&amp; count &lt; <span class="hljs-number">2</span>;i++)<br>        &#123; <br>            <span class="hljs-keyword">if</span>(nums[i] &gt; nums[i+<span class="hljs-number">1</span>])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[i<span class="hljs-number">-1</span>] &lt;= nums[i+<span class="hljs-number">1</span>] ) &#123; nums[i] = nums[i<span class="hljs-number">-1</span>]; ++count; &#125;<br>                <span class="hljs-keyword">else</span> &#123; nums[i+<span class="hljs-number">1</span>] = nums[i];++count;&#125;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> count &lt; <span class="hljs-number">2</span>;<br><br>       <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>可以通过贪心策略让局部达到最优，让需要更改的值尽可能的小，以便于让后面的值可以满足非递增的要求。分析实际情况，会得出每次下降只会是以下两种情况：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/381a90cae8ea2a09d35c41b43736c8aa-198c4.png" style="zoom:50%;" /></p><p>遍历的前提是：遍历的每个点的左侧都已经是非降状态。为了保证算法正常运行，所以在第一个点的左侧插入一个无限小的值，那么第一个点一定满足。之后从第一个点开始遍历到最后，只需考察每个点的右侧即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>88. 合并两个有序数组</title>
    <link href="/2021/01/15/LeetCode/88.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2021/01/15/LeetCode/88.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/">本题链接</a></p><h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-keyword">int</span> m, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> pos = m-- + --n ;<br>        <span class="hljs-keyword">while</span>(n &gt;= <span class="hljs-number">0</span>)<br>        &#123;   <br>            nums1[pos--] = m &gt;= <span class="hljs-number">0</span> &amp;&amp; nums1[m] &gt;= nums2[n] ? nums1[m--] : nums2[n--];<br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据题意使用双指针，同时自后向前遍历即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>112. 路径总和</title>
    <link href="/2021/01/14/LeetCode/112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <url>/2021/01/14/LeetCode/112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/path-sum/">本题链接</a></p><h2 id="递归-dfs"><a href="#递归-dfs" class="headerlink" title="递归+dfs"></a>递归+dfs</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; targetSum)</span> </span>&#123;<br><br>        <span class="hljs-comment">//出现在节点只有一个孩子的向下递归情况</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">//出现在叶子节点</span><br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;<br>            <span class="hljs-keyword">if</span>(targetSum == root-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasPathSum</span>(root-&gt;left,targetSum - root-&gt;val)||<span class="hljs-built_in">hasPathSum</span>(root-&gt;right,targetSum - root-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于题目要求是从根节点到叶子节点，所以只有当递归函数进入到叶子节点时才能知道是否满足结果。还有就是对于任何一个节点来说，只要它的左右孩子中有一个满足条件，那么这个节点就是满足条件的。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>763. 划分字母区间</title>
    <link href="/2021/01/11/LeetCode/763.%20%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/"/>
    <url>/2021/01/11/LeetCode/763.%20%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/partition-labels/">本题链接</a></p><h2 id="哈希表-贪心-暴力"><a href="#哈希表-贪心-暴力" class="headerlink" title="哈希表+贪心+暴力"></a>哈希表+贪心+暴力</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-comment">//异常处理</span><br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;<span class="hljs-number">1</span>&#125;;<br><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; index_vec;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; index_map;  <br>        <span class="hljs-keyword">auto</span> index_it = index_map.<span class="hljs-built_in">end</span>();<br>        <br>        <span class="hljs-comment">//预处理1:整理字符串出现的头尾位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>();i++)<br>        &#123;   <br>            index_it = index_map.<span class="hljs-built_in">find</span>(s[i]);<br>            <span class="hljs-keyword">if</span>(index_it != index_map.<span class="hljs-built_in">end</span>())<span class="hljs-comment">//找到该字符</span><br>            &#123;   <br>                <span class="hljs-comment">//刷新位置</span><br>                index_vec[index_it-&gt;second][<span class="hljs-number">1</span>] = i;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                index_vec.<span class="hljs-built_in">push_back</span>(&#123;i,i&#125;);<span class="hljs-comment">//插入第一次出现的位置</span><br>                index_map.<span class="hljs-built_in">insert</span>(&#123;s[i],index_vec.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>&#125;);<br>            &#125;<br>            <br>        &#125;<br><br>        <span class="hljs-comment">//预处理2:排序</span><br>        <span class="hljs-built_in">sort</span>(index_vec.<span class="hljs-built_in">begin</span>(),index_vec.<span class="hljs-built_in">end</span>(),[](vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; a,vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; b)&#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>        &#125;);<br><br>        <span class="hljs-keyword">int</span> lo = index_vec[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> hi = index_vec[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; index_vec.<span class="hljs-built_in">size</span>(); i++)&#123;<br><br>                <span class="hljs-keyword">if</span>( hi &gt; index_vec[i][<span class="hljs-number">0</span>])<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(hi &lt;index_vec[i][<span class="hljs-number">1</span>])<br>                        hi = index_vec[i][<span class="hljs-number">1</span>];<br>                &#125; <br>                <span class="hljs-keyword">else</span> <br>                &#123;   <br>                    res.<span class="hljs-built_in">push_back</span>(hi-lo+<span class="hljs-number">1</span>);<br>                    lo = index_vec[i][<span class="hljs-number">0</span>];<br>                    hi = index_vec[i][<span class="hljs-number">1</span>];<br>                &#125;<br>        &#125;<br><br>        res.<span class="hljs-built_in">push_back</span>(hi-lo+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>存储每个字符的起始和终止位置，然后根据贪心策略，让字符尽可能的挤在相同的一块区域。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>字符串</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>279. 完全平方数</title>
    <link href="/2021/01/04/LeetCode/279.%20%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <url>/2021/01/04/LeetCode/279.%20%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/perfect-squares/">本题链接</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,INT_MAX)</span></span>;<span class="hljs-comment">//dp[0] = 0;</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;++i)<span class="hljs-comment">//遍历1~n</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>;k*k &lt;= i;++k)<br>                dp[i] = <span class="hljs-built_in">min</span>(dp[i],dp[i - k*k] + <span class="hljs-number">1</span>);<br>      <br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据题意推出状态方程：</p><script type="math/tex; mode=display">dp[i] = min(dp[i],dp[i - k^2]+1)</script><p>其中，$dp[i]$表示i需要的最少的完全平方数数量，$dp[i - k^2]+1$中，1表示$k^2$的数量。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>77. 组合</title>
    <link href="/2021/01/04/LeetCode/77.%20%E7%BB%84%E5%90%88/"/>
    <url>/2021/01/04/LeetCode/77.%20%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/combinations/">本题链接</a></p><h2 id="回溯法-递归"><a href="#回溯法-递归" class="headerlink" title="回溯法+递归"></a>回溯法+递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">int</span> k;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>    <br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k) &#123;<br><br>        <span class="hljs-keyword">this</span>-&gt;n = n;<br>        <span class="hljs-keyword">this</span>-&gt;k = k;<br>        <span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(tmp.<span class="hljs-built_in">size</span>() == k)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = start;tmp.<span class="hljs-built_in">size</span>() &lt; k &amp;&amp; i &lt;= n;++i)&#123;<br><br>            tmp.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">func</span>(i + <span class="hljs-number">1</span>);<br>            tmp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每次取一个数，然后从剩下的数中再取一个数..直至一共取了k个数，就把结果放入数组中。整个过程持续迭代,直到遍历数超过n。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>回溯法</tag>
      
      <tag>组合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>79. 单词搜索</title>
    <link href="/2021/01/03/LeetCode/79.%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"/>
    <url>/2021/01/03/LeetCode/79.%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/word-search/">本题链接</a></p><h2 id="dfs-递归"><a href="#dfs-递归" class="headerlink" title="dfs+递归"></a>dfs+递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">int</span> dirc[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<span class="hljs-comment">//上 右 下 左</span><br>    <span class="hljs-keyword">int</span> row;<br>    <span class="hljs-keyword">int</span> col;<br>    <span class="hljs-comment">//set&lt;pair&lt;int,int&gt;&gt; re_set;</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;<br><br>        row = board.<span class="hljs-built_in">size</span>();<br>        col = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">state_vec</span>(row,vector&lt;<span class="hljs-keyword">bool</span>&gt;(col,<span class="hljs-literal">false</span>));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;r &lt; row;++r)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;c &lt; col;++c)<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(&#123;r,c&#125;,<span class="hljs-number">0</span>,board,word,state_vec)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&amp; point,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; pos,<span class="hljs-keyword">const</span> vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board,<span class="hljs-keyword">const</span> string&amp; word,vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt;&amp; state_vec)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(pos == word.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//如果找到所有的字符,就返回真</span><br>            <br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isLegal</span>(point) || board[point.first][point.second] != word[pos] || state_vec[point.first][point.second]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果这个点不符合要求</span><br>        state_vec[point.first][point.second] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//if(!isLegal(point) || board[point.first][point.second] != word[pos] || re_set.find(point) != re_set.end()) return false;//如果这个点不符合要求</span><br>        <span class="hljs-comment">//re_set.insert(point);</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> d = <span class="hljs-number">0</span>;d &lt; <span class="hljs-number">4</span>;++d) <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(&#123;point.first+dirc[d],point.second+dirc[d+<span class="hljs-number">1</span>]&#125;,pos + <span class="hljs-number">1</span>,board,word,state_vec)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        state_vec[point.first][point.second] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//re_set.erase(point);</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isLegal</span><span class="hljs-params">(<span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&amp; point)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= point.second &amp;&amp; point.second &lt; col)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= point.first &amp;&amp; point.first &lt; row)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路其实就是对每一个有可能的点进行dfs，然后为了避免回溯，就需要存储每个点是否被访问的状态。我一开始用的是set来保存每个点，后面超时了就更换了一个二维数组。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>342. 4的幂</title>
    <link href="/2020/12/30/LeetCode/342.%204%E7%9A%84%E5%B9%82/"/>
    <url>/2020/12/30/LeetCode/342.%204%E7%9A%84%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/power-of-four/">本题链接</a></p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPowerOfFour</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-comment">//如果n小于0或者n中比特位的1不止一个</span><br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span> || n &amp; (n - <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//相与若为0,则不是4的幂次方</span><br>        <span class="hljs-keyword">return</span> n &amp; <span class="hljs-number">0x55555555</span>;<br>        <span class="hljs-comment">// return num % 3 == 1;也可以</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为4的幂在比特位的形式上与2的幂相似，都是二进制中只有一个1，然后这个1一定待在比特位的奇数位上。所以可以用10101…10101这种形式的与它相与，若结果不为0，说明就是4的幂。</p><p>另外，对于<code>return num % 3 == 1</code>的解释如下：</p><blockquote><p>由于 4=3+1， 那么4的N次方就是（3+1）^N，尝试展开多项式，比如(3+1)^2 =(3+1)<em>(3+1)，除了1</em>1以外永远都有3相乘，再展开3次方，(3+1)<em>(3+1)</em>(3+1)，结论一致，除了结尾的1都有3相乘，因此可以有结论，一个数的N次方-1总能除尽比这个数小1的数。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xxx atribute should be defined</title>
    <link href="/2020/12/29/Android/%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/xxx_atribute_should_be_defined/"/>
    <url>/2020/12/29/Android/%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/xxx_atribute_should_be_defined/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h2><h3 id="1-’xxx’-atribute-should-be-defined"><a href="#1-’xxx’-atribute-should-be-defined" class="headerlink" title="1.’xxx’ atribute should be defined"></a>1.’xxx’ atribute should be defined</h3><p>在一开始自定义shape和selector的时候，会有 <strong>‘xxx’ attribute should be defined</strong>的问题。主要原因是xml文件存放的文件夹有错，应该放在drawable文件夹下。<br><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201228171559.png" alt=""><br><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201228171732.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>错误记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>257. 二叉树的所有路径</title>
    <link href="/2020/12/28/LeetCode/257.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"/>
    <url>/2020/12/28/LeetCode/257.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/binary-tree-paths/">本题链接</a></p><h2 id="DFS-递归"><a href="#DFS-递归" class="headerlink" title="DFS+递归"></a>DFS+递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    string s;<br>    vector&lt;string&gt; res;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* node)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//节点为空就返回</span><br><br>        string val_str = <span class="hljs-built_in">to_string</span>(node-&gt;val);<br>        s = s + val_str + <span class="hljs-string">&quot;-&gt;&quot;</span>;<span class="hljs-comment">//字符串拼接</span><br>        <span class="hljs-keyword">bool</span> bl_res;<br><br>        <span class="hljs-keyword">if</span>(((bl_res = <span class="hljs-built_in">dfs</span>(node-&gt;left)) == <span class="hljs-built_in">dfs</span>(node-&gt;right)) &amp;&amp; (bl_res == <span class="hljs-literal">false</span>))&#123;<span class="hljs-comment">//node为叶子节点</span><br><br>            s.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//&quot;&gt;&quot;</span><br>            s.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//&quot;-&quot;</span><br>            res.<span class="hljs-built_in">push_back</span>(s);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; val_str.<span class="hljs-built_in">size</span>();++i)<span class="hljs-comment">//&quot;&quot;</span><br>                s.<span class="hljs-built_in">pop_back</span>();<br>            <br>            <br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//node非叶子节点</span><br><br>           s.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//&quot;&gt;&quot;</span><br>           s.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//&quot;-&quot;</span><br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; val_str.<span class="hljs-built_in">size</span>();++i)<br>                s.<span class="hljs-built_in">pop_back</span>();<br>            <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对每一个节点进行DFS，然后每次进入一个节点就构造字符串，退出该节点的时候表示这个节点已经结束了，就把刚才构造的字符串取消掉。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Startup</title>
    <link href="/2020/12/27/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Startup/"/>
    <url>/2020/12/27/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Startup/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li>StartupCode的重要功能：让静态对象的构造函数正确的被调用</li><li>main()是由启动码函数调用</li></ul><h2 id="mainCRTStartup"><a href="#mainCRTStartup" class="headerlink" title="mainCRTStartup()"></a>mainCRTStartup()</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/54dc87706cafbf193f1a014a2af24970-5ee36.png" alt="C++程序的运行调用栈" style="zoom:100%;" /></p><ol><li><code>_heap_init()</code>：初始化堆内存</li><li><code>_ioinit()</code>：IO初始化<ul><li>任何一个C++程序第一次分配内存的大小都是256</li></ul></li><li><code>GetCommandLineA()</code>：命令行参数初始化。</li><li><code>_crtGetEnvironmentStringsA()</code>：环境变量初始化。从操作系统获取环境变量，并申请空间来存放这些环境变量。</li><li><code>_setargv()</code>：设置命令行参数。<img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/05dad4c0dbed55a7e04b9da98315d795-c474a.png" alt="设置命令行参数。"></li><li><code>_setenvp()</code>：分配<code>_crtGetEnvironmentStringsA()</code>刚才保存的环境变量，将它们存放在一个表中。其中，<code>_environ</code>指向这个表。<ul><li><code>_setenvp()</code>一共执行了n次内存分配操作，n等于一次表的内存分配+k个环境变量的内存分配，其中表的内存分配大小等于k个环境变量的指针大小再加上一个末尾的0。即$sizeof(表)=(k+1)*4$。（效果同<code>_setargv()</code>）<img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b37fc061c3c963ffd880c6e723d93471-dba61.png" style="zoom: 100%;" /></li><li>归还之前<code>_crtGetEnvironmentStringsA()</code>临时保存环境变量的内存。</li></ul></li></ol><p>3，4，5，6都在处理字符串</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/3d90aa9de9a2d03fe3386692e2c88316-1894d.png" alt=""></p><h2 id="WindowsXP-sp2-Heap"><a href="#WindowsXP-sp2-Heap" class="headerlink" title="WindowsXP-sp2 Heap"></a>WindowsXP-sp2 Heap</h2><ul><li>win上采用<strong>前区块</strong>来取代<strong>下cookie</strong></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6c367818cbe928e82625201a7ab44cb7-c6411.png" style="zoom:100%;" /></p><ul><li>debug信息是附加在内存块的尾部</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/98f2c9918d2fee82b83d8ae8b50ac89f-ff0a8.png" style="zoom: 100%;" /></p><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><ul><li>I/O泛指程序与外界的各种交互作用，包括file，pipe，network，console，semaphore等等，或泛指能被OS理解为file的任何事务，file在此是一个广义概念。</li><li>C通过一个pointer to FILE来进行file操作。在OS层面，Linux对应FILE的是File Descriptor（fd）,Windows对应的则是file handle，二者都用来映射kernel file object。</li><li>fd具体是个index of opened file table，一个进程拥有的的这个table是个array of pointers，每个pointer指向一个kernel opened object。当client开启一个file，OS会建立一个（kernel）opened file object并找到上述table中的一个idle entry指向之，然后以该entry的index作为fd。此table位于kernel mode，因此client即使拥有fd<strong>亦无法</strong>获得table address。Linux的fd中，0，1，2分别代表stdin、stdout、stderr。</li><li>C的File与Linux的fd必有一对一的关系。只要有table address p（kernel mode中才可得），p+fd就只想opened file table的某个entry，从而可得kernel file object。</li><li>Windows的file handle和Linux的fd大同小异，但handle不是index，而是index经某种变换后的结果。</li><li>ioinit就是要在client space中建立起stdin，stdout，stderr及其对应的FILEs，使程序进入main()之后立即可用printf()，scanf()等函数。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a72dd579fe9d4a3b0e7a7ec0afb459a8-ff92f.png" style="zoom: 100%;" /></p><ul><li>ioinfo对应了我们写的程序中的FILE（一对一）</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9d38b8e139329e440bd76a40bd36105d-db095.png" style="zoom:100%;" /></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/d9dd37a8490234a9b7eb62a00de58928-c1840.png" style="zoom:100%;" /></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
      <tag>CRT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>240. 搜索二维矩阵 II</title>
    <link href="/2020/12/26/LeetCode/240.%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%20II/"/>
    <url>/2020/12/26/LeetCode/240.%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%20II/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">本题链接</a></p><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br><br>       <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">int</span> row = matrix.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>,col = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> cow_border = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">while</span>(row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt;= cow_border)&#123;<br><br>            <span class="hljs-keyword">if</span>(matrix[row][col] &gt; target) --row;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[row][col] &lt; target) ++col;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一开始还想着根据行对列进行二分查找，但是使用二分查找非常容易越过可能的搜索区域。</p><p>后面发现只要从矩阵左下角，每次向上或向右遍历就可以遍历完整个矩阵。而且从左下角出发的优势在于，当前元素大于上面的元素且小于右边的元素，这样迭代就不会有两个方向，可以把搜索范围缩小。而如果从左上角开始，每次向下或向右遍历，虽然也能遍历完整个矩阵，但是由于当前元素同时小于下边和右边的元素，所以迭代会有两个方向，在不理想的情况下需要回溯处理。</p><p>同理，从右上角也可以开始。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>二维数组</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL：allocator</title>
    <link href="/2020/12/24/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/STL%EF%BC%9Aallocator/"/>
    <url>/2020/12/24/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/STL%EF%BC%9Aallocator/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9f392e29eaa3de0bce406431de47678e-57e69.png" alt="运行模式"></p><ul><li>STL：allocator的客户是STL的容器，如果在容器以外用的话会很麻烦，因为要记录使用的内存大小，以便于销毁的时候需要将大小告诉<code>deallocator</code>，让<code>deallocator</code>找到<code>free_list</code>的对应节点。</li><li><code>free_list</code>管理了16个节点，这16个节点从下标0到下标15，依次管理着8bytes、16bytes、24bytes、32bytes…128bytes的内存区域（按照8bytes增长）。</li><li>通过分配器分配的内存大小，在分配器内部会被设置为某个数的倍数，也就是类似内存对齐。原因是只有对象的size大于等于指针的大小（比如四字节），才能在未分配的内存块里使用指针。<code>vector&lt;bool&gt;</code>可能是个不好的用法，因为浪费了很多内存。</li><li><code>allocator</code>内存分配链表中的不同节点，指向的一大块内存区域都被等分为<strong>20</strong>块相同的内存块。就比如负责32bytes的节点，指向一共有20块大小为32bytes的内存区域，这块内存区域的大小即为20*32bytes。</li><li>如果内存区域用光了，如果有备用空间的话，就拿备用空间的内存，没有的话就向malloc申请一块2*20*(所需空间大小)的内存区域。比如这时候假设需要96bytes的空间，且没有备用空间，那么分配器会向malloc申请2<em>20个96btyes大小的空间，然后用前面的20个来给96bytes用，剩下的20\</em>96bytes的空间将成为备用空间。此时再要申请128bytes的内存块，又因为内存分配链表中，管理128bytes的节点中没有内容，那么就会将备用空间拿来用，划分内存块的流程是20*96bytes/128bytes，即划分为10*128bytes。（这个只是简单流程，更具体的流程看PDF）</li><li><code>start_free</code>和<code>end_free</code>指向备用区域（内存池）的头尾两端。</li><li>每次向<code>malloc</code>申请内存时都会有个追加量。</li><li><code>allocate</code>和<code>deallocate</code>都会先判断元素大小是否合法，如果不合法将调用第一级别的<code>allocate</code>和<code>deallocate</code>。</li><li>如果传入<code>deallocate</code>的对象指针p并非当初从<code>allocate</code>所得，在size参数合法的情况下，p依然会被并入到<code>free_list</code>中去。如果p所指的大小不是8的倍数，甚至会带来灾难。</li><li><code>chunk_alloc</code>中对碎片的处理：将碎片插入到合适的#号free-list中，一般情况是将节点接入链表的中间区域，而不一定是链表的最末尾。</li><li><code>deallocate</code>完全没有调用<code>free</code>和<code>delete</code>，源于其设计上的先天缺陷。</li></ul><h3 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h3><h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/e58fed98c2c7536e2576006a55cd8f90-f4728.png"  /></p><h4 id="将C-allocator转移到C"><a href="#将C-allocator转移到C" class="headerlink" title="将C++ allocator转移到C"></a>将C++ allocator转移到C</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/e8a2e33a35b2a1c866eee7bf827676fe-e9261.png" alt="C++"  /></p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><h5 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">obj* *p1,*p2;<span class="hljs-comment">//等效于下面代码</span><br>obj **p1,*p2;<span class="hljs-comment">//等效于下面代码</span><br>obj** p1;obj* p2;<br></code></pre></div></td></tr></table></figure><h5 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">void</span><span class="hljs-params">(*set_malloc_handler(<span class="hljs-keyword">void</span> (*f)()))</span><span class="hljs-params">()</span></span><br></code></pre></div></td></tr></table></figure><p>等效于</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*new_handler)</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(new_handler p)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br></code></pre></div></td></tr></table></figure><p>也等效于</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*H)</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> H <span class="hljs-title">set_malloc_handler</span><span class="hljs-params">(H f)</span></span>;<br></code></pre></div></td></tr></table></figure><h2 id="allocator源码"><a href="#allocator源码" class="headerlink" title="allocator源码"></a>allocator源码</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span>  <span class="hljs-comment">//for malloc(),realloc()</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;</span>  <span class="hljs-comment">//for size_t</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory.h&gt;</span>  <span class="hljs-comment">//for memcpy()</span></span><br><br><span class="hljs-comment">//#define __THROW_BAD_ALLOC   cerr &lt;&lt; &quot;out of memory&quot; &lt;&lt; endl; exit(1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __THROW_BAD_ALLOC   exit(1)</span><br><br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">// 第1級配置器。</span><br><span class="hljs-comment">//----------------------------------------------</span><br><br><span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*oom_handler)() = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">oom_malloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*my_malloc_handler)();<br>  <span class="hljs-keyword">void</span>* result;<br><br>  <span class="hljs-keyword">for</span> (;;) &#123;    <span class="hljs-comment">//不斷嘗試釋放、配置、再釋放、再配置…</span><br>    my_malloc_handler = oom_handler;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;<br>    (*my_malloc_handler)();    <span class="hljs-comment">//呼叫處理常式，企圖釋放記憶體</span><br>    result = <span class="hljs-built_in">malloc</span>(n);        <span class="hljs-comment">//再次嘗試配置記憶體</span><br>    <span class="hljs-keyword">if</span> (result) <span class="hljs-keyword">return</span>(result);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">oom_realloc</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *p, <span class="hljs-keyword">size_t</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*my_malloc_handler)();<br>  <span class="hljs-keyword">void</span>* result;<br><br>  <span class="hljs-keyword">for</span> (;;) &#123;    <span class="hljs-comment">//不斷嘗試釋放、配置、再釋放、再配置…</span><br>    my_malloc_handler = oom_handler;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;<br>    (*my_malloc_handler)();    <span class="hljs-comment">//呼叫處理常式，企圖釋放記憶體。</span><br>    result = <span class="hljs-built_in">realloc</span>(p, n);    <span class="hljs-comment">//再次嘗試配置記憶體。</span><br>    <span class="hljs-keyword">if</span> (result) <span class="hljs-keyword">return</span>(result);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">malloc_allocate</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">void</span> *result = <span class="hljs-built_in">malloc</span>(n);   <span class="hljs-comment">//直接使用 malloc()</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == result) result = <span class="hljs-built_in">oom_malloc</span>(n);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">malloc_deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-keyword">size_t</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">free</span>(p);  <span class="hljs-comment">//直接使用 free()</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">malloc_reallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *p, <span class="hljs-keyword">size_t</span> old_sz, <span class="hljs-keyword">size_t</span> new_sz)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">void</span>* result = <span class="hljs-built_in">realloc</span>(p, new_sz); <span class="hljs-comment">//直接使用 realloc()</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == result) result = <span class="hljs-built_in">oom_realloc</span>(p, new_sz);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*<span class="hljs-built_in">set_malloc_handler</span>(<span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*f)()))()<br>&#123; <span class="hljs-comment">//類似 C++ 的 set_new_handler().</span><br>  <span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*old)() = oom_handler;<br>  oom_handler = f;<br>  <span class="hljs-keyword">return</span>(old);<br>&#125;<br><br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">//第二級配置器</span><br><span class="hljs-comment">//----------------------------------------------</span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span>__ALIGN = <span class="hljs-number">8</span>&#125;;                        <span class="hljs-comment">//小區塊的上調邊界</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span>__MAX_BYTES = <span class="hljs-number">128</span>&#125;;                  <span class="hljs-comment">//小區塊的上限</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span>__NFREELISTS = __MAX_BYTES/__ALIGN&#125;; <span class="hljs-comment">//free-lists 個數</span><br><br><span class="hljs-comment">// union obj &#123;                   //G291[o],CB5[x],VC6[x]</span><br><span class="hljs-comment">//   union obj* free_list_link;  //這麼寫在 VC6 和 CB5 中也可以，</span><br><span class="hljs-comment">// &#125;;                            //但以後就得使用 &quot;union obj&quot; 而不能只寫 &quot;obj&quot;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">obj</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">obj</span>* <span class="hljs-title">free_list_link</span>;</span><br>&#125; obj;<br><br><span class="hljs-keyword">char</span>*   start_free = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span>*   end_free = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">size_t</span>  heap_size = <span class="hljs-number">0</span>;<br>obj* free_list[__NFREELISTS]<br>     = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">ROUND_UP</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> bytes)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (((bytes) + __ALIGN<span class="hljs-number">-1</span>) &amp; ~(__ALIGN - <span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">FREELIST_INDEX</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> bytes)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (((bytes) + __ALIGN<span class="hljs-number">-1</span>)/__ALIGN - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">// We allocate memory in large chunks in order to</span><br><span class="hljs-comment">// avoid fragmentingthe malloc heap too much.</span><br><span class="hljs-comment">// We assume that size is properly aligned.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Allocates a chunk for nobjs of size &quot;size&quot;.</span><br><span class="hljs-comment">// nobjs may be reduced if it is inconvenient to</span><br><span class="hljs-comment">// allocate the requested number.</span><br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">//char* chunk_alloc(size_t size, int&amp; nobjs)  //G291[o],VC6[x],CB5[x]</span><br><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">chunk_alloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span>* nobjs)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span>* result;<br>  <span class="hljs-keyword">size_t</span> total_bytes = size * (*nobjs);   <span class="hljs-comment">//原 nobjs 改為 (*nobjs)</span><br>  <span class="hljs-keyword">size_t</span> bytes_left = end_free - start_free;<br><br>  <span class="hljs-keyword">if</span> (bytes_left &gt;= total_bytes) &#123;<br>      result = start_free;<br>      start_free += total_bytes;<br>      <span class="hljs-keyword">return</span>(result);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bytes_left &gt;= size) &#123;<br>      *nobjs = bytes_left / size;         <span class="hljs-comment">//原 nobjs 改為 (*nobjs)</span><br>      total_bytes = size * (*nobjs);      <span class="hljs-comment">//原 nobjs 改為 (*nobjs)</span><br>      result = start_free;<br>      start_free += total_bytes;<br>      <span class="hljs-keyword">return</span>(result);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">size_t</span> bytes_to_get =<br>                 <span class="hljs-number">2</span> * total_bytes + <span class="hljs-built_in">ROUND_UP</span>(heap_size &gt;&gt; <span class="hljs-number">4</span>);<br>      <span class="hljs-comment">// Try to make use of the left-over piece.</span><br>      <span class="hljs-keyword">if</span> (bytes_left &gt; <span class="hljs-number">0</span>) &#123;<br>          obj* <span class="hljs-keyword">volatile</span> *my_free_list =<br>                 free_list + <span class="hljs-built_in">FREELIST_INDEX</span>(bytes_left);<br><br>          ((obj*)start_free)-&gt;free_list_link = *my_free_list;<br>          *my_free_list = (obj*)start_free;<br>      &#125;<br>      start_free = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(bytes_to_get);<br>      <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == start_free) &#123;<br>          <span class="hljs-keyword">int</span> i;<br>          obj* <span class="hljs-keyword">volatile</span> *my_free_list, *p;<br><br>          <span class="hljs-comment">//Try to make do with what we have. That can&#x27;t</span><br>          <span class="hljs-comment">//hurt. We do not try smaller requests, since that tends</span><br>          <span class="hljs-comment">//to result in disaster on multi-process machines.</span><br>          <span class="hljs-keyword">for</span> (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;<br>              my_free_list = free_list + <span class="hljs-built_in">FREELIST_INDEX</span>(i);<br>              p = *my_free_list;<br>              <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != p) &#123;<br>                  *my_free_list = p -&gt; free_list_link;<br>                  start_free = (<span class="hljs-keyword">char</span>*)p;<br>                  end_free = start_free + i;<br>                  <span class="hljs-keyword">return</span>(<span class="hljs-built_in">chunk_alloc</span>(size, nobjs));<br>                  <span class="hljs-comment">//Any leftover piece will eventually make it to the</span><br>                  <span class="hljs-comment">//right free list.</span><br>              &#125;<br>          &#125;<br>          end_free = <span class="hljs-number">0</span>;       <span class="hljs-comment">//In case of exception.</span><br>          start_free = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc_allocate</span>(bytes_to_get);<br>          <span class="hljs-comment">//This should either throw an exception or</span><br>          <span class="hljs-comment">//remedy the situation. Thus we assume it</span><br>          <span class="hljs-comment">//succeeded.</span><br>      &#125;<br>      heap_size += bytes_to_get;<br>      end_free = start_free + bytes_to_get;<br>      <span class="hljs-keyword">return</span>(<span class="hljs-built_in">chunk_alloc</span>(size, nobjs));<br>  &#125;<br>&#125;<br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">// Returns an object of size n, and optionally adds</span><br><span class="hljs-comment">// to size n free list. We assume that n is properly aligned.</span><br><span class="hljs-comment">// We hold the allocation lock.</span><br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">refill</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> nobjs = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">char</span>* chunk = <span class="hljs-built_in">chunk_alloc</span>(n,&amp;nobjs);<br>    obj* <span class="hljs-keyword">volatile</span> *my_free_list;   <span class="hljs-comment">//obj** my_free_list;</span><br>    obj* result;<br>    obj* current_obj;<br>    obj* next_obj;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == nobjs) <span class="hljs-keyword">return</span>(chunk);<br>    my_free_list = free_list + <span class="hljs-built_in">FREELIST_INDEX</span>(n);<br><br>    <span class="hljs-comment">//Build free list in chunk</span><br>    result = (obj*)chunk;<br>    *my_free_list = next_obj = (obj*)(chunk + n);<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;  ; ++i) &#123;<br>      current_obj = next_obj;<br>      next_obj = (obj*)((<span class="hljs-keyword">char</span>*)next_obj + n);<br>      <span class="hljs-keyword">if</span> (nobjs<span class="hljs-number">-1</span> == i) &#123;<br>          current_obj-&gt;free_list_link = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">break</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          current_obj-&gt;free_list_link = next_obj;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>(result);<br>&#125;<br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> n)</span>  <span class="hljs-comment">//n must be &gt; 0</span></span><br><span class="hljs-function"></span>&#123;<br>  obj* <span class="hljs-keyword">volatile</span> *my_free_list;    <span class="hljs-comment">//obj** my_free_list;</span><br>  obj* result;<br><br>  <span class="hljs-keyword">if</span> (n &gt; (<span class="hljs-keyword">size_t</span>)__MAX_BYTES) &#123;<br>      <span class="hljs-keyword">return</span>(<span class="hljs-built_in">malloc_allocate</span>(n));<br>  &#125;<br><br>  my_free_list = free_list + <span class="hljs-built_in">FREELIST_INDEX</span>(n);<br>  result = *my_free_list;<br>  <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">void</span>* r = <span class="hljs-built_in">refill</span>(<span class="hljs-built_in">ROUND_UP</span>(n));<br>      <span class="hljs-keyword">return</span> r;<br>  &#125;<br><br>  *my_free_list = result-&gt;free_list_link;<br>  <span class="hljs-keyword">return</span> (result);<br>&#125;<br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *p, <span class="hljs-keyword">size_t</span> n)</span>  <span class="hljs-comment">//p may not be 0</span></span><br><span class="hljs-function"></span>&#123;<br>  obj* q = (obj*)p;<br>  obj* <span class="hljs-keyword">volatile</span> *my_free_list;   <span class="hljs-comment">//obj** my_free_list;</span><br><br>  <span class="hljs-keyword">if</span> (n &gt; (<span class="hljs-keyword">size_t</span>) __MAX_BYTES) &#123;<br>      <span class="hljs-built_in">malloc_deallocate</span>(p, n);<br>      <span class="hljs-keyword">return</span>;<br>  &#125;<br>  my_free_list = free_list + <span class="hljs-built_in">FREELIST_INDEX</span>(n);<br>  q-&gt;free_list_link = *my_free_list;<br>  *my_free_list = q;<br>&#125;<br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//----------------------------------------------</span><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">reallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *p, <span class="hljs-keyword">size_t</span> old_sz, <span class="hljs-keyword">size_t</span> new_sz)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">void</span> * result;<br>  <span class="hljs-keyword">size_t</span> copy_sz;<br><br>  <span class="hljs-keyword">if</span> (old_sz &gt; (<span class="hljs-keyword">size_t</span>) __MAX_BYTES &amp;&amp; new_sz &gt; (<span class="hljs-keyword">size_t</span>) __MAX_BYTES) &#123;<br>      <span class="hljs-keyword">return</span>(<span class="hljs-built_in">realloc</span>(p, new_sz));<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ROUND_UP</span>(old_sz) == <span class="hljs-built_in">ROUND_UP</span>(new_sz)) <span class="hljs-keyword">return</span>(p);<br>  result = <span class="hljs-built_in">allocate</span>(new_sz);<br>  copy_sz = new_sz &gt; old_sz? old_sz : new_sz;<br>  <span class="hljs-built_in">memcpy</span>(result, p, copy_sz);<br>  <span class="hljs-built_in">deallocate</span>(p, old_sz);<br>  <span class="hljs-keyword">return</span>(result);<br>&#125;<br><span class="hljs-comment">//----------------------------------------------</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>上拉加载和下拉刷新</title>
    <link href="/2020/12/21/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0/"/>
    <url>/2020/12/21/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="SmartRefreshLayout结合RecyclerView"><a href="#SmartRefreshLayout结合RecyclerView" class="headerlink" title="SmartRefreshLayout结合RecyclerView"></a>SmartRefreshLayout结合RecyclerView</h2><h3 id="1-创建错误布局（空数据布局）"><a href="#1-创建错误布局（空数据布局）" class="headerlink" title="1.创建错误布局（空数据布局）"></a>1.创建错误布局（空数据布局）</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201220162105.png" alt="空数据布局"></p><h4 id="EmptyView-java"><a href="#EmptyView-java" class="headerlink" title="EmptyView.java"></a>EmptyView.java</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><br><span class="hljs-comment">//import ...</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmptyView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinearLayout</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ImageView icon;<br>    <span class="hljs-keyword">private</span> TextView title;<br>    <span class="hljs-keyword">private</span> Button action;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EmptyView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(context, <span class="hljs-keyword">null</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EmptyView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(context, attrs, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EmptyView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs, <span class="hljs-keyword">int</span> defStyleAttr)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(context, attrs, defStyleAttr, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EmptyView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs, <span class="hljs-keyword">int</span> defStyleAttr, <span class="hljs-keyword">int</span> style)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context, attrs, defStyleAttr, style);<br>        setOrientation(VERTICAL);<br>        setGravity(Gravity.CENTER);<br>        <span class="hljs-comment">//加载布局文件</span><br>        LayoutInflater.from(context).inflate(R.layout.layout_empty_view, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">true</span>);<br><br>        icon = findViewById(R.id.empty_icon);<br>        title = findViewById(R.id.empty_text);<br>        action = findViewById(R.id.empty_action);<br>    &#125;<br><br>    <span class="hljs-comment">//设置图片</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEmptyIcon</span><span class="hljs-params">(<span class="hljs-meta">@DrawableRes</span> <span class="hljs-keyword">int</span> iconRes)</span> </span>&#123;<br>        icon.setImageResource(iconRes);<br>    &#125;<br><br>    <span class="hljs-comment">//设置标题</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTitle</span><span class="hljs-params">(String text)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (TextUtils.isEmpty(text)) &#123;<br>            <span class="hljs-comment">//如果文本为空，设置text隐藏</span><br>            title.setVisibility(GONE);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            title.setText(text);<br>            title.setVisibility(VISIBLE);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">//设置按钮</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setButton</span><span class="hljs-params">(String text, View.OnClickListener listener)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (TextUtils.isEmpty(text)) &#123;<br>            action.setVisibility(GONE);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            action.setText(text);<br>            action.setVisibility(VISIBLE);<br>            action.setOnClickListener(listener);<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="layout-empty-view-xml"><a href="#layout-empty-view-xml" class="headerlink" title="layout_empty_view.xml"></a>layout_empty_view.xml</h4><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><br>    <span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;center&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center_horizontal&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/empty_icon&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@drawable/icon_empty_no_data&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/empty_text&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;16dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;虽然什么也没有,要不下拉刷新试试&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#999999&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;16sp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:visibility</span>=<span class="hljs-string">&quot;visible&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:text</span>=<span class="hljs-string">&quot;虽然什么也没有,要不下拉刷新看看&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TextView</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.button.MaterialButton</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/empty_action&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;16dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:paddingLeft</span>=<span class="hljs-string">&quot;16dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:paddingRight</span>=<span class="hljs-string">&quot;16dp&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#ffffff&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;14sp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:visibility</span>=<span class="hljs-string">&quot;gone&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:backgroundTint</span>=<span class="hljs-string">&quot;#ff678f&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:cornerRadius</span>=<span class="hljs-string">&quot;20dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:text</span>=<span class="hljs-string">&quot;朕知道了&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">com.google.android.material.button.MaterialButton</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br><br><br></code></pre></div></td></tr></table></figure><h3 id="2-编写总布局"><a href="#2-编写总布局" class="headerlink" title="2.编写总布局"></a>2.编写总布局</h3><h4 id="layout-refresh-view-xml"><a href="#layout-refresh-view-xml" class="headerlink" title="layout_refresh_view.xml"></a>layout_refresh_view.xml</h4><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><br><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">FrameLayout</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span><br><br>        <br>        <span class="hljs-tag">&lt;<span class="hljs-name">com.scwang.smartrefresh.layout.SmartRefreshLayout</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/refresh_layout&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><br><br>            <span class="hljs-comment">&lt;!-- 头 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">com.scwang.smartrefresh.layout.header.ClassicsHeader</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com.scwang.smartrefresh.layout.header.ClassicsHeader</span>&gt;</span><br><br>            <span class="hljs-comment">&lt;!-- 内容展示 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">androidx.recyclerview.widget.RecyclerView</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/recycler_view&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.recyclerview.widget.RecyclerView</span>&gt;</span><br><br>            <span class="hljs-comment">&lt;!-- 尾 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">com.scwang.smartrefresh.layout.footer.ClassicsFooter</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com.scwang.smartrefresh.layout.footer.ClassicsFooter</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">com.scwang.smartrefresh.layout.SmartRefreshLayout</span>&gt;</span><br><br><br><span class="hljs-comment">&lt;!--       错误布局 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">com.mooc.libcommon.view.EmptyView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/empty_view&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;100dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com.mooc.libcommon.view.EmptyView</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">FrameLayout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><p>注：需转化为dataBinding布局</p><h3 id="3-编写基础的ListFragment"><a href="#3-编写基础的ListFragment" class="headerlink" title="3.编写基础的ListFragment"></a>3.编写基础的ListFragment</h3><h4 id="AbsListFragment-class"><a href="#AbsListFragment-class" class="headerlink" title="AbsListFragment.class"></a>AbsListFragment.class</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><br><span class="hljs-comment">//import androidx.fragment.app.Fragment;</span><br><span class="hljs-comment">//import ...</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbsListFragment</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">M</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbsViewModel</span>&lt;<span class="hljs-title">T</span>&gt;&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Fragment</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OnRefreshListener</span>, <span class="hljs-title">OnLoadMoreListener</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> LayoutRefreshViewBinding binding;<br>    <span class="hljs-keyword">protected</span> RecyclerView mRecyclerView;<br>    <span class="hljs-keyword">protected</span> SmartRefreshLayout mRefreshLayout;<br>    <span class="hljs-keyword">protected</span> EmptyView mEmptyView;<br>    <span class="hljs-keyword">protected</span> PagedListAdapter&lt;T, RecyclerView.ViewHolder&gt; adapter;<br>    <span class="hljs-keyword">protected</span> M mViewModel;<br>    <span class="hljs-keyword">protected</span> DividerItemDecoration decoration;<br><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LayoutInflater inflater, <span class="hljs-meta">@Nullable</span> ViewGroup container, <span class="hljs-meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-comment">//获取databinding布局</span><br>        binding = LayoutRefreshViewBinding.inflate(inflater, container, <span class="hljs-keyword">false</span>);<br>        binding.getRoot().setFitsSystemWindows(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//获得view</span><br>        mRecyclerView = binding.recyclerView;<br>        mRefreshLayout = binding.refreshLayout;<br>        mEmptyView = binding.emptyView;<br><br>        <span class="hljs-comment">//打开上拉刷新</span><br>        mRefreshLayout.setEnableRefresh(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//打开下拉加载</span><br>        mRefreshLayout.setEnableLoadMore(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//设置上拉刷新监听事件</span><br>        mRefreshLayout.setOnRefreshListener(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-comment">//设置下拉加载监听事件</span><br>        mRefreshLayout.setOnLoadMoreListener(<span class="hljs-keyword">this</span>);<br><br>        <span class="hljs-comment">//设置适配器</span><br>        adapter = getAdapter();<br>        mRecyclerView.setAdapter(adapter);<br>        <span class="hljs-comment">//设置垂直线性布局</span><br>        mRecyclerView.setLayoutManager(<span class="hljs-keyword">new</span> LinearLayoutManager(getContext(), LinearLayoutManager.VERTICAL, <span class="hljs-keyword">false</span>));<br>        <span class="hljs-comment">//设置列表动画为空</span><br>        mRecyclerView.setItemAnimator(<span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//默认给列表中的Item 一个 10dp的ItemDecoration</span><br>        decoration = <span class="hljs-keyword">new</span> DividerItemDecoration(getContext(), LinearLayoutManager.VERTICAL);<br>        decoration.setDrawable(ContextCompat.getDrawable(getContext(), R.drawable.list_divider));<br>        mRecyclerView.addItemDecoration(decoration);<br><br>        genericViewModel();<br>        <span class="hljs-keyword">return</span> binding.getRoot();<br><br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">genericViewModel</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//利用 子类传递的 泛型参数实例化出absViewModel 对象。</span><br>        ParameterizedType type = (ParameterizedType) getClass().getGenericSuperclass();<br>        Type[] arguments = type.getActualTypeArguments();<br>        <span class="hljs-keyword">if</span> (arguments.length &gt; <span class="hljs-number">1</span>) &#123;<br>            Type argument = arguments[<span class="hljs-number">1</span>];<br>            Class modelClaz = ((Class) argument).asSubclass(AbsViewModel.class);<br>            mViewModel = (M) ViewModelProviders.of(<span class="hljs-keyword">this</span>).get(modelClaz);<br><br>            <span class="hljs-comment">//触发页面初始化数据加载的逻辑</span><br>            mViewModel.getPageData().observe(<span class="hljs-keyword">this</span>, pagedList -&gt; submitList(pagedList));<br><br>            <span class="hljs-comment">//监听分页时有无更多数据,以决定是否关闭上拉加载的动画</span><br>            mViewModel.getBoundaryPageData().observe(<span class="hljs-keyword">this</span>, hasData -&gt; finishRefresh(hasData));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//加载数据到界面</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">submitList</span><span class="hljs-params">(PagedList&lt;T&gt; result)</span> </span>&#123;<br>        <span class="hljs-comment">//只有当新数据集合大于0 的时候，才调用adapter.submitList</span><br>        <span class="hljs-comment">//否则可能会出现 页面----有数据-----&gt;被清空-----空布局</span><br>        <span class="hljs-keyword">if</span> (result.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            adapter.submitList(result);<br>        &#125;<br>        <span class="hljs-comment">//结束刷新</span><br>        finishRefresh(result.size() &gt; <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finishRefresh</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> hasData)</span> </span>&#123;<br><br>        <span class="hljs-comment">//获得adapter当前的数据集合</span><br>        PagedList&lt;T&gt; currentList = adapter.getCurrentList();<br>        <span class="hljs-comment">//判断是否有数据</span><br>        hasData = hasData || currentList != <span class="hljs-keyword">null</span> &amp;&amp; currentList.size() &gt; <span class="hljs-number">0</span>;<br>        RefreshState state = mRefreshLayout.getState();<br>        <br>        <span class="hljs-comment">//isOpening等同isLoading || isRefreshing</span><br>        <span class="hljs-keyword">if</span> (state.isFooter &amp;&amp; state.isOpening) &#123;<span class="hljs-comment">//当前于Footer一系列状态中</span><br>            <span class="hljs-comment">//上拉加载完成</span><br>            mRefreshLayout.finishLoadMore();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state.isHeader &amp;&amp; state.isOpening) &#123;<span class="hljs-comment">//当前于Header一系列状态中</span><br>            <span class="hljs-comment">//下拉刷新完成</span><br>            mRefreshLayout.finishRefresh();<br>        &#125;<br><br>        <span class="hljs-comment">//如果有数据，隐藏错误布局</span><br>        <span class="hljs-keyword">if</span> (hasData) &#123;<br>            mEmptyView.setVisibility(View.GONE);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mEmptyView.setVisibility(View.VISIBLE);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 因而 我们在 onCreateView的时候 创建了 PagedListAdapter</span><br><span class="hljs-comment">     * 所以，如果arguments 有参数需要传递到Adapter 中，那么需要在getAdapter()方法中取出参数。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>     <span class="hljs-comment">//设置虚方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> PagedListAdapter <span class="hljs-title">getAdapter</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><br></code></pre></div></td></tr></table></figure><h3 id="4-编写适配器"><a href="#4-编写适配器" class="headerlink" title="4.编写适配器"></a>4.编写适配器</h3><h4 id="AbsPagedListAdapter-class"><a href="#AbsPagedListAdapter-class" class="headerlink" title="AbsPagedListAdapter.class"></a>AbsPagedListAdapter.class</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><br><span class="hljs-comment">//import ...</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一个能够添加HeaderView,FooterView的PagedListAdapter。</span><br><span class="hljs-comment"> * 解决了添加HeaderView和FooterView时 RecyclerView定位不准确的问题</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt;  Java Bean</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;VH&gt;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbsPagedListAdapter</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">VH</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ViewHolder</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">PagedListAdapter</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">VH</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> SparseArray&lt;View&gt; mHeaders = <span class="hljs-keyword">new</span> SparseArray&lt;&gt;();<br>    <span class="hljs-keyword">private</span> SparseArray&lt;View&gt; mFooters = <span class="hljs-keyword">new</span> SparseArray&lt;&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> BASE_ITEM_TYPE_HEADER = <span class="hljs-number">100000</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> BASE_ITEM_TYPE_FOOTER = <span class="hljs-number">200000</span>;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">AbsPagedListAdapter</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> DiffUtil.ItemCallback&lt;T&gt; diffCallback)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(diffCallback);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addHeaderView</span><span class="hljs-params">(View view)</span> </span>&#123;<br>        <span class="hljs-comment">//判断给View对象是否还没有处在mHeaders数组里面</span><br>        <span class="hljs-keyword">if</span> (mHeaders.indexOfValue(view) &lt; <span class="hljs-number">0</span>) &#123;<br>            mHeaders.put(BASE_ITEM_TYPE_HEADER++, view);<br>            notifyDataSetChanged();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFooterView</span><span class="hljs-params">(View view)</span> </span>&#123;<br>        <span class="hljs-comment">//判断给View对象是否还没有处在mFooters数组里面</span><br>        <span class="hljs-keyword">if</span> (mFooters.indexOfValue(view) &lt; <span class="hljs-number">0</span>) &#123;<br>            mFooters.put(BASE_ITEM_TYPE_FOOTER++, view);<br>            notifyDataSetChanged();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 移除头部</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeHeaderView</span><span class="hljs-params">(View view)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> index = mHeaders.indexOfValue(view);<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        mHeaders.removeAt(index);<br>        notifyDataSetChanged();<br>    &#125;<br><br>    <span class="hljs-comment">// 移除底部</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeFooterView</span><span class="hljs-params">(View view)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> index = mFooters.indexOfValue(view);<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        mFooters.removeAt(index);<br>        notifyDataSetChanged();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHeaderCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mHeaders.size();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFooterCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mFooters.size();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> itemCount = <span class="hljs-keyword">super</span>.getItemCount();<br>        <span class="hljs-keyword">return</span> itemCount + mHeaders.size() + mFooters.size();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOriginalItemCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getItemCount() - mHeaders.size() - mFooters.size();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemViewType</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (isHeaderPosition(position)) &#123;<br>            <span class="hljs-comment">//返回该position对应的headerview的  viewType</span><br>            <span class="hljs-keyword">return</span> mHeaders.keyAt(position);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (isFooterPosition(position)) &#123;<br>            <span class="hljs-comment">//footer类型的，需要计算一下它的position实际大小</span><br>            position = position - getOriginalItemCount() - mHeaders.size();<br>            <span class="hljs-keyword">return</span> mFooters.keyAt(position);<br>        &#125;<br>        position = position - mHeaders.size();<br>        <span class="hljs-keyword">return</span> getItemViewType2(position);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemViewType2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFooterPosition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> position &gt;= getOriginalItemCount() + mHeaders.size();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeaderPosition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> position &lt; mHeaders.size();<br>    &#125;<br><br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> VH <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ViewGroup parent, <span class="hljs-keyword">int</span> viewType)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (mHeaders.indexOfKey(viewType) &gt;= <span class="hljs-number">0</span>) &#123;<br>            View view = mHeaders.get(viewType);<br>            <span class="hljs-keyword">return</span> (VH) <span class="hljs-keyword">new</span> RecyclerView.ViewHolder(view) &#123;<br>            &#125;;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (mFooters.indexOfKey(viewType) &gt;= <span class="hljs-number">0</span>) &#123;<br>            View view = mFooters.get(viewType);<br>            <span class="hljs-keyword">return</span> (VH) <span class="hljs-keyword">new</span> RecyclerView.ViewHolder(view) &#123;<br>            &#125;;<br>        &#125;<br><br><br>        <span class="hljs-keyword">return</span> onCreateViewHolder2(parent, viewType);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> VH <span class="hljs-title">onCreateViewHolder2</span><span class="hljs-params">(ViewGroup parent, <span class="hljs-keyword">int</span> viewType)</span></span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> VH holder, <span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (isHeaderPosition(position) || isFooterPosition(position))<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//列表中正常类型的itemView的 position 咱们需要减去添加headerView的个数</span><br>        position = position - mHeaders.size();<br>        onBindViewHolder2(holder, position);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder2</span><span class="hljs-params">(VH holder, <span class="hljs-keyword">int</span> position)</span></span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewAttachedToWindow</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> RecyclerView.ViewHolder holder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!isHeaderPosition(holder.getAdapterPosition()) &amp;&amp; !isFooterPosition(holder.getAdapterPosition())) &#123;<br>            <span class="hljs-keyword">this</span>.onViewAttachedToWindow2((VH) holder);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewAttachedToWindow2</span><span class="hljs-params">(VH holder)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewDetachedFromWindow</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> RecyclerView.ViewHolder holder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!isHeaderPosition(holder.getAdapterPosition()) &amp;&amp; !isFooterPosition(holder.getAdapterPosition())) &#123;<br>            <span class="hljs-keyword">this</span>.onViewDetachedFromWindow2((VH) holder);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewDetachedFromWindow2</span><span class="hljs-params">(VH holder)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerAdapterDataObserver</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> RecyclerView.AdapterDataObserver observer)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.registerAdapterDataObserver(<span class="hljs-keyword">new</span> AdapterDataObserverProxy(observer));<br>    &#125;<br><br>    <span class="hljs-comment">//如果我们先添加了headerView,而后网络数据回来了再更新到列表上</span><br>    <span class="hljs-comment">//由于Paging在计算列表上item的位置时 并不会顾及我们有没有添加headerView，就会出现列表定位的问题</span><br>    <span class="hljs-comment">//实际上 RecyclerView#setAdapter方法，它会给Adapter注册了一个AdapterDataObserver</span><br>    <span class="hljs-comment">//咱么可以代理registerAdapterDataObserver()传递进来的observer。在各个方法的实现中，把headerView的个数算上，再中转出去即可</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdapterDataObserverProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">AdapterDataObserver</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> RecyclerView.AdapterDataObserver mObserver;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AdapterDataObserverProxy</span><span class="hljs-params">(RecyclerView.AdapterDataObserver observer)</span> </span>&#123;<br>            mObserver = observer;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onChanged</span><span class="hljs-params">()</span> </span>&#123;<br>            mObserver.onChanged();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemRangeChanged</span><span class="hljs-params">(<span class="hljs-keyword">int</span> positionStart, <span class="hljs-keyword">int</span> itemCount)</span> </span>&#123;<br>            mObserver.onItemRangeChanged(positionStart + mHeaders.size(), itemCount);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemRangeChanged</span><span class="hljs-params">(<span class="hljs-keyword">int</span> positionStart, <span class="hljs-keyword">int</span> itemCount, <span class="hljs-meta">@Nullable</span> Object payload)</span> </span>&#123;<br>            mObserver.onItemRangeChanged(positionStart + mHeaders.size(), itemCount, payload);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemRangeInserted</span><span class="hljs-params">(<span class="hljs-keyword">int</span> positionStart, <span class="hljs-keyword">int</span> itemCount)</span> </span>&#123;<br>            mObserver.onItemRangeInserted(positionStart + mHeaders.size(), itemCount);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemRangeRemoved</span><span class="hljs-params">(<span class="hljs-keyword">int</span> positionStart, <span class="hljs-keyword">int</span> itemCount)</span> </span>&#123;<br>            mObserver.onItemRangeRemoved(positionStart + mHeaders.size(), itemCount);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemRangeMoved</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fromPosition, <span class="hljs-keyword">int</span> toPosition, <span class="hljs-keyword">int</span> itemCount)</span> </span>&#123;<br>            mObserver.onItemRangeMoved(fromPosition + mHeaders.size(), toPosition + mHeaders.size(), itemCount);<br>        &#125;<br><br><br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>每个继承于PagedListAdapter的RecyclerViewAdatpter，都必须在构造方法里面复写下图中的某个方法。<br><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201220172145.png" alt="PagedListAdapter"></p><ul><li>PagedListAdapter(@NonNull DiffUtil.ItemCallback<T> diffCallback)：这个是给新旧数据集做拆分页，做比对的时候，需要使用的一个回调</li><li>PagedListAdapter(@NonNull AsyncDifferConfig<T> config)：做拆分页时的一个配置。AsyncDifferConfig的设置如下表：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">private final Executor mMainThreadExecutor;</td><td style="text-align:left">主线程线程池</td></tr><tr><td style="text-align:left">private final Executor mBackgroundThreadExecutor;</td><td style="text-align:left">子线程线程池</td></tr><tr><td style="text-align:left">private final DiffUtil.ItemCallback<T> mDiffCallback;</td><td style="text-align:left">做拆分页的回调</td></tr></tbody></table></div><h4 id="FeedAdapter-class"><a href="#FeedAdapter-class" class="headerlink" title="FeedAdapter.class"></a>FeedAdapter.class</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//import ...</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeedAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbsPagedListAdapter</span>&lt;<span class="hljs-title">Feed</span>, <span class="hljs-title">FeedAdapter</span>.<span class="hljs-title">ViewHolder</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LayoutInflater inflater;<br>    <span class="hljs-keyword">protected</span> Context mContext;<br>    <span class="hljs-keyword">protected</span> String mCategory;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FeedAdapter</span><span class="hljs-params">(Context context, String category)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> DiffUtil.ItemCallback&lt;Feed&gt;() &#123;<br>            <span class="hljs-comment">//判断两个Item是否相等</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">areItemsTheSame</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Feed oldItem, <span class="hljs-meta">@NonNull</span> Feed newItem)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> oldItem.id == newItem.id;<br>            &#125;<br>            <span class="hljs-comment">//比较两个Item里面的内容是否相同</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">areContentsTheSame</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Feed oldItem, <span class="hljs-meta">@NonNull</span> Feed newItem)</span> </span>&#123;<br>                <span class="hljs-comment">//Feed中的equals方法被复写</span><br>                <span class="hljs-keyword">return</span> oldItem.equals(newItem);<br>            &#125;<br>        &#125;);<br><br>        inflater = LayoutInflater.from(context);<br>        mContext = context;<br>        mCategory = category;<br>    &#125;<br><br>    <span class="hljs-comment">//返回Feed是图片类型还是视频类型</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemViewType2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        Feed feed = getItem(position);<br>        <span class="hljs-keyword">if</span> (feed.itemType == Feed.TYPE_IMAGE_TEXT) &#123;<br>            <span class="hljs-keyword">return</span> R.layout.layout_feed_type_image;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (feed.itemType == Feed.TYPE_VIDEO) &#123;<br>            <span class="hljs-keyword">return</span> R.layout.layout_feed_type_video;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> ViewHolder <span class="hljs-title">onCreateViewHolder2</span><span class="hljs-params">(ViewGroup parent, <span class="hljs-keyword">int</span> viewType)</span> </span>&#123;<br>        ViewDataBinding binding = DataBindingUtil.inflate(inflater, viewType, parent, <span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ViewHolder(binding.getRoot(), binding);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder2</span><span class="hljs-params">(ViewHolder holder, <span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Feed feed = getItem(position);<br><br>        holder.bindData(feed);<br><br>        holder.itemView.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>                FeedDetailActivity.startFeedDetailActivity(mContext, feed, mCategory);<br>                onStartFeedDetailActivity(feed);<br>                <span class="hljs-keyword">if</span> (mFeedObserver == <span class="hljs-keyword">null</span>) &#123;<br>                    mFeedObserver = <span class="hljs-keyword">new</span> FeedObserver();<br>                    LiveDataBus.get()<br>                            .with(InteractionPresenter.DATA_FROM_INTERACTION)<br>                            .observe((LifecycleOwner) mContext, mFeedObserver);<br>                &#125;<br>                mFeedObserver.setFeed(feed);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartFeedDetailActivity</span><span class="hljs-params">(Feed feed)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> FeedObserver mFeedObserver;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeedObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span>&lt;<span class="hljs-title">Feed</span>&gt; </span>&#123;<br><br>        <span class="hljs-keyword">private</span> Feed mFeed;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onChanged</span><span class="hljs-params">(Feed newOne)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (mFeed.id != newOne.id)<br>                <span class="hljs-keyword">return</span>;<br>            mFeed.author = newOne.author;<br>            mFeed.ugc = newOne.ugc;<br>            mFeed.notifyChange();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFeed</span><span class="hljs-params">(Feed feed)</span> </span>&#123;<br><br>            mFeed = feed;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewHolder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ViewHolder</span> </span>&#123;<br><br>        <span class="hljs-keyword">public</span> ViewDataBinding mBinding;<br>        <span class="hljs-keyword">public</span> ListPlayerView listPlayerView;<br>        <span class="hljs-keyword">public</span> ImageView feedImage;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View itemView, ViewDataBinding binding)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(itemView);<br>            mBinding = binding;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bindData</span><span class="hljs-params">(Feed item)</span> </span>&#123;<br>            <span class="hljs-comment">//这里之所以手动绑定数据的原因是 图片 和视频区域都是需要计算的</span><br>            <span class="hljs-comment">//而dataBinding的执行默认是延迟一帧的。</span><br>            <span class="hljs-comment">//当列表上下滑动的时候 ，会明显的看到宽高尺寸不对称的问题</span><br><br>            mBinding.setVariable(com.mooc.ppjoke.BR.feed, item);<br>            mBinding.setVariable(BR.lifeCycleOwner, mContext);<br>            <span class="hljs-keyword">if</span> (mBinding <span class="hljs-keyword">instanceof</span> LayoutFeedTypeImageBinding) &#123;<span class="hljs-comment">//图片类型</span><br>                LayoutFeedTypeImageBinding imageBinding = (LayoutFeedTypeImageBinding) mBinding;<br>                feedImage = imageBinding.feedImage;<br>                imageBinding.feedImage.bindData(item.width, item.height, <span class="hljs-number">16</span>, item.cover);<br>                <span class="hljs-comment">//imageBinding.setFeed(item);</span><br>                <span class="hljs-comment">//imageBinding.interactionBinding.setLifeCycleOwner((LifecycleOwner) mContext);</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mBinding <span class="hljs-keyword">instanceof</span> LayoutFeedTypeVideoBinding) &#123;<span class="hljs-comment">//视频类型</span><br>                LayoutFeedTypeVideoBinding videoBinding = (LayoutFeedTypeVideoBinding) mBinding;<br>                videoBinding.listPlayerView.bindData(mCategory, item.width, item.height, item.cover, item.url);<br>                listPlayerView = videoBinding.listPlayerView;<br>                <span class="hljs-comment">//videoBinding.setFeed(item);</span><br>                <span class="hljs-comment">//videoBinding.interactionBinding.setLifeCycleOwner((LifecycleOwner) mContext);</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isVideoItem</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> mBinding <span class="hljs-keyword">instanceof</span> LayoutFeedTypeVideoBinding;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> ListPlayerView <span class="hljs-title">getListPlayerView</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> listPlayerView;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br></code></pre></div></td></tr></table></figure><h3 id="5-编写下拉刷新的通用配置"><a href="#5-编写下拉刷新的通用配置" class="headerlink" title="5.编写下拉刷新的通用配置"></a>5.编写下拉刷新的通用配置</h3><h4 id="AbsViewModel-class"><a href="#AbsViewModel-class" class="headerlink" title="AbsViewModel.class"></a>AbsViewModel.class</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-comment">//import ...</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbsViewModel</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewModel</span> </span>&#123;<br><br><br>    <span class="hljs-keyword">protected</span> PagedList.Config config;<br>    <span class="hljs-keyword">private</span> DataSource dataSource;<br>    <span class="hljs-keyword">private</span> LiveData&lt;PagedList&lt;T&gt;&gt; pageData;<br><br>    <span class="hljs-keyword">private</span> MutableLiveData&lt;Boolean&gt; boundaryPageData = <span class="hljs-keyword">new</span> MutableLiveData&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbsViewModel</span><span class="hljs-params">()</span> </span>&#123;<br><br>        config = <span class="hljs-keyword">new</span> PagedList.Config.Builder()<br>                .setPageSize(<span class="hljs-number">10</span>)<span class="hljs-comment">//每次分页加载的数量</span><br>                .setInitialLoadSizeHint(<span class="hljs-number">12</span>)<span class="hljs-comment">//初始化加载时的数量</span><br>                <span class="hljs-comment">// .setMaxSize(100)；</span><br>                <span class="hljs-comment">// .setEnablePlaceholders(false)//设置数据未满的占位符</span><br>                <span class="hljs-comment">// .setPrefetchDistance()//设置根据距离屏幕底部几个item时，加载下一页</span><br>                .build();<br><br>        pageData = <span class="hljs-keyword">new</span> LivePagedListBuilder(factory, config)<br>                .setInitialLoadKey(<span class="hljs-number">0</span>)<span class="hljs-comment">//加载初始化区域的时候，需要传递的参数。如果是多个参数，需要组装成javabean对象</span><br>                <span class="hljs-comment">//.setFetchExecutor()</span><br>                .setBoundaryCallback(callback)<span class="hljs-comment">//监听Pagedlist数据加载的状态</span><br>                .build();<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> LiveData&lt;PagedList&lt;T&gt;&gt; getPageData() &#123;<br>        <span class="hljs-keyword">return</span> pageData;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">getDataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LiveData&lt;Boolean&gt; <span class="hljs-title">getBoundaryPageData</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> boundaryPageData;<br>    &#125;<br><br>    <span class="hljs-comment">//PagedList数据被加载情况的边界回调callback</span><br>    <span class="hljs-comment">//但 不是每一次分页 都会回调这里，具体请看 ContiguousPagedList#mReceiver#onPageResult</span><br>    <span class="hljs-comment">//deferBoundaryCallbacks</span><br>    PagedList.BoundaryCallback&lt;T&gt; callback = <span class="hljs-keyword">new</span> PagedList.BoundaryCallback&lt;T&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onZeroItemsLoaded</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">//新提交的PagedList中没有数据</span><br>            boundaryPageData.postValue(<span class="hljs-keyword">false</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemAtFrontLoaded</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> T itemAtFront)</span> </span>&#123;<br>            <span class="hljs-comment">//新提交的PagedList中第一条数据被加载到列表上</span><br>            boundaryPageData.postValue(<span class="hljs-keyword">true</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemAtEndLoaded</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> T itemAtEnd)</span> </span>&#123;<br>            <span class="hljs-comment">//新提交的PagedList中最后一条数据被加载到列表上</span><br>        &#125;<br>    &#125;;<br><br>    DataSource.Factory factory = <span class="hljs-keyword">new</span> DataSource.Factory() &#123;<br>        <span class="hljs-meta">@NonNull</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">//如果dataSource为空或者无效</span><br>            <span class="hljs-keyword">if</span> (dataSource == <span class="hljs-keyword">null</span> || dataSource.isInvalid()) &#123;<br>                dataSource = createDataSource();<br>            &#125;<br>            <span class="hljs-keyword">return</span> dataSource;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">//该方法推迟到子类实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> DataSource <span class="hljs-title">createDataSource</span><span class="hljs-params">()</span></span>;<br><br><br>    <span class="hljs-comment">//可以在这个方法里 做一些清理 的工作</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCleared</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br><br><br></code></pre></div></td></tr></table></figure><h4 id="AbsViewModel的实现类HomeViewModel-class"><a href="#AbsViewModel的实现类HomeViewModel-class" class="headerlink" title="AbsViewModel的实现类HomeViewModel.class"></a>AbsViewModel的实现类HomeViewModel.class</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//import ...</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeViewModel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbsViewModel</span>&lt;<span class="hljs-title">Feed</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> witchCache = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">private</span> MutableLiveData&lt;PagedList&lt;Feed&gt;&gt; cacheLiveData = <span class="hljs-keyword">new</span> MutableLiveData&lt;&gt;();<br>    <span class="hljs-keyword">private</span> AtomicBoolean loadAfter = <span class="hljs-keyword">new</span> AtomicBoolean(<span class="hljs-keyword">false</span>);<br>    <span class="hljs-keyword">private</span> String mFeedType;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">createDataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FeedDataSource();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> MutableLiveData&lt;PagedList&lt;Feed&gt;&gt; getCacheLiveData() &#123;<br>        <span class="hljs-keyword">return</span> cacheLiveData;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFeedType</span><span class="hljs-params">(String feedType)</span> </span>&#123;<br><br>        mFeedType = feedType;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeedDataSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ItemKeyedDataSource</span>&lt;<span class="hljs-title">Integer</span>, <span class="hljs-title">Feed</span>&gt; </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadInitial</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LoadInitialParams&lt;Integer&gt; params, <span class="hljs-meta">@NonNull</span> LoadInitialCallback&lt;Feed&gt; callback)</span> </span>&#123;<br>            <span class="hljs-comment">//加载初始化数据的</span><br>            Log.e(<span class="hljs-string">&quot;homeviewmodel&quot;</span>, <span class="hljs-string">&quot;loadInitial: &quot;</span>);<br>            <span class="hljs-comment">//先加载缓存</span><br>            loadData(<span class="hljs-number">0</span>, params.requestedLoadSize, callback);<br>            witchCache = <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadAfter</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LoadParams&lt;Integer&gt; params, <span class="hljs-meta">@NonNull</span> LoadCallback&lt;Feed&gt; callback)</span> </span>&#123;<br>            <span class="hljs-comment">//向后加载分页数据的</span><br>            Log.e(<span class="hljs-string">&quot;homeviewmodel&quot;</span>, <span class="hljs-string">&quot;loadAfter: &quot;</span>);<br>            loadData(params.key, params.requestedLoadSize, callback);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBefore</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LoadParams&lt;Integer&gt; params, <span class="hljs-meta">@NonNull</span> LoadCallback&lt;Feed&gt; callback)</span> </span>&#123;<br>            callback.onResult(Collections.emptyList());<br>            <span class="hljs-comment">//能够向前加载数据的</span><br>            <span class="hljs-comment">//比如进入首页时在第三页，但是想往前加载第一第二页</span><br>        &#125;<br><br><br>        <span class="hljs-comment">//通过最后一条Item的信息，来返回id</span><br>        <span class="hljs-meta">@NonNull</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getKey</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Feed item)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> item.id;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> count, ItemKeyedDataSource.LoadCallback&lt;Feed&gt; callback)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (key &gt; <span class="hljs-number">0</span>) &#123;<br>            loadAfter.set(<span class="hljs-keyword">true</span>);<br>        &#125;<br>        <span class="hljs-comment">//feeds/queryHotFeedsList</span><br>        Request request = ApiService.get(<span class="hljs-string">&quot;/feeds/queryHotFeedsList&quot;</span>)<br>                .addParam(<span class="hljs-string">&quot;feedType&quot;</span>, mFeedType)<br>                .addParam(<span class="hljs-string">&quot;userId&quot;</span>, UserManager.get().getUserId())<br>                .addParam(<span class="hljs-string">&quot;feedId&quot;</span>, key)<br>                .addParam(<span class="hljs-string">&quot;pageCount&quot;</span>, count)<br>                .responseType(<span class="hljs-keyword">new</span> TypeReference&lt;ArrayList&lt;Feed&gt;&gt;() &#123;<br>                &#125;.getType());<br><br>        <span class="hljs-keyword">if</span> (witchCache) &#123;<br>            request.cacheStrategy(Request.CACHE_ONLY);<br>            request.execute(<span class="hljs-keyword">new</span> JsonCallback&lt;List&lt;Feed&gt;&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCacheSuccess</span><span class="hljs-params">(ApiResponse&lt;List&lt;Feed&gt;&gt; response)</span> </span>&#123;<br>                    Log.e(<span class="hljs-string">&quot;loadData&quot;</span>, <span class="hljs-string">&quot;onCacheSuccess: &quot;</span>);<br>                    MutablePageKeyedDataSource dataSource = <span class="hljs-keyword">new</span> MutablePageKeyedDataSource&lt;Feed&gt;();<br>                    dataSource.data.addAll(response.body);<br><br>                    PagedList pagedList = dataSource.buildNewPagedList(config);<br>                    cacheLiveData.postValue(pagedList);<br><br>                    <span class="hljs-comment">//下面的不可取，否则会报</span><br>                    <span class="hljs-comment">// java.lang.IllegalStateException: callback.onResult already called, cannot call again.</span><br>                    <span class="hljs-comment">//if (response.body != null) &#123;</span><br>                    <span class="hljs-comment">//  callback.onResult(response.body);</span><br>                    <span class="hljs-comment">// &#125;</span><br>                &#125;<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Request netRequest = witchCache ? request.clone() : request;<br>            netRequest.cacheStrategy(key == <span class="hljs-number">0</span> ? Request.NET_CACHE : Request.NET_ONLY);<br>            ApiResponse&lt;List&lt;Feed&gt;&gt; response = netRequest.execute();<br>            List&lt;Feed&gt; data = response.body == <span class="hljs-keyword">null</span> ? Collections.emptyList() : response.body;<br><br>            callback.onResult(data);<br><br>            <span class="hljs-keyword">if</span> (key &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">//通过BoundaryPageData发送数据 告诉UI层 是否应该主动关闭上拉加载分页的动画</span><br>                ((MutableLiveData) getBoundaryPageData()).postValue(data.size() &gt; <span class="hljs-number">0</span>);<br>                loadAfter.set(<span class="hljs-keyword">false</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        Log.e(<span class="hljs-string">&quot;loadData&quot;</span>, <span class="hljs-string">&quot;loadData: key:&quot;</span> + key);<br><br>    &#125;<br><br>    <span class="hljs-meta">@SuppressLint(&quot;RestrictedApi&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadAfter</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, ItemKeyedDataSource.LoadCallback&lt;Feed&gt; callback)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (loadAfter.get()) &#123;<br>            callback.onResult(Collections.emptyList());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ArchTaskExecutor.getIOThreadExecutor().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                loadData(id, config.pageSize, callback);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p><a href="https://blog.csdn.net/zsp_android_com/article/details/86235067">刷新加载（SmartRefreshLayout）</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RecyclerView</tag>
      
      <tag>SmartRefreshLayout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>160. 相交链表</title>
    <link href="/2020/12/20/LeetCode/160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/12/20/LeetCode/160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">本题链接</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br><br>        unordered_set&lt;ListNode*&gt; list_set;<br><br>        <span class="hljs-keyword">while</span>(headA || headB)&#123;<br><br>            <span class="hljs-keyword">if</span>(headA)&#123;<br>                <span class="hljs-keyword">if</span>(list_set.<span class="hljs-built_in">find</span>(headA) == list_set.<span class="hljs-built_in">end</span>())&#123;<br>                    list_set.<span class="hljs-built_in">insert</span>(headA);<br>                    headA = headA-&gt;next;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> headA;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(headB)&#123;<br>                <span class="hljs-keyword">if</span>(list_set.<span class="hljs-built_in">find</span>(headB) == list_set.<span class="hljs-built_in">end</span>())&#123;<br>                    list_set.<span class="hljs-built_in">insert</span>(headB);<br>                    headB = headB-&gt;next;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> headB;<br>                &#125;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用哈希表存储两条链表中出现过的节点，如果某条链表存储节点时发现该节点已经被保存过，那么这个节点就是相交的节点。</p><h2 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode* p1 = headA;ListNode* p2 = headB;<br>        <span class="hljs-keyword">while</span>(p1 != p2)&#123;<br>           p1 ? p1 = p1-&gt;next : p1 = headB;<br>           p2 ? p2 = p2-&gt;next : p2 = headA;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p1;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>将两条链表到相交点的距离分别设置为A和B，然后相交点到链表的距离为C，那么对于两条路径就有</p><script type="math/tex; mode=display">A+C+B=B+C+A</script>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>链表</tag>
      
      <tag>奇技淫巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>点赞实现</title>
    <link href="/2020/12/19/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E7%82%B9%E8%B5%9E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/12/19/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E7%82%B9%E8%B5%9E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>利用dataBinding实现点赞颜色更改和点赞图片更改</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">variable</span></span><br><span class="hljs-tag">        <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;comment&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.mooc.ppjoke.model.Comment&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.mooc.ppjoke.ui.InteractionPresenter&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;android.text.TextUtils&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;android.view.View&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.mooc.ppjoke.utils.StringConvert&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center_vertical&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@&#123;comment.ugc.likeCount&gt;0?StringConvert.convertFeedUgc(comment.ugc.likeCount):null&#125;&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@&#123;comment.ugc.hasLiked?@color/color_theme:@color/color_3d3&#125;&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;@dimen/sp_12&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:text</span>=<span class="hljs-string">&quot;1000&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TextView</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_marginLeft</span>=<span class="hljs-string">&quot;@dimen/dp_2&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:onClick</span>=<span class="hljs-string">&quot;@&#123;()-&gt;InteractionPresenter.toggleCommentLike(lifeCycleOwner,comment)&#125;&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@&#123;comment.ugc.hasLiked?@drawable/icon_cell_liked:@drawable/icon_cell_like&#125;&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:src</span>=<span class="hljs-string">&quot;@drawable/icon_cell_liked&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">ImageView</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dataBinding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataSource</title>
    <link href="/2020/12/17/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/DataSource/"/>
    <url>/2020/12/17/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/DataSource/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li><p>DataSource<Key,Value>数据源：</p><ol><li>Key对应加载数据的条件信息</li><li>Value对应数据实体类</li></ol></li><li><p>内置三种对象<br>  |对象|描述|场景<br>  |:——————————————-|:—————————————————|:—————————————————|<br>  |PageKeyedDataSource<Key,Value>|适用于目标数据根据页信息请求数据的场景|初始化的时候加载第一页信息，上拉加载第二页…根据页码来请求数据|<br>  |ItemKeyedDataSource<Key,Value>|适用于目标数据的加载依赖特定item的信息|当页面滑动到最底下的时候，根据最后一个item的信息，来请求下一页的数据|<br>  |PositionalDataSource<T>|适用于目标数据总数固定，通过特定的位置加载数据|规定有一百条数据，指定要这些数据中的哪条数据|</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DataSource</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标签实现</title>
    <link href="/2020/12/17/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E6%A0%87%E7%AD%BE%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/12/17/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E6%A0%87%E7%AD%BE%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="MaterialButton"><a href="#MaterialButton" class="headerlink" title="MaterialButton"></a>MaterialButton</h2><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201217213919.png" alt="MaterialButton效果图"></p><ol><li>修改xml文档</li></ol><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.button.MaterialButton</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;20dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@color/color_2f2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;@dimen/sp_10&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:backgroundTint</span>=<span class="hljs-string">&quot;@color/color_gray&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:icon</span>=<span class="hljs-string">&quot;@drawable/icon_tag&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:cornerRadius</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:iconGravity</span>=<span class="hljs-string">&quot;textStart&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:iconPadding</span>=<span class="hljs-string">&quot;@dimen/dp_4&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:iconSize</span>=<span class="hljs-string">&quot;@dimen/dp_12&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:iconTintMode</span>=<span class="hljs-string">&quot;multiply&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:text</span>=<span class="hljs-string">&quot;神秘皮皮虾&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">com.google.android.material.button.MaterialButton</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><ol><li>修改style.xml文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;AppTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.MaterialComponents.Light.NoActionBar&quot;</span>&gt;</span><span class="xml"></span><br><span class="xml">        <span class="hljs-comment">&lt;!-- Customize your theme here. --&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimary&quot;</span>&gt;</span>@color/colorPrimary<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimaryDark&quot;</span>&gt;</span>@color/colorPrimaryDark<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorAccent&quot;</span>&gt;</span>@color/colorAccent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;materialButtonStyle&quot;</span>&gt;</span>@style/materialButton<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;materialButton&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Widget.MaterialComponents.Button&quot;</span>&gt;</span><span class="xml"></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:paddingLeft&quot;</span>&gt;</span>8dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:paddingRight&quot;</span>&gt;</span>8dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:paddingTop&quot;</span>&gt;</span>4dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:paddingBottom&quot;</span>&gt;</span>4dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:inset&quot;</span>&gt;</span>0dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:insetLeft&quot;</span>&gt;</span>0dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:insetRight&quot;</span>&gt;</span>0dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:insetBottom&quot;</span>&gt;</span>0dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:insetTop&quot;</span>&gt;</span>0dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:minWidth&quot;</span>&gt;</span>0dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:minHeight&quot;</span>&gt;</span>0dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:elevation&quot;</span>&gt;</span>0dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MaterialButton</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1047. 删除字符串中的所有相邻重复项</title>
    <link href="/2020/12/14/LeetCode/1047.%20%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <url>/2020/12/14/LeetCode/1047.%20%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">本题链接</a></p><h2 id="使用栈"><a href="#使用栈" class="headerlink" title="使用栈"></a>使用栈</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> s;<br>        string res;<br><br>        stack&lt;<span class="hljs-keyword">char</span>&gt; c_stack;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>() ; ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>( !c_stack.<span class="hljs-built_in">empty</span>() &amp;&amp; c_stack.<span class="hljs-built_in">top</span>() == s[i]) c_stack.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">else</span> c_stack.<span class="hljs-built_in">push</span>(s[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(!c_stack.<span class="hljs-built_in">empty</span>())&#123;<br><br>            res.<span class="hljs-built_in">insert</span>(res.<span class="hljs-built_in">begin</span>(),c_stack.<span class="hljs-built_in">top</span>());<br>            c_stack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="模拟栈"><a href="#模拟栈" class="headerlink" title="模拟栈"></a>模拟栈</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> s;<br>        <br>        <span class="hljs-keyword">int</span> stack_top = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> len = s.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">while</span>(len--)&#123;<br><br>           <span class="hljs-keyword">if</span>(stack_top != <span class="hljs-number">-1</span> &amp;&amp; s[stack_top] == s[stack_top+<span class="hljs-number">1</span>]) <br>           &#123;<br>                s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>() + stack_top,s.<span class="hljs-built_in">begin</span>() + stack_top + <span class="hljs-number">2</span>);<br>                --stack_top;<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               ++stack_top;<br>           &#125;<br>           <br>        <br>        &#125;<br>       <br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="模拟栈-就地算法"><a href="#模拟栈-就地算法" class="headerlink" title="模拟栈+就地算法"></a>模拟栈+就地算法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> s;<br>        <br>        <span class="hljs-keyword">int</span> stack_top = <span class="hljs-number">-1</span>;<span class="hljs-comment">//模拟栈顶</span><br>        <span class="hljs-keyword">int</span> org = <span class="hljs-number">0</span>;<span class="hljs-comment">//原字符串指针</span><br><br>        <span class="hljs-comment">//遍历每一个字符</span><br>        <span class="hljs-keyword">while</span>(org &lt; s.<span class="hljs-built_in">size</span>())&#123;<br><br>           <span class="hljs-keyword">if</span>(stack_top != <span class="hljs-number">-1</span> &amp;&amp; s[stack_top] == s[org])<span class="hljs-comment">//如果相等,模拟退出栈元素</span><br>           &#123;<br>                --stack_top;<br>                ++org;<br><br>           &#125;<span class="hljs-keyword">else</span>&#123;<br><br>               s[++stack_top] = s[org++];<span class="hljs-comment">//模拟元素入栈</span><br>           &#125;<br>           <br>        &#125;<br>        s.<span class="hljs-built_in">resize</span>(stack_top+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用就地算法，配合双指针，在原来的字符串上操作。栈底为字符串的begin()的前一位，栈顶指向的就是当前判断元素的上一个。</p><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>字符串或是数组类型的都可以使用就地算法来避免大量的移动开销。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>就地算法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>111. 二叉树的最小深度</title>
    <link href="/2020/12/14/LeetCode/111.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
    <url>/2020/12/14/LeetCode/111.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">本题链接</a></p><h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">int</span> res  = <span class="hljs-number">-1</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root,<span class="hljs-keyword">int</span> depth = <span class="hljs-number">1</span>)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">if</span>((<span class="hljs-built_in">minDepth</span>(root-&gt;left,depth + <span class="hljs-number">1</span>) + <span class="hljs-built_in">minDepth</span>(root-&gt;right,depth + <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>)<span class="hljs-comment">//到达叶子节点</span><br>            <span class="hljs-comment">//这里的判断是为了避免树退化成单链表的情况出现错误</span><br>            res = res == <span class="hljs-number">-1</span> ? depth : <span class="hljs-built_in">min</span>(depth,res);<br><br>        <span class="hljs-comment">//其实这个返回值只对第一个函数有意义</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对结果的赋值操作出现在叶子节点，所以只要在叶子节点进行判断即可。</p><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>…</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">int</span> res  = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root,<span class="hljs-keyword">int</span> depth = <span class="hljs-number">1</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> root?((<span class="hljs-built_in">minDepth</span>(root-&gt;left,depth+<span class="hljs-number">1</span>)+<span class="hljs-built_in">minDepth</span>(root-&gt;right,depth+<span class="hljs-number">1</span>))==<span class="hljs-number">0</span>?res=(res==<span class="hljs-number">0</span>?depth:<span class="hljs-built_in">min</span>(depth,res)):res):<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小型内存分配器</title>
    <link href="/2020/12/13/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%B0%8F%E5%9E%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/"/>
    <url>/2020/12/13/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%B0%8F%E5%9E%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>起因：</p><ul><li>提升速度</li><li>降低浪费率（cookie），或者说减少cookie的用量</li></ul><h2 id="per-class-allocator-1"><a href="#per-class-allocator-1" class="headerlink" title="per-class allocator 1"></a>per-class allocator 1</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Screen</span>(<span class="hljs-keyword">int</span> x):<span class="hljs-built_in">i</span>(x)&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> i;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">size_t</span>)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    Screen* next;<span class="hljs-comment">//用来指向申请的内存池</span><br>    <span class="hljs-keyword">static</span> Screen* freeStore;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> screenChunk;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> i;<span class="hljs-comment">//该类数据</span><br>&#125;;<br><br>Screen* Screen::freeStore = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Screen::screenChunk = <span class="hljs-number">24</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* Screen::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    Screen* p;<br>    <span class="hljs-keyword">if</span>(!freeStore)<br>    &#123;<br>        <span class="hljs-keyword">size_t</span> chunk = screenChunk * size;<span class="hljs-comment">//申请内存的大小</span><br>        freeStore = p = <span class="hljs-keyword">reinterpret_cast</span>&lt;Screen*&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[chunk]);<br>        <span class="hljs-comment">//将一大块分割片片，当作linked list串接起来</span><br>        <span class="hljs-keyword">for</span>(;p!=&amp;freeStore[screenChunk<span class="hljs-number">-1</span>];++p)<br>            p-&gt;next = p+<span class="hljs-number">1</span>;<br>        p-&gt;next = <span class="hljs-number">0</span>;<br>    &#125;<br>    p = freeStore;<br>    freeStore = freeStore-&gt;next;<span class="hljs-comment">//指向链表首位</span><br>    <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//把链表传回去</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> Screen::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *p, <span class="hljs-keyword">size_t</span>)</span></span><br><span class="hljs-function"></span>&#123;        <span class="hljs-comment">//将指针回收到单向链表之中，放回前端</span><br>    (<span class="hljs-keyword">static_cast</span>&lt;Screen*&gt;(p))-&gt;next = freeStore;<br>    freeStore = <span class="hljs-keyword">static_cast</span>&lt;Screen*&gt;(p);    <br>&#125; <br></code></pre></div></td></tr></table></figure><ul><li>这种设计虽然降低了cookie的数量，但是会引发多耗用一个next的问题，即多了个指针的大小。</li><li><code>operator delete</code>并不算是释放，而是将p归还到链表中，可以让下一个创建者继续使用，而原先p指向的那个区域的旧东西将被新创建者覆盖。</li></ul><h2 id="per-class-allocator-2"><a href="#per-class-allocator-2" class="headerlink" title="per-class allocator 2"></a>per-class allocator 2</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Airplane</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AirplaneRep</span> &#123;</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> miles;<br><span class="hljs-keyword">char</span> type;<br>&#125;;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>AirplaneRep rep;<span class="hljs-comment">//此指针指向使用中的对象</span><br>Airplane* next;<span class="hljs-comment">//此指针指向free list上的对象</span><br>&#125;;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getMiles</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> rep.miles;&#125;<br><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> rep.type;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> m, <span class="hljs-keyword">char</span> t)</span> </span>&#123;<br>rep.miles = m;<br>rep.type = t;<br>&#125;<br><span class="hljs-comment">//重载new和delete</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* deadObject, <span class="hljs-keyword">size_t</span> size)</span></span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> BLOCK_SIZE;<br><span class="hljs-keyword">static</span> Airplane* headOfFreeList;<br>&#125;;<br>Airplane* Airplane::headOfFreeList;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Airplane::BLOCK_SIZE = <span class="hljs-number">512</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* Airplane::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//在继承发生时可能size大小有误</span><br><span class="hljs-keyword">if</span>(size != <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Airplane))<br><span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in"><span class="hljs-keyword">new</span></span>(size);<br>Airplane* p = headOfFreeList;<br><span class="hljs-keyword">if</span>(p)<span class="hljs-comment">//如果p有效就把链表头部向下移</span><br>headOfFreeList = p-&gt;next;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//如果链表已空，申请一大块内存</span><br>Airplane* newBlock = <span class="hljs-keyword">static_cast</span>&lt;Airplane*&gt;<br>            (::<span class="hljs-keyword">operator</span> <span class="hljs-built_in"><span class="hljs-keyword">new</span></span>(BLOCK_SIZE * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Airplane)));<br><br><span class="hljs-comment">//将小块穿成一个freelist</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; BLOCK_SIZE - <span class="hljs-number">1</span>; ++i)<br>newBlock[i].next = &amp;newBlock[i+<span class="hljs-number">1</span>];<br>newBlock[BLOCK_SIZE - <span class="hljs-number">1</span>].next = <span class="hljs-number">0</span>;<br>p = newBlock;<br>headOfFreeList = &amp;newBlock[<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//operator delete截获一个内存块</span><br><span class="hljs-comment">//如果大小正确，就把它加到freelist前端</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> Airplane::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* deadObject, <span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(deadObject == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(size != <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Airplane)) &#123;<br>::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(deadObject)</span></span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>Airplane* carcass = <span class="hljs-keyword">static_cast</span>&lt;Airplane*&gt;(deadObject);<br>carcass-&gt;next = headOfFreeList;<br>headOfFreeList = carcass;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>这种设计很巧妙的运用了联合体。当该内存块在单元中未使用，就让<code>next</code>指针指向下一个未分配的内存块，当这个块被实例化后，next所占用的4个字节就是真正的数据了。若该内存块被创建者使用，创建者就可以使用<code>AirplaneRep</code>的数据覆盖掉<code>next</code>指针。这样做相比<strong>per-class allocator 1</strong>的方法少了额外放成员变量的空间，也就是说将指针和数据合二为一了，根据使用场景不同使用不同的变量。</li><li><code>operator new</code>中<code>for(int i = 1; i &lt; BLOCK_SIZE - 1; ++i)&#123;...&#125;</code>的迭代值<code>i</code>是从<strong>1</strong>开始的，原因是只有当内存中没有这个链表内存空间才会走到当前for循环，也就是说<strong>第一次</strong>有创建者需要一个<code>Airplane</code>。所以直接返回一个第一个对象的空间就可以了，并不需要将该对象的<code>next</code>指向下一个链表内存块，因为对于使用者来说，<code>next</code>指针对他没用处。</li><li>而至于<code>operator delete</code>中为什么要多创建一个<code>Airplane* carcass</code>的原因，有点摸不着头脑。感觉只能这么解释：因为传进来的<code>deadObject</code>使用的是联合体中的<code>AirplaneRep</code>，而<code>AirplaneRep</code>中并没有<code>next</code>指针，所以不能用<code>deadObject</code>去获得<code>next</code>指针，只能通过创建一个新的指针<code>carcass</code>通过显式转换指向<code>deadObject</code>，然后根据这个<code>carcass</code>去修改<code>next</code>的值。</li></ul><h2 id="static-allocator-3"><a href="#static-allocator-3" class="headerlink" title="static allocator 3"></a>static allocator 3</h2><p>之前的两个版本<strong>per-class allocator 1</strong>和<strong>per-class allocator 2</strong>都是在类里重载<code>new</code>和<code>delete</code>，实际上都是完成同样的任务，所以可以将这部分的内存分配抽出来成为一个<code>allocator</code>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">allocator</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">obj</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">obj</span>* <span class="hljs-title">next</span>;</span><br>&#125;;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*,<span class="hljs-keyword">size_t</span>)</span></span>;<br><span class="hljs-keyword">private</span>:<br>obj* freeStore = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> CHUNK = <span class="hljs-number">5</span>;<span class="hljs-comment">//这里小一些以便观察</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">allocator::deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p,<span class="hljs-keyword">size_t</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//将*p收回插入free list 前端</span><br>((obj*)p)-&gt;next = freeStore;<br>freeStore = (obj*)p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">allocator::allocate</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>obj* p;<br><span class="hljs-keyword">if</span>(!freeStore) &#123;<br><span class="hljs-comment">//linked list为空，于是申请一大块</span><br><span class="hljs-keyword">size_t</span> chunk = CHUNK * size;<br>freeStore = p = (obj*)<span class="hljs-built_in">malloc</span>(chunk);<br><br><span class="hljs-comment">//将分配得来的一大块当作linked list</span><br><span class="hljs-comment">//串接起来</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (CHUNK - <span class="hljs-number">1</span>); ++i) &#123;<br>p-&gt;next = (obj*)((<span class="hljs-keyword">char</span>*)p + size);<br>p = p-&gt;next;<br>&#125;<br>p-&gt;next = <span class="hljs-literal">nullptr</span>;<br>&#125;<br>p = freeStore;<br>freeStore = freeStore-&gt;next;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">long</span> L;<br>string str;<br><span class="hljs-keyword">static</span> allocator myAlloc;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Foo</span>(<span class="hljs-keyword">long</span> l):<span class="hljs-built_in">L</span>(<span class="hljs-number">1</span>)&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> </span>&#123;<br><span class="hljs-keyword">return</span> myAlloc.<span class="hljs-built_in">allocate</span>(size);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* pdead,<span class="hljs-keyword">size_t</span> size)</span> </span>&#123;<br><span class="hljs-keyword">return</span> myAlloc.<span class="hljs-built_in">deallocate</span>(pdead,size);<br>&#125;<br>&#125;;<br>allocator Foo::myAlloc;<br></code></pre></div></td></tr></table></figure><ul><li><p>这个版本由于allocator的提取，所以增加了代码的复用性。</p></li><li><p>因为<code>const int CHUNK = 5</code>，所以在内存里面分配的容量会比较小，便于管理。例如创建了<strong>23</strong>个<code>Foo</code>，在下图中可以看到地址是不连续的：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/0cdb64f500e17561171414bbe163980f-ed140.png" style="zoom: 50%;" /></p></li><li><p>因为在<code>Foo</code>中的<code>allocator</code>为<code>static</code>类型，所以<code>Foo</code>独自拥有一个静态的<code>allocator</code>变量。推而广之，可以针对不同的类维护<code>allocator</code>里的<code>freeStore</code>和<code>next</code>，即每个类都有单独的区域，不互相影响。</p></li></ul><h3 id="macro-for-static-allocator"><a href="#macro-for-static-allocator" class="headerlink" title="macro for static allocator"></a>macro for static allocator</h3><p>由偷懒而引发的小技巧：<strong>static allocator</strong>中的<code>allocator</code>可以进一步写成以下形式，然后在类里的使用会非常方便。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECLARE_POOL_ALLOC() \</span><br><span class="hljs-meta">public: \</span><br><span class="hljs-meta">    void* operator new(size_t size) &#123; return myAlloc.allocate(size); &#125; \</span><br><span class="hljs-meta">    void operator delete(void* p) &#123; myAlloc.deallocate(p, 0); &#125; \</span><br><span class="hljs-meta">protected: \</span><br><span class="hljs-meta">    static allocator myAlloc; </span><br><br><span class="hljs-comment">// IMPLEMENT_POOL_ALLOC -- used in class implementation file</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMPLEMENT_POOL_ALLOC(class_name) \</span><br><span class="hljs-meta">allocator class_name::myAlloc; </span><br><br><br><span class="hljs-comment">// in class definition file</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span><br>   <span class="hljs-built_in">DECLARE_POOL_ALLOC</span>()<br><span class="hljs-keyword">public</span>: <br><span class="hljs-keyword">long</span> L;<br>string str;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Foo</span>(<span class="hljs-keyword">long</span> l) : <span class="hljs-built_in">L</span>(l) &#123;  &#125;   <br>&#125;;<br><span class="hljs-comment">//in class implementation file</span><br><span class="hljs-built_in">IMPLEMENT_POOL_ALLOC</span>(Foo) <br></code></pre></div></td></tr></table></figure><h2 id="new-handler"><a href="#new-handler" class="headerlink" title="new handler"></a>new handler</h2><p>当<code>operator new</code>没有能力分配我们所申请的内存，会抛出一个<code>std::bad_alloc</code> exception。某些老旧编译器则是返回0，但是我们依然可以让我们的编译器返回0，做法是：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">new</span>(nothrow) Foo;<span class="hljs-comment">//此称为nothrow形式</span><br></code></pre></div></td></tr></table></figure><p>当我们不按照上面的写法，而是想让我们的内存分配失败时执行我们想要的行为可以吗？可以，C++提供了一个机制<strong>new handler</strong>，我们首先需实现一个形为如下的函数：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*new_handler)</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(new_handler p)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br></code></pre></div></td></tr></table></figure><p>使用方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;new&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cassert&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//我们写的new_handler函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">noMoreMemory</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//在此写上我们希望的行为</span><br>cerr &lt;&lt; <span class="hljs-string">&quot;out of memory&quot;</span>;<br><span class="hljs-built_in">abort</span>();<span class="hljs-comment">//此处若没有这条，那么内存分配失败将一直输出&quot;out of memory&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//设置new_handler</span><br><span class="hljs-built_in">set_new_handler</span>(noMoreMemory);<br><br><span class="hljs-keyword">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100000000000000000</span>];<br><span class="hljs-built_in">assert</span>(p);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意：<strong>new handler</strong>的设计只有两种选择</p><ul><li>让更多的内存可用</li><li>调用<code>abort()</code>或<code>exit()</code></li></ul><p><strong>operator new源码：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7142b5769c270e56124913e1a424b890-1c387.png" style="zoom:50%;" /></p><p><strong>new handler源码：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/c93305fadc36ed14255c47a1efdb058a-8b3c7.png" style="zoom: 67%;" /></p><h2 id="delete-和-default"><a href="#delete-和-default" class="headerlink" title="= delete 和 = default"></a>= delete 和 = default</h2><p><code>= default</code>的作用是：该函数使用默认版本。比如使用默认的构造、拷贝构造等。</p><p><code>= delete</code>的作用是：让该函数无效。</p><p>参考：<a href="https://blog.csdn.net/qq_41453285/article/details/100606913">C++:73—-C++11标准（类的删除函数：=delete关键字、阻止构造、阻止拷贝、private阻止拷贝控制）</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>问题归纳</title>
    <link href="/2020/12/13/C++/%E9%97%AE%E9%A2%98%E5%BD%92%E7%BA%B3/"/>
    <url>/2020/12/13/C++/%E9%97%AE%E9%A2%98%E5%BD%92%E7%BA%B3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="引用的生命周期？"><a href="#引用的生命周期？" class="headerlink" title="引用的生命周期？"></a>引用的生命周期？</h2><p>与局部变量类似</p><h2 id="友元函数是类成员函数吗？"><a href="#友元函数是类成员函数吗？" class="headerlink" title="友元函数是类成员函数吗？"></a>友元函数是类成员函数吗？</h2><p>不是，友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。</p><p>参考：<a href="https://www.runoob.com/cplusplus/cpp-friend-functions.html">C++ 友元函数</a></p><h2 id="如何判断操作符重载放在类里还是类外？"><a href="#如何判断操作符重载放在类里还是类外？" class="headerlink" title="如何判断操作符重载放在类里还是类外？"></a>如何判断操作符重载放在类里还是类外？</h2><p>赋值（=）、下标（[]）、调用（()）和成员访问箭头（-&gt;）运算符必须是成员（函数）。</p><p>参考：<a href="https://blog.csdn.net/qq_29344757/article/details/78820189">为什么有的操作符重载函数只能是成员函数?</a></p><h2 id="初始化列表的优势体现在哪里？"><a href="#初始化列表的优势体现在哪里？" class="headerlink" title="初始化列表的优势体现在哪里？"></a>初始化列表的优势体现在哪里？</h2><ol><li>类成员中存在常量，如<code>const int a</code>,只能用初始化不能复制</li><li>类成员中存在引用，同样只能使用初始化不能赋值</li><li>提高效率</li></ol><p>参考：<a href="https://www.cnblogs.com/wuyepeng/p/9863763.html">使用初始化列表的好处</a></p><h2 id="为什么要虚的析构函数？"><a href="#为什么要虚的析构函数？" class="headerlink" title="为什么要虚的析构函数？"></a>为什么要虚的析构函数？</h2><p>这样做是为了当<strong>用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用</strong>。当然，<strong>并不是要把所有类的析构函数都写成虚函数</strong>。因为当类里面有虚函数的时候，编译器会给类添加一个虚函数表，里面来存放虚函数指针，这样就会增加类的存储空间。所以，只有<strong>当一个类被用来作为基类的时候，才把析构函数写成虚函数</strong>。</p><p>参考：<a href="https://blog.csdn.net/zhangjingyangguang/article/details/21549991">为什么要用虚析构函数</a></p><h2 id="什么叫做对象切割？"><a href="#什么叫做对象切割？" class="headerlink" title="什么叫做对象切割？"></a>什么叫做对象切割？</h2><p>出现在多态情况下，使用基类类型指向派生类实例，即向上转型</p><h2 id="什么叫做编译转换？"><a href="#什么叫做编译转换？" class="headerlink" title="什么叫做编译转换？"></a>什么叫做编译转换？</h2><h2 id="std-move？"><a href="#std-move？" class="headerlink" title="std::move？"></a>std::move？</h2><ul><li><strong>事实上std::move移动不了什么，唯一的功能是把左值强制转化为右值</strong>，让右值引用可以指向左值。其实现等同于一个类型转换：<code>static_cast&lt;T&amp;&amp;&gt;(lvalue)</code>。 所以，<strong>单纯的std::move(xxx)不会有性能提升</strong></li><li><strong>被声明出来的左、右值引用都是左值</strong>。 因为被声明出的左右值引用是有地址的，也位于等号左边。</li><li><strong>右值引用既可以是左值也可以是右值，如果有名称则为左值，否则是右值</strong></li><li><strong>从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。</strong></li><li><strong>右值引用可以直接指向右值，也可以通过std::move指向左值；而左值引用只能指向左值(const左值引用也能指向右值)。</strong></li><li><strong>作为函数形参时，右值引用更灵活。虽然const左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。</strong></li><li>编译器会<strong>默认</strong>在用户自定义的<code>class</code>和<code>struct</code>中生成移动语义函数，但前提是用户没有主动定义该类的<code>拷贝构造</code>等函数</li><li><strong>可移动对象在&lt;需要拷贝且被拷贝者之后不再被需要&gt;的场景，建议使用</strong><code>std::move</code><strong>触发移动语义，提升性能</strong></li><li><strong>std::move本身只做类型转换，对性能无影响。</strong> <strong>我们可以在自己的类中实现移动语义，避免深拷贝，充分利用右值引用和std::move的语言特性</strong></li></ul><p>参考：<a href="https://zhuanlan.zhihu.com/p/335994370">一文读懂C++右值引用和std::move</a></p><h2 id="返回值的生命周期？"><a href="#返回值的生命周期？" class="headerlink" title="返回值的生命周期？"></a>返回值的生命周期？</h2><h2 id="操作符重载作为成员函数和非成员函数时的优缺点"><a href="#操作符重载作为成员函数和非成员函数时的优缺点" class="headerlink" title="操作符重载作为成员函数和非成员函数时的优缺点"></a>操作符重载作为成员函数和非成员函数时的优缺点</h2><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><h2 id="C-RAII？"><a href="#C-RAII？" class="headerlink" title="C++RAII？"></a>C++RAII？</h2><p>RAII（<strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization）是由c++之父Bjarne Stroustrup提出的，中文翻译为资源获取即初始化，他说：使用局部对象来管理资源的技术称为资源获取即初始化；这里的资源主要是指操作系统中有限的东西如内存、网络套接字等等，局部对象是指存储在栈的对象，它的生命周期是由操作系统来管理的，无需人工介入；</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/34660259">c++经验之谈一：RAII原理介绍</a></p><h2 id="为什么要用基类指针指向派生类？"><a href="#为什么要用基类指针指向派生类？" class="headerlink" title="为什么要用基类指针指向派生类？"></a>为什么要用基类指针指向派生类？</h2><p>在基类与派生类之间，有一个<strong>规定</strong>：派生类对象的地址可以赋给指向基类对象的指针变量（简称<strong>基类指针</strong>），即基类指针也可以指向派生类对象。为什么有这一规定呢？因为它可以实现<strong>多态性</strong>，即向不同的对象发送同一个消息，不同的对象在接受时会产生不同的行为。</p><p>基类指针可以指向基类对象；派生类指针可以指向派生类对象；基类指针可以指向派生类对象（无需强制转换），但只能引用基类中有的成员； 派生类指针指向基类对象，会引发语法错误。但派生类指针通过强制转换可指向基类对象。可是该动作很危险：若引用对象中不村在的派生类成员，会得到错误的结果。</p><p>参考：<a href="https://blog.csdn.net/hk121/article/details/81165391">为什么要用基类指针指向派生类对象？</a></p><h2 id="动态联编和静态联编"><a href="#动态联编和静态联编" class="headerlink" title="动态联编和静态联编"></a>动态联编和静态联编</h2><h2 id="向上转型和向下转型"><a href="#向上转型和向下转型" class="headerlink" title="向上转型和向下转型"></a>向上转型和向下转型</h2><h2 id="释放一个空指针会有什么问题"><a href="#释放一个空指针会有什么问题" class="headerlink" title="释放一个空指针会有什么问题"></a>释放一个空指针会有什么问题</h2><h2 id="c-类的内存模型"><a href="#c-类的内存模型" class="headerlink" title="c++类的内存模型"></a>c++类的内存模型</h2><h2 id="内存分配中的cookie"><a href="#内存分配中的cookie" class="headerlink" title="内存分配中的cookie"></a>内存分配中的cookie</h2><p>在malloc为用户分配内存的时候，除了分配用户本身的内存，还会在内存前后加上两个cookie，来记录分配了多少内存，这样在调用free函数的时候才能准确的回收内存。因此每次调用malloc函数都会产生cookie消耗。</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/338043328">C++内存管理（malloc和free中的cookie）</a></p><h2 id="Debug模式下多出来的内存空间干嘛用？Debugger-Header、no-man-land？"><a href="#Debug模式下多出来的内存空间干嘛用？Debugger-Header、no-man-land？" class="headerlink" title="Debug模式下多出来的内存空间干嘛用？Debugger Header、no man land？"></a>Debug模式下多出来的内存空间干嘛用？Debugger Header、no man land？</h2><p>详见《malloc与free》</p><h2 id="静态数据什么时候会被创建"><a href="#静态数据什么时候会被创建" class="headerlink" title="静态数据什么时候会被创建"></a>静态数据什么时候会被创建</h2><h2 id="纯虚函数的定义"><a href="#纯虚函数的定义" class="headerlink" title="纯虚函数的定义"></a>纯虚函数的定义</h2><h2 id="C-子类拥有和父类的同名非虚函数会发生什么情况？"><a href="#C-子类拥有和父类的同名非虚函数会发生什么情况？" class="headerlink" title="C++子类拥有和父类的同名非虚函数会发生什么情况？"></a>C++子类拥有和父类的同名非虚函数会发生什么情况？</h2><h2 id="C-函数签名？"><a href="#C-函数签名？" class="headerlink" title="C++函数签名？"></a>C++函数签名？</h2><ul><li>C++中的函数签名(function signature)：包含了一个函数的信息，包括函数名、参数类型、参数个数、顺序以及它所在的类和命名空间。普通函数签名并不包含函数返回值部分，如果两个函数仅仅只有函数返回值不同，那么系统是无法区分这两个函数的，此时编译器会提示语法错误。函数签名用于识别不同的函数，函数的名字只是函数签名的一部分。在编译器及链接器处理符号时，使用某种名称修饰的方法，使得每个函数签名对应一个修饰后名称(decorated name)。编译器在将C++源代码编译成目标文件时，会将函数和变量的名字进行修饰，形成符号名，也就是说，C++的源代码编译后的目标文件中所使用的符号名是相应的函数和变量的修饰后名称。C++编译器和链接器都使用符号来识别和处理函数和变量，所以对于不同函数签名的函数，即使函数名相同，编译器和链接器都认为它们是不同的函数。</li></ul><p>参考：<a href="https://blog.csdn.net/fengbingchun/article/details/79133749">C++中的函数签名</a></p><h2 id="栈对象如何向上转型"><a href="#栈对象如何向上转型" class="headerlink" title="栈对象如何向上转型"></a>栈对象如何向上转型</h2><h2 id="C-中的原子对象"><a href="#C-中的原子对象" class="headerlink" title="C++中的原子对象"></a>C++中的原子对象</h2><h2 id="C-中的reorder"><a href="#C-中的reorder" class="headerlink" title="C++中的reorder"></a>C++中的reorder</h2><h2 id="C-的异常和底层机制"><a href="#C-的异常和底层机制" class="headerlink" title="C++的异常和底层机制"></a>C++的异常和底层机制</h2><h2 id="C-abort"><a href="#C-abort" class="headerlink" title="C++abort()"></a>C++abort()</h2><h2 id="C-List为什么会有maxsize"><a href="#C-List为什么会有maxsize" class="headerlink" title="C++List为什么会有maxsize?"></a>C++List为什么会有maxsize?</h2><h2 id="C-泛化指针"><a href="#C-泛化指针" class="headerlink" title="C++泛化指针"></a>C++泛化指针</h2><h2 id="C-的malloc详解"><a href="#C-的malloc详解" class="headerlink" title="C++的malloc详解"></a>C++的malloc详解</h2><p>详见《malloc与free》</p><h2 id="C-序列化"><a href="#C-序列化" class="headerlink" title="C++序列化"></a>C++序列化</h2><h2 id="C-访问级别底层原理？"><a href="#C-访问级别底层原理？" class="headerlink" title="C++访问级别底层原理？"></a>C++访问级别底层原理？</h2><h2 id="C-智能指针？"><a href="#C-智能指针？" class="headerlink" title="C++智能指针？"></a>C++智能指针？</h2><h2 id="C-override"><a href="#C-override" class="headerlink" title="C++override?"></a>C++override?</h2><p>详见《高级开发》</p><h2 id="C-如何充分利用CPU时间片？"><a href="#C-如何充分利用CPU时间片？" class="headerlink" title="C++如何充分利用CPU时间片？"></a>C++如何充分利用CPU时间片？</h2><h2 id="C-类中的typedef以及它的空间占用和底层实现？"><a href="#C-类中的typedef以及它的空间占用和底层实现？" class="headerlink" title="C++类中的typedef以及它的空间占用和底层实现？"></a>C++类中的typedef以及它的空间占用和底层实现？</h2><p>无空间占用，只在编译阶段对指令取址范围进行处理</p><h2 id="C-引用折叠？"><a href="#C-引用折叠？" class="headerlink" title="C++引用折叠？"></a>C++引用折叠？</h2><h2 id="C-嵌入式指针？"><a href="#C-嵌入式指针？" class="headerlink" title="C++嵌入式指针？"></a>C++嵌入式指针？</h2><p>即使用联合体，详见《小型内存分配器》的第一个例子</p><h2 id="C-类的静态函数能直接被调用吗？"><a href="#C-类的静态函数能直接被调用吗？" class="headerlink" title="C++类的静态函数能直接被调用吗？"></a>C++类的静态函数能直接被调用吗？</h2><p>答：可以。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符:: 就可以访问。 静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。 静态成员函数有一个类范围，他们不能访问类的this 指针。</p><h2 id="C-typename"><a href="#C-typename" class="headerlink" title="C++typename"></a>C++typename</h2><ul><li>typename在下面情况下禁止使用：<ul><li>模板定义之外，即typename只能用于模板的定义中</li><li>非限定类型，比如前面介绍过的<code>int</code>，<code>vector&lt;int&gt;</code>之类</li><li>基类列表中，比如<code>template &lt;class T&gt; class C1 : T::InnerType</code>不能在<code>T::InnerType</code>前面加typename</li><li>构造函数的初始化列表中</li></ul></li><li>如果类型是依赖于模板参数的限定名，那么在它之前<strong>必须</strong>加typename(除非是基类列表，或者在类的初始化成员列表中)</li><li>其它情况下typename是<strong>可选</strong>的，也就是说对于一个不是依赖名的限定名，该名称是可选的，例如<code>vector&lt;int&gt; vi;</code></li></ul><p>参考：<a href="https://feihu.me/blog/2014/the-origin-and-usage-of-typename/">知无涯之C++ typename的起源与用法</a></p><h2 id="C-volatile"><a href="#C-volatile" class="headerlink" title="C++volatile?"></a>C++volatile?</h2><p>对于施加了volatile的变量：</p><ul><li>阻止编译器为了提高速度将该变量缓存到寄存器内而不写回</li><li>阻止编译器调整操作volatile变量的指令顺序</li></ul><p>一般说来，volatile用在如下的几个地方：</p><ul><li>中断服务程序中修改的供其它程序检测的变量需要加 volatile</li><li>多任务环境下各任务间共享的标志应该加 volatile</li><li>存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对它的读写都可能由不同意义</li></ul><p>参考：<a href="https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777432.html">C/C++中volatile关键字详解</a>、《程序员的自我修养：链接、装载与库》</p><h2 id="C-创建对象用中括号"><a href="#C-创建对象用中括号" class="headerlink" title="C++创建对象用中括号{}"></a>C++创建对象用中括号{}</h2><p>新特性语法糖</p><h2 id="C-如何刷新缓冲区及其原理"><a href="#C-如何刷新缓冲区及其原理" class="headerlink" title="C++如何刷新缓冲区及其原理"></a>C++如何刷新缓冲区及其原理</h2><h2 id="在C-拷贝构造函数中使用初始化列表"><a href="#在C-拷贝构造函数中使用初始化列表" class="headerlink" title="在C++拷贝构造函数中使用初始化列表"></a>在C++拷贝构造函数中使用初始化列表</h2><p>参考：<a href="https://blog.csdn.net/justin12zhu/article/details/9174491">在C++拷贝构造函数中使用初始化列表</a></p><h2 id="C-释放一个空指针？"><a href="#C-释放一个空指针？" class="headerlink" title="C++释放一个空指针？"></a>C++释放一个空指针？</h2><h2 id="C-中进程的栈和堆的空间为多少？"><a href="#C-中进程的栈和堆的空间为多少？" class="headerlink" title="C++中进程的栈和堆的空间为多少？"></a>C++中进程的栈和堆的空间为多少？</h2><ul><li><strong>栈：</strong>在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</li><li><strong>堆：</strong>堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</li></ul><p>参考：<a href="https://blog.csdn.net/capecape/article/details/78038997">C++堆空间和栈空间的区别</a></p><h2 id="C-中被调用函数如何被释放？返回值在什么时候被获取？"><a href="#C-中被调用函数如何被释放？返回值在什么时候被获取？" class="headerlink" title="C++中被调用函数如何被释放？返回值在什么时候被获取？"></a>C++中被调用函数如何被释放？返回值在什么时候被获取？</h2><h2 id="C-强制类型转换？"><a href="#C-强制类型转换？" class="headerlink" title="C++强制类型转换？"></a>C++强制类型转换？</h2><ul><li>const_cast<ul><li>常量指针被转化成非常量的指针，并且仍然指向原来的对象；</li><li>常量引用被转换成非常量的引用，并且仍然指向原来的对象；</li><li>const_cast一般用于修改指针。如const char *p形式。</li></ul></li><li>static_cast<ul><li>static_cast 作用和C语言风格强制转换的效果基本一样，由于没有运行时类型检查来保证转换的安全性，所以这类型的强制转换和C语言风格的强制转换都有安全隐患。</li><li>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。注意：进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。</li><li>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性需要开发者来维护。</li><li>static_cast不能转换掉原有类型的const、volatile、或者 __unaligned属性。(前两种可以使用const_cast 来去除)</li><li>在c++ primer 中说道：c++ 的任何的隐式转换都是使用 <em>static_cast</em> 来实现。</li></ul></li><li>dynamic_cast<ul><li><em>dynamic_cast</em>强制转换,应该是这四种中最特殊的一个,因为他涉及到面向对象的多态性和程序运行时的状态,也与编译器的属性设置有关.所以不能完全使用C语言的强制转换替代,它也是最常有用的,最不可缺少的一种强制转换.</li><li>对于从子类到基类的指针转换 ,dynamic_cast 成功转换,没有什么运行异常,且达到预期结果<br>而从基类到子类的转换 , dynamic_cast 在转换时也没有报错,但是输出给 base2sub 是一个 nullptr ,说明dynami_cast 在程序运行时对类型转换对“运行期类型信息”（Runtime type information，RTTI）进行了检查.<br>这个检查主要来自虚函数(virtual function) 在C++的面对对象思想中，虚函数起到了很关键的作用，当一个类中拥有至少一个虚函数，那么编译器就会构建出一个虚函数表(virtual method table)来指示这些函数的地址，假如继承该类的子类定义并实现了一个同名并具有同样函数签名（function siguature）的方法重写了基类中的方法，那么虚函数表会将该函数指向新的地址。此时多态性就体现出来了：当我们将基类的指针或引用指向子类的对象的时候，调用方法时，就会顺着虚函数表找到对应子类的方法而非基类的方法。</li></ul></li><li>reinterpret_cast<ul><li>reinterpret_cast是强制类型转换符用来处理无关类型转换的，通常为操作数的位模式提供较低层次的重新解释！但是他仅仅是重新解释了给出的对象的比特模型，并没有进行二进制的转换！<br>他是用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换</li></ul></li></ul><p>参考：<a href="https://blog.csdn.net/ydar95/article/details/69822540">c++ 四种强制类型转换介绍</a></p><h2 id="断言和异常的区别和使用场景"><a href="#断言和异常的区别和使用场景" class="headerlink" title="断言和异常的区别和使用场景?"></a>断言和异常的区别和使用场景?</h2><h2 id="C-模板类型推导？"><a href="#C-模板类型推导？" class="headerlink" title="C++模板类型推导？"></a>C++模板类型推导？</h2><ul><li>在模板类型推导时，引用类型实参会被当成非引用类型的，即忽略引用性。</li><li>为通用引用类型形参推导类型时，左值实参会被特殊对待。</li><li>为值传递类型形参推导类型时，const 和 volatile 实参会被当成 non-const 和 non-volatile。</li><li>在模板类型推导时，数组或函数实参会退化为指针，除非它们被用于初始化引用。</li></ul><p>参考：<a href="http://blog.leanote.com/post/gaunthan/C-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC">C++ 模板类型推导</a></p><h2 id="C-引用折叠与万能引用？"><a href="#C-引用折叠与万能引用？" class="headerlink" title="C++引用折叠与万能引用？"></a>C++引用折叠与万能引用？</h2><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">所有的引用折叠最终都代表一个引用，要么是左值引用，要么是右值引用。<br><br>规则就是：<br><br>如果任一引用为左值引用，则结果为左值引用。否则（即两个都是右值引用），结果为右值引用。<br>《Effective Modern C++》<br></code></pre></div></td></tr></table></figure><ul><li>模板函数参数为 T&amp;&amp; param,也就是说，不管T是什么类型，T&amp;&amp;的最终结果必然是一个引用类型。如果T是int, 那么T&amp;&amp; 就是 int &amp;&amp;；如果T为 int &amp;，那么 T &amp;&amp;(int&amp; &amp;&amp;) 就是&amp;，如果T为&amp;&amp;,那么T &amp;&amp;(&amp;&amp; &amp;&amp;) 就是&amp;&amp;。很明显，接受左值的话，T只能推导为int &amp;。</li><li><strong>万能引用就是利用模板推导和引用折叠的相关规则，生成不同的实例化模板来接收传进来的参数。</strong></li><li><em>任何的函数内部，对形参的直接使用，都是按照左值进行的</em></li></ul><p>参考：<a href="https://zhuanlan.zhihu.com/p/50816420">引用折叠和完美转发</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>122. 买卖股票的最佳时机 II</title>
    <link href="/2020/12/11/LeetCode/122.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II/"/>
    <url>/2020/12/11/LeetCode/122.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">本题链接</a></p><h1 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a>122. 买卖股票的最佳时机 II</h1><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(prices.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(prices[i+<span class="hljs-number">1</span>]&gt;prices[i])&#123;<br>                max += ( prices[i+<span class="hljs-number">1</span>] - prices[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>思路：这题过于简单，有点像脑筋急转弯。如果在能当天买入及卖出的情况下，那么根据贪心策略，只要第二天的价格大于前一天的价格就把差价累计即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>贪心</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级开发</title>
    <link href="/2020/12/11/C++/%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91/"/>
    <url>/2020/12/11/C++/%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="类体里的内联函数"><a href="#类体里的内联函数" class="headerlink" title="类体里的内联函数"></a>类体里的内联函数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br><span class="hljs-built_in">complex</span> (T r = <span class="hljs-number">0</span>, T i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i)&#123;&#125; <br>complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp;); <br><span class="hljs-function">T <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125; <span class="hljs-comment">//内联函数的候选人</span><br><span class="hljs-function">T <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125; <span class="hljs-comment">//内联函数的候选人</span><br><span class="hljs-keyword">private</span>: <br>T re, im; <span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-keyword">const</span> complex&amp;);  <br>&#125;;<br></code></pre></div></td></tr></table></figure><p>在类体里定义的函数会成为内联函数的<strong>候选人</strong>，最终是否为内联函数由编译器决定。</p><h3 id="构造函数的重载"><a href="#构造函数的重载" class="headerlink" title="构造函数的重载"></a>构造函数的重载</h3><p>构造函数重载的情况很常见，但是比如</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br><span class="hljs-built_in">complex</span> (<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i) &#123;&#125; <span class="hljs-comment">//构造函数1</span><br><span class="hljs-built_in">complex</span> () : <span class="hljs-built_in">re</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">im</span>(<span class="hljs-number">0</span>) &#123;&#125; <span class="hljs-comment">//构造函数2</span><br>complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp;); <br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125; <br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125; <br><span class="hljs-keyword">private</span>: <br><span class="hljs-keyword">double</span> re, im; <br><br><span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-keyword">const</span> complex&amp;);  <br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>构造函数1</strong>和<strong>构造函数2</strong>是不能同时存在的，原因是<strong>构造函数1</strong>的形参设置了默认值，编译器无法分辨它和<strong>构造函数2</strong>的区别</p><h2 id="参数传递与返回值"><a href="#参数传递与返回值" class="headerlink" title="参数传递与返回值"></a>参数传递与返回值</h2><h3 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h3><p>const关键字用于成员函数（如下面代码段中的<strong>一号const</strong>和<strong>二号const</strong>），表示该成员函数所执行的内容不会改变类里面的数据。</p><p>另外，const用于变量（如下面代码段中的<strong>三号const</strong>），表示该变量的值无法被修改。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/*xxx.h*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">complex</span> (<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i)  &#123; &#125; <br>    complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp;); <br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125; <span class="hljs-comment">//一号const</span><br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125; <span class="hljs-comment">//二号const</span><br><span class="hljs-keyword">private</span>: <br>    <span class="hljs-keyword">double</span> re, im; <br>    <span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-keyword">const</span> complex&amp;);  <br>&#125;;<br><br><span class="hljs-comment">/*mian.cc*/</span><br><span class="hljs-comment">//...</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">const</span> complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//三号const</span><br>cout &lt;&lt; c1.<span class="hljs-built_in">real</span>();<span class="hljs-comment">//代码1</span><br>cout &lt;&lt; c1.<span class="hljs-built_in">imag</span>();<span class="hljs-comment">//代码2</span><br>&#125;<br><span class="hljs-comment">//...</span><br></code></pre></div></td></tr></table></figure><p>假设有两种情况：</p><ol><li>一号const和二号const存在</li><li>一号const和二号const不存在</li></ol><p>第一种情况是正确的。c1为const，故无法更改c1的内容。又因为<strong>real()</strong>方法为const，所以<strong>代码1</strong>和<strong>代码2</strong>不会报错。</p><p>第二种情况是错误的。此时<strong>real()</strong>和<strong>imag()</strong>这两个成员函数不是const，而c1变量又是const，当执行<code>cout&lt;&lt;c1.real();</code>时，编译器认为<strong>real()</strong>这个方法可能会改变c1变量的内容，故会报错。这种情况下把<strong>三号const</strong>也去掉，编译器就不会报错了。</p><p>不过为了程序的健壮性与开发规范，没有改变类数据的成员函数加上const是必不可少的。</p><h3 id="参数传递和返回值传递"><a href="#参数传递和返回值传递" class="headerlink" title="参数传递和返回值传递"></a>参数传递和返回值传递</h3><ol><li>值传递：值有多大就传多大</li><li>指针：传地址</li><li>引用：引用的底层就是指针，传引用就是传指针</li></ol><p><strong>参数和返回值传递尽量使用引用</strong>。不过有些情况可以用值，比如值的大小&lt;4字节时，速度会更快点。</p><p>引用速度很快，但是它和指针一样，内容会被修改。当我们只想追求参数传递速度而不想改变引用的内容时，可以使用const来修饰引用。如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br><span class="hljs-built_in">complex</span> (<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i)  &#123; &#125; <br>complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp;); <span class="hljs-comment">//const引用修饰的形参</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125; <br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125; <br><span class="hljs-keyword">private</span>: <br><span class="hljs-keyword">double</span> re, im; <br><span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-keyword">const</span> complex&amp;);<span class="hljs-comment">//const引用修饰的返回值</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p>当函数返回值为函数的<strong>局部变量</strong>时，禁止使用引用。</p><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>在一个类里声明一个友元函数，表示这个友元函数可以随意访问这个类的内容，比如private修饰的类成员数据。即类对于友元函数失去了封装性。</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br><span class="hljs-built_in">complex</span> (<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i)  &#123; &#125; <br>complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp;); <br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125; <br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125; <br><span class="hljs-keyword">private</span>: <br><span class="hljs-keyword">double</span> re, im ; <br><span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-keyword">const</span> complex&amp;);  <br>&#125;;<br><br><span class="hljs-keyword">inline</span> complex&amp; __doapl (complex* ths, <span class="hljs-keyword">const</span> complex&amp; r) &#123; <br>    ths - &gt;re += r.re ; <br>    ths - &gt;im += r.im ; <br>    <span class="hljs-keyword">return</span> *ths ; <br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于友元函数还有个特例：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br><span class="hljs-built_in">complex</span> (<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i)  &#123; &#125; <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> complex&amp; param)</span> </span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> param.re + param.im; &#125; <br><span class="hljs-keyword">private</span>: <br><span class="hljs-keyword">double</span> re, im; <br>&#125;;<br><span class="hljs-comment">//...</span><br>&#123; <br><span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>; <br>complex c2; <br>c2.<span class="hljs-built_in">func</span>(c1); <br>&#125;<br><span class="hljs-comment">//...</span><br></code></pre></div></td></tr></table></figure><p>上面的例子是正确。虽然re和im这两个类成员数据是私有的，但是c2却能访问c1的私有变量。这个隐藏属性用一句话就能解释：</p><p><strong>相同 class 的各个 objects 互为 friends (友元)</strong>。</p><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><h3 id="成员函数的隐藏参数"><a href="#成员函数的隐藏参数" class="headerlink" title="成员函数的隐藏参数"></a>成员函数的隐藏参数</h3><p>所有成员函数都自带一个隐藏的<strong>this</strong>指针</p><h3 id="返回值引用的语法分析"><a href="#返回值引用的语法分析" class="headerlink" title="返回值引用的语法分析"></a>返回值引用的语法分析</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//XXX.h</span><br><span class="hljs-comment">//方法1</span><br><span class="hljs-keyword">inline</span> complex&amp;<span class="hljs-comment">//返回值是引用类型，速度更快</span><br>__doapl(complex* ths, <span class="hljs-keyword">const</span> complex&amp; r) &#123; <br>    ... <br>    <span class="hljs-keyword">return</span> *ths; <span class="hljs-comment">//这里的*表示取ths这个指针的内容</span><br>&#125; <br><br><span class="hljs-comment">//方法2</span><br><span class="hljs-keyword">inline</span> complex&amp; <span class="hljs-comment">//这里返回值改成“值”类型也是没问题的</span><br>complex::<span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp; r) &#123; <span class="hljs-comment">//这里的参数列表只有一个r,这个r指的是右值。而左值是隐藏的this</span><br>    <span class="hljs-keyword">return</span> __doapl(<span class="hljs-keyword">this</span>,r); <span class="hljs-comment">//调用__doapl</span><br>&#125;<br><br><span class="hljs-comment">//main.c</span><br>&#123;<br><span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-function">complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>c2 += c1;<span class="hljs-comment">//上面代码的返回值类型的改动不会影响到这行代码的结果</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>__doapl</strong>这个函数的返回值为引用，所以调用该函数者，无论是以值的类型接收还是以引用的类型接收都可以，与<strong>__doapl</strong>无关。</p><p>我们设计<strong>方法2</strong>的时候，如果只考虑使用者只会编写出<code>c2 += c1</code>这种情况，那么方法2的返回值类型改成void的也是可以的。但是当使用者编写出<code>c3 += c2 += c1</code>这样的连续赋值的代码时，方法2为void返回值类型就会出错。</p><p>一个好的函数设计应该做到：</p><p><strong>传递者无需知道接收者是以引用形式接收</strong></p><p>那么如何判断一个函数的返回值类型能不能为引用呢？其实很简单，只要判断返回值在函数内是不是该函数的临时变量，如果是，就老老实实的用值类型；如果不是，即该返回值是事先存在的（还没调用到该函数时就已经存在了），那么就可以用引用类型的返回值。</p><h3 id="操作符重载的非成员函数与临时对象"><a href="#操作符重载的非成员函数与临时对象" class="headerlink" title="操作符重载的非成员函数与临时对象"></a>操作符重载的非成员函数与临时对象</h3><p>例1：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//函数1</span><br><span class="hljs-keyword">inline</span> complex <br><span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">const</span> complex&amp; x, <span class="hljs-keyword">const</span> complex&amp; y) <br>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>(<span class="hljs-built_in">real</span> (x) + <span class="hljs-built_in">real</span> (y), <span class="hljs-built_in">imag</span> (x) + <span class="hljs-built_in">imag</span> (y)); <br>&#125; <br><br><span class="hljs-comment">//函数2</span><br><span class="hljs-keyword">inline</span> complex <br><span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">const</span> complex&amp; x, <span class="hljs-keyword">double</span> y) <br>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>(<span class="hljs-built_in">real</span> (x) + y, <span class="hljs-built_in">imag</span> (x)); <br>&#125; <br><br><span class="hljs-comment">//函数3</span><br><span class="hljs-keyword">inline</span> complex <br><span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">const</span> complex&amp; y) <br>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>(x + <span class="hljs-built_in">real</span> (y), <span class="hljs-built_in">imag</span> (y)); <br>&#125;<br><br><span class="hljs-comment">//函数4</span><br><span class="hljs-keyword">inline</span> complex<br><span class="hljs-keyword">operator</span> - (<span class="hljs-keyword">const</span> complex&amp; x)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span> (-<span class="hljs-built_in">real</span> (x), -<span class="hljs-built_in">imag</span> (x));<br>&#125;<br><br><span class="hljs-comment">//函数5</span><br><span class="hljs-keyword">inline</span> complex<br><span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">const</span> complex&amp; x)<br>&#123;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-comment">//main.c</span><br>&#123;<br><span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br>complex c2;<br>c2 = c1 + c2;<span class="hljs-comment">//对应函数1</span><br>c2 = c1 + <span class="hljs-number">5</span>;<span class="hljs-comment">//对应函数2</span><br>c2 = <span class="hljs-number">7</span> + c1;<span class="hljs-comment">//对应函数3</span><br>    cout &lt;&lt; -c1;<span class="hljs-comment">//对应函数4</span><br>    cout &lt;&lt; +c1;<span class="hljs-comment">//对应函数5</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面的函数1~4的返回值类型都是值，而不是引用。原因是这几个函数最后返回的complex都是<strong>临时对象</strong>，所以不能用引用，否则会出错。函数5应该可以把返回值类型改成引用，由于代码源自标准库，所以设计者有他的道理或者说该函数不够完美。</p><p>例2：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//函数1</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> complex</span><br><span class="hljs-function"><span class="hljs-title">conj</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> complex&amp; x)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span> (<span class="hljs-built_in">real</span> (x), -<span class="hljs-built_in">imag</span> (x));<br>&#125;<br><br><span class="hljs-comment">//函数2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream.h&gt;</span></span><br>ostream&amp;<span class="hljs-comment">//函数2的返回值类型</span><br><span class="hljs-keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="hljs-keyword">const</span> complex&amp; x)<br>&#123;<br><span class="hljs-keyword">return</span> os &lt;&lt; <span class="hljs-string">&#x27;(&#x27;</span> &lt;&lt; <span class="hljs-built_in">real</span> (x) &lt;&lt; <span class="hljs-string">&#x27;,&#x27;</span> &lt;&lt; <span class="hljs-built_in">imag</span> (x) &lt;&lt; <span class="hljs-string">&#x27;)&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">//main.c</span><br>&#123;<br><span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-built_in">conj</span>(c1);<span class="hljs-comment">//代码1</span><br>cout &lt;&lt; c1 &lt;&lt; <span class="hljs-built_in">conj</span>(c1);<span class="hljs-comment">//代码2</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于函数2，返回值类型可以为void，但是只有代码1才能正确执行。当返回值类型为引用时，代码1和代码2都能正确执行。</p><p>另外，我们也可以写出<code>c1&lt;&lt;cout;</code>这样的代码，将<strong>函数2</strong>写为成员函数就会出现这种情况，不过一般不这么做，因为不符合规范。</p><h2 id="拷贝构造，拷贝复制，析构（Big-Three）"><a href="#拷贝构造，拷贝复制，析构（Big-Three）" class="headerlink" title="拷贝构造，拷贝复制，析构（Big Three）"></a>拷贝构造，拷贝复制，析构（Big Three）</h2><h3 id="默认的Big-Three"><a href="#默认的Big-Three" class="headerlink" title="默认的Big Three"></a>默认的Big Three</h3><p>编译器都会给类默认生成Big Three，当然我们也可以自己写。但是当一个类里面有指针类型的成员变量时，我们最好要自定义Big Three。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">String</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr = <span class="hljs-number">0</span>); <span class="hljs-comment">//构造函数</span><br><span class="hljs-built_in">String</span>(<span class="hljs-keyword">const</span> String&amp; str); <span class="hljs-comment">//拷贝构造</span><br>String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> String&amp; str);<span class="hljs-comment">//拷贝复制 </span><br>~<span class="hljs-built_in">String</span>(); <span class="hljs-comment">//析构函数</span><br><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">get_c_str</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_data; &#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">char</span>* m_data;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-title">String::String</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr = <span class="hljs-number">0</span>)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (cstr) &#123;<br>m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-built_in">strlen</span>(cstr)+<span class="hljs-number">1</span>];<br><span class="hljs-built_in">strcpy</span>(m_data, cstr);<br>&#125;<br><span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 未指定初值</span><br>m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1</span>]; *m_data = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">inline</span><br>String::~<span class="hljs-built_in">String</span>() &#123;<br><span class="hljs-keyword">delete</span>[] m_data;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="对象拥有指针时的拷贝构造"><a href="#对象拥有指针时的拷贝构造" class="headerlink" title="对象拥有指针时的拷贝构造"></a>对象拥有指针时的拷贝构造</h3><p>编译器自带的拷贝构造有缺点，比如当一个对象1中有一个指针指向内存的地址，而通过编译器给的拷贝构造进行拷贝时，对象2也会拥有这个指针，同时也指向同一块内存，所以这并不是真正意义上的拷贝。所以<strong>当类含有指针，我们一定不能使用默认的拷贝构造</strong>。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416173442.png" alt="拷贝构造示例"></p><h3 id="拷贝复制中的检测自我赋值"><a href="#拷贝复制中的检测自我赋值" class="headerlink" title="拷贝复制中的检测自我赋值"></a>拷贝复制中的检测自我赋值</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">inline</span><br>String&amp; String::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> String&amp; str)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;str)<span class="hljs-comment">//检测自我赋值</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><br><span class="hljs-keyword">delete</span>[] m_data;<span class="hljs-comment">//第一步，删除自己的空间</span><br>m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-built_in">strlen</span>(str.m_data) + <span class="hljs-number">1</span>];<span class="hljs-comment">//第二步，创建空间，空间大小参考复制的对象</span><br><span class="hljs-built_in">strcpy</span>(m_data, str.m_data);<span class="hljs-comment">//第三步，将复制的对象的内容复制到自己的空间里</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416173919.png" alt="检测自我复制"></p><p>假设我们执行<code>a=a;</code>,此时若没有<strong>检测自我赋值</strong>，直接执行第一步，那么执行当第二步的时候，由于<code>str.m_data</code>这个指针已经被第一步删除了，所以会出错。</p><h2 id="堆、栈与内存管理"><a href="#堆、栈与内存管理" class="headerlink" title="堆、栈与内存管理"></a>堆、栈与内存管理</h2><h3 id="new和delete的详解"><a href="#new和delete的详解" class="headerlink" title="new和delete的详解"></a>new和delete的详解</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417172347.png" alt="new"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417172442.png" alt="delete"></p><h3 id="动态分配所得到的内存块以及array"><a href="#动态分配所得到的内存块以及array" class="headerlink" title="动态分配所得到的内存块以及array"></a>动态分配所得到的内存块以及array</h3><p>一块由动态分配得到的内存如下所示：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417175419.png" alt="内存"></p><p>须知：分配出来内存的大小必须为16的倍数。</p><p>绿色的内存区域是我们为类型分配空间时，该类型占用的存储空间。</p><p>头尾两块红色的内存，称为cookie，它的作用是表示这块内存的大小和状态。比如一块内存大小为64的内存，转换为16进制为0x40，但是我们看最左边的那片内存，头尾的cookie却是0x41，原因是当这片内存处于释放状态时，cookie的最后一位为0；而当这片内存处于使用状态时，cookie的最后一位为1。所以0x41实际上代表着：这块内存的大小为64且正在被使用。</p><p>灰色的内存区域表示处于debug模式下需要用到的空间，具体名称见下图。</p><p>浅绿色的内存区域表示当这块内存区域的大小不是16的倍数时，需要多余的内存区域。这块内存区域纯粹是起到了填充的作用，让整片内存区域变成16的倍数。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417181042.png" alt="动态分配array"></p><p>上图中String这边对应着下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">String</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr = <span class="hljs-number">0</span>);<br><span class="hljs-built_in">String</span>(<span class="hljs-keyword">const</span> String&amp; str);<br>String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> String&amp; str);<br>~<span class="hljs-built_in">String</span>();<br><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">get_c_str</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_data; &#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">char</span>* m_data;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-title">String::String</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr = <span class="hljs-number">0</span>)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (cstr) &#123;<br>m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-built_in">strlen</span>(cstr)+<span class="hljs-number">1</span>];<span class="hljs-comment">//这里的new使用中括号，会导致下面析构函数的delete使用中括号</span><br><span class="hljs-built_in">strcpy</span>(m_data, cstr);<br>&#125;<br><span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 未指定初值</span><br>m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1</span>]; *m_data = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">inline</span><br>String::~<span class="hljs-built_in">String</span>() &#123;<br><span class="hljs-keyword">delete</span>[] m_data;<span class="hljs-comment">//这里的delete使用中括号，是因为上面构造函数的new使用了中括号</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>array new、array delete这两者需要互相搭配</strong>，不然像下图的情况，会导致内存泄露：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417174307.png" alt="示意图"></p><h3 id="new和delete的重载"><a href="#new和delete的重载" class="headerlink" title="new和delete的重载"></a>new和delete的重载</h3><p>对于new和delete的重载比较特殊，对于<strong>全局</strong>的重载只能改变<code>new</code>内部的<code>operator new</code>。比如</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Complex* pc = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">//此处的new并不能被重载</span><br><br><span class="hljs-comment">//**********</span><br><span class="hljs-keyword">void</span>* mem = <span class="hljs-keyword">operator</span> <span class="hljs-built_in"><span class="hljs-keyword">new</span></span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Complex));<span class="hljs-comment">//只有这里的new会被重载</span><br>pc = <span class="hljs-keyword">static_cast</span>&lt;Complex*&gt;(mem);<br>pc-&gt;Complex::<span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br><span class="hljs-comment">//**********</span><br></code></pre></div></td></tr></table></figure><p>实际上，类里对于<code>operator new</code>的重载必须是<code>static</code>静态方法，因为<code>operator new</code>无法通过对象来调用。但是又因为<strong>必须</strong>是<code>static</code>，所以我们可以省略不写，编译器会自动转成静态方法。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/66788b8ddbd5222fc1305edc2eb807b9-291fd.png" alt="new和delete的重载"></p><p>成员的重载和全局的重载类似，但是成员的重载只会影响具体的对象，并不会影响到全局。比如：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/802ea01e86c5f33027bb662e7cb8f6eb-fe55d.png" alt="成员的重载"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f93c6a1d0fbc45623c36504b87fc7ff7-9832f.png" alt="成员的重载"></p><p>内存池经常使用这种重载的写法。</p><h4 id="new和delete重载例子"><a href="#new和delete重载例子" class="headerlink" title="new和delete重载例子"></a>new和delete重载例子</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6d9b9f2bcaea735bfe0440039666101e-2c912.png" alt="new和delete重载例子"></p><p>注意：若使用者想绕过成员重载的new和delete，那么可以使用域运算符强制使用全局的new和delete：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">Foo* pf = ::<span class="hljs-keyword">new</span> Foo;<span class="hljs-comment">//强制使用全局的new</span><br>::<span class="hljs-keyword">delete</span> pf;<span class="hljs-comment">//强制使用全局的delete</span><br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8d373471aa84c1428828b9fbc2b7a43b-483b9.png" alt="new和delete重载例子"></p><p>本例中的<code>Foo</code>大小为$int(4)+long(4)+string(4) = 12$，五个<code>Foo</code>就是$12<em>5=60$。但是上图中，大小为5的<code>Foo</code>指针数组的<em>*size</em></em>却为64。这多出来的4个字节实际上是计数器，记录了该数组的元素个数，不然当<code>array delete</code>的时候，无法正常释放。</p><p>还有一点，上图右边的内存示意图，表示当<code>array new</code>时，对象的构造是自上而下，即从下标为0开始的元素构造到最后一个；而<code>array delete</code>的顺序正好相反。</p><h4 id="placement-operator-new-delete"><a href="#placement-operator-new-delete" class="headerlink" title="placement operator new/delete"></a>placement operator new/delete</h4><p>因为new操作符是先分配内存，再执行构造函数，所以当构造函数发生异常后，需要及时的归还内存，否则会造成内存泄漏。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/711308668153592ca45c4aada96ad2bc-c4497.png" alt="placement operator new/delete"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/d85663e5f18393030570a21bb364de79-d3e5d.png" alt="placement operator new/delete"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/427d96d859f4c379c07aeb0c363f03fc-c443a.png" alt="placement operator new/delete"></p><h4 id="c-库例子：basic-string使用new-extra-扩充申请量"><a href="#c-库例子：basic-string使用new-extra-扩充申请量" class="headerlink" title="c++库例子：basic_string使用new(extra)扩充申请量"></a>c++库例子：basic_string使用new(extra)扩充申请量</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f40ea2a9e53c950064695b344070ea3f-68f51.png" alt="c++库例子：basic_string使用new(extra)扩充申请量"></p><h2 id="拓展补充：类模板、函数模板及其他"><a href="#拓展补充：类模板、函数模板及其他" class="headerlink" title="拓展补充：类模板、函数模板及其他"></a>拓展补充：类模板、函数模板及其他</h2><h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><p><strong>每个类成员函数都有一个指向自己所处对象的this指针</strong>，通过对象调用成员函数时，会把对象的地址放到成员函数里变成this指针</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417194726.png" alt="示意图"></p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ol><li>静态数据、静态函数与对象脱离，它不属于对象。它只有一份，存储在内存的某片区域</li><li>静态函数没有this指针，所以它只能处理静态的数据</li><li>静态函数可以通过类名调用，也可以通过对象名调用</li><li>只有调用或执行到含有静态数据的函数或代码块，该静态数据才会被创建</li></ol><h3 id="模板简介"><a href="#模板简介" class="headerlink" title="模板简介"></a>模板简介</h3><p>类模板：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">complex</span> (T r = <span class="hljs-number">0</span>, T i = <span class="hljs-number">0</span>): <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i) &#123; &#125;<br>complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp;);<br><span class="hljs-function">T <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125;<br><span class="hljs-function">T <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125;<br><span class="hljs-keyword">private</span>:<br>T re, im;<br><span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-keyword">const</span> complex&amp;); <br>&#125;;<br><br>&#123;<br><span class="hljs-function">complex&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2.5</span>,<span class="hljs-number">1.5</span>)</span></span>;<span class="hljs-comment">//代码1</span><br><span class="hljs-function">complex&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">6</span>)</span></span>;<span class="hljs-comment">//代码2</span><br>...<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>当执行到<strong>代码1</strong>和<strong>代码</strong>2时，类模板会根据<code>double</code>和<code>int</code>生成相应的代码。这种行为会造成代码的膨胀，但是这是必要的。</p><p>函数模板：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417201643.png" alt="函数模板"></p><p>类模板的类型用<strong>typename</strong>来代替，而函数模板用<strong>class</strong>来代替，虽然看起来两者不同，但是意思上是一样的。</p><p>类模板和函数模板的不同点在于<strong>引数推导</strong>，即编译器会根据实参的类型来推导，比如上图<code>r3 = min(r1,r2)</code>中的<strong>r1</strong>和<strong>r2</strong>。</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417212750.png" alt="命名空间"></p><h2 id="组合与继承"><a href="#组合与继承" class="headerlink" title="组合与继承"></a>组合与继承</h2><h3 id="组合-has-a"><a href="#组合-has-a" class="headerlink" title="组合 has-a"></a>组合 has-a</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417212913.png" alt="复合例子1"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417212933.png" alt="复合例子2"></p><h3 id="组合关系下的构造与析构"><a href="#组合关系下的构造与析构" class="headerlink" title="组合关系下的构造与析构"></a>组合关系下的构造与析构</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417213018.png" alt="复合的析构"></p><h3 id="委托-Composition-by-reference"><a href="#委托-Composition-by-reference" class="headerlink" title="委托 Composition by reference"></a>委托 Composition by reference</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417213157.png" alt="委托"></p><p>这样的做法很好，因为这样做可以保持左边不变右边变，即提供给客户端的接口不变，但是实现接口的功能可以改变。这样又称为编译防火墙，因为左边不变，所以左边无需再编译。</p><p>委托和组合的区别：</p><ol><li>组合中，两者的生命周期是同时的。而在委托里，两者的生命周期可以分先后。</li></ol><h3 id="继承关系下的构造与析构"><a href="#继承关系下的构造与析构" class="headerlink" title="继承关系下的构造与析构"></a>继承关系下的构造与析构</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417221702.png" alt="继承"></p><h3 id="继承-组合关系下的构造与析构"><a href="#继承-组合关系下的构造与析构" class="headerlink" title="继承+组合关系下的构造与析构"></a>继承+组合关系下的构造与析构</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/d47977674578fa527e49b603340f0e60-d4e93.png" alt="继承+组合关系下的构造与析构"></p><h2 id="虚函数与多态"><a href="#虚函数与多态" class="headerlink" title="虚函数与多态"></a>虚函数与多态</h2><h3 id="内存中的继承"><a href="#内存中的继承" class="headerlink" title="内存中的继承"></a>内存中的继承</h3><p>函数继承：子类继承了父类的函数调用权</p><h3 id="继承与模板方法"><a href="#继承与模板方法" class="headerlink" title="继承与模板方法"></a>继承与模板方法</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210418075133.png" alt="模板方法"></p><h3 id="委托-继承与观察者模式"><a href="#委托-继承与观察者模式" class="headerlink" title="委托+继承与观察者模式"></a>委托+继承与观察者模式</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210418080207.png" alt="观察者模式"></p><h4 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/25e2643d8ad391fd2a7ee50d3e4ac2a9-375551.png" alt="委托+继承"></p><ol><li>add()函数不能为纯虚函数的原因：如果是纯虚函数，那么Primitive这个类就必须实现。</li><li>Composite是个容器，可以同时存放Primitive和自身。这种情况下可以抽象出两者的父类，并以父类的指针作为容器的元素。</li><li>应用场景：可以把Primitive看成文件，Composite看成目录。</li></ol><h4 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h4><p>若有如下需求：在一个树状继承体系中，创建出一个未来才会实现的类。即在代码中对未来的类进行提前的封装，然后进行相关的操作？</p><p>设想：派生出来的子类创建完自己后，将自己的位置告诉给父类，让父类存储。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/cd0bd4e2038edfe0b32e67c780956a79-737a8.png" alt="Prototype"></p><p>父类：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">imageType</span> &#123;</span> LSAT, SPOT &#125;; <span class="hljs-comment">//子类类型的枚举变量</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Image</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <br>    <span class="hljs-function"><span class="hljs-keyword">static</span> Image *<span class="hljs-title">findAndClone</span><span class="hljs-params">(imageType)</span></span>; <br>    <br>    <span class="hljs-keyword">protected</span>: <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> imageType <span class="hljs-title">returnType</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//由子类实现，让子类返回自己的类型</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Image *<span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//由子类实现clone过程</span><br>    <span class="hljs-built_in">addPrototype</span>(Image *image) &#123; <span class="hljs-comment">// 当 Image 的每个子类被声明时，它会注册它的static void原型</span><br>                _prototypes[_nextSlot++] = image;<br>            &#125; <br>    <br>    <span class="hljs-keyword">private</span>: <br>    <span class="hljs-keyword">static</span> Image *_prototypes[<span class="hljs-number">10</span>]; <span class="hljs-comment">// addPrototype() 在这里保存每个注册的原型</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _nextSlot; <br>&#125;; <br>Image *Image::_prototypes[]; <br><span class="hljs-keyword">int</span> Image::_nextSlot;<br><span class="hljs-comment">// 客户需要实例时调用这个公共静态成员函数</span><br><span class="hljs-comment">// 返回一个 Image子类</span><br><span class="hljs-function">Image *<span class="hljs-title">Image::findAndClone</span><span class="hljs-params">(imageType type)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; _nextSlot; i++)<br><span class="hljs-keyword">if</span> (_prototypes[i]-&gt;<span class="hljs-built_in">returnType</span>() == type)<br><span class="hljs-keyword">return</span> _prototypes[i]-&gt;<span class="hljs-built_in">clone</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>子类：<br><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LandSatImage</span>:</span> <span class="hljs-keyword">public</span> Image &#123; <br>    <span class="hljs-keyword">public</span>: <br>    <span class="hljs-function">imageType <span class="hljs-title">returnType</span><span class="hljs-params">()</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> LSAT; <br>    &#125; <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;  <br>        cout &lt;&lt; <span class="hljs-string">&quot;LandSatImage::draw &quot;</span> &lt;&lt; _id &lt;&lt; endl; <br>    &#125; <br>    <span class="hljs-comment">// 当clone被调用时, 调用带了一个假参数(dummy)的构造函数：LandSatImage(int dummy)</span><br>    <span class="hljs-function">Image *<span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">LandSatImage</span>(<span class="hljs-number">1</span>); <br>    &#125; <br>    <span class="hljs-keyword">protected</span>: <br>    <span class="hljs-comment">// 只会被clone()函数调用 </span><br>    <span class="hljs-built_in">LandSatImage</span>(<span class="hljs-keyword">int</span> dummy) &#123;<br>                _id = _count++; <br>            &#125; <br>    <span class="hljs-keyword">private</span>: <br>    <span class="hljs-comment">// 始化 Image 子类 - 这会导致调用默认的构造函数，它注册子类的原型 </span><br>    <span class="hljs-keyword">static</span> LandSatImage _landSatImage; <br>    <span class="hljs-comment">// 这仅在初始化私有静态数据成员时调用 </span><br>    <span class="hljs-built_in">LandSatImage</span>() &#123; <span class="hljs-built_in">addPrototype</span>(<span class="hljs-keyword">this</span>); &#125; <br>    <span class="hljs-comment">// 区分每个实例所需 </span><br>    <span class="hljs-keyword">int</span> _id; <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _count; <br>&#125;; <br><span class="hljs-comment">// 注册子类的原型</span><br>LandSatImage LandSatImage::_landSatImage; <br><span class="hljs-comment">// 区分每个实例所需</span><br><span class="hljs-keyword">int</span> LandSatImage::_count = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//略</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpotImage</span>:</span> <span class="hljs-keyword">public</span> Image<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">imageType <span class="hljs-title">returnType</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> SPOT;<br>&#125;<br>    <span class="hljs-comment">//....与class LandSatImage相似，略</span><br>&#125;<br></code></pre></div></td></tr></table></figure></p><p>main:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 模拟创建请求</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> NUM_IMAGES = <span class="hljs-number">8</span>; <br>imageType input[NUM_IMAGES] = &#123; LSAT, LSAT, LSAT, SPOT, LSAT, SPOT, SPOT, LSAT &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>Image* images[NUM_IMAGES];<br><span class="hljs-comment">// 给定一个图像类型，找到正确的原型，并返回一个克隆</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_IMAGES; i++)<br>images[i] = Image::<span class="hljs-built_in">findAndClone</span>(input[i]);<br><span class="hljs-comment">// 证明已克隆正确的图像对象</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NUM_IMAGES; i++)<br>images[i]-&gt;<span class="hljs-built_in">draw</span>();<br><span class="hljs-comment">// 释放动态内存</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NUM_IMAGES; i++)<br><span class="hljs-keyword">delete</span> images[i];<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="conversion-function（转换函数）"><a href="#conversion-function（转换函数）" class="headerlink" title="conversion function（转换函数）"></a>conversion function（转换函数）</h2><ul><li>转换函数没有返回类型</li><li>为了程序的健壮性，转换函数需要加const</li><li>转换类型不一定得是基本类型，自定义类型也行，只要编译器认得转换的类型就可以。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Fraction</span>(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> den=<span class="hljs-number">1</span>) <br>  : <span class="hljs-built_in">m_numerator</span>(num), <span class="hljs-built_in">m_denominator</span>(den)<br>&#123;&#125;<br><br>    <span class="hljs-comment">//转换函数</span><br> <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <br>      <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)m_numerator / m_denominator; <br> &#125;<br> <br><span class="hljs-keyword">private</span>:   <br>   <span class="hljs-keyword">int</span> m_numerator;    <span class="hljs-comment">//分子</span><br>   <span class="hljs-keyword">int</span> m_denominator;  <span class="hljs-comment">//分母</span><br>&#125;;<br><br><span class="hljs-comment">//main.cpp...</span><br><span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-keyword">double</span> d = <span class="hljs-number">4</span> + f;<span class="hljs-comment">//f将会被转换为0.6</span><br></code></pre></div></td></tr></table></figure><p>若没有转换函数，重载运算符<code>+</code>，也能运行</p><h3 id="STL中的转换函数"><a href="#STL中的转换函数" class="headerlink" title="STL中的转换函数"></a>STL中的转换函数</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/e131cbce529c3873f473dd3a802fbfb5-21f79b.png" alt="STL中的转换函数"></p><h2 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h2><h3 id="non-explicit-one-argument-ctor"><a href="#non-explicit-one-argument-ctor" class="headerlink" title="non-explicit-one-argument ctor"></a>non-explicit-one-argument ctor</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Fraction</span>(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> den=<span class="hljs-number">1</span>) <br>  : <span class="hljs-built_in">m_numerator</span>(num), <span class="hljs-built_in">m_denominator</span>(den)&#123;&#125;<br><br> Fraction <span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">const</span> Fraction&amp; f) &#123;  <br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fraction</span>(......);<br>&#125;<br>    <br><span class="hljs-keyword">private</span>:   <br>   <span class="hljs-keyword">int</span> m_numerator;    <span class="hljs-comment">//分子</span><br>   <span class="hljs-keyword">int</span> m_denominator;  <span class="hljs-comment">//分母</span><br>&#125;<br><br><span class="hljs-comment">//main.cpp...</span><br><span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;<br>Fraction d2 = f + <span class="hljs-number">4</span>;<span class="hljs-comment">//调用 non-explicit 构造函数，将4转换为Fraction(4,1)，然后调用operator+</span><br></code></pre></div></td></tr></table></figure><p>本例中：</p><ul><li>Fraction的构造函数，虽然说有两个形式参数，但是由于其中有一个默认值，所以实际上这个构造函数可以看成<strong>单实参</strong>构造函数。（单实参并不是单形参）</li><li>在编译器编译到<code>Fraction d2 = f + 4;</code>这条语句的时候，找到了Fraction类中operator+重载函数，但是该重载函数的参数为<code>Fraction&amp;</code>类型，所以编译器接下来会<strong>尝试</strong>将<code>4</code>转换为Fraction类型。在此例中，有了<strong>“单实参构造函数“</strong>的前提条件，编译器将会调用<code>Fraction</code>的构造函数，将<code>4</code>传入，即执行<code>Fraction(4,1)</code>。</li></ul><h3 id="conversion-function-vs-non-explicit-one-argument-ctor"><a href="#conversion-function-vs-non-explicit-one-argument-ctor" class="headerlink" title="conversion function vs. non-explicit-one-argument ctor"></a>conversion function vs. non-explicit-one-argument ctor</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Fraction</span>(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> den=<span class="hljs-number">1</span>) <br>  : <span class="hljs-built_in">m_numerator</span>(num), <span class="hljs-built_in">m_denominator</span>(den)&#123;&#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <br>      <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)m_numerator / m_denominator; <br> &#125;<br> <br> Fraction <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Fraction&amp; f) &#123;  <br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fraction</span>(......);<br>&#125; <br><br><span class="hljs-keyword">private</span>:   <br>   <span class="hljs-keyword">int</span> m_numerator;    <span class="hljs-comment">//分子</span><br>   <span class="hljs-keyword">int</span> m_denominator;  <span class="hljs-comment">//分母</span><br>&#125;;<br><br><span class="hljs-comment">//main.cpp</span><br><span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>; <br>Fraction d2 = f + <span class="hljs-number">4</span>;<span class="hljs-comment">//[Error]ambiguous  </span><br></code></pre></div></td></tr></table></figure><p>在本例中，由于同时重载了<code>double()</code>和<code>operator+</code>，所以当编译器编译<code>double d2 = f + 4;</code>时，会遇到问题，即二义性问题。编译器接来下处理<code>f + 4</code>会面临两种抉择：</p><ol><li>将<code>f</code>通过<code>double()</code>转化<code>0.6</code>，即<code>0.6+4</code></li><li>将<code>4</code>通过构造函数转化为<code>Fraction(4,1)</code>，即<code>f+Fraction(4,1)</code></li></ol><p>编译器不知道该怎么选择，所以会报错：<strong>ambiguous</strong>  </p><h3 id="explicit-one-argument-ctor"><a href="#explicit-one-argument-ctor" class="headerlink" title="explicit-one-argument ctor"></a>explicit-one-argument ctor</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Fraction</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> den=<span class="hljs-number">1</span>)</span> <span class="hljs-comment">//加入explicit关键字</span></span><br><span class="hljs-function">  : m_numerator(num), m_denominator(den)&#123;</span>&#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <br>      <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)m_numerator / m_denominator; <br> &#125;<br> <br> Fraction <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Fraction&amp; f) &#123;  <br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fraction</span>(......);<br>&#125; <br>    <br><span class="hljs-keyword">private</span>:   <br>   <span class="hljs-keyword">int</span> m_numerator;    <span class="hljs-comment">//分子</span><br>   <span class="hljs-keyword">int</span> m_denominator;  <span class="hljs-comment">//分母</span><br>&#125;;<br><br><span class="hljs-comment">//main.cpp</span><br><span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;<br>Fraction d2 = f + <span class="hljs-number">4</span>;<span class="hljs-comment">//[Error]conversion from &#x27;double&#x27; to &#x27;Fraction&#x27; requested</span><br></code></pre></div></td></tr></table></figure><p>本例中，在构造函数的前面添加了<code>explicit</code>关键字。这个关键字的作用就是告诉编译器：</p><p><strong>只有当构造函数被显式的调用，编译器才可以调用构造函数</strong></p><p>所以当编译器编译<code>Fraction d2 = f + 4;</code>时，已经不会再尝试地将<code>4</code>转化为<code>Fraction(4,1)</code>了，只会将<code>f</code>通过<code>double()</code>进行转换，所以<code>f+4</code>会变成<code>0.6+4</code>。又因为<code>d2</code>是Fraction类型，所以编译器报错是正常的。</p><h2 id="pointer-like-classes"><a href="#pointer-like-classes" class="headerlink" title="pointer-like classes"></a>pointer-like classes</h2><p>也可以对类进行分类：比如像指针的类，像函数的类</p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><h4 id="关于operator-和operator-gt"><a href="#关于operator-和operator-gt" class="headerlink" title="关于operator*和operator-&gt;"></a>关于operator*和operator-&gt;</h4><p>智能指针中都会带有一个一般的指针。</p><p>在智能指针中，重载操作符<code>*</code>和<code>-&gt;</code>一般都是固定写法。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/34dc5fe416e326ad1ec2a555b1c1fed6-c414f2.png" alt="关于operator*和operator-&gt;"></p><p>对于图中三个已经编号的语句：</p><ul><li>语句1看起来很正常，因为重载操作符<code>*</code>，返回的同样是解引用。所以<code>Foo f(*sp)</code>实际上就是<code>Foo f(*px)</code>。</li><li>而对于语句2，如果通过重载操作符<code>-&gt;</code>返回值为<code>px</code>的话，按照正常的思路，<code>sp-&gt;method()</code>就会变成<code>pxmethod()</code>，少了<code>-&gt;</code>。但是实际上，语句2会变成语句3。原因是是C++的语法规定：<strong>-&gt;符号有个特殊的行为，在-&gt;符号作用的结果上，-&gt;符号会继续作用下去。</strong></li></ul><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>迭代器其实也是智能指针</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/58ff59423d173f39de7f3c07a6639191-a6f205.png" alt="迭代器"></p><h2 id="function-like-classes：仿函数"><a href="#function-like-classes：仿函数" class="headerlink" title="function-like classes：仿函数"></a>function-like classes：仿函数</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/bcbb678ba6becab283407c1b358ca181-f3318a.png" alt="仿函数"></p><p>调用方法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">select1st&lt;Pair&gt;()()<br>select2nd&lt;Pair&gt;()()<br></code></pre></div></td></tr></table></figure><p>在一个class里重载<code>()</code>，说明用意就是想让<strong>class</strong>变成一个<strong>function</strong>。对于这种模仿函数行为的对象，称之为函数对象。（stl里面有很多的仿函数）</p><h2 id="namespace经验谈"><a href="#namespace经验谈" class="headerlink" title="namespace经验谈"></a>namespace经验谈</h2><p>对于测试程序，可以使用<code>namespace</code>。比如：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8d4c799728c33e47f9ea6b6385880545-b66f52.png" alt="namespace经验谈"></p><h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><h3 id="class-template"><a href="#class-template" class="headerlink" title="class template"></a>class template</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/af7e08d3ba53835799e99215f45aa80c-d1a5b2.png" alt="类模板"></p><h3 id="member-template：成员模板"><a href="#member-template：成员模板" class="headerlink" title="member template：成员模板"></a>member template：成员模板</h3><p>这种成员模板的应用在STL标准库中大量出现：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b8270b8b0d56bd28cc0c9e01e8008574-ae6359.png" alt="member template 1"></p><p>智能指针中模仿向上转型的做法：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/51f2f90ada34ecd33f6f6380f26ca958-a29028.png" alt="member template 2"></p><h3 id="specialization：模板特化"><a href="#specialization：模板特化" class="headerlink" title="specialization：模板特化"></a>specialization：模板特化</h3><ul><li>特化可以写任意版本</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8bed3c001f2f63d2ceddcf13ad43eb0d-151429.png" alt="模板特化"></p><h4 id="partial-specialization：模板偏特化"><a href="#partial-specialization：模板偏特化" class="headerlink" title="partial specialization：模板偏特化"></a>partial specialization：模板偏特化</h4><ul><li>模板绑定参数需要从左边到右边进行绑定，比如形参次序为1，2，3，4，5，那么绑定参数不能挑选出1，3，5进行绑定，只能1，2，3这样绑定。</li></ul><h5 id="个体偏特化"><a href="#个体偏特化" class="headerlink" title="个体偏特化"></a>个体偏特化</h5><p>对某种具体类型的特殊处理，比如对bool类型偏特化：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/cecfd818959022054a9923abcb3d8698-2ddbe1.png" alt="单个偏特化"></p><h5 id="范围偏特化"><a href="#范围偏特化" class="headerlink" title="范围偏特化"></a>范围偏特化</h5><p>对某个范围的类型进行特殊处理，比如对<strong>所有</strong>指针类型进行偏特化：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/ccf5547367e4a7c109b8db153d0582a4-2cea76.png" alt="范围偏特化"></p><h3 id="template-template-parameter：模板模板参数"><a href="#template-template-parameter：模板模板参数" class="headerlink" title="template template parameter：模板模板参数"></a>template template parameter：模板模板参数</h3><h4 id="对于list的例子"><a href="#对于list的例子" class="headerlink" title="对于list的例子"></a>对于list的例子</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/33c4d4e3c79a9f39707e67c21c688199-f878bf.png" alt="模板模板参数"></p><p>现在的需求是：动态的指定<code>list</code>的类型，就相当于<code>list&lt;string&gt;</code>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">XCls&lt;string,list&gt; mylist1;<span class="hljs-comment">//错误</span><br></code></pre></div></td></tr></table></figure><p>虽然说结合上面的模板模板参数，看起来语法正确，但是由于<code>list</code>不止有一个模板参数，所以编译<code>XCls&lt;string,list&gt; mylist1;</code>编译器会报错。为了实现需求，可以使用：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> Lst = list&lt;T,allocator&lt;T&gt;&gt;;<br></code></pre></div></td></tr></table></figure><p>然后再：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">XCls&lt;string,Lst&gt; mylist1;<span class="hljs-comment">//正确</span><br></code></pre></div></td></tr></table></figure><h4 id="对于智能指针的例子"><a href="#对于智能指针的例子" class="headerlink" title="对于智能指针的例子"></a>对于智能指针的例子</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/60f943f55fb92522b88c79061ece7635-a17588.png" alt="对于智能指针的例子"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">XCls&lt;string,shared_ptr&gt; p1;<span class="hljs-comment">//正确</span><br>XCls&lt;<span class="hljs-keyword">double</span>,unique_ptr&gt; p2;<span class="hljs-comment">//错误</span><br>XCls&lt;<span class="hljs-keyword">int</span>,weak_ptr&gt; p3;<span class="hljs-comment">//错误</span><br>XCls&lt;<span class="hljs-keyword">long</span>,auto_ptr&gt; p4;<span class="hljs-comment">//正确</span><br></code></pre></div></td></tr></table></figure><p>同样的，参考对于list的例子，p2和p3错误的原因也是因为模板的参数不是唯一的。</p><h4 id="一个不是模板模板参数的例子"><a href="#一个不是模板模板参数的例子" class="headerlink" title="一个不是模板模板参数的例子"></a>一个不是模板模板参数的例子</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b1dd9c5d60a6f8e2197052c8dd45178e-34bb35.png" alt="一个不是模板模板参数的例子"></p><p>虽然说<code>Sequence</code>的默认参数是<code>deque&lt;T&gt;</code>，这个默认参数是一个模板类型的参数。但是他作为参数的时候已经不算是模板了，而是由模板初始化而来的一个参数。也就是说它已经被确定了。</p><h3 id="variadic-templates：数量不定的模板参数（C-11）"><a href="#variadic-templates：数量不定的模板参数（C-11）" class="headerlink" title="variadic templates：数量不定的模板参数（C++11）"></a>variadic templates：数量不定的模板参数（C++11）</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b6f56c4064300c100f3b179589d66b96-c7d814.png" alt="variadic templates：数量不定的模板参数"></p><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>可以在指定模板参数后，在模板后面加()直接生成临时的对象。比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span>*p allocator&lt;<span class="hljs-keyword">int</span>&gt;().<span class="hljs-built_in">allocate</span>(<span class="hljs-number">512</span>,(<span class="hljs-keyword">int</span>*)<span class="hljs-number">0</span>);<br></code></pre></div></td></tr></table></figure><h2 id="auto（C-11）"><a href="#auto（C-11）" class="headerlink" title="auto（C++11）"></a>auto（C++11）</h2><p>auto关键字可以让编译器自动推导类型</p><ul><li>所有变量都用auto可取吗？不行：<ul><li>对于变量的类型需要很熟悉，且auto的可读性不高</li><li>不可能每一次在声明对象的时候都赋值</li></ul></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/28998a55f89820c73ef91e0c3fcd8581-7889b2.png" alt="auto"></p><h2 id="ranged-base-for-：for新写法（C-11）"><a href="#ranged-base-for-：for新写法（C-11）" class="headerlink" title="ranged-base for ：for新写法（C++11）"></a>ranged-base for ：for新写法（C++11）</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8e75a572eebe3e248f33caa6cd148262-ebcb46.png" alt="ranged-base for ：for新写法（C++11）"></p><ul><li>pass by value：实际上是值传递，<strong>vec</strong>拷贝了一份赋值给<strong>elem</strong>，传值无法修改原来的值</li><li>pass by reference：<strong>vec</strong>将当前迭代元素的引用赋值给<strong>elem</strong>，传引用可以修改原来的值</li></ul><h2 id="reference：引用"><a href="#reference：引用" class="headerlink" title="reference：引用"></a>reference：引用</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/28e8af9de3f3e70f82cd704c38b65447-b2cca6.png" alt="reference：引用"></p><ul><li><p>虽然说引用的底层是指针，指针大小在32位上是4个字节。但是引用代表的东西sizeof多大，引用sizeof就多大</p></li><li><p>引用代表的东西的地址在哪里，引用的地址就在哪里</p></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/56041a3b3f0c57e698c49ed766c64dca-f12e4d.png" alt=""></p><h3 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h3><blockquote><p>引用就是一个漂亮的指针</p></blockquote><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f49b1cb39974da549e0c65f5d904b80e-4c0f1c.png" alt=""></p><p>Q：const是不是函数签名的一部分？</p><p>A：是</p><p><strong>注意：函数签名不含返回值</strong></p><h2 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h2><h3 id="关于vptr和vtbl"><a href="#关于vptr和vtbl" class="headerlink" title="关于vptr和vtbl"></a>关于vptr和vtbl</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b4a9e8f6e13e6d20e65eda01095ce90e-d9e28.png" alt="关于vptr和vtbl"></p><ul><li>只要类里面有一个以上的虚函数，那么这个类以及它的派生类在内存里就会多一根指针，这个指针就是虚表指针</li><li>继承函数是继承调用权，而不是继承函数的内存大小。所以父类若有虚函数，子类一定也有虚函数</li><li>动态绑定的三个条件<ul><li>通过指针调用</li><li>指针为up-cast，向上转型</li><li>调用的是虚函数</li></ul></li><li>静态绑定：编译时直接指定某个地址</li></ul><h3 id="关于this指针"><a href="#关于this指针" class="headerlink" title="关于this指针"></a>关于this指针</h3><ul><li>在C++的成员函数里面，一定有一个隐藏的this作为参数。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a9d134fab38b6f37fc66b43f2e205b77-abf79.png" alt="关于this指针"></p><h4 id="汇编层面的函数调用"><a href="#汇编层面的函数调用" class="headerlink" title="汇编层面的函数调用"></a>汇编层面的函数调用</h4><h5 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/dc0e09af8263a41969ed8ab2396e9ecc-0f736.png" alt="汇编层面的多态"></p><h5 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7f59aad8017b1fe873dec0b1da9cf192-43f3b.png" alt="动态绑定"></p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h3 id="const-member-functions：常量成员函数"><a href="#const-member-functions：常量成员函数" class="headerlink" title="const member functions：常量成员函数"></a>const member functions：常量成员函数</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/52c2717bc969b0b16180cc37360601b1-4963e.png" alt="const member functions：常量成员函数 "></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新特性</tag>
      
      <tag>对象模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>347. 前 K 个高频元素</title>
    <link href="/2020/12/10/LeetCode/347.%20%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
    <url>/2020/12/10/LeetCode/347.%20%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">本题链接</a></p><h2 id="计数排序-map"><a href="#计数排序-map" class="headerlink" title="计数排序+map"></a>计数排序+map</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-comment">//计数排序</span><br>        map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; i_map;<br>        <span class="hljs-comment">//先存放数组到map中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">if</span>(i_map.<span class="hljs-built_in">find</span>(nums[i]) == i_map.<span class="hljs-built_in">end</span>()) i_map.<span class="hljs-built_in">insert</span>(&#123;nums[i],<span class="hljs-number">1</span>&#125;);<br>            <span class="hljs-keyword">else</span> ++i_map[nums[i]];<br>        &#125;<br><br>        <span class="hljs-comment">//将i_map的key和value对调放入一个新的multimap</span><br>        multimap&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; res_map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; pair:i_map)&#123;<br>            res_map.<span class="hljs-built_in">insert</span>(&#123;pair.second,pair.first&#125;);<br>        &#125;<br><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res_vec;<br>        <span class="hljs-comment">//逆向</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i = res_map.<span class="hljs-built_in">rbegin</span>();i != res_map.<span class="hljs-built_in">rend</span>() &amp;&amp; --k &gt;= <span class="hljs-number">0</span>;++i)&#123;<br>            res_vec.<span class="hljs-built_in">push_back</span>((*i).second);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res_vec;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用map存储每个数的出现次数，然后再使用multimap存储每种出现次数的数，最后遍历multimap取值即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>数组</tag>
      
      <tag>计数排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dataBinding</title>
    <link href="/2020/12/09/Android/Jetpack/dataBinding/"/>
    <url>/2020/12/09/Android/Jetpack/dataBinding/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-在build-gradle文件中配置"><a href="#1-在build-gradle文件中配置" class="headerlink" title="1.在build.gradle文件中配置"></a>1.在build.gradle文件中配置</h2><p>配置dataBinging无需引用任何的依赖，只需要在build.gradle中配置即可</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">android &#123;<br>    <br>    <span class="hljs-comment">//....</span><br><br>    dataBinding&#123;<br>        enabled=<span class="hljs-keyword">true</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-修改xml布局文件"><a href="#2-修改xml布局文件" class="headerlink" title="2.修改xml布局文件"></a>2.修改xml布局文件</h2><ol><li><p>先将原有布局转换成dataBinging布局<br><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201216234512.png" alt="转换布局"></p></li><li><p>修改xml文件</p></li></ol><h3 id="2-1-在TextView里面使用"><a href="#2-1-在TextView里面使用" class="headerlink" title="2.1 在TextView里面使用"></a>2.1 在TextView里面使用</h3><h4 id="2-1-1-例一"><a href="#2-1-1-例一" class="headerlink" title="2.1.1 例一"></a>2.1.1 例一</h4><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- a.xml --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">variable</span></span><br><span class="hljs-tag">            <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;User&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.mooc.ppjoke.model.User&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/author_name&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@&#123;user.name&#125;&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">tools:text</span>=<span class="hljs-string">&quot;use_name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TextView</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- b.xml --&gt;</span><br>    <span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">variable</span></span><br><span class="hljs-tag">            <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;feed&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Feed&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.mooc.ppjoke.model.Feed&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span></span><br><span class="hljs-tag">        <span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;@layout/layout_feed_author&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:user</span>=<span class="hljs-string">&quot;@&#123;feed.author&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><p>在data标签里声明变量：在import标签里引入变量所在的类，variable标签里的type为变量类型，name为变量的名称。在例一中，b.xml包含了a.xml。a.xml中的user，是由b.xml中include标签里的app:user传入的。<br>注：即使user.name为空也不会报错，因为dataBinding是空安全的</p><h4 id="2-1-2-例二"><a href="#2-1-2-例二" class="headerlink" title="2.1.2 例二"></a>2.1.2 例二</h4><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">variable</span></span><br><span class="hljs-tag">            <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;feedText&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> /&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;android.text.TextUtils&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;android.view.View&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@&#123;feedText&#125;&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:visibility</span>=<span class="hljs-string">&quot;@&#123;TextUtils.isEmpty(feedText)?View.GONE:View.VISIBLE&#125;&quot;</span>&gt;</span><br><br></code></pre></div></td></tr></table></figure><p>判断feedText是否为空。若为空，则设置android:visibility属性为不显示；若有值，则设置android:visibility属性为显示。</p><h3 id="2-2-在ImageView里面使用"><a href="#2-2-在ImageView里面使用" class="headerlink" title="2.2 在ImageView里面使用"></a>2.2 在ImageView里面使用</h3><ol><li>写一个继承自AppCompatImageView的类</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PPImageView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatImageView</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-comment">//image_url：图片的url；isCircle：图片是否有圆角</span><br>    <span class="hljs-comment">//requireAll：若为true，表示配置的时候只有把参数全都设置了，才能调用该方法</span><br>    <span class="hljs-comment">//这个方法的第一个参数一定是类自身</span><br>    <span class="hljs-meta">@BindingAdapter(value = &#123;&quot;image_url&quot;, &quot;isCircle&quot;&#125;, requireAll = false)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setImageUrl</span><span class="hljs-params">(PPImageView view, String imageUrl, <span class="hljs-keyword">boolean</span> isCircle, <span class="hljs-keyword">int</span> radius)</span> </span>&#123;<br><br>        RequestBuilder&lt;Drawable&gt; builder = Glide.with(view).load(imageUrl);<br>        <span class="hljs-comment">//是否圆角</span><br>        <span class="hljs-keyword">if</span> (isCircle) &#123;<br>            builder.transform(<span class="hljs-keyword">new</span> CircleCrop());<br>        &#125;<br>        <span class="hljs-comment">//设置图片的尺寸</span><br>        ViewGroup.LayoutParams layoutParams = view.getLayoutParams();<br>        <span class="hljs-keyword">if</span> (layoutParams != <span class="hljs-keyword">null</span> &amp;&amp; layoutParams.width &gt; <span class="hljs-number">0</span> &amp;&amp; layoutParams.height &gt; <span class="hljs-number">0</span>) &#123;<br>            builder.override(layoutParams.width, layoutParams.height);<br>        &#125;<br>        builder.into(view);<br>    &#125;<br></code></pre></div></td></tr></table></figure><ol><li>在xml文件中配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">com.mooc.ppjoke.view.PPImageView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/avatar&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;@dimen/dp_40&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;@dimen/dp_40&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:image_url</span>=<span class="hljs-string">&quot;@&#123;user.avatar&#125;&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:isCircle</span>=<span class="hljs-string">&quot;@&#123;true&#125;&quot;</span></span><br><span class="hljs-tag">            &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com.mooc.ppjoke.view.PPImageView</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>注：<strong>@BindingAdapter</strong>注解中的requireAll参数设置为true时，只有配置了<strong>app:image_url</strong>和<strong>app:isCircle</strong>，才能调用PPImageView中的setImageUrl方法。</p><h2 id="dataBinding特殊性"><a href="#dataBinding特殊性" class="headerlink" title="dataBinding特殊性"></a>dataBinding特殊性</h2><ol><li>强校验</li><li>空安全</li><li>根据经验，dataBinding在布局文件里绑定视频资源的时候，会延迟一帧。扩展：如果需要绑定的数据需要计算宽和高，建议使用原生方法</li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jetpack</tag>
      
      <tag>dataBinding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>malloc与free</title>
    <link href="/2020/12/08/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/malloc%E4%B8%8Efree/"/>
    <url>/2020/12/08/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/malloc%E4%B8%8Efree/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="SBH（VC6）"><a href="#SBH（VC6）" class="headerlink" title="SBH（VC6）"></a>SBH（VC6）</h2><ul><li><p><strong>SBH = Small Block Heap</strong></p></li><li><p><code>HeapAlloc()</code>：windows内存分配函数</p></li></ul><p>在新版本如VC10，已经不做小块的内存管理了，统统将操作丢给<code>HeapAlloc()</code>，因为<code>HeapAlloc()</code>也开始做小块内存管理了。</p><p>下图为C++程序的运行调用栈（VC6）：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/54dc87706cafbf193f1a014a2af24970-5ee36.png" alt="C++程序的运行调用栈"  /></p><p>上图中的常量<code>_sbh_threshold</code>的值为<strong>1016</strong>，和<strong>1024</strong>差了<strong>8</strong>个字节，这8个字节就是内存块上下的<strong>cookie</strong>。当我们需要的内存块加上<strong>cookie</strong>一共超过了<strong>1024</strong>，那么<strong>SBH</strong>将会把内存分配的操作<strong>转交给操作系统处理</strong>。由此可见小区块定义的大小就是1024。</p><p>自下而上，首先进入操作系统内核部分，由操作调用<code>mainCRTStartup()</code>，即CRT的动作。</p><h3 id="heap-init"><a href="#heap-init" class="headerlink" title="_heap_init()"></a>_heap_init()</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6ae13a524af0ecd498241c14b290e7d4-c5fe0.png" alt=" _heap_init()"  /></p><ul><li><code>_heap_init()</code>从操作系统的<strong>CRT Heap</strong>申请空间，来应付CRT的需求，<code>_sbh_pHeaderList</code>指向这个空间。</li><li><code>bitvEntryHi</code>和<code>bitvEntryLo</code>实际上会组合起来，即一共64bit。</li><li><code>_heap_init()</code>做的事实际上就是分配了16个<strong>Header</strong>。</li><li>一个<strong>Header</strong>管理<strong>1MB</strong>。</li></ul><p><strong>Header</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> BITVEC;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagHeader</span></span><br><span class="hljs-class">&#123;</span><br>BITVEC bitvEntryHi;<br>BITVEC bitvEntryLo;<br>BITVEC bitvCommit;<br><span class="hljs-keyword">void</span>* pHeapData;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagRegion</span>* <span class="hljs-title">pRegion</span>;</span><br>&#125;<br>HEADER,*PHEADER;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/d58d5e1aad1b8db3e051fdad0f205cf7-6b918.png" alt="**Header**："></p><h3 id="ioinit-（SBH运行例子：malloc与free）"><a href="#ioinit-（SBH运行例子：malloc与free）" class="headerlink" title="_ioinit()（SBH运行例子：malloc与free）"></a>_ioinit()（SBH运行例子：malloc与free）</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/0f99d7cce6fa99cafeb92ce68548dc1e-99459.png" alt="_ioinit()"  /></p><p><code>_ioinit()</code>是跟io相关的初始化，也是<strong>第一次</strong>内存分配。</p><h4 id="添加DebugHeader"><a href="#添加DebugHeader" class="headerlink" title="添加DebugHeader"></a>添加DebugHeader</h4><p>假设在<strong>DEBUG</strong>模式下，首先要给<strong>IO所需的空间</strong>附着<strong>DebugHeader</strong>：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b79b80c6866320719070b90bfe43ff9f-bab51.png"  /></p><ul><li><code>nSize</code>就是IO需要的空间大小，对于IO来说就是256字节。</li><li><code>_CrtMemBlockHeader</code>为<strong>debug</strong>模式下，附着在我们申请的内存之上的东西，即<strong>DebugHeader</strong>。</li><li><code>szFileName</code>是指针，存放文件名；再结合<code>nLine</code>存放的行数，调试器可以知道这块内存是从哪一个文件的哪一行分配出来的。</li><li><code>nDataSize</code>记录着原本所需分配的内存大小，即<code>nSize</code>。</li><li><code>nBlockUse</code>记录该内存块的用途。<img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7e3c56f6d983475ba91219ef3806bf6b-93c18.png" style="zoom:50%;" /></li><li><code>IRequest</code>为流水号，因为图中的内存块是第一块分配的内存，所以<code>IRequest</code>的内容为1。</li><li><code>gap[nNoMansLandSize]</code>的作用就是，万一我们使用的时候超过<code>nSize</code>的边界，到达<code>nNoMansLandSize</code>区域，调试器就可以检查出来。</li><li>在调试模式下，经过malloc分配的所有内存块，都会被登记起来。即使被我们使用了，也会被登记。所以调试器可以进行追踪内存等动作。</li></ul><p>至此，<code>blockSize</code>的大小已经计算出来了，然后根据计算的大小从<code>malloc</code>获得了内存。接着需要往内存里面写内容：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b4dcea961f8a609d602b7d31d5068c7b-fefe5.png" alt="填充"  /></p><p>可以看到，<code>nNoMansLandSize</code>区域被填充了<code>0xFD</code>，IO真正的区域（大小为<code>nSize</code>）被填充了<code>0xCD</code>。这也就是为什么在调试的时候看内存会出现很多“<strong>烫烫烫….</strong>”。</p><h4 id="添加cookie及RoundUp"><a href="#添加cookie及RoundUp" class="headerlink" title="添加cookie及RoundUp"></a>添加cookie及RoundUp</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9e5757177cd3b04692df36a354577d6f-95be9.png"  /></p><p>有了blockSize以及相应大小的内存区域，接下来：</p><ul><li>在内存块上下添加<strong>cookie</strong>，这个<strong>cookie</strong>的值需要变成<strong>16的倍数</strong>，所以在上图根据计算变成了<code>0x130</code>。</li><li>因为这块内存是正在使用的，所以将<code>0x130</code>变成<code>0x131</code>。</li></ul><h4 id="管理模式"><a href="#管理模式" class="headerlink" title="管理模式"></a>管理模式</h4><ul><li>SBH为了管理1MB，成本是16K。</li><li>SBH通过控制中心分配内存块的行为与STL：allocator的行为几乎相似。</li><li>SBH对区域的粒度划分如此细致，是为了更好的将内存归还给OS。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/64e245b7a20655a9367ed949b23d8149-9775f.png" alt="管理模式"  /></p><h5 id="全回收"><a href="#全回收" class="headerlink" title="全回收"></a>全回收</h5><ul><li>如果没有下cookie的设计，就没办法往上合并。</li><li>SBH手上有两个全回收才会将其中一个Group还给OS。</li><li>每次回收只会往上和往下查看上下区块的cookie<strong>一次</strong>。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/78d00a624e830a518a6e9d2a845063b6-7e63b.png" alt="全回收"  /></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>326. 3的幂</title>
    <link href="/2020/12/06/LeetCode/326.%203%E7%9A%84%E5%B9%82/"/>
    <url>/2020/12/06/LeetCode/326.%203%E7%9A%84%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/power-of-three/">本题链接</a></p><h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPowerOfThree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">1162261467</span> % n == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>在int范围内3的最大次方是3^19 = 1162261467，如果n是3的整数次方，那么1162261467除以n的余数一定是0；反之亦然。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件项目管理</title>
    <link href="/2020/12/06/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    <url>/2020/12/06/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/zhongshiyu98/cdnrepo/pdf/SoftwareProjectManagement.pdf" width="100%" height="550" type="application/pdf"></div><hr><a class="btn" href="https://blog.zhongshiyu.xyz/pdf/mindmaster/SoftwareProjectManagement.pdf"  title="在新窗口打开" target="_blank">进入全屏</a>]]></content>
    
    
    <categories>
      
      <category>软件项目管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Room数据库</title>
    <link href="/2020/12/06/Android/Jetpack/Room%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2020/12/06/Android/Jetpack/Room%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-meta">@Database(entities = &#123;Cache.class&#125;, version = 1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheDatabase</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RoomDatabase</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用抽象类的原因：RoomDatabase是使用注解来使用相关的功能，在编译时使用annotationprocesser来实现类。在使用abstract声明的时候，运行时会产生一个CacheDatabase的实现类。这样一来就不用复写RoomDatabase的几个默认方法</p><h2 id="数据库的创建"><a href="#数据库的创建" class="headerlink" title="数据库的创建"></a>数据库的创建</h2><ol><li>inMemoryDatabaseBuilder()：创建一个内存数据库</li><li>databaseBuilder()：常规创建</li></ol><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><ol><li>allowMainThreadQueries()：是否允许在主线程进行查询，默认是关闭的。如果关闭情况下在主线程查询数据库，将会抛出异常</li><li>addCallback()：数据库创建和打开后的回调</li><li>setQueryExecutor()：设置查询的线程池</li><li>openHelperFactory()：数据库Heper的工厂类</li><li>setJournalMode()：设置数据库的日志模式</li><li>fallbackToDestructiveMigration()：数据库升级异常之后的回滚，设置后将重新创建数据库。若不设置将会销毁数据库</li><li>fallbackToDestructiveMigrationFrom()：数据库升级异常后根据指定版本进行回滚</li><li>addMigrations()：数据库跨版本升级</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-comment">//跨版本升级举例</span><br><br><span class="hljs-comment">//....</span><br><span class="hljs-comment">//数据库从版本1升级到版本3</span><br><span class="hljs-keyword">static</span> Migration sMigration = <span class="hljs-keyword">new</span> Migration(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">migrate</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> SupportSQLiteDatabase database)</span> </span>&#123;<br>        database.execSQL(<span class="hljs-string">&quot;alter table teacher rename to student&quot;</span>);<br>        database.execSQL(<span class="hljs-string">&quot;alter table teacher add column teacher_age INTEGER NOT NULL default 0&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> CacheDatabase database;<br>database = Room.databaseBuilder(AppGlobals.getApplication(), CacheDatabase.class, <span class="hljs-string">&quot;ppjoke_cache&quot;</span>).  addMigrations(sMigration).build();<br><br></code></pre></div></td></tr></table></figure><h2 id="Database注解"><a href="#Database注解" class="headerlink" title="@Database注解"></a>@Database注解</h2><ol><li>entities：数据库中有哪些表</li><li>version：后续数据库升级可用到</li><li>exportSchema：默认为true。会导出一个JSON文件，内容为数据库在升级或创建数据表的时候的操作。也包含了所有表的字段和字段的描述。需要在包的build.gradle文件中配置</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA">defaultConfig &#123;<br>        ...<br><br>        javaCompileOptions&#123;<br>            annotationProcessorOptions&#123;<br>                arguments=[<span class="hljs-string">&quot;room.schemaLocation&quot;</span>:<span class="hljs-string">&quot;$projectDir/schemas&quot;</span>.toString()]<span class="hljs-comment">//表示文件放在包的根目录下的schemas文件夹下</span><br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><h2 id="Entity相关"><a href="#Entity相关" class="headerlink" title="@Entity相关"></a>@Entity相关</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-meta">@Entity(tableName = &quot;cache&quot;,</span><br><span class="hljs-meta">        foreignKeys = &#123;entity = User.class,parentColumns = &quot;id&quot;,childColumns = &quot;key&quot;,</span><br><span class="hljs-meta">        onDelete = &quot;ForeignKey.RESTRICT&quot;,onUpdate = &quot;ForeignKey.SET_DEFAULT&quot;&#125;</span><br><span class="hljs-meta">        )</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-meta">@PrimaryKey(autoGenerate = false)</span><br>    <span class="hljs-keyword">public</span> String key;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] data;<br><br>    <span class="hljs-meta">@Embedded</span> <br>    <span class="hljs-keyword">public</span> User user<br><br>    <span class="hljs-meta">@Relation(entity = Address.class,parentColumn = &quot;id&quot;,entityColumn = &quot;id&quot;,projection = &#123;&#125;)</span><br>    <span class="hljs-keyword">public</span> Address address;<br><br>    <span class="hljs-meta">@ColumnInfo(name = &quot;name&quot;)</span><br>    <span class="hljs-keyword">public</span> String name;<br><br>    <span class="hljs-meta">@Ignore</span><br>    <span class="hljs-keyword">public</span> String age;<br><br>    <span class="hljs-meta">@TypeConverters(value = &#123;DateConverter.class&#125;)</span><br>    <span class="hljs-keyword">public</span> Date mDate;<br><br>&#125;<br><br># DateConverter.class<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateConverter</span> </span>&#123;<br><br>    <span class="hljs-meta">@TypeConverter</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title">date2Long</span><span class="hljs-params">(Date date)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> date.getTime();<br>    &#125;<br><br>    <span class="hljs-meta">@TypeConverter</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">long2Date</span><span class="hljs-params">(Long data)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Date(data);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><ul><li><strong>@ColumnInfo</strong> ：若不加这条注解，表创建时，name在表中的字段名称不变(name)。而加入 <strong>@ColumnInfo(name = “name_”)</strong>，当表创建时，name在表中映射的列名为name_。</li><li><strong>@Embedded</strong> ：对象嵌套,User对象中所有字段,也都会被映射到cache表中</li><li><strong>@Entity</strong> ：定义表的名称</li><li><strong>@PrimaryKey</strong> ：定义表的主键,其中的autoGenerate为true时表示主键自动生成</li><li><strong>foreignKeys</strong> : 定义表的外键。其中entity表示外键所在的表，parentColumns表示外键在其原表中的列名，而childColumns表示外键关联本表中列的列名。onDelete表示外键删除时本表所需动作，onUpdate同理。具体宏作用如下表。<br>  |宏|描述|<br>  |:————|:—————|<br>  |NO_ACTION|什么都不做|<br>  |RESTRICT|当外键删除时，本表中关联的键也会立即删除|<br>  |SET_NULL|设置为空值|<br>  |SET_DEFAULT|设置为默认值|<br>  |CASCADE|与RESTRICT相似，区别在于RESTRICT会立即发生|</li><li><strong>@Ignore</strong> ：该注解标记的字段将不会出现在表中</li><li><strong>@Relation</strong> ：关联查询。entity表示要关联的表，parentColumn表示关联表中的列名，entityColumn表示本表中的列名，projection是个数组，里面填写关联查询所需要返回的列名。</li><li><strong>@TypeConverters</strong> ：它是TypeConverter的集合。可以标记在方法、参数、类、字段上面。当Date类型存入数据库时转换成Long类型，或者从数据库取出后将Long类型转换成Date类型，使用的是DateConverter.class中用 <strong>@TypeConverter</strong> 标注的方法。<strong>@TypeConverter</strong>所标注的方法，必须有一个参数，还有一个不是void类型的返回值。</li></ul><h2 id="Dao相关"><a href="#Dao相关" class="headerlink" title="@Dao相关"></a>@Dao相关</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JAVA"><span class="hljs-meta">@Dao</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CacheDao</span> </span>&#123;<br><br>    <span class="hljs-meta">@Insert(onConflict = OnConflictStrategy.REPLACE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">save</span><span class="hljs-params">(Cache cache)</span></span>;<br><br>    <span class="hljs-comment">//如果是一对多,这里可以写List&lt;Cache&gt;</span><br>    <span class="hljs-meta">@Query(&quot;select *from cache where `key`=:key&quot;)</span><br>    <span class="hljs-function">Cache <span class="hljs-title">getCache</span><span class="hljs-params">(String key)</span></span>;<br><br>    <span class="hljs-comment">//只能传递对象昂,删除时根据Cache中的主键 来比对的</span><br>    <span class="hljs-meta">@Delete</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">delete</span><span class="hljs-params">(Cache cache)</span></span>;<br><br>    <span class="hljs-comment">//只能传递对象昂,删除时根据Cache中的主键 来比对的</span><br>    <span class="hljs-meta">@Update(onConflict = OnConflictStrategy.REPLACE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(Cache cache)</span></span>;<br><br><br><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>当一个类被 <strong>@Dao</strong> 标记，说明它是一个能操作数据库的一个类。可标注在 <strong>interface</strong> 类或者 <strong>abstract</strong> 类上面</li><li><strong>@Insert</strong> 、<strong>@Query</strong> 、 <strong>@Delete</strong> 、<strong>@Update</strong> 等注解</li><li>@Insert(onConflict = OnConflictStrategy.REPLACE)中的<strong>onConflict</strong>表示当插入时发生冲突的行为( <strong>@Update</strong> 也是一样)。<br>  |宏|描述|<br>  |:————|:—————|<br>  |REPLACE|直接用新的数据替换掉旧的数据|<br>  |ROLLBACK|回滚，保留旧的数据|<br>  |ABORT|终止提交，保留旧的数据|<br>  |FAIL|提交失败|<br>  |IGNORE|忽略本次提交|</li><li><strong>@Delete</strong> 中的参数可以是对象、集合、数组等。</li><li><strong>@Transaction</strong> ：所标记的方法将会被当作事务来提交</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>room数据库</tag>
      
      <tag>jetpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>720. 词典中最长的单词</title>
    <link href="/2020/12/05/LeetCode/720.%20%E8%AF%8D%E5%85%B8%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <url>/2020/12/05/LeetCode/720.%20%E8%AF%8D%E5%85%B8%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/">本题链接</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestWord</span><span class="hljs-params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(words.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-built_in">sort</span>(words.<span class="hljs-built_in">begin</span>(),words.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">const</span> string&amp; s1,<span class="hljs-keyword">const</span> string&amp; s2)&#123;<br>            <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">size</span>() == s2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> s1 &lt; s2;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt; s2.<span class="hljs-built_in">size</span>();<br>        &#125;);<br>    <br>        set&lt;string&gt; hash;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; s:words)&#123;<br>            <span class="hljs-comment">//如果字符串长度等于1或者在哈希表中找到了字符串的前缀</span><br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span> || hash.<span class="hljs-built_in">find</span>(<span class="hljs-built_in">string</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>()<span class="hljs-number">-1</span>)) != hash.<span class="hljs-built_in">end</span>())&#123;<br>                <span class="hljs-comment">//将该字符串加入哈希表中</span><br>                hash.<span class="hljs-built_in">emplace</span>(s);<br>                <span class="hljs-comment">//如果当前字符串长度大于结果，或者长度相等时字符串的字典序小于结果</span><br>                <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() &lt; s.<span class="hljs-built_in">size</span>() || (res.<span class="hljs-built_in">size</span>() == s.<span class="hljs-built_in">size</span>() &amp;&amp; res &gt; s)) res = s;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于结果的选取，长度优先考虑，之后再选择字典序最小的。先将数组排序，让字符串长度越小的越靠前，然后依次放入哈希表中，如果字符串的前缀没有在哈希表里，那么就跳过。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ExecutorService</title>
    <link href="/2020/12/03/JAVA/ExecutorService/"/>
    <url>/2020/12/03/JAVA/ExecutorService/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>ExecutorService是Java中对线程池定义的一个接口，它位于java.util.concurrent包中，在这个接口中定义了和后台任务执行相关的方法：</p><ol><li>ThreadPoolExecutor</li><li>ScheduledThreadPoolExecutor</li></ol><p>除此之外，ExecutorService还继承了Executor接口（注意区分Executor接口和Executors工厂类），这个接口只有一个execute()方法，最后我们看一下整个继承树：<br><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201203213311.png" alt="继承树"></p><h2 id="ExecutorService的创建"><a href="#ExecutorService的创建" class="headerlink" title="ExecutorService的创建"></a>ExecutorService的创建</h2><p>创建一个什么样的ExecutorService的实例（即线程池）需要根据具体应用场景而定，不过Java给我们提供了一个Executors工厂类，它可以帮助我们很方便的创建各种类型ExecutorService线程池，Executors一共可以创建下面这四类线程池：</p><ol><li>newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li><li>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li><li>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</li><li>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ol><p><em>注意</em>：Executors只是一个工厂类，它所有的方法返回的都是ThreadPoolExecutor、ScheduledThreadPoolExecutor这两个类的实例。</p><h2 id="ExecutorService的使用"><a href="#ExecutorService的使用" class="headerlink" title="ExecutorService的使用"></a>ExecutorService的使用</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br>executorService.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Asynchronous task&quot;</span>);<br>    &#125;<br>&#125;);<br><br>executorService.shutdown();<br></code></pre></div></td></tr></table></figure><h2 id="ExecutorService的执行"><a href="#ExecutorService的执行" class="headerlink" title="ExecutorService的执行"></a>ExecutorService的执行</h2><ul><li>execute(Runnable)</li><li>submit(Runnable)</li><li>submit(Callable)</li><li>invokeAny(…)</li><li>invokeAll(…)</li></ul><h3 id="execute-Runnable"><a href="#execute-Runnable" class="headerlink" title="execute(Runnable)"></a>execute(Runnable)</h3><p>这个方法接收一个Runnable实例，并且异步的执行</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ExecutorService executorService = Executors.newSingleThreadExecutor();<br><br>executorService.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Asynchronous task&quot;</span>);<br>    &#125;<br>&#125;);<br><br>executorService.shutdown();<br></code></pre></div></td></tr></table></figure><p>这个方法有个问题，就是没有办法获知task的执行结果。如果我们想获得task的执行结果，我们可以传入一个Callable的实例。</p><h3 id="submit-Runnable"><a href="#submit-Runnable" class="headerlink" title="submit(Runnable)"></a>submit(Runnable)</h3><p>submit(Runnable)和execute(Runnable)区别是前者可以返回一个Future对象，通过返回的Future对象，我们可以检查提交的任务是否执行完毕。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br>Future future = executorService.submit(<span class="hljs-keyword">new</span> Runnable() &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Asynchronous task&quot;</span>);<br>&#125;<br>&#125;);<br><br>future.get(); <span class="hljs-comment">/*该方法会产生阻塞*/</span><br><br></code></pre></div></td></tr></table></figure><p>如果任务执行完成，future.get()方法会返回一个null。</p><h3 id="submit-Callable"><a href="#submit-Callable" class="headerlink" title="submit(Callable)"></a>submit(Callable)</h3><p>submit(Callable)和submit(Runnable)类似，也会返回一个Future对象，但是除此之外，submit(Callable)接收的是一个Callable的实现，Callable接口中的call()方法有一个返回值，可以返回任务的执行结果，而Runnable接口中的run()方法是void的，没有返回值。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br>Future future = executorService.submit(<span class="hljs-keyword">new</span> Callable()&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Asynchronous Callable&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Callable Result&quot;</span>;<br>    &#125;<br>&#125;);<br><br>System.out.println(<span class="hljs-string">&quot;future.get() = &quot;</span> + future.get());<span class="hljs-comment">/*该方法会产生阻塞*/</span><br><br></code></pre></div></td></tr></table></figure><p>如果任务执行完成，future.get()方法会返回Callable任务的执行结果。</p><h3 id="invokeAny-…"><a href="#invokeAny-…" class="headerlink" title="invokeAny(…)"></a>invokeAny(…)</h3><p>invokeAny(…)方法接收的是一个Callable的集合，执行这个方法不会返回Future，但是会返回所有Callable任务中其中一个任务的执行结果。这个方法也无法保证返回的是哪个任务的执行结果，反正是其中的某一个。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ExecutorService executorService = Executors.newSingleThreadExecutor();<br><br>Set&lt;Callable&lt;String&gt;&gt; callables = <span class="hljs-keyword">new</span> HashSet&lt;Callable&lt;String&gt;&gt;();<br><br>callables.add(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Task 1&quot;</span>;<br>    &#125;<br>&#125;);<br>callables.add(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Task 2&quot;</span>;<br>    &#125;<br>&#125;);<br>callables.add(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Task 3&quot;</span>;<br>    &#125;<br>&#125;);<br><br>String result = executorService.invokeAny(callables);<br>System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>executorService.shutdown();<br></code></pre></div></td></tr></table></figure><p>每次执行都会返回一个结果，并且返回的结果是变化的，可能会返回“Task2”也可是“Task1”或者其它。</p><h3 id="invokeAll-…"><a href="#invokeAll-…" class="headerlink" title="invokeAll(…)"></a>invokeAll(…)</h3><p>invokeAll(…)与 invokeAny(…)类似也是接收一个Callable集合，但是前者执行之后会返回一个Future的List，其中对应着每个Callable任务执行后的Future对象。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">ExecutorService executorService = Executors.newSingleThreadExecutor();<br><br>Set&lt;Callable&lt;String&gt;&gt; callables = <span class="hljs-keyword">new</span> HashSet&lt;Callable&lt;String&gt;&gt;();<br><br>callables.add(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Task 1&quot;</span>;<br>    &#125;<br>&#125;);<br>callables.add(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Task 2&quot;</span>;<br>    &#125;<br>&#125;);<br>callables.add(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Task 3&quot;</span>;<br>    &#125;<br>&#125;);<br><br>List&lt;Future&lt;String&gt;&gt; futures = executorService.invokeAll(callables);<br><br><span class="hljs-keyword">for</span>(Future&lt;String&gt; future : futures)&#123;<br>    System.out.println(<span class="hljs-string">&quot;future.get = &quot;</span> + future.get());<br>&#125;<br><br>executorService.shutdown();<br><br></code></pre></div></td></tr></table></figure><h2 id="ExecutorService的关闭"><a href="#ExecutorService的关闭" class="headerlink" title="ExecutorService的关闭"></a>ExecutorService的关闭</h2><p>当我们使用完成ExecutorService之后应该关闭它，否则它里面的线程会一直处于运行状态。</p><p>举个例子，如果的应用程序是通过main()方法启动的，在这个main()退出之后，如果应用程序中的ExecutorService没有关闭，这个应用将一直运行。之所以会出现这种情况，是因为ExecutorService中运行的线程会阻止JVM关闭。</p><p>如果要关闭ExecutorService中执行的线程，我们可以调用ExecutorService.shutdown()方法。在调用shutdown()方法之后，ExecutorService不会立即关闭，但是它不再接收新的任务，直到当前所有线程执行完成才会关闭，所有在shutdown()执行之前提交的任务都会被执行。</p><p>如果我们想立即关闭ExecutorService，我们可以调用ExecutorService.shutdownNow()方法。这个动作将跳过所有正在执行的任务和被提交还没有执行的任务。但是它并不对正在执行的任务做任何保证，有可能它们都会停止，也有可能执行完成。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p><a href="https://www.cnblogs.com/Transkai/p/11230734.html">Java 线程池ExecutorService详解</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ExecutorService</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>19. 删除链表的倒数第 N 个结点</title>
    <link href="/2020/12/03/LeetCode/19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <url>/2020/12/03/LeetCode/19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">本题链接</a></p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> head;<br><br>        <span class="hljs-function">ListNode <span class="hljs-title">dummy</span><span class="hljs-params">(<span class="hljs-number">0</span>,head)</span></span>;<br>        ListNode* p1 = head;ListNode* p2 = &amp;dummy;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n - <span class="hljs-number">1</span>; ++i)<span class="hljs-comment">//p1往前递进n-1个</span><br>            p1 = p1-&gt;next;<br>        <br>        <span class="hljs-comment">//两个指针一起走,直到p1到达末尾</span><br>        <span class="hljs-comment">//p2从head的前一个节点开始</span><br>        <span class="hljs-keyword">while</span>(p1-&gt;next)&#123;<br>            p1 = p1-&gt;next;<br>            p2 = p2-&gt;next;<br>        &#125;<br><br>        <span class="hljs-comment">//去除节点</span><br>        p2-&gt;next = p2-&gt;next-&gt;next;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用双指针，开始时第一个指针指向head，第二个指针指向head的前一个节点，先让第一个指针走n+1步，然后第二个指针也和第一个指针一样一起走，直到第一个指针走到最后一个节点，那么第二个指针指向的就是倒数第n+1个节点。至于为什么走到第n+1个节点而不是第n个节点的原因是，删除倒数第n个节点需要用到倒数第n+1个节点。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>链表</tag>
      
      <tag>快慢指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PermissionsDispatcher</title>
    <link href="/2020/12/03/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/PermissionsDispatcher/"/>
    <url>/2020/12/03/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/PermissionsDispatcher/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PermissionsDispatcher是一个基于注解、帮助开发者简单处理Android 6.0系统中的运行时权限的开源库。避免了开发者编写大量繁琐的样板代码。</p><h2 id="注解列表"><a href="#注解列表" class="headerlink" title="注解列表"></a>注解列表</h2><div class="table-container"><table><thead><tr><th style="text-align:left">注解</th><th style="text-align:left">必须</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">@RuntimePermissions</td><td style="text-align:left">是</td><td style="text-align:left">注解在其内部需要使用运行时权限的Activity或Fragment上</td></tr><tr><td style="text-align:left">@NeedsPermission</td><td style="text-align:left">是</td><td style="text-align:left">注解在需要调用运行时权限的方法上，当用户给予权限时会执行该方法</td></tr><tr><td style="text-align:left">@OnShowRationale</td><td style="text-align:left">否</td><td style="text-align:left">注解在用于向用户解释为什么需要调用该权限的方法上，只有当第一次请求权限被用户拒绝，下次请求权限之前会调用</td></tr><tr><td style="text-align:left">@OnPermissionDenied</td><td style="text-align:left">否</td><td style="text-align:left">注解在当用户拒绝了权限请求时需要调用的方法上</td></tr><tr><td style="text-align:left">@OnNeverAskAgain</td><td style="text-align:left">否</td><td style="text-align:left">注解在当用户选中了授权窗口中的不再询问复选框后并拒绝了权限请求时需要调用的方法，一般可以向用户解释为何申请此权限，并根据实际需求决定是否再次弹出权限请求对话框</td></tr></tbody></table></div><p><em>注意：私有方法不能被注解！</em></p><h2 id="简单使用方法（以相机权限为例）"><a href="#简单使用方法（以相机权限为例）" class="headerlink" title="简单使用方法（以相机权限为例）"></a>简单使用方法（以相机权限为例）</h2><ol><li>打开bulid.gradle(Module)添加依赖</li></ol><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">dependencies</span> &#123;<br>  <span class="hljs-attribute">implementation</span> <span class="hljs-string">&quot;org.permissionsdispatcher:permissionsdispatcher:<span class="hljs-variable">$&#123;latest.version&#125;</span>&quot;</span><br>  annotationProcessor <span class="hljs-string">&quot;org.permissionsdispatcher:permissionsdispatcher-processor:<span class="hljs-variable">$&#123;latest.version&#125;</span>&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ol><li><p>AndroidManifest.xml中添加权限<br><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201203123324.png" alt="添加权限">  </p></li><li><p>在需要运行权限的Activity上添加@RuntimePermissions<br><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201203123501.png" alt="@RuntimePermissions"></p></li><li><p>在需要调用运行时权限的方法上添加@NeedsPermission并标注所需权限</p></li></ol><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201203123613.png" alt="@NeedsPermission"></p><ol><li>使用MainActivityPermissionsDispatcher.startCameraWithPermissionCheck(this)来调用第四步中创建的方法。其中，startCameraWithPermissionCheck中的startCamera需与第四步中的方法名一致。即调用XXX方法使用MainActivityPermissionsDispatcher.XXXWithPermissionCheck(this)</li></ol><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20201203123840.png" alt="调用"></p><ol><li>重写该Activity的onRequestPermissionsResult()方法，其方法内调用MainActivityPermissionsDispatcher的onRequestPermissionsResult()方法</li></ol><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@Override</span><br>public void onRequestPermissionsResult(int requestCode, <span class="hljs-variable">@NonNull</span> String[] permissions, <span class="hljs-variable">@NonNull</span> int[] grantResults) &#123;<br>    <span class="hljs-selector-tag">super</span><span class="hljs-selector-class">.onRequestPermissionsResult</span>(requestCode, permissions, grantResults);<br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> delegate the permission handling to generated method</span><br>    <span class="hljs-selector-tag">MainActivityPermissionsDispatcher</span><span class="hljs-selector-class">.onRequestPermissionsResult</span>(this, requestCode, grantResults);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h2><p><a href="https://github.com/permissions-dispatcher/PermissionsDispatcher">https://github.com/permissions-dispatcher/PermissionsDispatcher</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PermissionsDispatcher</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>637. 二叉树的层平均值</title>
    <link href="/2020/12/02/LeetCode/637.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/"/>
    <url>/2020/12/02/LeetCode/637.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">本题链接</a></p><h2 id="层序遍历-迭代"><a href="#层序遍历-迭代" class="headerlink" title="层序遍历+迭代"></a>层序遍历+迭代</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">averageOfLevels</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>        queue&lt;TreeNode*&gt; node_queue;<br>        vector&lt;<span class="hljs-keyword">double</span>&gt; res;<br><br>        node_queue.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!node_queue.<span class="hljs-built_in">empty</span>())&#123;<br><br>            <span class="hljs-keyword">double</span> size = node_queue.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//该层大小</span><br>            <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0</span>;<span class="hljs-comment">//该层总数</span><br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; size;++i)&#123;<br>                <br>                <span class="hljs-keyword">if</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;left) node_queue.<span class="hljs-built_in">push</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;left);<br>                <span class="hljs-keyword">if</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;right) node_queue.<span class="hljs-built_in">push</span>(node_queue.<span class="hljs-built_in">front</span>()-&gt;right);<br>                sum += node_queue.<span class="hljs-built_in">front</span>()-&gt;val;<br>                <br>                node_queue.<span class="hljs-built_in">pop</span>();<br>            &#125;   <br><br>            res.<span class="hljs-built_in">push_back</span>(sum/size);<span class="hljs-comment">//保存结果</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>与&lt;&lt;<strong>102. 二叉树的层序遍历</strong>&gt;&gt;思路一致</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代</tag>
      
      <tag>层序遍历</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存原语</title>
    <link href="/2020/12/01/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%8E%9F%E8%AF%AD/"/>
    <url>/2020/12/01/C++/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%8E%9F%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="C-内存原语"><a href="#C-内存原语" class="headerlink" title="C++内存原语"></a>C++内存原语</h1><h2 id="内存分配操作"><a href="#内存分配操作" class="headerlink" title="内存分配操作"></a>内存分配操作</h2><div class="table-container"><table><thead><tr><th>分配</th><th>释放</th><th>类属</th><th>可否重载</th></tr></thead><tbody><tr><td>malloc()</td><td>free()</td><td>C 函数</td><td>不可</td></tr><tr><td>new</td><td>delete</td><td>C++ 表达式</td><td>不可</td></tr><tr><td>::operator new()</td><td>::operator delete()</td><td>C++ 函数</td><td>可</td></tr><tr><td>allocator::allocate()</td><td>allocator::deallocate</td><td>C++ 标准库</td><td>可自由设计并予以搭配任何容器</td></tr></tbody></table></div><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>new实际上在内部执行了三个步骤：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">Complex *pc;<span class="hljs-comment">//实际上会执行以下三步</span><br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">/* 1 */</span> <span class="hljs-keyword">void</span> mem = <span class="hljs-keyword">operator</span> <span class="hljs-built_in"><span class="hljs-keyword">new</span></span> (<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Complex));  <span class="hljs-comment">// allocate 申请内存空间</span><br>    <span class="hljs-comment">/* 2 */</span> pc = <span class="hljs-built_in"><span class="hljs-keyword">static_cast</span></span>(mem);                      <span class="hljs-comment">// cast 类型转换</span><br>    <span class="hljs-comment">/* 3 */</span> pc-&gt;Complex::<span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);                 <span class="hljs-comment">// construct 调用构造函数</span><br>    <span class="hljs-comment">// 注意：只有编译器才可以像上面那样直接呼叫 ctor</span><br>&#125;<br><span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (std::bad_alloc) &#123;<br>    <span class="hljs-comment">// 若 allocation 失败，就不执行 constructor </span><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>在GCC只能由编译器调用构造函数，而VC6下可以自己调用构造函数。而析构函数没有这种限制。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br>    <span class="hljs-comment">//....</span><br>&#125;<br><br>A* pA = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>);<br>pA-&gt;A::<span class="hljs-built_in">A</span>(<span class="hljs-number">3</span>);                    <span class="hljs-comment">//in VC6 : ctor. this=000307A8 id=3</span><br>  <span class="hljs-comment">//in GCC : [Error] cannot call constructor </span><br><span class="hljs-keyword">delete</span> pA; <br></code></pre></div></td></tr></table></figure></li></ul><p><code>operator new</code> 的操作：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// ...\vc98\crt\src\newop2.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> std::<span class="hljs-keyword">nothrow_t</span> &amp;_THROW0())</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// try to allocate size bytes</span><br>    <span class="hljs-keyword">void</span> *p;<br>    <span class="hljs-keyword">while</span> ((p = <span class="hljs-built_in">malloc</span>(size)) == <span class="hljs-number">0</span>)<span class="hljs-comment">//当分配失败时</span><br>    &#123;<br>        <span class="hljs-comment">// buy more memory or return null pointer</span><br>        <span class="hljs-function">__TRY_BEGIN</span><br><span class="hljs-function">        <span class="hljs-title">if</span> <span class="hljs-params">(_callnewh(size) == <span class="hljs-number">0</span>)</span> <span class="hljs-keyword">break</span></span>;<br>        _CATCH(std::bad_alloc)  <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>        _CATCH_END<br>    &#125;   <br>&#125;<br></code></pre></div></td></tr></table></figure><p>在上面代码段中：</p><ul><li><code>const std::nothrow_t &amp;_THROW0()</code>：指示该函数应返回空指针以报告分配失败，而不是引发异常。</li><li><code>_callnewh()</code>：当分配失败时执行这个函数，这个函数由我们自己编写，让我们可以借此机会释放一些内存。</li></ul><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>delete实际上在内部执行了两个步骤：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">Complex *pc = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">delete</span> pc;<span class="hljs-comment">//实际上会执行以下两条代码</span><br><br>pc-&gt;~<span class="hljs-built_in">Complex</span>();         <span class="hljs-comment">// 调用析构函数</span><br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span> <span class="hljs-params">(pc)</span></span>;   <span class="hljs-comment">// 释放内存</span><br></code></pre></div></td></tr></table></figure><p><code>operator delete</code>：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// ...\vc98\crt\src\delop.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> __cdelc <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *p)</span> __<span class="hljs-title">THROW0</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// free an allocated object</span><br>    <span class="hljs-built_in">free</span>(p);<span class="hljs-comment">//实际上就调用了一个free</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="array-new-和-array-delete"><a href="#array-new-和-array-delete" class="headerlink" title="array new 和 array delete"></a>array new 和 array delete</h2><ul><li>所有编译器的malloc和free都会分配cookie。</li><li>一个类的析构函数<strong>没有意义</strong>的话，<strong>array new</strong>后不使用<strong>array delete</strong>也可以。</li></ul><h2 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h2><p><strong>作用：将对象构建在一个已经分配好的内存中</strong>。</p><p>没有所谓的<strong>placement delete</strong>，因为placement new根本没分配内存。或者说与<strong>placement new</strong>相对应的<strong>operator delete</strong>为<strong>placement delete</strong>。</p><p>用法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;new&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span>;</span><br><span class="hljs-keyword">char</span>* buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Complex)*<span class="hljs-number">3</span>];<br>Complex* pc = <span class="hljs-built_in"><span class="hljs-keyword">new</span></span>(buf) <span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">//placement new在此</span><br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">delete</span>[] buf;<br></code></pre></div></td></tr></table></figure><p>在<code>new(buf)Complex(1,2)</code>内部：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">/* 1 */</span> <span class="hljs-keyword">void</span> mem = <span class="hljs-keyword">operator</span> <span class="hljs-built_in"><span class="hljs-keyword">new</span></span> (<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Complex),buf);<br>    <span class="hljs-comment">/* 2 */</span> pc = <span class="hljs-keyword">static_cast</span>&lt;Complex*&gt;(mem);                  <br>    <span class="hljs-comment">/* 3 */</span> pc-&gt;Complex::<span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);             <br>&#125;<br><span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (std::bad_alloc) &#123;<br>    <span class="hljs-comment">// 若 allocation 失败，就不执行 constructor </span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>而上述代码中的<code>operator new</code> 的操作实际上就返回了一个指针。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span>,<span class="hljs-keyword">void</span>* loc)</span></span>&#123;<span class="hljs-keyword">return</span> loc;&#125;<br></code></pre></div></td></tr></table></figure><p>即<strong>指针pc</strong>和<strong>指针buf</strong>都指向同一个地址。</p><p>注意：<strong>placement new</strong>或指<code>new(p)</code>，或指<code>::operator new(size,void*)</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>不应该直接调用构造和析构函数，而是用<code>new</code>和<code>delete</code></li><li>虽然析构函数可以被直接调用，但是也不应该直接调用。若是析构函数中需要释放系统资源，那么析构函数被调用多次，资源也将被释放多次。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>53. 最大子序和</title>
    <link href="/2020/11/28/LeetCode/53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <url>/2020/11/28/LeetCode/53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">本题链接</a></p><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">psum</span><span class="hljs-params">(nums.size() + <span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <br>        <span class="hljs-comment">//构造前缀和</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>            psum[i + <span class="hljs-number">1</span>] = psum[i] + nums[i];<br><br>        <span class="hljs-keyword">int</span> res = psum[<span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">//使用滑动窗口</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; psum.<span class="hljs-built_in">size</span>(); ++i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i;j &lt; psum.<span class="hljs-built_in">size</span>(); ++j)<br>                res = <span class="hljs-built_in">max</span>(res,psum[j] - psum[i<span class="hljs-number">-1</span>]);<br>            <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>记录每个元素的前缀和，然后使用滑动窗口计算每个区域的大小。但是后面发现多此一举…没必要统计前缀和，使用单纯的累计值对比就行。</p><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> res = INT_MIN;<br><br>        <span class="hljs-comment">//使用滑动窗口</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i;j &lt; nums.<span class="hljs-built_in">size</span>(); ++j)&#123;<br>                sum+=nums[j];<br>                res = <span class="hljs-built_in">max</span>(res,sum);<br>            &#125;   <br>        &#125;<br> <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>简单直观，直接暴力遍历每个可能的区间，但是复杂度很高。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>,ans = nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; p : nums)&#123;<br>            <br>            pre = <span class="hljs-built_in">max</span>(p,pre + p);<span class="hljs-comment">//选择是否保留前面的区域</span><br>            ans = <span class="hljs-built_in">max</span>(pre,ans);<span class="hljs-comment">//选择最大的结果</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>根据规律其实可以推出状态转移方程：</p><script type="math/tex; mode=display">dp[i]=max(dp[i-1],dp[i-1]+numsp[i])</script><p>如果前面的区域加上自己还小于自己的话，说明前面的区域可以舍弃了。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>数组</tag>
      
      <tag>动态规划</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>283. 移动零</title>
    <link href="/2020/11/26/LeetCode/283.%20%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <url>/2020/11/26/LeetCode/283.%20%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/move-zeroes/">本题链接</a></p><h2 id="双指针-就地算法"><a href="#双指针-就地算法" class="headerlink" title="双指针+就地算法"></a>双指针+就地算法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> pos_insert = <span class="hljs-number">0</span>,i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>( i &lt; nums.<span class="hljs-built_in">size</span>())&#123;<br><br>            <span class="hljs-keyword">if</span>( nums[i] != <span class="hljs-number">0</span>) <span class="hljs-built_in">swap</span>(nums[pos_insert++], nums[i++]);<br>            <span class="hljs-keyword">else</span> ++i;<br><br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><code>pos_insert</code>指针指向需要插入的地方，另一根<code>i</code>指针遍历数组，找到非零就插入到<code>pos_insert</code>指向的地方。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>就地算法</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21. 合并两个有序链表</title>
    <link href="/2020/11/23/LeetCode/21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/11/23/LeetCode/21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">本题链接</a></p><h2 id="迭代版"><a href="#迭代版" class="headerlink" title="迭代版"></a>迭代版</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <br>        <span class="hljs-function">ListNode <span class="hljs-title">head</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>        ListNode* nextNode = &amp;head;<br><br>        <span class="hljs-keyword">while</span>(l1 &amp;&amp; l2)&#123;<br><br>            <span class="hljs-keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)&#123;<br>                nextNode-&gt;next = l1;<br>                l1 = l1-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                nextNode-&gt;next = l2;<br>                l2 = l2-&gt;next;<br>            &#125;<br>            nextNode = nextNode-&gt;next;<br>        &#125;<br><br>        nextNode-&gt;next = l1 ? l1 : l2;<br>        <span class="hljs-keyword">return</span> head.next;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>构建一个头节点，然后每次往这个节点依次添加两个链表中最小的节点</p><h2 id="递归版1"><a href="#递归版1" class="headerlink" title="递归版1"></a>递归版1</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br><br>        <span class="hljs-function">ListNode <span class="hljs-title">head</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>        ListNode* node = &amp;head;<br>        <span class="hljs-built_in">merge</span>(l1, l2,node);<br>        <span class="hljs-keyword">return</span> head.next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* l1, ListNode* l2,ListNode* node)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(l1 &amp;&amp; l2)&#123;<br><br>            <span class="hljs-keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)&#123;<br>                node-&gt;next = l1;<br>                l1 = l1-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                node-&gt;next = l2;<br>                l2 = l2-&gt;next;<br>            &#125;<br>            node = node-&gt;next;<br>            <span class="hljs-built_in">merge</span>(l1, l2,node);<br>            <br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            node-&gt;next = l1 ? l1 : l2;<br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>与迭代版一样</p><h2 id="递归版2"><a href="#递归版2" class="headerlink" title="递归版2"></a>递归版2</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br><br>        <br>        <span class="hljs-keyword">if</span>(!l1) <span class="hljs-keyword">return</span> l2;<br>        <br>        <span class="hljs-keyword">if</span>(!l2) <span class="hljs-keyword">return</span> l1;<br>        <br>        <span class="hljs-keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;<br>            l1-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(l1-&gt;next,l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br><br>        l2-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(l1,l2-&gt;next);<br>        <span class="hljs-keyword">return</span> l2;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>优化了递归版1，主要的思路就是每个递归函数返回给上一个递归函数需要挂接的节点。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代</tag>
      
      <tag>递归</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24. 两两交换链表中的节点</title>
    <link href="/2020/11/23/LeetCode/24.%20%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2020/11/23/LeetCode/24.%20%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">本题链接</a></p><h2 id="迭代版"><a href="#迭代版" class="headerlink" title="迭代版"></a>迭代版</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(head== <span class="hljs-literal">nullptr</span> ||head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br><br>        <span class="hljs-function">ListNode <span class="hljs-title">dummy</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>        ListNode* node = &amp;dummy;<br>        ListNode* tmp;<br>        <span class="hljs-keyword">while</span>(head)&#123;<br><br>            <span class="hljs-keyword">if</span>(head-&gt;next == <span class="hljs-literal">nullptr</span>)&#123;<br>                node-&gt;next = head;<br>                <span class="hljs-keyword">return</span> dummy.next;<br>            &#125;<br><br>            tmp = head-&gt;next-&gt;next;<span class="hljs-comment">//保存下一个开始值</span><br>            node-&gt;next = head-&gt;next;<span class="hljs-comment">//串接到结果上</span><br>            node-&gt;next-&gt;next = head;<span class="hljs-comment">//反转</span><br>            node = node-&gt;next-&gt;next;<span class="hljs-comment">//设置下一次挂接的点</span><br>            head = tmp;<span class="hljs-comment">//设置下一个开始值</span><br><br>        &#125;<br>        node-&gt;next = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//避免回环</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>两两交换，需要注意的是记得保存结果对接点和节点为空的情况判断。</p><h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        <span class="hljs-comment">//递归基判断</span><br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span>(!head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment">//交换操作</span><br>        ListNode* ret = head-&gt;next;<br>        ListNode* tmp = head-&gt;next-&gt;next;<br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-built_in">swapPairs</span>(tmp);<br>        <span class="hljs-comment">//返回给上一个递归需要对接的节点</span><br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>与迭代版一样</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代</tag>
      
      <tag>递归</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更新UI方法</title>
    <link href="/2020/11/23/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E6%9B%B4%E6%96%B0UI%E6%96%B9%E6%B3%95/"/>
    <url>/2020/11/23/Android/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E6%9B%B4%E6%96%B0UI%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="view-post-Runnable-action"><a href="#view-post-Runnable-action" class="headerlink" title="view.post(Runnable action)"></a>view.post(Runnable action)</h2><p>假如该方法是在子线程中</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br>textView.post(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            textView.setText(<span class="hljs-string">&quot;更新textView&quot;</span>);<br>            <span class="hljs-comment">//还可以更新其他的控件</span><br>            imageView.setBackgroundResource(R.drawable.update);<br>        &#125;<br>    &#125;);<br><br></code></pre></div></td></tr></table></figure><p>这是view自带的方法，比较简单，如果你的子线程里可以得到要更新的view的话，可以用此方法进行更新。</p><p>view还有一个方法view.postDelayed(Runnable action, long delayMillis)用来延迟发送。</p><h2 id="activity-runOnUiThread-Runnable-action"><a href="#activity-runOnUiThread-Runnable-action" class="headerlink" title="activity.runOnUiThread(Runnable action)"></a>activity.runOnUiThread(Runnable action)</h2><p>假如该方法是在子线程中</p><p>注意：context 对象要是 主线程中的MainActivity，这样强转才可以。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateUI</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Context context)</span> </span>&#123;<br>        ((MainActivity) context).runOnUiThread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">//此时已在主线程中，可以更新UI了</span><br>            &#125;<br>        &#125;);<br>    &#125;<br><br></code></pre></div></td></tr></table></figure><p>如果没有上下文（context），试试下面的方法：<br>1.用view.getContext()可以得到上下文。<br>2.跳过context直接用new Activity().runOnUiThread(Runnable action)来切换到主线程。</p><h2 id="Handler机制"><a href="#Handler机制" class="headerlink" title="Handler机制"></a>Handler机制</h2><p>首先在主线程中定义Handler，Handler mainHandler = new Handler();（必须要在主线程中定义才能操作主线程，如果想在其他地方定义声明时要这样写Handler mainHandler = new Handler(Looper.getMainLooper())，来获取主线程的 Looper 和 Queue ）</p><p>获取到 Handler 后就很简单了，用handler.post(Runnable r)方法把消息处理放在该 handler 依附的消息队列中（也就是主线程消息队列）。</p><h3 id="1-假如该方法是在子线程中"><a href="#1-假如该方法是在子线程中" class="headerlink" title="1.假如该方法是在子线程中"></a>1.假如该方法是在子线程中</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br>Handler mainHandler = <span class="hljs-keyword">new</span> Handler(Looper.getMainLooper());<br>mainHandler.post(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//已在主线程中，可以更新UI</span><br>    &#125;<br>&#125;);<br><br></code></pre></div></td></tr></table></figure><p>Handler还有下面的方法：<br>1.postAtTime(Runnable r, long uptimeMillis); //在某一时刻发送消息<br>2.postAtDelayed(Runnable r, long delayMillis); //延迟delayMillis毫秒再发送消息</p><h3 id="2-假设在主线程中"><a href="#2-假设在主线程中" class="headerlink" title="2.假设在主线程中"></a>2.假设在主线程中</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br>Handler myHandler = <span class="hljs-keyword">new</span> Handler() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span>(msg.what) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                <span class="hljs-comment">//更新UI等</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                 <span class="hljs-comment">//更新UI等</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>之后可以把 mainHandler 当做参数传递在各个类之间，当需要更新UI时，可以调用sendMessage一系列方法来执行handleMessage里的操作。</p><p>假设现在在子线程了</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  *获取消息，尽量用obtainMessage()方法，查看源码发现，该方法节省内存。</span><br><span class="hljs-comment">  *不提倡用Messenger msg=new Messenger()这种方法，每次都去创建一个对象，肯定不节省内存啦！</span><br><span class="hljs-comment">  */</span><br>Message msg = myHandler.obtainMessage();<br>msg.what = <span class="hljs-number">0</span>; <span class="hljs-comment">//消息标识</span><br>myHandler.sendMessage(msg); <span class="hljs-comment">//发送消息</span><br></code></pre></div></td></tr></table></figure><p>如上代码，只是发送了个消息标识，并没有传其他参数。<br>如果想传递参数，可以这样：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br>msg.what = <span class="hljs-number">1</span>;  <span class="hljs-comment">//消息标识</span><br>msg.arg1=<span class="hljs-number">2</span>;   <span class="hljs-comment">//存放整形数据，如果携带数据简单，优先使用arg1和arg2，比Bundle更节省内存。</span><br>msg.arg2=<span class="hljs-number">3</span>;   <span class="hljs-comment">//存放整形数据</span><br>Bundle bundle=<span class="hljs-keyword">new</span> Bundle();<br>bundle.putString(<span class="hljs-string">&quot;dd&quot;</span>,<span class="hljs-string">&quot;adfasd&quot;</span>);<br>bundle.putInt(<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-number">5</span>);<br>msg.setData(bundle);<br>msg.obj=bundle;   <span class="hljs-comment">//用来存放Object类型的任意对象</span><br>myHandler.sendMessage(msg); <span class="hljs-comment">//发送消息</span><br><br></code></pre></div></td></tr></table></figure><p>总结： msg.obj它的功能比较强大一下，至于它和利用Bundle传递数据，那个会效率高一些，更节省内存一些。个人认为：从传递数据的复杂程度看，由简单到复杂依次使用，arg1， setData(), obj。会比较好一些。</p><p>当然可以用简化方法sendEmptyMessage(int what)来减少不必要的代码，这样写：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java">myHandler.sendEmptyMessage(<span class="hljs-number">0</span>); <span class="hljs-comment">//其实内部实现还是和上面一样</span><br></code></pre></div></td></tr></table></figure><p>发送消息的其他方法有：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><br>endEmptyMessageAtTime(<span class="hljs-keyword">int</span> what, <span class="hljs-keyword">long</span> uptimeMillis); <span class="hljs-comment">//定时发送空消息</span><br>sendEmptyMessageDelayed(<span class="hljs-keyword">int</span> what, <span class="hljs-keyword">long</span> delayMillis); <span class="hljs-comment">//延时发送空消息</span><br>sendMessageAtTime(Message msg, <span class="hljs-keyword">long</span> uptimeMillis); <span class="hljs-comment">//定时发送消息</span><br>sendMessageDelayed(Message msg, <span class="hljs-keyword">long</span> delayMillis); <span class="hljs-comment">//延时发送消息</span><br>sendMessageAtFrontOfQueue(Message msg); <span class="hljs-comment">//最先处理消息（慎用）</span><br><br></code></pre></div></td></tr></table></figure><h2 id="使用AsyncTask"><a href="#使用AsyncTask" class="headerlink" title="使用AsyncTask"></a>使用AsyncTask</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 该类中方法的执行顺序依次为：onPreExecute, doInBackground, onPostExecute</span><br><span class="hljs-comment">  */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAsyncTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AsyncTask</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">Integer</span>, <span class="hljs-title">String</span>&gt; </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 主线程中执行</span><br><span class="hljs-comment">         * 在execute()被调用后首先执行</span><br><span class="hljs-comment">         * 一般用来在执行后台任务前对UI做一些标记</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPreExecute</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.onPreExecute();<br>            System.out.println(<span class="hljs-string">&quot;MyAsyncTask.onPreExecute&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 子线程中执行，执行一些耗时操作，关键方法</span><br><span class="hljs-comment">         * 在执行过程中可以调用publishProgress(Progress... values)来更新进度信息。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">doInBackground</span><span class="hljs-params">(String... params)</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;MyAsyncTask.doInBackground&quot;</span>);<br>            <span class="hljs-comment">//只是模拟了耗时操作</span><br>            <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    count++;<br>                    publishProgress((count % <span class="hljs-number">100</span>) * <span class="hljs-number">10</span>);<br>                    Thread.sleep(<span class="hljs-number">3000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// publishProgress((int) ((count / (float) total) * 100));</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;耗时操作执行完毕&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 主线程中执行</span><br><span class="hljs-comment">         * 在调用publishProgress(Progress... values)时，此方法被执行，直接将进度信息更新到UI组件中</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onProgressUpdate</span><span class="hljs-params">(Integer... values)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.onProgressUpdate(values);<br>            progressBar.setProgress(values[<span class="hljs-number">0</span>]);<br>            textView.setText(<span class="hljs-string">&quot;loading...&quot;</span> + values[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;%&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;MyAsyncTask.onProgressUpdate&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 在主线程中，当后台操作结束时，此方法将会被调用</span><br><span class="hljs-comment">         * 计算结果将做为参数传递到此方法中，直接将结果显示到UI组件上。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPostExecute</span><span class="hljs-params">(String aVoid)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.onPostExecute(aVoid);<br>            System.out.println(<span class="hljs-string">&quot;MyAsyncTask.onPostExecute aVoid=&quot;</span> + aVoid);<br>            textView.setText(aVoid);<br>        &#125;<br><br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 主线程中执行</span><br><span class="hljs-comment">         * 当异步任务取消后的，会回调该函数。在该方法内可以更新UI</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCancelled</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.onCancelled();<br>            System.out.println(<span class="hljs-string">&quot;MyAsyncTask.onCancelled&quot;</span>);<br>            progressBar.setProgress(<span class="hljs-number">0</span>);<br>            textView.setText(<span class="hljs-string">&quot;0&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCancelled</span><span class="hljs-params">(String s)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.onCancelled(s);<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>注意：doInBackground方法是在子线程中，所以，我们在这个方法里面执行耗时操作。同时，由于其返回结果会传递到onPostExecute方法中，而onPostExecute方法工作在UI线程，这样我们就在这个方法里面更新ui，达到了异步更新ui的目的。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p><a href="https://blog.csdn.net/da_caoyuan/article/details/52931007">【Android】快速切换到主线程更新UI的几种方法</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>STL：其他</title>
    <link href="/2020/11/22/C++/STL/STL%EF%BC%9A%E5%85%B6%E4%BB%96/"/>
    <url>/2020/11/22/C++/STL/STL%EF%BC%9A%E5%85%B6%E4%BB%96/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="一个万用的哈希函数"><a href="#一个万用的哈希函数" class="headerlink" title="一个万用的哈希函数"></a>一个万用的哈希函数</h2><ul><li><p>哈希函数设计不好，哈希冲突的概率会很大</p></li><li><p>哈希函数可以写成下面几种形式：（以<code>class Customer&#123;&#125;;</code>为例）</p><ul><li><p>仿函数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerHash</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">std::<span class="hljs-keyword">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Customer&amp; c)</span> <span class="hljs-keyword">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> ...<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//使用</span><br>unordered_set&lt;Customer,CustomerHash&gt; custset;<br></code></pre></div></td></tr></table></figure></li><li><p>函数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">customer_hash_func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Cunstomer&amp; c)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> ...<br>&#125;;<br><br><span class="hljs-comment">//使用，相较于仿函数会麻烦些</span><br><span class="hljs-function">unordered_set&lt;Customer,<span class="hljs-title">size_t</span><span class="hljs-params">(*)</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Customer&amp;)</span>&gt;</span><br><span class="hljs-function"><span class="hljs-title">custset</span><span class="hljs-params">(<span class="hljs-number">20</span>,customer_hash_func)</span></span>;<br></code></pre></div></td></tr></table></figure></li><li><p>偏特化版本</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std <span class="hljs-comment">//必須放在 std 內 </span><br>&#123;<br><span class="hljs-keyword">template</span>&lt;&gt; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hash</span>&lt;</span>MyString&gt; <span class="hljs-comment">//這是為了 unordered containers </span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">size_t</span> </span><br><span class="hljs-function"><span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MyString&amp; s)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> hash&lt;string&gt;()(<span class="hljs-built_in">string</span>(s.<span class="hljs-built_in">get</span>()));  &#125;  <br>    <span class="hljs-comment">//借用現有的 hash&lt;string&gt; (in ...\include\c++\bits\basic_string.h)</span><br>&#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>一个万用的哈希函数：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f4bffe2eac8d6a071babb44115bb418e-86291.png"  /></p></li></ul><h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><h2 id="type-traits"><a href="#type-traits" class="headerlink" title="type traits"></a>type traits</h2><h2 id="moveable"><a href="#moveable" class="headerlink" title="moveable"></a>moveable</h2><ul><li>差距的多少和内存中的碎片情况息息相关</li><li>move操作是浅拷贝，速度很快，但是很危险。最好是在原来的元素不使用的时候再进行move操作</li><li>对于临时对象，编译器会自动查找move版本的copy。前提是有定义move的方法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>138. 复制带随机指针的链表</title>
    <link href="/2020/11/21/LeetCode/138.%20%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/11/21/LeetCode/138.%20%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">本题链接</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* random;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">        random = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>       <br>        unordered_map&lt;Node*,<span class="hljs-keyword">int</span>&gt; hash;<span class="hljs-comment">//建立原节点与链表的位置关系</span><br>        Node* tmp = head;<br>        <span class="hljs-comment">//设置每个节点在链表的位置</span><br>        <span class="hljs-keyword">int</span> node_cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(tmp)&#123;<br>            hash[tmp] = node_cnt++;<br>            tmp = tmp-&gt;next;<br>        &#125;<br>        hash[<span class="hljs-number">0x0</span>] = node_cnt++;<span class="hljs-comment">//放入空节点</span><br><br>        vector&lt;Node*&gt; clone_vec;<span class="hljs-comment">//新的节点数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; node_cnt - <span class="hljs-number">1</span>;++i)<br>            clone_vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">0</span>));<br>        clone_vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">nullptr</span>);<span class="hljs-comment">//放入最后一个空节点</span><br><br>        tmp = head;<br>        <span class="hljs-comment">//根据原链表中的映射关系串接新链表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; clone_vec.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;++i)&#123;<span class="hljs-comment">//这里循环条件clone_vec.size() - 1是为了避开最后一个空节点</span><br>            clone_vec[i]-&gt;val = tmp-&gt;val;<br>            clone_vec[i]-&gt;next = clone_vec[hash[tmp-&gt;next]];<br>            clone_vec[i]-&gt;random = clone_vec[hash[tmp-&gt;random]];<br>            tmp = tmp-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> clone_vec[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于节点中有一个随机节点引用的存在，所以可以依靠节点在链表中的关系来构建哈希表，即哈希表的key为节点，value为节点在链表中的位置。因为数组和链表在逻辑上是一样的，所以只要在一个数组中建立所有的新节点，并且依照这个哈希表的映射关系，可以很快的得到随机节点在数组中的下标。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL：迭代器</title>
    <link href="/2020/11/18/C++/STL/STL%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2020/11/18/C++/STL/STL%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在标准库中，算法的形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> iterator&gt;</span><br><span class="hljs-function"><span class="hljs-title">Algorithm</span><span class="hljs-params">(iterator itr1,iterator itr2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> iterator,<span class="hljs-keyword">typename</span> Cmp&gt;</span><br><span class="hljs-function"><span class="hljs-title">Algorithm</span><span class="hljs-params">(iterator itr1,iterator itr2,Cmp comp)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="迭代器的作用"><a href="#迭代器的作用" class="headerlink" title="迭代器的作用"></a>迭代器的作用</h2><ul><li>在标准库中算法是个<strong>function template</strong>，而其他都是<strong>class template</strong><ul><li><strong>function template</strong>没有所谓特化，一般使用重载手法。</li></ul></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/fbd310e5be02fd856bced0cb146cd7c1-1025d.png"  /></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/275f8ff4e3f5caa867c4eb223ba08072-a54af.png"  /></p><ul><li><p>标准库中迭代器的分类不是靠枚举类型，而是靠对象</p><ul><li><p>迭代器的分类也影响到算法的效率</p></li><li><p>可根据继承关系来确定编译期模板参数的具体类型（泛化、特化）</p></li><li>算法内部可以根据具体对象<strong>强化</strong>算法。比如一个类中的成员变量不含指针类型，那么这个对象的Big-tree是不重要的，拷贝类型算法可以根据这个类的特点来强化算法。</li><li>在for循环中使用迭代器来终止循环会比较慢，而类似头尾指针相减的这种（和具体数比较）的方式会比较快</li></ul></li><li><p>由于<strong>output iterator</strong>(例ostream_itreator)是<strong>write-only</strong>，无法像<strong>forward iterator</strong>那般可以<strong>read</strong>，所以不能有类似<em>`result != </em>first`的动作，因此需设计出专属版本。</p></li><li><p>在算法的模板参数中，设计者只能用模板参数的名字来暗示使用者如何使用。</p></li></ul><h3 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9cf1875bf6956855508dcab5d3cdd2c9-8ae89.png"  /></p><ul><li>如果算法结构已经搭建好了，而对于不同的类型有不同的执行需求的话，可以考虑重载操作符。如下图：</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/22e5b15a7cbac739fa25ff314518f672-4f1f7.png"  /></p><p>还有一些特殊的迭代器适配器：<code>ostream_iterator</code>和<code>istream_iterator</code>。具体如下图：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9a6a41624ebdcfc3d59fba9f33bcb901-da2ce.png"  /></p><ul><li>ostream_iterator的迭代器会将值传到控制台</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/bc7706fc2c052df652c65f4f92cb3add-bd53c.png"  /></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/caecc79f3ad9b0120e62c2c2c4117971-c53c4.png"  /></p><ul><li>如果初始化<code>istream_iterator</code>没有参数，那么它就是一个<strong>end-of-stream-iterator</strong>，指向<strong>istream</strong>的最后位置，和容器的<code>end()</code>一个道理。</li><li>当一个含参的<code>istream_iterator</code>被创建时，它会立刻等待输入，即在<code>operator++</code>中阻塞。比如<code>istream_iterator&lt;int&gt; iit(cin);</code>。</li></ul><h2 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h2><p><strong>STL中的仿函数只为算法服务。</strong></p><p>STL中的仿函数分为三大类：</p><ul><li>算术类（x-y）</li><li>逻辑运算类（x&amp;&amp;y）</li><li>相对关系类（x&gt;y）</li></ul><h3 id="可适配条件"><a href="#可适配条件" class="headerlink" title="可适配条件"></a>可适配条件</h3><p>STL规定每个Adaptable Function 都应该挑选适当者继承，因为Function Adapter将会提问。不然<strong>无法融入STL库</strong>。虽然说不继承也能编译成功运行成功，但是一些STL的操作就用不了。比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Arg</span>,<span class="hljs-keyword">class</span> <span class="hljs-title">Result</span>&gt;</span><span class="hljs-comment">//一个操作数</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">unary_function</span>&#123;</span><br><span class="hljs-keyword">typedef</span> Arg argument_type;<br><span class="hljs-keyword">typedef</span> Result result_type;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Arg1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title">Arg2</span>,<span class="hljs-keyword">class</span> <span class="hljs-title">Result</span>&gt;</span><span class="hljs-comment">//两个操作数</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binary_function</span>&#123;</span><br><span class="hljs-keyword">typedef</span> Arg1 first_argument_type;<br><span class="hljs-keyword">typedef</span> Arg2 second_argument_type;<br><span class="hljs-keyword">typedef</span> Result result_type;<br>&#125;<br><br><span class="hljs-comment">//例子（STL中的）</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">less</span>:</span><span class="hljs-keyword">public</span> binary_function&lt;T,T,<span class="hljs-keyword">bool</span>&gt;&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; x,<span class="hljs-keyword">const</span> T&amp; y)</span><span class="hljs-keyword">const</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> x&lt;y;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h3><ul><li>编译器会自动进行类型推导</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a13bd6f63f4103cfe8ba3535abf18a4a-bc003.png" alt="函数适配器"  /></p><ul><li>新版本中，bind已实现规范用法。如下图：</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/605c3141d262b9a9c14dfa75cd440707-f1e39.png"  /></p><ul><li>其中，_1，_2，_3为占位符。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>83. 删除排序链表中的重复元素</title>
    <link href="/2020/11/16/LeetCode/83.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <url>/2020/11/16/LeetCode/83.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">本题链接</a></p><h2 id="迭代版"><a href="#迭代版" class="headerlink" title="迭代版"></a>迭代版</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <br>        ListNode* node = head;<br><br>        <span class="hljs-keyword">while</span>(node)&#123;<br><br>            <span class="hljs-keyword">if</span>(node-&gt;next)&#123;<br>                <span class="hljs-keyword">if</span>(node-&gt;val == node-&gt;next-&gt;val)&#123;<br>                    node-&gt;next = node-&gt;next-&gt;next;<span class="hljs-comment">//可能为空</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125; <br>            &#125;<br>            node = node-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>逐步删除，但是注意若有删除操作，指针不能移动，以避免跳过重复的元素。至于为什么没有delete掉链表中重复的节点，原因是我认为不应该在被调函数中删除调用者的内存。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1110. 删点成林</title>
    <link href="/2020/11/15/LeetCode/1110.%20%E5%88%A0%E7%82%B9%E6%88%90%E6%9E%97/"/>
    <url>/2020/11/15/LeetCode/1110.%20%E5%88%A0%E7%82%B9%E6%88%90%E6%9E%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/delete-nodes-and-return-forest/">本题链接</a></p><h2 id="迭代-哈希表"><a href="#迭代-哈希表" class="headerlink" title="迭代+哈希表"></a>迭代+哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">delNodes</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; to_delete)</span> </span>&#123;<br>        <br>        vector&lt;TreeNode*&gt; res;<span class="hljs-comment">//结果</span><br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">delete_set</span><span class="hljs-params">(to_delete.begin(),to_delete.end())</span></span>;<span class="hljs-comment">//要被删除的节点</span><br>        unordered_set&lt;TreeNode*&gt; unqinue_set;<span class="hljs-comment">//放入该哈希表的节点都不能作为根节点</span><br><br>        queue&lt;TreeNode*&gt; node_queue;<br>        TreeNode* cur_node;<br><br>        node_queue.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!node_queue.<span class="hljs-built_in">empty</span>())&#123;<br><br>            cur_node = node_queue.<span class="hljs-built_in">front</span>();node_queue.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">bool</span> self = delete_set.<span class="hljs-built_in">find</span>(cur_node-&gt;val) == delete_set.<span class="hljs-built_in">end</span>();<span class="hljs-comment">//自己是否被删除</span><br>            <br>            <span class="hljs-comment">//如果自己不会被删除,并且自己不属于其他节点</span><br>            <span class="hljs-keyword">if</span>(self &amp;&amp; unqinue_set.<span class="hljs-built_in">find</span>(cur_node) == unqinue_set.<span class="hljs-built_in">end</span>()) res.<span class="hljs-built_in">push_back</span>(cur_node);<br>            <br>            <span class="hljs-keyword">if</span>(cur_node-&gt;left)&#123;<span class="hljs-comment">//如果存在左孩子</span><br>                node_queue.<span class="hljs-built_in">push</span>(cur_node-&gt;left);<span class="hljs-comment">//将左孩子入队</span><br>                <span class="hljs-comment">//如果自己不用被删除,那么左孩子不能作为树的根节点</span><br>                <span class="hljs-keyword">if</span>(self) unqinue_set.<span class="hljs-built_in">insert</span>(cur_node-&gt;left);<br>                <span class="hljs-comment">//如果左孩子是被删除的节点,那么就把自己左孩子的引用删除掉</span><br>                <span class="hljs-keyword">if</span>(delete_set.<span class="hljs-built_in">find</span>(cur_node-&gt;left-&gt;val) != delete_set.<span class="hljs-built_in">end</span>()) cur_node-&gt;left = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(cur_node-&gt;right)&#123;<span class="hljs-comment">//如果存在右孩子</span><br>                node_queue.<span class="hljs-built_in">push</span>(cur_node-&gt;right);<span class="hljs-comment">//将右孩子入队</span><br>                <span class="hljs-comment">//如果自己不用被删除,那么右孩子不能作为树的根节点</span><br>                <span class="hljs-keyword">if</span>(self) unqinue_set.<span class="hljs-built_in">insert</span>(cur_node-&gt;right);<br>                <span class="hljs-comment">//如果右孩子是被删除的节点,那么就把自己右孩子的引用删除掉</span><br>                <span class="hljs-keyword">if</span>(delete_set.<span class="hljs-built_in">find</span>(cur_node-&gt;right-&gt;val) != delete_set.<span class="hljs-built_in">end</span>()) cur_node-&gt;right = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>节点的删除，因为有对左右孩子引用的存在，且是单向的，所以有两种情况：</p><ol><li>自己将会被删除。那么只要将左右孩子入队参加节点遍历即可。</li><li>若自己不会被删除，说明自己将成为一棵树的根节点。<ul><li>若左右孩子会被删除，那么先将自己的左右孩子入队参加节点遍历，以防止之后的节点丢失。然后再将自己对删除节点的引用设置为<code>nullptr</code></li><li>若左右孩子不会被删除，不仅要将自己的左右孩子入队参加节点遍历，而且还要防止自己的左右孩子作为一棵树的根节点</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>迭代</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20. 有效的括号</title>
    <link href="/2020/11/13/LeetCode/20.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <url>/2020/11/13/LeetCode/20.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">本题链接</a></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || s.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">char</span>&gt; hash&#123;&#123;<span class="hljs-string">&#x27;&#125;&#x27;</span>,<span class="hljs-string">&#x27;&#123;&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;)&#x27;</span>,<span class="hljs-string">&#x27;(&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;]&#x27;</span>,<span class="hljs-string">&#x27;[&#x27;</span>&#125;&#125;;<br>        stack&lt;<span class="hljs-keyword">char</span>&gt; bracket_stack;<br>        bracket_stack.<span class="hljs-built_in">push</span>(s[<span class="hljs-number">0</span>]);<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <br>            <span class="hljs-comment">//如果是左边的括号</span><br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;&#123;&#x27;</span> || s[i] == <span class="hljs-string">&#x27;(&#x27;</span> || s[i] == <span class="hljs-string">&#x27;[&#x27;</span>) bracket_stack.<span class="hljs-built_in">push</span>(s[i]);<span class="hljs-comment">//如果是左边的括号</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bracket_stack.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果是右边的括号且此时栈为空,说明没有左括号与之匹配</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bracket_stack.<span class="hljs-built_in">top</span>() == hash[s[i]]) bracket_stack.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//左括号和右括号匹配成功</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//左括号和右括号不匹配</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> bracket_stack.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据括号的匹配方式和对字符串的遍历，每次碰到左括号，就把左括号压栈。碰到右括号，就和栈顶的左括号匹配。</p><ul><li>时间复杂度$O(n)$</li><li>空间复杂度为栈所使用的$O(n)$空间和哈希表所使用的空间$O(m)$之和$O(n+m)$，哈希表所使用的空间取决于括号的数量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>225. 用队列实现栈</title>
    <link href="/2020/11/13/LeetCode/225.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <url>/2020/11/13/LeetCode/225.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">本题链接</a></p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyStack</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-comment">/** Push element x onto stack. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(reversal) q1.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-keyword">else</span> q2.<span class="hljs-built_in">push</span>(x);<br>        <br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> res;<br>        <span class="hljs-keyword">if</span>(reversal)&#123;<br><br>            <span class="hljs-keyword">while</span>(q1.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)&#123;<br>                q2.<span class="hljs-built_in">push</span>(q1.<span class="hljs-built_in">front</span>());<br>                q1.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            res = q1.<span class="hljs-built_in">front</span>();<br>            q1.<span class="hljs-built_in">pop</span>();<br><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br><br>            <span class="hljs-keyword">while</span>(q2.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)&#123;<br>                q1.<span class="hljs-built_in">push</span>(q2.<span class="hljs-built_in">front</span>());<br>                q2.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            res = q2.<span class="hljs-built_in">front</span>();<br>            q2.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        reversal = !reversal;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;   <br>    <br>    <span class="hljs-comment">/** Get the top element. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> reversal ? q1.<span class="hljs-built_in">back</span>() : q2.<span class="hljs-built_in">back</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns whether the stack is empty. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> q1.<span class="hljs-built_in">empty</span>() &amp;&amp; q2.<span class="hljs-built_in">empty</span>();<br>    &#125;<br><br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q1;<br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q2;<br>    <span class="hljs-keyword">bool</span> reversal = <span class="hljs-literal">true</span>;<span class="hljs-comment">//true表示q1为下次元素放入的队列,false表示q2...</span><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyStack* obj = new MyStack();</span><br><span class="hljs-comment"> * obj-&gt;push(x);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * bool param_4 = obj-&gt;empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义两个队列，每个队列都可能是下一次元素入栈存放元素的队列，所以使用一个标志位<code>reversal</code>来表示。当需要返回栈顶元素时，只需要将下一次存放元素的队列的值不断的放入另一个队列中，直到下一次存放元素的队列中只剩下一个元素，那么这个元素就是栈顶元素。这个标志位其实也不一定需要，只需要判断其中某个队列是否为空，也能判断下一次存放元素的队列是哪个。</p><p>实际上用一个队列也可以实现栈，就是每次取出栈顶元素的时候，需要让队列中除了最后一个入队的元素不动，其他元素再次出队然后入队，那么栈顶元素一定会出现在队头。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>560. 和为K的子数组</title>
    <link href="/2020/11/13/LeetCode/560.%20%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2020/11/13/LeetCode/560.%20%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">本题链接</a></p><h2 id="前缀和-哈希表"><a href="#前缀和-哈希表" class="headerlink" title="前缀和+哈希表"></a>前缀和+哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        set&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; unique_set;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">pand</span><span class="hljs-params">(nums.size() + <span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">//初始化前缀和 O(n)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; pand.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            pand[i] = nums[i<span class="hljs-number">-1</span>] + pand[i<span class="hljs-number">-1</span>];<br>        &#125;<br><br>        <span class="hljs-comment">//暴力遍历 O(n^2)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>;lo &lt; nums.<span class="hljs-built_in">size</span>();++lo)&#123;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> hi = lo;hi &lt; nums.<span class="hljs-built_in">size</span>();++hi)&#123;<br><br>                <span class="hljs-keyword">if</span>(pand[hi + <span class="hljs-number">1</span>] - pand[lo] == k)&#123;<br><br>                    <span class="hljs-keyword">if</span>(unique_set.<span class="hljs-built_in">find</span>(&#123;lo,hi&#125;)  == unique_set.<span class="hljs-built_in">end</span>())&#123;<br>                        unique_set.<span class="hljs-built_in">insert</span>(&#123;lo,hi&#125;);<br>                        ++res;<br><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>超时，时间主要消耗在亦步亦趋的遍历个个区间和计算，并且有重复区间会被计算</p><h2 id="前缀和-哈希表-1"><a href="#前缀和-哈希表-1" class="headerlink" title="前缀和+哈希表"></a>前缀和+哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; psum_map;<span class="hljs-comment">//第一个int表示前缀和,第二个int表示出现次数</span><br>        psum_map[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>,psum = <span class="hljs-number">0</span>;<br> <br>        <span class="hljs-comment">//初始化前缀和 O(n)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-comment">//累计前缀和</span><br>            psum += nums[i];<br>            res += psum_map[psum - k];<span class="hljs-comment">//当前psum_map[psum - k]存在，表示之前有一个前缀和等于k。若不存在,psum_map[psum - k]的值为0</span><br>            ++psum_map[psum];<span class="hljs-comment">//将当前前缀和保存</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>如果对应的k存在，那么表示某两个前缀和的差值为k。又因为题目要求是连续的子数组，所以在按顺序计算前缀和的同时，计算是否存在与当前前缀和差值为k的之前的前缀和即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>数组</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL：容器</title>
    <link href="/2020/11/13/C++/STL/STL%EF%BC%9A%E5%AE%B9%E5%99%A8/"/>
    <url>/2020/11/13/C++/STL/STL%EF%BC%9A%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="STL六大部件"><a href="#STL六大部件" class="headerlink" title="STL六大部件"></a>STL六大部件</h2><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8fc0bded58b81b6d96a516528d6f8c41-af505.png" alt="关系"></p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>$O(1)或O(c)$：常数时间</li><li>$O(n)$：线性时间</li><li>$O(log_2{n})$：次线性时间</li><li>$O(n^2)$：平方时间</li><li>$O(n^3)$：立方时间</li><li>$O(2^n)$：指数时间</li><li>$O(nlog_2{n})$：介于线性及二次方成长的中间之行为模式</li></ul><h3 id="前闭后开区间"><a href="#前闭后开区间" class="headerlink" title="前闭后开区间"></a>前闭后开区间</h3><ul><li><p><code>begin</code>：指向第一个元素</p></li><li><p><code>end</code>：指向最后一个元素的下一个元素</p></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8a140f7be2e3e0c027357761ef6dd359-02bfc.png" alt="前闭后开区间"></p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="结构与分类"><a href="#结构与分类" class="headerlink" title="结构与分类"></a>结构与分类</h4><ul><li>Sequence Containers：循序式容器<ul><li>Array：数组</li><li>Vector：向量</li><li>Deque：双向队列</li><li>List：链表（双向环状链表）</li><li>Forward-List：单向链表</li></ul></li><li>Associative Containers：关联式容器<ul><li>Set/Multiset（底层是红黑树）</li><li>Map/Multimap（底层是红黑树）</li></ul></li><li>Unordered Containers：不定序容器<ul><li>Unordered  Set/Multiset</li><li>Unordered  Map/Multimap</li></ul></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6cfe93a4229328bde82237f6743d260a-a9f92.png" alt="结构与分类"></p><h4 id="使用经验"><a href="#使用经验" class="headerlink" title="使用经验"></a>使用经验</h4><ul><li>array：使用二分查找<code>bsearch()</code>之前需要用<code>qsort()</code>进行排序。</li><li>vector：使用二分查找<code>bsearch()</code>之前需要用<code>sort()</code>进行排序。</li><li>获取容器起始地址用<code>Container.data()</code>。</li><li>所有的算法都是全局的模板函数</li><li>标准库提供的算法如果在容器里也有提供，那么就用容器里的，会更快</li></ul><h3 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h3><p>普通使用不建议用分配器，对于分配和释放内存使用new、delete、malloc、free即可。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/3581061f0c009b1c3a4c3c6b0e58bde5-3c6c8.png" alt="分配器"></p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="OOP-vs-GP"><a href="#OOP-vs-GP" class="headerlink" title="OOP vs. GP"></a>OOP vs. GP</h3><ul><li><p>OOP：企图将datas和methods关联在一起</p></li><li><p>GP：是将datas和methods分开来</p><ul><li>Containers和Algorithms团队可各自闭门造车，其间以Iterator沟通即可。</li><li>Algorithms通过Iterator确定操作范围，并通过Iterator取用Containers元素。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/015e3b07b02f49daaa00064df2cfea0e-2ace9.png" alt="GP"></p></li><li><p>所有Algorithms，其内最终涉及元素本身的操作，无非就是比大小。</p></li><li><p>新版本的STL都遵循了Handle-Body的设计原则。</p></li></ul><h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><h4 id="须知"><a href="#须知" class="headerlink" title="须知"></a>须知</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a260b867c46971748bffeffdc042c0f8-dc287.png" alt="须知"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f674b93cc84802c5a067657e0ed40dc3-7b5dd.png" alt="须知"></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/c11eea35e05921569966c536db823441-a2260.png" alt="例子"></p><h3 id="分配器-1"><a href="#分配器-1" class="headerlink" title="分配器"></a>分配器</h3><ul><li>无论怎样的内存分配操作，最后都是malloc。malloc视环境而定，比如windows\linux。</li><li>调用malloc分配的内存会比我们原本意图中所需要的内存会大。我们要的内存越小，这些额外的内存占比越大。</li><li>VC6+、BC++、GCC2.9的<code>allocator</code>只是以<code>::operator new</code>和<code>::operator delete</code>完成<code>allocate()</code>和<code>deallocate()</code>，没有任何特殊设计。</li></ul><h3 id="容器，结构与分类"><a href="#容器，结构与分类" class="headerlink" title="容器，结构与分类"></a>容器，结构与分类</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8021b54cb711137f50fcf6b5a1a2664c-a318b.png" alt="容器，结构与分类"></p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="成员结构"><a href="#成员结构" class="headerlink" title="成员结构"></a>成员结构</h4><p><strong>G2.9版本：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b715fde3789a0501fdb5d3c9ae46944c-69fb2.png" alt=""></p><ul><li>结构体<code>_list_node</code>的<code>void_pointer</code>实际上指的就是自己这个类型。</li></ul><p><strong>G4.9版本：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/c934a9c4da75f69acb4d7ba487d83d4e-25388.png" alt="G4.9版本"></p><ul><li>List实际上没有大小，因为它继承的父类大小为8，所以List的大小才为8。</li><li><code>end()</code>指向的是<code>_List_impl</code>中的<code>_M_node</code>，<code>begin()</code>指向的是<code>_M_node</code>中的<code>_M_next</code>。</li></ul><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p><strong>G2.9版本：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/73e37be9941993b4030ca243f7274845-a87d0.png" alt="迭代器"></p><ul><li>除了Array和Vector的迭代器，其他容器的迭代器必须是class类型。只有class类型才能设计出”聪明“的动作。</li></ul><p><strong>G4.9版本：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5f7c225801940e0704568741c2a875fa-be049.png" alt="G4.9版本："></p><h4 id="前自增与后自增"><a href="#前自增与后自增" class="headerlink" title="前自增与后自增"></a>前自增与后自增</h4><p><strong>G2.9版本：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/150855421610ef9fbb5b5d7fbe6e1f35-97b34.png" alt="迭代器"></p><ul><li><p><code>*this</code>中的<strong>*</strong>作用的是指针，而迭代器中重载的<code>operator*</code>作用的是迭代器对象。</p></li><li><p>后自增<code>self operator++(int)</code>中的<code>int</code>的作用就是为了给编译器看，符合编译器的语法而已。</p></li><li>后自增一共调用了两次拷贝构造。</li><li>至于后自增返回值、前自增返回引用，是因为参照<code>int</code>类型而设计的规范。（图左下角）</li></ul><h4 id="迭代器的设计原则"><a href="#迭代器的设计原则" class="headerlink" title="迭代器的设计原则"></a>迭代器的设计原则</h4><p><strong>迭代器是容器和算法的桥梁。</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/4d92bd2d2d7a87367f42df3a009d0941-1439b.png" alt="**迭代器是容器和算法的桥梁。**"></p><p>在算法执行的时候，它需要知道迭代器中的：</p><ul><li><strong>分类</strong>（<code>iterator_category()</code>）。它想要知道迭代器的移动性质，比如有些迭代器只能往前走，有些迭代器能往后走。这样它才能采取最佳的移动方式。（图中序号1）</li><li><strong>距离</strong>（<code>difference_type</code>）。就是两个迭代器指针间的距离，应该用什么<strong>type</strong>来表现。（图中序号2）</li><li><strong>类型</strong>（<code>value_type</code>）。即迭代器指向的容器的类型。（图中序号3）</li><li><strong>指针</strong>。从未在C++标准库中被使用。</li><li><strong>引用</strong>。从未在C++标准库中被使用。</li></ul><p>关于这五种的<strong>迭代器关联类型</strong>，具体看下图：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/04d6adf9cc6b1a8ab5807b0356085659-656e3.png" alt="迭代器关联类型"></p><p>以上的方式只有迭代器为class类型时，算法才能获取<strong>迭代器关联类型</strong>。因为标准库的算法是个函数模板，传迭代器和指针都可以，所以当迭代器是指针类型时，以上的处理方式是错误的。为了能应对不同类型的迭代器，算法可以使用萃取机制（<code>iterator_traits</code>），来获取所需信息。</p><h5 id="萃取机制"><a href="#萃取机制" class="headerlink" title="萃取机制"></a>萃取机制</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5255bf7b118a98cb8fbc6e777ffe8c3f-8ffdd.png" alt="萃取机制"></p><p>萃取机中使用了模板偏特化统一了接口：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/fa0e9abfd730734cd7ed183ac9aa76ae-15879.png" alt="萃取机中使用了模板偏特化"></p><p>注意<strong>const指针</strong>的传入，具体看上图右下角。</p><h6 id="萃取机例子"><a href="#萃取机例子" class="headerlink" title="萃取机例子"></a>萃取机例子</h6><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/299e805e56c24b3f39926f39d1fa84a8-1aa6f.png" alt="萃取机例子"></p><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><ul><li><p>TR1是C++过渡版本</p></li><li><p>创建Array时必须指定Array大小 </p></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/0d80554f3f92f6215d591158ced0157b-a0c91.png" alt="必须指定大小"></p><p>和Vector一样，Array的指针也是<code>native pointer</code>。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/43a93960338ab9efbfe3c104646baf22-14cd4.png" alt="Array"></p><h3 id="Forward-List"><a href="#Forward-List" class="headerlink" title="Forward-List"></a>Forward-List</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/cf072de20e41d9542dbd366698ea944e-0bdc6.png" alt="Forward-List"></p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><h4 id="向量结构"><a href="#向量结构" class="headerlink" title="向量结构"></a>向量结构</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f2f9fb58f888ffc9ab8f7f330a6b5bef-40eb7.png" alt="容器"></p><ul><li>向量为倍增式扩容。mscv下是1.5倍扩容,gnu c上是2倍扩容</li><li>向量用三个指针（迭代器）控制整个容器，其中<ul><li><code>start</code>：指向向量起始位置</li><li><code>finish</code>：元素最后一个元素的下一个地址</li><li><code>end_of_storage</code>：指向向量的最后一个位置</li></ul></li><li>向量的一些量化指标：<ul><li><code>size</code>：向量中的元素个数</li><li><code>capacity</code>：向量的最大容量</li></ul></li><li><code>vector</code>需要注意迭代器失效，失效的时机出现在<code>vector</code>在<code>push_back</code>一个新元素后，可能发生的倍增扩容。所以当扩容发生时，由于<code>vector</code>更换了存放位置，指向原来位置的迭代器会失效。比如在更换位置之前，使用某个变量存储了迭代器。</li></ul><p>G4.9版本：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7900b61baeb08459c96f5ec131302b85-85010.png" alt="G4.9版本："></p><h4 id="向量扩容示范"><a href="#向量扩容示范" class="headerlink" title="向量扩容示范"></a>向量扩容示范</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/c0640655601dcb97f9b843aa79b75bfd-a5b6d.png" alt="向量扩容示范"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/fa25a0efee12df1a7217ba4c3dc8fc3e-b3b72.png" alt="向量扩容示范"></p><h4 id="向量的迭代器"><a href="#向量的迭代器" class="headerlink" title="向量的迭代器"></a>向量的迭代器</h4><p>向量的迭代器实际上就是个指针，因为向量在物理空间上连续，可以随机访问，指针完全能应付。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/4357a1735241c0f4cf7b3337675d956f-6790e.png" alt="向量的迭代器"></p><p><strong>向量迭代器实质：使用适配器模式包装了<code>_Tp*</code>。</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9c0c3d525067662be0409430e3292dc5-320b0.png" alt="向量的迭代器"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/bc3b907f33ed8b45e0e48b829e291481-a2259.png" alt="向量迭代器"></p><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9de2d27b24e5bb52cd08544ed87c55cf-1f51e.png" alt="deque"></p><p>注意：控制中心的map是指向vector的，以后也是2倍增长。（map左右两边一般留有剩余空间，用于前后插入元素）。</p><p>参考：<a href="https://blog.csdn.net/JMW1407/article/details/106930972">C++ 标准模板库（STL）_序列式容器—— deque(模拟连续空间)（侯捷老师）</a></p><ol><li><p>map在初始化时会预留前后两个节点，并将start和finish迭代器指向map的存放数据的头尾区域。</p></li><li><p>在元素插入/删除时如果越过缓冲区，那么下一个/该缓冲区将会被申请/释放。</p></li><li>deque主要使用迭代器来模拟连续空间，迭代器的主要参数为：</li></ol><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// 保持与容器的联结</span><br>  T* cur;       <span class="hljs-comment">// 此迭代器所指之缓冲区中的现行元素</span><br>  T* first;     <span class="hljs-comment">// 此迭代器所指之缓冲区的头</span><br>  T* last;      <span class="hljs-comment">// 此迭代器所指之缓冲区的尾（含备用空间）</span><br>  map_pointer node; <span class="hljs-comment">//指向管控中心</span><br></code></pre></div></td></tr></table></figure><ol><li>保持连续性的关键在于源代码中的迭代器做了大量的操作符重载。</li><li>插入操作若不在两端，那么将会计算插入点离前后的距离谁比较短，取短的区域进行位移。</li></ol><h4 id="stack和queue"><a href="#stack和queue" class="headerlink" title="stack和queue"></a>stack和queue</h4><ul><li><p>stack内含了一个deque底层容器，所有事情交由deque去做：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">tmpplate&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>,<span class="hljs-keyword">class</span> <span class="hljs-title">Sequence</span> =</span> deque&lt;T&gt;&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">stack</span>&#123;</span><br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>stack和queue都可以选择list或deque作为底层容器，但是默认的deque速度会比较快。原因是list需要执行new操作，这种操作是普通语句的两百倍左右的时间，所以用deque。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">stack&lt;string,list&lt;string&gt;&gt; c;<br>queue&lt;string,list&lt;string&gt;&gt; c;<br></code></pre></div></td></tr></table></figure></li><li><p>stack和queue都不允许遍历，也不提供iterator。</p></li><li><p>stack可选择vector作为底层结构，但是queue不可选择vector作为底层结构（虽然编译器会通过，但是当queue使用pop行为时，编译器会报错，因为编译器只会做局部检查，就是你用了什么编译器就会检查什么）。</p></li><li><p>stack和queue都不可以选择set或map做底层结构（编译器也会通过，但是不能用，原因同上）。</p></li></ul><h3 id="RB-TREE"><a href="#RB-TREE" class="headerlink" title="RB-TREE"></a>RB-TREE</h3><ul><li>我们不应使用红黑树的迭代器改变元素值（因为元素有严谨的排列规则）。编程层面并未阻止此事。如此设计是正确的，因为红黑树即将为set和map服务（作为其底部支持），而map允许元素的data被改变，只有元素的key才是不可以被改变的。</li><li>红黑树提供遍历操作以及迭代器，按正常规则++遍历，便能获得排序状态。</li><li>红黑树提供两种插入操作：<code>insert_unique()</code>和<code>insert_equal()</code>。<ul><li>insert_unique()：key一定在树中独一无二。</li><li>insert_equal()：key一定在树中可以重复。</li></ul></li><li>节点value包含了key和data。key为标识，data是数据的组合。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/98f547d907431f6fe65ca78692299d05-f4830.png"  /></p><ul><li><p>红黑树的初始化所需要的参数中：</p><ul><li><p>keyofvalue：告诉红黑树，key要怎么拿。</p></li><li><p>compare：两个元素怎么比大小。</p></li></ul></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7dc9204bb800fef539f165e869569856-1059b.png" alt="红黑树的结构中"></p><ul><li><p>红黑树的结构中：</p><ul><li><p>node_count：节点数量</p></li><li><p>header：红黑树的头节点</p></li><li><p>key_compare：key的大小比较规则，应该是各function object。注意：仿函数的理论大小为0，因为它没有任何的数据。但是编译器会把它的大小变为1。因为编译器对于大小为0的class，编译出来的大小永远为1。</p></li></ul></li></ul><h4 id="set和multiset"><a href="#set和multiset" class="headerlink" title="set和multiset"></a>set和multiset</h4><ul><li>set和multiset都以红黑树作为底层结构，因此有元素自动排序的特性。排序的依据是key，而set和multiset的value和key二合一，也就是说value就是key。</li><li>set和multiset提供遍历操作以及迭代器，按照正常规则++遍历，便能获得排序状态。</li><li>我们无法使用set和multiset的迭代器改变元素值（因为key有严谨的排序规则）。set和multiset的迭代器是const类型的迭代器，所以无法改变元素内容。</li><li>set元素的key必须独一无二，因此它的<code>insert()</code>是红黑树的<code>insert_unique()</code>。</li><li>multiset的key可以重复，因此它的<code>insert()</code>是红黑树的<code>insert_equal()</code>。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/226616eb2ac701fa588539126010962a-e27d3.png" alt="set和multiset"></p><h4 id="map和multimap"><a href="#map和multimap" class="headerlink" title="map和multimap"></a>map和multimap</h4><ul><li>map/multimap以红黑树为底层结构。因此有元素自动排序特性。排序的依据是key。</li><li>map/multimap提供遍历操作及迭代器。按照正常规则++遍历，就能获得排序状态。</li><li>我们无法使用map/multimap的迭代器改变元素的key，但可以用它来改变元素的data。因此map/multimap内部自动将user指定的key type设为const，如此便能禁止user对元素的key赋值。即map构造RB-Tree的过程中，将<code>Key</code>和<code>T</code>组成了<code>pair&lt;const Key,T&gt;</code>传入了RB-Tree。</li><li>set元素的key必须独一无二，因此它的<code>insert()</code>是红黑树的<code>insert_unique()</code>。</li><li>multimap的key可以重复，因此它的<code>insert()</code>是红黑树的<code>insert_equal()</code>。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/09daead3d61f70f9e1c77fffde7773dc-57418.png" alt="map和multimap"></p><ul><li>multimap无法使用<code>[]</code>做插入，但是map可以。map的<code>operator[]</code>的操作是：如果找到该元素，便返回。若没有找到，就在map中合适的地方创建一个。<img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/2ef03b91b6d7aa257b7b8e3b027eefb8-7dd08.png" alt="map"></li></ul><h3 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/76b4b14163eb272f541bfe777f2532f8-c19db.png" style="zoom:50%;" /></p><ul><li>如果挂的链表太长的话，就要把它们打散，变成散列表。</li><li>如果元素个数比桶的个数还要多，就很危险。这种情况下就把桶增加两倍。然后重新将元素放进桶里。 <strong>所以桶的数量永远大于元素个数。</strong></li><li>翻倍(<strong>rehash</strong>)的原则是：原来的桶数量为53，那么就先翻倍成106，再找到离106最近最小的质数97。</li><li>桶中元素越少，查找和插入速度越快。所以有时候需要翻倍处理。</li><li>桶的数量已经写死了。<img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/269af63212907508fb2d06d575a17b06-ffe8e.png" style="zoom: 50%;" /></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/c3f6b7978fec1d67994c72d1affb0968-13938.png" style="zoom:50%;" /></p><ul><li><code>ExtractKey</code>：如何获取存储数据的Key，即仿函数</li><li><code>EqualKey</code>：如何比较两个Key相等，即仿函数</li><li><p>标准库提供了针对基本类型的hash函数，实质上就是把传入的东西再返回。而<code>char*</code>和<code>string</code>会通过一些换算形成哈希值。</p></li><li><p><strong>unordered</strong>容器的底层就是<strong>hashtable</strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>172. 阶乘后的零</title>
    <link href="/2020/11/09/LeetCode/172.%20%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/"/>
    <url>/2020/11/09/LeetCode/172.%20%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/">本题链接</a></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trailingZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> ? n / <span class="hljs-number">5</span> + <span class="hljs-built_in">trailingZeroes</span>(n / <span class="hljs-number">5</span>) : <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>阶乘后面的0是因为质因子2和质因子5相乘产生的，所以统计阶乘后面的0转化为统计质因子2和5的个数。又因为阶乘中质因子2的数量明显会比5多，所以统计5的个数就行。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1334. 阈值距离内邻居最少的城市</title>
    <link href="/2020/11/08/LeetCode/1334.%20%E9%98%88%E5%80%BC%E8%B7%9D%E7%A6%BB%E5%86%85%E9%82%BB%E5%B1%85%E6%9C%80%E5%B0%91%E7%9A%84%E5%9F%8E%E5%B8%82/"/>
    <url>/2020/11/08/LeetCode/1334.%20%E9%98%88%E5%80%BC%E8%B7%9D%E7%A6%BB%E5%86%85%E9%82%BB%E5%B1%85%E6%9C%80%E5%B0%91%E7%9A%84%E5%9F%8E%E5%B8%82/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/">本题链接</a></p><h2 id="最短路Floyd算法"><a href="#最短路Floyd算法" class="headerlink" title="最短路Floyd算法"></a>最短路Floyd算法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> src 0 <span class="hljs-comment">//源节点</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> tar 1 <span class="hljs-comment">//指向的节点</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dist 2 <span class="hljs-comment">//两个节点之间的距离</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTheCity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; edges, <span class="hljs-keyword">int</span> distanceThreshold)</span> </span>&#123;<br><br>        <span class="hljs-comment">//Floyd算法</span><br>        <span class="hljs-comment">//中转节点表path 初始化时将所有节点的中转节点设置为-1,因为数组的下标不可能为-1</span><br>        <span class="hljs-comment">//vector&lt;vector&lt;int&gt;&gt; path(n,vector&lt;int&gt;(n,-1));</span><br>        <span class="hljs-comment">//最短路径表A 初始化时将所有节点之间的距离设置为无穷大</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">A</span>(n,vector&lt;<span class="hljs-keyword">int</span>&gt;(n,INT_MAX));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; info : edges)&#123;<br>            <span class="hljs-comment">//设置连通节点之间的距离 (无向图) 若是有向图只需设置一个</span><br>            A[info[src]][info[tar]] = info[dist];<br>            A[info[tar]][info[src]] = info[dist];<br>        &#125;<br>        <span class="hljs-comment">//将自己到自己的距离设置为0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; A.<span class="hljs-built_in">size</span>();++i)&#123;<br>            A[i][i] = <span class="hljs-number">0</span>;<br>        &#125;   <br><br><br>        <span class="hljs-comment">//Floyd算法主流程</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;t &lt; n;++t)&#123;<span class="hljs-comment">//逐次的将每个节点当成中转点 </span><br>            <span class="hljs-comment">//对A表中的每个点进行遍历</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;row &lt; n;++row)&#123;<span class="hljs-comment">//逐行 row行表示点A</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>;col &lt; n;++col)&#123;<span class="hljs-comment">//逐列 col列表示点B</span><br>                    <span class="hljs-keyword">if</span>(A[row][t] == INT_MAX || A[t][col] == INT_MAX) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-comment">//如果点A经过中转点到点B的距离比点A直接到点B还小</span><br>                    <span class="hljs-keyword">if</span>(A[row][t] + A[t][col] &lt; A[row][col])&#123;<span class="hljs-comment">//(A[row][t] == INT_MAX || A[t][col] == INT_MAX) || </span><br>                        A[row][col] = A[row][t] + A[t][col];<span class="hljs-comment">//更新最小的距离</span><br>                        <span class="hljs-comment">//path[row][col] = t;//并更新点A到B的中转点</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">//以下为题目要求</span><br><br>        <span class="hljs-comment">//遍历A表 保存所有点A到点B的距离小于等于阈值</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">res</span>(n,vector&lt;<span class="hljs-keyword">int</span>&gt;());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;row &lt; n;++row)&#123;<span class="hljs-comment">//逐行 row行表示点A</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>;col &lt; n;++col)&#123;<span class="hljs-comment">//逐列 col列表示点B</span><br>                <span class="hljs-keyword">if</span>(A[row][col] &lt;= distanceThreshold)&#123;<br>                    res[row].<span class="hljs-built_in">emplace_back</span>(col);<span class="hljs-comment">//加入结果</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//找到最少城市的最小点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; res.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">if</span>(res[i].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(res[i].<span class="hljs-built_in">size</span>() &lt; res[ret].<span class="hljs-built_in">size</span>())&#123;<span class="hljs-comment">//优先考虑城市数量,城市数量小的优先</span><br>                ret = i;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res[i].<span class="hljs-built_in">size</span>() == res[ret].<span class="hljs-built_in">size</span>())&#123;<span class="hljs-comment">//城市数量相等时</span><br>                ret = i &gt; ret ? i : ret ;<span class="hljs-comment">//编号最大的优先</span><br>            &#125;<br>        &#125;<br>       <br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用最短路Floyd算法</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路Floyd算法</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>230. 二叉搜索树中第K小的元素</title>
    <link href="/2020/11/08/LeetCode/230.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <url>/2020/11/08/LeetCode/230.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">本题链接</a></p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>        stack&lt;TreeNode*&gt; node_stack;<br><br>        TreeNode* cur_node = root;<br>        <span class="hljs-keyword">while</span>(!node_stack.<span class="hljs-built_in">empty</span>() || cur_node)&#123;<br><br>            <span class="hljs-keyword">if</span>(cur_node)&#123;<span class="hljs-comment">//沿着左侧链下行</span><br><br>                node_stack.<span class="hljs-built_in">push</span>(cur_node);<br>                cur_node = cur_node-&gt;left;<br><br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//当前左侧链已经到头</span><br><br>                cur_node = node_stack.<span class="hljs-built_in">top</span>();node_stack.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//取出栈顶的节点</span><br><br>                <span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> cur_node-&gt;val;<span class="hljs-comment">//若此时k为1,就说明该节点是第k小的元素</span><br>                <span class="hljs-keyword">else</span>&#123;<br>                    --k;<br>                    cur_node = cur_node-&gt;right;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二叉搜索树的中序遍历序列是单调递增的，所以二叉搜索树的第k小元素就是中序遍历中第k个元素。</p><ul><li>时间复杂度$O(h+k)$，h为树高，需要先向下到达叶子节点（左侧链）​​</li><li>空间复杂度$O(h+k)$​​</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>中序遍历</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>455. 分发饼干</title>
    <link href="/2020/11/06/LeetCode/455.%20%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/"/>
    <url>/2020/11/06/LeetCode/455.%20%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/assign-cookies/">本题链接</a></p><h1 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a>455. 分发饼干</h1><h2 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; g, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; s)</span> </span>&#123;<br><br>        <span class="hljs-comment">//预处理</span><br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">//排序</span><br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(),g.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">int</span>&amp; x,<span class="hljs-keyword">int</span>&amp; y)&#123; <span class="hljs-keyword">return</span> x &lt; y;&#125;);<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">int</span>&amp; x,<span class="hljs-keyword">int</span>&amp; y)&#123; <span class="hljs-keyword">return</span> x &lt; y;&#125;);<br><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> loop_s = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">//让胃口最小的孩子先获得</span><br>        <span class="hljs-keyword">while</span>(loop_s &lt; s.<span class="hljs-built_in">size</span>())&#123;<br>            <br>            <span class="hljs-keyword">if</span>(s[loop_s] &gt;= g[count] &amp;&amp; ++count &gt;= g.<span class="hljs-built_in">size</span>())<br>                <span class="hljs-keyword">break</span>;<br><br>            ++loop_s;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> count;  <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据贪心策略，让胃口最小的孩子去吃最小的饼干，让后面的孩子有更大的几率获得大饼干。不过首先需要先排序。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>509. 斐波那契数</title>
    <link href="/2020/11/04/LeetCode/509.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <url>/2020/11/04/LeetCode/509.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/fibonacci-number/">本题链接</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br><br>        <span class="hljs-keyword">int</span> p1 = <span class="hljs-number">0</span>,p2 = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; n;++i)&#123;<br>            p2 = p1 + p2;<br>            p1 = p2 - p1;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p2;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>只要根据斐波那契数列的性质推出状态转移方程</p><script type="math/tex; mode=display">dp[i]=dp[i-1]+dp[i-2]</script>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>144. 二叉树的前序遍历</title>
    <link href="/2020/11/02/LeetCode/144.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2020/11/02/LeetCode/144.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">本题链接</a></p><h2 id="栈-迭代1"><a href="#栈-迭代1" class="headerlink" title="栈+迭代1"></a>栈+迭代1</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; node_stack;<br>        TreeNode* cur_node;<br><br>        node_stack.<span class="hljs-built_in">push</span>(root);<span class="hljs-comment">//将第一个节点压栈</span><br>        <span class="hljs-keyword">while</span>(!node_stack.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-comment">//获得当前节点，并将当前节点出栈</span><br>            cur_node = node_stack.<span class="hljs-built_in">top</span>();node_stack.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">//将结果保存到数组中</span><br>            res.<span class="hljs-built_in">push_back</span>(cur_node-&gt;val);<br>            <span class="hljs-comment">//根据栈先进后出的特性，先将右孩子入栈</span><br>            <span class="hljs-keyword">if</span>(cur_node-&gt;right) node_stack.<span class="hljs-built_in">push</span>(cur_node-&gt;right);<br>            <span class="hljs-keyword">if</span>(cur_node-&gt;left) node_stack.<span class="hljs-built_in">push</span>(cur_node-&gt;left);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>只要对<strong>局部的子树</strong>进行前序遍历，再借由栈的特性进行入栈出栈即可。</p><h2 id="栈-迭代2"><a href="#栈-迭代2" class="headerlink" title="栈+迭代2"></a>栈+迭代2</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; node_stack;<br>        TreeNode* cur_node = root;<br>        <br>        <span class="hljs-keyword">while</span>(!node_stack.<span class="hljs-built_in">empty</span>() || cur_node)&#123;<br>            <br>            <span class="hljs-keyword">if</span>(cur_node)&#123;<span class="hljs-comment">//如果当前节点存在</span><br>                <br>                res.<span class="hljs-built_in">push_back</span>(cur_node-&gt;val);<span class="hljs-comment">//保存当前节点的值</span><br>                node_stack.<span class="hljs-built_in">push</span>(cur_node-&gt;right);<span class="hljs-comment">//将右孩子入栈</span><br>                cur_node = cur_node-&gt;left;<span class="hljs-comment">//控制权交给右孩子</span><br><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                cur_node = node_stack.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//将当前节点更换成栈顶节点</span><br>                node_stack.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//将栈顶节点出栈</span><br>            &#125;<br>            <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>按照前序遍历的次序，每次将控制权交给左孩子，然后让右孩子入栈。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-built_in">preOrder</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br><br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<span class="hljs-comment">//优先处理自己</span><br>        <span class="hljs-built_in">preOrder</span>(root-&gt;left);<br>        <span class="hljs-built_in">preOrder</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>递归直观简单，只需要按照前序遍历的顺序优先处理自己即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代</tag>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
      <tag>栈</tag>
      
      <tag>前序遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>696. 计数二进制子串</title>
    <link href="/2020/10/26/LeetCode/696.%20%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/"/>
    <url>/2020/10/26/LeetCode/696.%20%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/count-binary-substrings/">本题链接</a></p><h2 id="双指针-中心扩展法"><a href="#双指针-中心扩展法" class="headerlink" title="双指针+中心扩展法"></a>双指针+中心扩展法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countBinarySubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; s.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            <span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>] == s[i]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果相等就跳过</span><br>            <br>            <span class="hljs-keyword">int</span> left = i<span class="hljs-number">-1</span>,right = i;<span class="hljs-comment">//双指针</span><br>            <span class="hljs-keyword">while</span>(<span class="hljs-number">0</span> &lt;= left &amp;&amp; right &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[left] == s[i<span class="hljs-number">-1</span>] &amp;&amp; s[right] == s[i])&#123;<br>                ++res;<br>                --left;<br>                ++right;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每当遍历到一个元素与它前面的元素不相等的时候，就以这两个元素为中心向左右拓展并计数。</p><h2 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countBinarySubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> arr[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">char</span> tmp = s[<span class="hljs-number">0</span>];<span class="hljs-comment">//对比字符初始化</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            <span class="hljs-keyword">if</span>(s[i] == tmp) ++arr[<span class="hljs-number">1</span>];<span class="hljs-comment">//如果字符相等,就计数</span><br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//否则</span><br>                tmp = s[i];<span class="hljs-comment">//改变对比字符</span><br>                res += <span class="hljs-built_in">min</span>(arr[<span class="hljs-number">0</span>],arr[<span class="hljs-number">1</span>]);<span class="hljs-comment">//选择最小的累加</span><br>                arr[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">1</span>];<span class="hljs-comment">//将此次计数往前置</span><br>                arr[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//设置新的计数值</span><br>            &#125;<br><br>        &#125;<br><br>        res += <span class="hljs-built_in">min</span>(arr[<span class="hljs-number">0</span>],arr[<span class="hljs-number">1</span>]);<span class="hljs-comment">//计算最后一次比较次数</span><br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><blockquote><p>先统计连续的0和1分别有多少个，如：111100011000，得到4323；在4323中的任意相邻两个数字，取小的一个加起来，就是3+2+2 = 7.</p></blockquote><p>来自：<a href="https://leetcode-cn.com/problems/count-binary-substrings/comments/55920">https://leetcode-cn.com/problems/count-binary-substrings/comments/55920</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
      <tag>奇技淫巧</tag>
      
      <tag>中心扩展法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>139. 单词拆分</title>
    <link href="/2020/10/23/LeetCode/139.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
    <url>/2020/10/23/LeetCode/139.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/word-break/">本题链接</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;<br><br>        <span class="hljs-comment">//使用哈希表</span><br>        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">hash</span><span class="hljs-params">(wordDict.begin(),wordDict.end())</span></span>;<span class="hljs-comment">//将单词存入哈希表</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size() + <span class="hljs-number">1</span>,<span class="hljs-literal">false</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= s.<span class="hljs-built_in">size</span>();++i)&#123;<span class="hljs-comment">//遍历整个字符串</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; i;++j)&#123;<span class="hljs-comment">//分割点前进</span><br>                <span class="hljs-keyword">if</span>(dp[j] &amp;&amp; hash.<span class="hljs-built_in">find</span>(s.<span class="hljs-built_in">substr</span>(j,i-j)) != hash.<span class="hljs-built_in">end</span>())&#123;<br>                    dp[i] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> dp[dp.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>具体见<a href="https://leetcode-cn.com/problems/word-break/solution/dan-ci-chai-fen-by-leetcode-solution/">官方解析</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>344. 反转字符串</title>
    <link href="/2020/10/23/LeetCode/344.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2020/10/23/LeetCode/344.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/reverse-string/">本题链接</a></p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">char</span>&gt;&amp; s)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> r = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(r &gt;= l)&#123;<br>            <span class="hljs-built_in">swap</span>(s[l++],s[r--]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用双指针，每次迭代一前一后往中间靠拢并交换。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>461. 汉明距离</title>
    <link href="/2020/10/20/LeetCode/461.%20%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/"/>
    <url>/2020/10/20/LeetCode/461.%20%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/hamming-distance/">本题链接</a></p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingDistance</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> dis = x^y;<span class="hljs-comment">//异或</span><br><br>        <span class="hljs-keyword">while</span>(dis)&#123;<span class="hljs-comment">//计算1出现的次数</span><br>            dis &amp;= (dis<span class="hljs-number">-1</span>);<br>            ++cnt;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对x和y进行异或操作，得到的dis中1出现的次数就是汉明距离。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>504. 七进制数</title>
    <link href="/2020/10/20/LeetCode/504.%20%E4%B8%83%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
    <url>/2020/10/20/LeetCode/504.%20%E4%B8%83%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/base-7/">本题链接</a></p><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">convertToBase7</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br><br>        <span class="hljs-keyword">int</span> dig = <span class="hljs-built_in">abs</span>(num);<br>        string res;<br><br>        <span class="hljs-keyword">while</span>(dig != <span class="hljs-number">0</span>)&#123;<br>            res = <span class="hljs-built_in">to_string</span>(dig % <span class="hljs-number">7</span>) + res;<br>            dig /= <span class="hljs-number">7</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> num &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;-&#x27;</span> + res : res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和二进制的转换过程一样，不断求余即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>进制转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51. N 皇后</title>
    <link href="/2020/10/18/LeetCode/51.%20N%20%E7%9A%87%E5%90%8E/"/>
    <url>/2020/10/18/LeetCode/51.%20N%20%E7%9A%87%E5%90%8E/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/n-queens/">本题链接</a></p><h2 id="回溯法-栈"><a href="#回溯法-栈" class="headerlink" title="回溯法+栈"></a>回溯法+栈</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">int</span> rac;<span class="hljs-comment">//n</span><br>    stack&lt;vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&gt; cb_stack;<span class="hljs-comment">//栈顶保存着当前合法的棋盘状态. 二维数组状态:0:安全地带 1:攻击范围 2:已有皇后</span><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; cb_tmp;<span class="hljs-comment">//临时棋盘</span><br>    <span class="hljs-keyword">int</span> dirc[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<span class="hljs-comment">//方向</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; queen_pos&#123;vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">9</span>,<span class="hljs-number">-1</span>)&#125;; <span class="hljs-comment">//第n个皇后所处的第n个位置</span><br>    vector&lt;vector&lt;string&gt;&gt; res;<span class="hljs-comment">//最终结果</span><br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-keyword">int</span> n) &#123;<br><br>        <span class="hljs-comment">//初始化:空间换时间</span><br>        rac = n;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; tmp_vec = vector&lt;<span class="hljs-keyword">int</span>&gt;(n,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;n;++i)&#123;<br>            cb_tmp.<span class="hljs-built_in">push_back</span>(tmp_vec);<br>        &#125;<br>        cb_stack.<span class="hljs-built_in">push</span>(cb_tmp);<br>        <span class="hljs-keyword">int</span> loop_col = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> loop_row = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">//逐行逐列遍历</span><br>        <span class="hljs-keyword">for</span>(;loop_row &lt; n;)&#123;<br><br>            <span class="hljs-keyword">int</span> cur_queen_pos = loop_row;<br><br>            <span class="hljs-keyword">for</span>(;loop_col &lt; n;++loop_col)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">setAttack</span>(&#123;loop_row,loop_col&#125;))&#123;<span class="hljs-comment">//如果皇后能待在该处,则移动到下一行</span><br>                    loop_col = <span class="hljs-number">0</span>;<br>                    ++loop_row;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果不行就遍历列,直到一个合适的位置</span><br>            &#125;<br><br>            <span class="hljs-comment">//如果当前遍历完,该行皇后还是找不到合适的位置,那么就更改上一行皇后,或是已经满足一种情况</span><br>            <span class="hljs-keyword">if</span>(queen_pos[cur_queen_pos] == <span class="hljs-number">-1</span> || cb_stack.<span class="hljs-built_in">size</span>() == n + <span class="hljs-number">1</span>)&#123;<br><br>                <span class="hljs-keyword">if</span>(queen_pos[cur_queen_pos] != <span class="hljs-number">-1</span>) <span class="hljs-built_in">saveRes</span>();<span class="hljs-comment">//保存棋盘到结果里</span><br>                <span class="hljs-keyword">if</span>(cur_queen_pos == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//如果第一位皇后遍历结束</span><br>                <span class="hljs-comment">//将上一个皇后的最后状态取出</span><br>                loop_col = queen_pos[--loop_row] + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//将上一个皇后的状态设置为-1</span><br>                queen_pos[loop_row] = <span class="hljs-number">-1</span>;<br>                <span class="hljs-comment">//将上一个皇后的合法棋盘撤销</span><br>                cb_stack.<span class="hljs-built_in">pop</span>();<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">//设置皇后攻击状态 失败情况:攻击到其他皇后</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">setAttack</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; queen)</span></span>&#123;<br><br>        <span class="hljs-comment">//如果该皇后处于其他皇后的攻击范围</span><br>        <span class="hljs-keyword">if</span>(((vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;)cb_stack.<span class="hljs-built_in">top</span>())[queen.first][queen.second] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        cb_tmp = cb_stack.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//备份一份当前的合法棋盘</span><br>        pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; point_tmp;<span class="hljs-comment">//创建一个点备份</span><br>        cb_tmp[queen.first][queen.second] = <span class="hljs-number">2</span>;<span class="hljs-comment">//设置皇后自身</span><br>        <span class="hljs-comment">//设置皇后的八个方向</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> dir = <span class="hljs-number">0</span>;dir &lt; <span class="hljs-number">8</span>;++dir)&#123;<br>            point_tmp = queen;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                point_tmp.first+=dirc[dir];<span class="hljs-comment">//根据方向位移点</span><br>                point_tmp.second+=dirc[dir+<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isLegal</span>(point_tmp)) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//如果不合法,退出</span><br>                <span class="hljs-keyword">if</span>(cb_tmp[point_tmp.first][point_tmp.second] == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果攻击到其他皇后</span><br>                cb_tmp[point_tmp.first][point_tmp.second] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>       cb_stack.<span class="hljs-built_in">push</span>(cb_tmp);<span class="hljs-comment">//保存当前的合法棋盘</span><br>       queen_pos[queen.first] = queen.second;<span class="hljs-comment">//保存皇后的位置</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>    <span class="hljs-comment">//判断点是否合法</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isLegal</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; p)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= p.first &amp;&amp; p.first &lt; rac)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= p.second &amp;&amp; p.second &lt; rac)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//保存结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveRes</span><span class="hljs-params">()</span></span>&#123;<br><br>        vector&lt;string&gt; tmp_res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; vec:(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;)cb_stack.<span class="hljs-built_in">top</span>())&#123;<br>            string s;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; rac;++i)&#123;<br>                <span class="hljs-keyword">if</span>(vec[i] == <span class="hljs-number">2</span>) s.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;Q&#x27;</span>);<br>                <span class="hljs-keyword">else</span> s.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br>            &#125;<br>            tmp_res.<span class="hljs-built_in">push_back</span>(s);<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(tmp_res);<br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>回溯法的重点就是要保存之前的某个状态。后面想到用栈来保存每次合法的棋盘状态，然后根据条件来对之前的合法棋盘进行重新的操作。该方法虽然合理且通俗易懂。但是空间和时间的效率都十分低下……</p><h2 id="回溯法-递归"><a href="#回溯法-递归" class="headerlink" title="回溯法+递归"></a>回溯法+递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">int</span> rac;<span class="hljs-comment">//n</span><br>    <span class="hljs-keyword">int</span> dirc[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<span class="hljs-comment">//对角方向</span><br>    vector&lt;vector&lt;string&gt;&gt; res;<br>    <br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-keyword">int</span> n) &#123;<br><br>        rac = n; <br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">cb</span><span class="hljs-params">(n, string(n, <span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br>        <span class="hljs-built_in">refreshCB</span>(<span class="hljs-number">0</span>,cb);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">refreshCB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row,vector&lt;string&gt;&amp; cb)</span></span>&#123;<br><br>        <span class="hljs-comment">//保存结果</span><br>        <span class="hljs-keyword">if</span>(row == rac)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(cb);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; rac; ++col)&#123;<br><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">setAttack</span>(&#123;row,col&#125;,cb))&#123;<span class="hljs-comment">//如果成功放置皇后</span><br>                <span class="hljs-built_in">refreshCB</span>(row + <span class="hljs-number">1</span>,cb);<span class="hljs-comment">//交给下一行</span><br>            &#125;<br>            cb[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//设置皇后攻击状态 失败情况:攻击到其他皇后</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">setAttack</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; queen,vector&lt;string&gt;&amp; cb)</span></span>&#123;<br><br>        <span class="hljs-comment">//判断列方向</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> loop_rac = <span class="hljs-number">0</span>;loop_rac &lt; queen.first;++loop_rac)&#123;<br>            <span class="hljs-keyword">if</span>(cb[loop_rac][queen.second] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果攻击到其他皇后</span><br>        &#125;<br>        <span class="hljs-comment">//判断对角方向</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> dir = <span class="hljs-number">0</span>;dir &lt; <span class="hljs-number">4</span>;++dir)&#123;<br>            pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; point_tmp = queen;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                point_tmp.first+=dirc[dir];<span class="hljs-comment">//根据方向位移点</span><br>                point_tmp.second+=dirc[dir+<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isLegal</span>(point_tmp)) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//如果不合法,退出</span><br>                <span class="hljs-keyword">if</span>(cb[point_tmp.first][point_tmp.second] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果攻击到其他皇后</span><br>            &#125;<br>        &#125;<br>       cb[queen.first][queen.second] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//判断点是否合法</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isLegal</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; p)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= p.first &amp;&amp; p.first &lt; rac)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= p.second &amp;&amp; p.second &lt; rac)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>在回溯法+栈的版本上进行了优化：</p><ul><li>剪枝操作。只要判断当前皇后是否会攻击到其他皇后就行，无需考虑其他皇后攻击当前皇后的情况。因为两者是等价的</li><li>利用内存栈来代替显式的数据栈</li><li>不再考虑皇后同一行的冲突问题，而皇后同一列的只向上考虑</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>栈</tag>
      
      <tag>回溯法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>108. 将有序数组转换为二叉搜索树</title>
    <link href="/2020/10/17/LeetCode/108.%20%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2020/10/17/LeetCode/108.%20%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">本题链接</a></p><h2 id="递归-中序遍历"><a href="#递归-中序遍历" class="headerlink" title="递归+中序遍历"></a>递归+中序遍历</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">addNodeByInOrder</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">addNodeByInOrder</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; lo,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; hi)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(lo &gt; hi) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//如果到达边界</span><br><br>        <span class="hljs-comment">//每次取[lo,hi]的中点</span><br>        <span class="hljs-keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="hljs-number">1</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br><br>        root-&gt;left = <span class="hljs-built_in">addNodeByInOrder</span>(nums,lo,mid<span class="hljs-number">-1</span>);<span class="hljs-comment">//添加左孩子</span><br>        root-&gt;right = <span class="hljs-built_in">addNodeByInOrder</span>(nums,mid+<span class="hljs-number">1</span>,hi);<span class="hljs-comment">//添加右孩子</span><br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>其实中序遍历序列就是对树的投影，题目给的数组不仅有序，且要求的是高度平衡的二叉树。所以取子树根节点的时候，尽量让这个节点左右两侧的节点数量相等，以满足高度平衡二叉树的要求。所以根节点应该在一段连续的左闭右闭区间内选择中点，让左侧的元素作为左子树，让右侧的元素作为右子树。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
      <tag>中序遍历</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>456. 132 模式</title>
    <link href="/2020/10/17/LeetCode/456.%20132%20%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/10/17/LeetCode/456.%20132%20%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/132-pattern/">本题链接</a></p><h2 id="使用单调栈"><a href="#使用单调栈" class="headerlink" title="使用单调栈"></a>使用单调栈</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">find132pattern</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        stack&lt;<span class="hljs-keyword">int</span>&gt; tmp_stack;<br>        <span class="hljs-keyword">int</span> last = INT_MIN;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i &gt;= <span class="hljs-number">0</span>;--i)&#123;<br>            <br>            <span class="hljs-keyword">if</span>(tmp_stack.<span class="hljs-built_in">empty</span>()) tmp_stack.<span class="hljs-built_in">push</span>(nums[i]);<span class="hljs-comment">//如果栈空,将元素入栈</span><br>            <span class="hljs-keyword">else</span>&#123;<br><br>                <span class="hljs-keyword">if</span>(tmp_stack.<span class="hljs-built_in">top</span>() &gt; nums[i])&#123;<span class="hljs-comment">//如果栈顶元素大于nums[i]</span><br>                    tmp_stack.<span class="hljs-built_in">push</span>(nums[i]);<span class="hljs-comment">//将元素入栈</span><br>                &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果栈顶元素小于nums[i]</span><br>                    <span class="hljs-keyword">while</span>(!tmp_stack.<span class="hljs-built_in">empty</span>() &amp;&amp; tmp_stack.<span class="hljs-built_in">top</span>() &lt; nums[i])&#123;<br>                        <span class="hljs-keyword">if</span>(tmp_stack.<span class="hljs-built_in">top</span>() &lt; last) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                        last = tmp_stack.<span class="hljs-built_in">top</span>();<br>                        tmp_stack.<span class="hljs-built_in">pop</span>();<br>                    &#125;<span class="hljs-comment">//出栈,直到栈顶元素大于nums[i]或栈变空</span><br>                    tmp_stack.<span class="hljs-built_in">push</span>(nums[i]);<br>                &#125;  <br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> !tmp_stack.<span class="hljs-built_in">empty</span>() &amp;&amp; tmp_stack.<span class="hljs-built_in">top</span>() &lt; last ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>栈混洗是不可能出现<strong>132</strong>这种情况，所以可以模拟栈混洗的反向行为。假设原本的栈为单调栈，使用<code>last</code>这个值代表单调栈的栈顶元素，在单调栈中，从栈顶元素往栈底的方向看去，每个元素都比它下面的元素要大，所以只要当<code>tmp_stack</code>这个栈的栈顶元素小于<code>last</code>的值，就可以确定<strong>132</strong>情况的出现。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>单调栈</tag>
      
      <tag>栈混洗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>104. 二叉树的最大深度</title>
    <link href="/2020/10/11/LeetCode/104.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <url>/2020/10/11/LeetCode/104.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">本题链接</a></p><h2 id="递归-dfs"><a href="#递归-dfs" class="headerlink" title="递归+dfs"></a>递归+dfs</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>       <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left),<span class="hljs-built_in">maxDepth</span>(root-&gt;right));<br><br>       <span class="hljs-comment">//return root ? 1 + max(maxDepth(root-&gt;left),maxDepth(root-&gt;right)) : 0;</span><br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在递归函数里取左右子树的最大深度并加上自己</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>208. 实现 Trie (前缀树)</title>
    <link href="/2020/10/11/LeetCode/208.%20%E5%AE%9E%E7%8E%B0%20Trie%20(%E5%89%8D%E7%BC%80%E6%A0%91)/"/>
    <url>/2020/10/11/LeetCode/208.%20%E5%AE%9E%E7%8E%B0%20Trie%20(%E5%89%8D%E7%BC%80%E6%A0%91)/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">本题链接</a></p><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR_COUNT 26</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span>&#123;</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TrieNode</span>&#123;</span><br><br>        TrieNode* childNode[CHAR_COUNT];<br>        <span class="hljs-keyword">bool</span> isVal;<br><br>        <span class="hljs-built_in">TrieNode</span>():<span class="hljs-built_in">isVal</span>(<span class="hljs-literal">false</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; CHAR_COUNT;++i)<br>                childNode[i] = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;;<br><br>    TrieNode* root;<br><br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">Trie</span>():<span class="hljs-built_in">root</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>())&#123;&#125;<br><br>    <span class="hljs-comment">//将新单词插入字典树</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp; word)</span> </span>&#123;<br><br>        TrieNode* tmp = root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>&amp; c : word)&#123;<br>            <span class="hljs-comment">//寻找字典树中是否存在&#x27;*c&#x27;前缀</span><br>            <span class="hljs-keyword">if</span>(!tmp-&gt;childNode[c-<span class="hljs-string">&#x27;a&#x27;</span>])&#123;<span class="hljs-comment">//若没有</span><br>                tmp-&gt;childNode[c-<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<span class="hljs-comment">//则创建一个</span><br>            &#125;<br>            tmp = tmp-&gt;childNode[c-<span class="hljs-string">&#x27;a&#x27;</span>];<span class="hljs-comment">//tmp前进</span><br>        &#125;<br>        tmp-&gt;isVal = <span class="hljs-literal">true</span>;<span class="hljs-comment">//设置当前单词存在</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//搜索单词</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp; word)</span> <span class="hljs-keyword">const</span></span>&#123;<br><br>        TrieNode* tmp = root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>&amp; c : word)&#123;<br>            <span class="hljs-keyword">if</span>(!tmp-&gt;childNode[c-<span class="hljs-string">&#x27;a&#x27;</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> tmp = tmp-&gt;childNode[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> tmp-&gt;isVal;<span class="hljs-comment">//返回单词是否存在</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//寻找单词前缀</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp; prefix)</span> <span class="hljs-keyword">const</span></span>&#123;<br><br>        TrieNode* tmp = root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>&amp; c : prefix)&#123;<br>            <span class="hljs-keyword">if</span>(!tmp-&gt;childNode[c-<span class="hljs-string">&#x27;a&#x27;</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> tmp = tmp-&gt;childNode[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Trie* obj = new Trie();</span><br><span class="hljs-comment"> * obj-&gt;insert(word);</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;search(word);</span><br><span class="hljs-comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>就是维护一个公共前缀树，具体可看<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/208-shi-xian-trie-qian-zhui-shu-bao-gua-insert-sea/">\208. 实现 Trie (前缀树) 包括insert、search、startwith、delete四种操作</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀树</tag>
      
      <tag>字典树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>142. 环形链表 II</title>
    <link href="/2020/10/09/LeetCode/142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II/"/>
    <url>/2020/10/09/LeetCode/142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">本题链接</a></p><h2 id="Floyd判圈法"><a href="#Floyd判圈法" class="headerlink" title="Floyd判圈法"></a>Floyd判圈法</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br><br>        <span class="hljs-comment">//使用floyd判圈法</span><br>        <span class="hljs-comment">//使用快慢指针</span><br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <br>            <span class="hljs-comment">//移动指针</span><br>            <span class="hljs-keyword">if</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;fast = fast-&gt;next-&gt;next;slow = slow-&gt;next;&#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>            <span class="hljs-comment">//判断是否相等</span><br>            <span class="hljs-keyword">if</span>(fast == slow) &#123;fast = head;<span class="hljs-keyword">break</span>;&#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//第二次相遇位置即环路路口</span><br>        <span class="hljs-keyword">while</span>(fast != slow)&#123;<br><br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> fast;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用floyd判圈法即可。</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br><br>        unordered_set&lt;ListNode*&gt; hash;<br>        <span class="hljs-keyword">while</span>(head)&#123;<br>            <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">find</span>(head) == hash.<span class="hljs-built_in">end</span>())&#123;<br>                hash.<span class="hljs-built_in">insert</span>(head);<br>                head = head-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>使用哈希表存储出现过的节点，如果存入节点时发现哈希表中已经有该节点了，那么该节点就是环的入口节点。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>链表</tag>
      
      <tag>Floyd判圈法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>235. 二叉搜索树的最近公共祖先</title>
    <link href="/2020/10/05/LeetCode/235.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2020/10/05/LeetCode/235.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">本题链接</a></p><h2 id="递归-中序遍历"><a href="#递归-中序遍历" class="headerlink" title="递归+中序遍历"></a>递归+中序遍历</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    TreeNode* res;    <br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br><br>        <span class="hljs-built_in">inOrder</span>(root,p,q);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;<br><br>        <span class="hljs-comment">//当节点为空或者已经有结果,就不再递归深入</span><br>        <span class="hljs-keyword">if</span>(!root || res) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">bool</span> left = <span class="hljs-built_in">inOrder</span>(root-&gt;left,p,q);<span class="hljs-comment">//左子树中是否存在</span><br>        <span class="hljs-keyword">bool</span> right = <span class="hljs-built_in">inOrder</span>(root-&gt;right,p,q);<span class="hljs-comment">//右子树中是否存在</span><br>        <span class="hljs-keyword">bool</span> self = root == p || root == q;<span class="hljs-comment">//自己是否符合条件</span><br><br>        <span class="hljs-comment">//1.如果自己符合条件且左右子树有一个符合条件</span><br>        <span class="hljs-comment">//2.如果左右子树都符合条件</span><br>        <span class="hljs-keyword">if</span>((self &amp;&amp; (left || right)) || (left &amp;&amp; right)) res = root;<br>        <br>        <span class="hljs-keyword">return</span> self || left || right;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接中序遍历递归，每当递归深入到一个节点时，判断它是否是两点之一，或者它的左右子树是否拥有两个点之一即可。返回true表示以这个节点为根节点的子树拥有两个点之一。</p><h2 id="迭代-利用平衡二叉树的性质"><a href="#迭代-利用平衡二叉树的性质" class="headerlink" title="迭代+利用平衡二叉树的性质"></a>迭代+利用平衡二叉树的性质</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>            <span class="hljs-comment">//如果p,q都在当前节点的左边,将节点更换成节点的左孩子</span><br>            <span class="hljs-keyword">if</span>(p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) root = root-&gt;left;<br>            <span class="hljs-comment">//如果p,q都在当前节点的右边,将节点更换成节点的右孩子</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) root = root-&gt;right;<br>            <span class="hljs-comment">//p,q分散在节点两边,其中节点可以包含p或q</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>一开始没注意看到是平衡二叉树，利用平衡二叉树的性质即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
      <tag>中序遍历</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>993. 二叉树的堂兄弟节点</title>
    <link href="/2020/10/04/LeetCode/993.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9/"/>
    <url>/2020/10/04/LeetCode/993.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/">本题链接</a></p><h2 id="哈希表-递归"><a href="#哈希表-递归" class="headerlink" title="哈希表+递归"></a>哈希表+递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br><br>        <span class="hljs-keyword">int</span> depth;<br>        TreeNode* father;<br><br>    &#125;Elem;<br><br>    unordered_map&lt;<span class="hljs-keyword">int</span>,Elem&gt; node_map;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isCousins</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><br>        <span class="hljs-built_in">func</span>(root,<span class="hljs-number">0</span>,<span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-keyword">return</span> node_map[x].depth == node_map[y].depth &amp;&amp; node_map[x].father != node_map[y].father;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(TreeNode* root,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; depth,TreeNode* father)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br><br>        node_map[root-&gt;val] = &#123;depth,father&#125;;<br><br>        <span class="hljs-built_in">func</span>(root-&gt;left,depth+<span class="hljs-number">1</span>,root);<br>        <span class="hljs-built_in">func</span>(root-&gt;right,depth+<span class="hljs-number">1</span>,root);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>比较简单粗暴的方式就是遍历所有的节点，然后保存每个节点的高度和父节点，最后再进行比较。虽然简单直观但是很慢，如果只是对比其中两个节点的话其实没必要遍历所有的节点。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>496. 下一个更大元素 I</title>
    <link href="/2020/10/03/LeetCode/496.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20I/"/>
    <url>/2020/10/03/LeetCode/496.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20I/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/next-greater-element-i/">本题链接</a></p><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br><br>        map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; f_map;<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; d_stack;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(nums1.size(),<span class="hljs-number">-1</span>)</span></span>;<br><br>        <span class="hljs-comment">//维护nums2对应的递增单调栈</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = nums2.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span> ;--i)&#123;<br>           <span class="hljs-keyword">while</span>(!d_stack.<span class="hljs-built_in">empty</span>() &amp;&amp; d_stack.<span class="hljs-built_in">top</span>() &lt; nums2[i]) d_stack.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//如果栈非空且栈顶元素小于当前元素:将栈顶元素出栈</span><br>           <span class="hljs-keyword">if</span>(!d_stack.<span class="hljs-built_in">empty</span>()) f_map.<span class="hljs-built_in">insert</span>(&#123;nums2[i],d_stack.<span class="hljs-built_in">top</span>()&#125;);<span class="hljs-comment">//当栈顶元素大于当前元素,就将&#123;key:当前元素,value:栈顶元素&#125;放入map</span><br>           d_stack.<span class="hljs-built_in">push</span>(nums2[i]);<span class="hljs-comment">//将当前元素入栈</span><br>        &#125;<br><br>        <span class="hljs-comment">//对结果进行查找</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>();++i)<br>            <span class="hljs-keyword">if</span>(f_map.<span class="hljs-built_in">find</span>(nums1[i]) != f_map.<span class="hljs-built_in">end</span>())<br>                res[i] = f_map[nums1[i]];<br>            <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>维护一个单调递增栈，从nums2的尾部向前进行遍历：在栈非空的情况下，当前的nums2元素的下一个最大元素为栈顶元素。若栈为空，当前元素没有下一个最大元素。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>98. 验证二叉搜索树</title>
    <link href="/2020/10/02/LeetCode/98.%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2020/10/02/LeetCode/98.%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">本题链接</a></p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">bool</span> res = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">long</span> last = LONG_MIN;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">inOrder</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root || !res) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-built_in">inOrder</span>(root-&gt;left);<span class="hljs-comment">//先进入左孩子</span><br><br>        <span class="hljs-keyword">if</span>(last &gt;= root-&gt;val)&#123;<span class="hljs-comment">//如果小于或等于上次的值</span><br>            res = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">else</span> last = root-&gt;val;<span class="hljs-comment">//更新上一次的值</span><br>        <br>        <span class="hljs-built_in">inOrder</span>(root-&gt;right);<span class="hljs-comment">//再进入右孩子</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二叉搜索树的中序遍历序列是递增的，所以可以按照这个递增的性质进行处理。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>中序遍历</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>328. 奇偶链表</title>
    <link href="/2020/09/27/LeetCode/328.%20%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/09/27/LeetCode/328.%20%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">本题链接</a></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">oddEvenList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        <span class="hljs-comment">//异常情况</span><br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">if</span>(!head-&gt;next) <span class="hljs-keyword">return</span> head;<br><br>        <span class="hljs-comment">//初始化</span><br>        <span class="hljs-function">ListNode <span class="hljs-title">odd_head</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;ListNode* odd_node = &amp;odd_head;<span class="hljs-comment">//奇数链表</span><br>        <span class="hljs-function">ListNode <span class="hljs-title">even_head</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;ListNode* even_node = &amp;even_head;<span class="hljs-comment">//偶数链表</span><br>        <span class="hljs-comment">//预处理</span><br>        odd_node-&gt;next = head;odd_node = odd_node-&gt;next;<span class="hljs-comment">//odd_node指向第一个奇数节点</span><br>        even_node-&gt;next = head-&gt;next;even_node = even_node-&gt;next;<span class="hljs-comment">//even_node指向第一个偶数节点</span><br><br>        <span class="hljs-keyword">while</span>(even_node)&#123;<br><br>            <span class="hljs-keyword">if</span>(!even_node-&gt;next) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//如果是奇数位置为空</span><br><br>            <span class="hljs-comment">//找到下一个奇数</span><br>            odd_node-&gt;next = even_node-&gt;next;<span class="hljs-comment">//将奇数节点串接</span><br>            odd_node = odd_node-&gt;next;<span class="hljs-comment">//奇数指针往前移</span><br>            <span class="hljs-comment">//找到下一个偶数</span><br>            even_node-&gt;next = odd_node-&gt;next;<span class="hljs-comment">//将偶数节点串接</span><br>            even_node = even_node-&gt;next;<span class="hljs-comment">//偶数指针往前移</span><br>        &#125;<br><br>        <span class="hljs-comment">//将偶数链表挂到奇数链表后面</span><br>        odd_node-&gt;next = even_head.next;<br><br>        <span class="hljs-keyword">return</span> odd_head.next;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用奇偶链表分别挂接奇偶节点，最后再将偶链表接到奇链表的后头就行。代码还可以优化，奇偶链表其实不是必须的，只要每次挂接的时候保持第一个偶数节点在最后一个奇数节点的后头就行。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11. 盛最多水的容器</title>
    <link href="/2020/09/24/LeetCode/11.%20%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <url>/2020/09/24/LeetCode/11.%20%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/container-with-most-water/">本题链接</a></p><h2 id="暴力-双指针（超时）"><a href="#暴力-双指针（超时）" class="headerlink" title="暴力+双指针（超时）"></a>暴力+双指针（超时）</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; height)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>,hi = <span class="hljs-number">0</span>,res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(; lo &lt; height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; lo++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(hi = lo + <span class="hljs-number">1</span>;hi &lt; height.<span class="hljs-built_in">size</span>();hi++)<br>            &#123;<br>                res = <span class="hljs-built_in">max</span>( res , <span class="hljs-built_in">min</span>( height[lo] , height[hi] )*(hi - lo) );<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="贪心-双指针"><a href="#贪心-双指针" class="headerlink" title="贪心+双指针"></a>贪心+双指针</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; height)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>,hi = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>,res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(lo &lt; hi)&#123;<br><br>            res = <span class="hljs-built_in">max</span>( res , <span class="hljs-built_in">min</span>( height[lo] , height[hi] )*(hi - lo) );<br>            <span class="hljs-keyword">if</span>(height[lo] &gt; height[hi]) --hi;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(height[lo] == height[hi]) height[lo+<span class="hljs-number">1</span>] &gt; height[hi<span class="hljs-number">-1</span>] ? ++lo : --hi;<br>            <span class="hljs-keyword">else</span> ++lo;            <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>前后两个指针分别从头尾开始。既然往中间靠拢，那么就要求两根柱子尽量大，使面积尽可能的大。那么每次迭代的时候就需要舍弃当前两根柱子中最小的那个。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>双指针</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>198. 打家劫舍</title>
    <link href="/2020/09/23/LeetCode/198.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <url>/2020/09/23/LeetCode/198.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/house-robber/">本题链接</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(),nums[<span class="hljs-number">0</span>])</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);<br><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-2</span>]+nums[i]);<br>            <br>        <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为在在第i个房子的时候，要么选择打劫，要么选择跳过。所以只要求出状态方程：</p><script type="math/tex; mode=display">dp[i] = max(dp[i-1],dp[i-2]+num[i])</script>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1011. 在 D 天内送达包裹的能力</title>
    <link href="/2020/09/22/LeetCode/1011.%20%E5%9C%A8%20D%20%E5%A4%A9%E5%86%85%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B/"/>
    <url>/2020/09/22/LeetCode/1011.%20%E5%9C%A8%20D%20%E5%A4%A9%E5%86%85%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">本题链接</a></p><h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shipWithinDays</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; weights, <span class="hljs-keyword">int</span> days)</span> </span>&#123;<br><br>        <span class="hljs-comment">//先获取运载能力的上下限,作为二分查找的边界</span><br>        <span class="hljs-keyword">int</span> left = *<span class="hljs-built_in">max_element</span>(weights.<span class="hljs-built_in">begin</span>(),weights.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">accumulate</span>(weights.<span class="hljs-built_in">begin</span>(),weights.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-keyword">int</span> loop_weights,day,mid;<br><br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br><br>            mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            loop_weights = <span class="hljs-number">0</span>;<br>            day = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//对货物进行遍历</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> &amp;goods:weights)&#123;<br>                <br>                <span class="hljs-keyword">if</span>(loop_weights + goods &gt; mid)&#123;<span class="hljs-comment">//如果已存的货物重量大于载重量</span><br>                    loop_weights = <span class="hljs-number">0</span>;<br>                    ++day;<br>                &#125;<br>                loop_weights += goods;<br>        <br>            &#125;<br>            <span class="hljs-keyword">if</span>(day &lt;= days) right = mid;<span class="hljs-comment">//说明载重量太大</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(day &gt; days) left = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//说明载重量太小</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> left;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>依照题意，可知船的载重量不会小于最大货物的重量；而船的最大载重量取决于所有的货物总量。那么可以按照这两个量作为左右边界，二分搜索最佳载重量，让天数匹配。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>263. 丑数</title>
    <link href="/2020/09/20/LeetCode/263.%20%E4%B8%91%E6%95%B0/"/>
    <url>/2020/09/20/LeetCode/263.%20%E4%B8%91%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/ugly-number/">本题链接</a></p><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isUgly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">while</span>(n % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>)&#123;<br>            n /= <span class="hljs-number">5</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(n % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>)&#123;<br>            n /= <span class="hljs-number">3</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>            n /= <span class="hljs-number">2</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接按照题目给的条件组成流程就行….</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>119. 杨辉三角 II</title>
    <link href="/2020/09/19/LeetCode/119.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%20II/"/>
    <url>/2020/09/19/LeetCode/119.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%20II/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/">本题链接</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getRow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rowIndex)</span> </span>&#123;<br><br>        map&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;,<span class="hljs-keyword">int</span>&gt; dp;<br>        dp[&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;] = <span class="hljs-number">1</span>;<br>        dp[&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;] = <span class="hljs-number">1</span>;<br>        dp[&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> row = <span class="hljs-number">2</span>;row &lt;= rowIndex;++row)&#123;<br>            dp[&#123;row,<span class="hljs-number">0</span>&#125;] = <span class="hljs-number">1</span>;<span class="hljs-comment">//左边的1</span><br>            dp[&#123;row,row&#125;] = <span class="hljs-number">1</span>;<span class="hljs-comment">//右边的1</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> col = <span class="hljs-number">1</span>;col &lt; row;++col)&#123;<br>                dp[&#123;row,col&#125;] = dp[&#123;row - <span class="hljs-number">1</span>,col&#125;] + dp[&#123;row - <span class="hljs-number">1</span>,col - <span class="hljs-number">1</span>&#125;];<br>                <br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//结果</span><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= rowIndex;++i)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(dp[&#123;rowIndex,i&#125;]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据杨辉三角的规律可得状态转移方程：</p><script type="math/tex; mode=display">dp[r][c]=dp[r-1][c-1]+dp[r-1][c]</script><p>其中，r为当前行，c为当前行的元素下标，$dp[r][c]$为当前元素的值。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>107. 二叉树的层序遍历 II</title>
    <link href="/2020/09/17/LeetCode/107.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%20II/"/>
    <url>/2020/09/17/LeetCode/107.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%20II/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">本题链接</a></p><h2 id="递归版1-数组反转"><a href="#递归版1-数组反转" class="headerlink" title="递归版1+数组反转"></a>递归版1+数组反转</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrderBottom</span>(TreeNode* root) &#123;<br><br>        <span class="hljs-built_in">func</span>(root,<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//反转结果</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = res.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-built_in">swap</span>(res[left++],res[right--]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(TreeNode* root,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; depth)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">//若没有空间</span><br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>()  &lt; depth + <span class="hljs-number">1</span>)<br>            res.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;&#125;);<br>        <br>        res[depth].<span class="hljs-built_in">push_back</span>(root-&gt;val);<span class="hljs-comment">//将自己存入结果数组中</span><br><br>        <span class="hljs-built_in">func</span>(root-&gt;left,depth+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">func</span>(root-&gt;right,depth+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和&lt;&lt;<strong>102. 二叉树的层序遍历</strong>&gt;&gt;的思路一样，最后在返回结果的时候反转一下结果数组就行了…</p><h2 id="递归版2"><a href="#递归版2" class="headerlink" title="递归版2"></a>递归版2</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res&#123;vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;&#125;&#125;;<br>    <br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrderBottom</span>(TreeNode* root) &#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>&#123;&#125;;<br><br>        <span class="hljs-built_in">func</span>(root,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(TreeNode* root,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; depth)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">//若没有空间</span><br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>()  &lt; depth + <span class="hljs-number">1</span>)<br>            res.<span class="hljs-built_in">insert</span>(res.<span class="hljs-built_in">begin</span>(),vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;&#125;);<br><br>        <span class="hljs-built_in">func</span>(root-&gt;left,depth+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">func</span>(root-&gt;right,depth+<span class="hljs-number">1</span>);<br><br>        res[(res.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>) - depth].<span class="hljs-built_in">push_back</span>(root-&gt;val);<span class="hljs-comment">//将自己存入结果数组中</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>和&lt;&lt;<strong>102. 二叉树的层序遍历</strong>&gt;&gt;的思路一样，不过此时视作后序遍历。但是很耗时，原因在于在递归中对<code>res</code>的插入操作。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>层序遍历</tag>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>145. 二叉树的后序遍历</title>
    <link href="/2020/09/17/LeetCode/145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2020/09/17/LeetCode/145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">本题链接</a></p><h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">postOrder</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-built_in">postOrder</span>(root-&gt;left);<span class="hljs-comment">//先处理左孩子</span><br>        <span class="hljs-built_in">postOrder</span>(root-&gt;right);<span class="hljs-comment">//再处理右孩子</span><br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<span class="hljs-comment">//最后处理自己</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>递归简洁直观，只需按照后序遍历的顺序即可。</p><h2 id="迭代版-栈-哈希表"><a href="#迭代版-栈-哈希表" class="headerlink" title="迭代版+栈+哈希表"></a>迭代版+栈+哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br><br>        stack&lt;TreeNode*&gt; node_stack;<br>        unordered_set&lt;TreeNode*&gt; unique_hash;<span class="hljs-comment">//避免重复放入孩子</span><br>        TreeNode* cur_node;<br><br>        node_stack.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!node_stack.<span class="hljs-built_in">empty</span>())&#123;<br><br>            cur_node = node_stack.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//当前的栈顶节点</span><br><br>            <span class="hljs-keyword">bool</span> hasRight = cur_node-&gt;right &amp;&amp; unique_hash.<span class="hljs-built_in">find</span>(cur_node-&gt;right) == unique_hash.<span class="hljs-built_in">end</span>();<span class="hljs-comment">//是否放入右孩子</span><br>            <br>            <span class="hljs-keyword">if</span>(hasRight) node_stack.<span class="hljs-built_in">push</span>(cur_node-&gt;right);<span class="hljs-comment">//放入右孩子</span><br><br>            <span class="hljs-keyword">if</span>(cur_node-&gt;left &amp;&amp; unique_hash.<span class="hljs-built_in">find</span>(cur_node-&gt;left) == unique_hash.<span class="hljs-built_in">end</span>()) node_stack.<span class="hljs-built_in">push</span>(cur_node-&gt;left);<span class="hljs-comment">//放入左孩子</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!hasRight)&#123;<span class="hljs-comment">//若同时也不放入右孩子</span><br>                res.<span class="hljs-built_in">push_back</span>(cur_node-&gt;val);<span class="hljs-comment">//保存结果</span><br>                unique_hash.<span class="hljs-built_in">insert</span>(cur_node);<span class="hljs-comment">//标记当前节点已被使用</span><br>                node_stack.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//将当前节点出栈</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>按照后序遍历的顺序放入左右节点，然后使用哈希表记录已经被使用的节点，防止左右孩子重复入栈。当该节点为叶子节点时就使用，或者当该节点的孩子都被使用过，那么该节点也可以看成叶子节点。</p><h2 id="迭代版-栈"><a href="#迭代版-栈" class="headerlink" title="迭代版+栈"></a>迭代版+栈</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; node_stack;<br>        TreeNode* cur_node = root;<br>        TreeNode* tmp;<br><br>        <span class="hljs-keyword">while</span>(!node_stack.<span class="hljs-built_in">empty</span>() || cur_node)&#123;<br><br>            <span class="hljs-keyword">if</span>(cur_node)&#123;<span class="hljs-comment">//沿着左侧链下行</span><br><br>                node_stack.<span class="hljs-built_in">push</span>(cur_node);<br>                cur_node = cur_node-&gt;left;<br><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                cur_node = node_stack.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//取出栈顶的节点</span><br><br>                <span class="hljs-comment">//如果没有右孩子或者右孩子已经被遍历过</span><br>                <span class="hljs-keyword">if</span>(cur_node-&gt;right == <span class="hljs-literal">nullptr</span> || cur_node-&gt;right == tmp)&#123;<br>                    <br>                    res.<span class="hljs-built_in">push_back</span>(cur_node-&gt;val);<span class="hljs-comment">//将元素保存到res</span><br>                    node_stack.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//将栈顶元素出栈</span><br>                    tmp = cur_node;<span class="hljs-comment">//将上一个右孩子节点设置为当前节点</span><br>                    cur_node = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//将当前节点置空</span><br><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    cur_node = cur_node-&gt;right;<span class="hljs-comment">//将当前节点设置为自己的右孩子</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>根据后序遍历的性质，使用了一个临时变量来存储被使用过的右孩子，以避免重复入栈。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
      <tag>栈</tag>
      
      <tag>后序遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>210. 课程表 II</title>
    <link href="/2020/09/12/LeetCode/210.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8%20II/"/>
    <url>/2020/09/12/LeetCode/210.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8%20II/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/course-schedule-ii/">本题链接</a></p><h2 id="拓扑排序-深度优先搜索"><a href="#拓扑排序-深度优先搜索" class="headerlink" title="拓扑排序+深度优先搜索"></a>拓扑排序+深度优先搜索</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-comment">//有向图的存储</span><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; edges;<br>    <span class="hljs-comment">//标记每个节点的状态 0:未搜索 1:搜索中 2:已完成</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; visited;<br>    <span class="hljs-comment">//用数组来模拟栈，下标0为栈底，n-1为栈顶</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; result;<br>    <span class="hljs-comment">//判断有向图中是否有环</span><br>    <span class="hljs-keyword">bool</span> valid = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br><br>        <span class="hljs-comment">//对节点状态数组初始化</span><br>        visited.<span class="hljs-built_in">resize</span>(numCourses);<br>        <span class="hljs-comment">//对有向图数组初始化 </span><br>        edges.<span class="hljs-built_in">resize</span>(numCourses);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; info : prerequisites)&#123;<br>            edges[info[<span class="hljs-number">1</span>]].<span class="hljs-built_in">emplace_back</span>(info[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-comment">//每次挑选一个未搜索的节点,开始进行深度优先搜索</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; numCourses &amp;&amp; valid;++i)&#123;<br>            <span class="hljs-keyword">if</span>(!visited[i])&#123;<br>                <span class="hljs-built_in">dfs</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!valid) <span class="hljs-keyword">return</span> &#123;&#125;;<span class="hljs-comment">//如果有环,代表没有拓扑排序</span><br><br>        <span class="hljs-comment">//由于数组是模仿栈的行为,所以应该在返回结果前将数组反转</span><br>        <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(),result.<span class="hljs-built_in">end</span>());<br>        <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;<br><br>        <span class="hljs-comment">//将节点标记为搜索中</span><br>        visited[u] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//搜索其相邻节点</span><br>        <span class="hljs-comment">//只要发现有环，立即停止搜索</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v:edges[u])&#123;<br><br>            <span class="hljs-keyword">if</span>(visited[v] == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//如果这个相邻节点处于未遍历的状态</span><br>                <span class="hljs-built_in">dfs</span>(v);<span class="hljs-comment">//对该节点进行深度优先搜索</span><br>                <span class="hljs-keyword">if</span>(!valid) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//如果过程中出现了环</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(visited[v] == <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//如果这个相邻节点处于正在搜索的状态,那么就说明图中有环出现</span><br>                valid = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//对相邻节点搜索完毕后</span><br>        <span class="hljs-comment">//将自己设置成搜索完成</span><br>        visited[u] = <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//将自己入栈</span><br>        result.<span class="hljs-built_in">push_back</span>(u);<br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>详情见<a href="https://leetcode-cn.com/problems/course-schedule-ii/solution/ke-cheng-biao-ii-by-leetcode-solution/">官方解析</a></p><h2 id="拓扑排序-广度优先搜索"><a href="#拓扑排序-广度优先搜索" class="headerlink" title="拓扑排序+广度优先搜索"></a>拓扑排序+广度优先搜索</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-comment">// 存储有向图</span><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; edges;<br>    <span class="hljs-comment">// 存储每个节点的入度</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; indeg;<br>    <span class="hljs-comment">// 存储答案 </span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br><br>       <span class="hljs-comment">// 入度表初始化</span><br>       indeg.<span class="hljs-built_in">resize</span>(numCourses);<br>       <span class="hljs-comment">// 有向图初始化</span><br>       edges.<span class="hljs-built_in">resize</span>(numCourses);<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; info : prerequisites)&#123;<br>           edges[info[<span class="hljs-number">1</span>]].<span class="hljs-built_in">emplace_back</span>(info[<span class="hljs-number">0</span>]);<br>           ++indeg[info[<span class="hljs-number">0</span>]];<br>       &#125;<br><br>       <span class="hljs-comment">//节点队列</span><br>       queue&lt;<span class="hljs-keyword">int</span>&gt; node_queue;<br>       <span class="hljs-comment">// 将所有入度为0的节点放入队列中</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; numCourses;++i)&#123;<br>           <span class="hljs-keyword">if</span>(indeg[i] == <span class="hljs-number">0</span>)&#123;<br>               node_queue.<span class="hljs-built_in">push</span>(i);<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-keyword">while</span>(!node_queue.<span class="hljs-built_in">empty</span>())&#123;<br>           <span class="hljs-comment">// 从队首取出一个节点</span><br>           <span class="hljs-keyword">int</span> u = node_queue.<span class="hljs-built_in">front</span>();node_queue.<span class="hljs-built_in">pop</span>();<br>           <span class="hljs-comment">// 放入答案中</span><br>           res.<span class="hljs-built_in">emplace_back</span>(u);<br>           <span class="hljs-comment">// 遍历自己的邻接节点</span><br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v:edges[u])&#123;<br>               --indeg[v];<span class="hljs-comment">//将自己邻接节点的入度数量减一</span><br>               <span class="hljs-keyword">if</span>(indeg[v] == <span class="hljs-number">0</span>) node_queue.<span class="hljs-built_in">push</span>(v);<span class="hljs-comment">//如果相邻节点的入度为0,就把相邻节点入队</span><br>           &#125;<br>       &#125;<br><br>       <span class="hljs-comment">//若还有节点的入度不为0 那么说明图中出现了环路</span><br>       <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() != numCourses) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>       <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>详情见<a href="https://leetcode-cn.com/problems/course-schedule-ii/solution/ke-cheng-biao-ii-by-leetcode-solution/">官方解析</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度优先搜索</tag>
      
      <tag>图</tag>
      
      <tag>广度优先搜索</tag>
      
      <tag>拓扑排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>105. 从前序与中序遍历序列构造二叉树</title>
    <link href="/2020/09/11/LeetCode/105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/09/11/LeetCode/105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">本题链接</a></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">int</span> p_index = <span class="hljs-number">0</span>;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;<br><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>();<br><br>        <span class="hljs-comment">//此刻preorder的第一个元素为inorder中代表根节点的元素</span><br>        <span class="hljs-built_in">addNode</span>(preorder,inorder,<span class="hljs-number">0</span>,inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>,root);<br><br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br>    <span class="hljs-comment">//进入该函数的节点都视作子树的根节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder,vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; lo,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; hi,TreeNode* root)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(p_index == preorder.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//在inorder的[lo,hi]中找到preorder[p_index]</span><br>        <span class="hljs-keyword">int</span> index = <span class="hljs-built_in">getElemIndexInVec</span>(preorder[p_index],inorder,lo,hi);<br>        root-&gt;val = preorder[p_index++];<span class="hljs-comment">//给根节点赋值</span><br>        <span class="hljs-comment">//递归进入左子树</span><br>        <span class="hljs-keyword">if</span>(lo &lt; index)&#123;<br>            TreeNode* left_child = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>();<br>            root-&gt;left = left_child;<br>            <span class="hljs-built_in">addNode</span>(preorder,inorder,lo,index - <span class="hljs-number">1</span>,left_child);<br>        &#125;<br>        <span class="hljs-comment">//递归进入右子树</span><br>        <span class="hljs-keyword">if</span>(index &lt; hi)&#123;<br>            TreeNode* right_child = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>();<br>            root-&gt;right = right_child;<br>            <span class="hljs-built_in">addNode</span>(preorder,inorder,index + <span class="hljs-number">1</span>,hi,right_child);<br>        &#125; <br>    &#125;<br><br>    <span class="hljs-comment">//返回vector中elem的索引</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getElemIndexInVec</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; elem,vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; vec,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; lo,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; hi)</span> <span class="hljs-keyword">const</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = lo;i &lt;= hi;++i)<br>            <span class="hljs-keyword">if</span>(vec[i] == elem) <span class="hljs-keyword">return</span> i;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据二叉树的前序与中序遍历的序列可知，每个时刻前序遍历的当前元素都是中序遍历序列中某个子树的根节点。使用递归可以很直观的反应思路，但是每次都要在中序遍历序列中找子树根节点，该操作($O(n)$)会造成很大的开销</p><h2 id="递归-哈希表"><a href="#递归-哈希表" class="headerlink" title="递归+哈希表"></a>递归+哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-keyword">int</span> p_index = <span class="hljs-number">0</span>;<br>    unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; hash;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;<br><br>        <span class="hljs-comment">//构造hash表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; inorder.<span class="hljs-built_in">size</span>();++i)<br>            hash[inorder[i]] = i;<br>        <br><br>        <span class="hljs-comment">//此刻preorder的第一个元素为inorder中代表根节点的元素</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">addNode</span>(preorder,<span class="hljs-number">0</span>,inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//进入该函数的节点都视作子树的根节点</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">addNode</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; lo,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; hi)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(lo &gt; hi) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">//在inorder的[lo,hi]中找到preorder[p_index]</span><br>        <span class="hljs-keyword">int</span> index = hash[preorder[p_index]];<br><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[p_index++]);<br><br>        root-&gt;left = <span class="hljs-built_in">addNode</span>(preorder,lo,index - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">addNode</span>(preorder,index + <span class="hljs-number">1</span>,hi);<br>   <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>同第一个递归的思路一致，然后使用哈希表加速中序遍历序列元素下标的查找。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>162. 寻找峰值</title>
    <link href="/2020/09/09/LeetCode/162.%20%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/"/>
    <url>/2020/09/09/LeetCode/162.%20%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/find-peak-element/">本题链接</a></p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]&gt;nums[<span class="hljs-number">1</span>]?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>,r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>,mid;<br><br>        <span class="hljs-keyword">while</span>((l + <span class="hljs-number">2</span>) &lt;= r)&#123;<br>            <br>            mid = (r + l)  / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] &gt; nums[mid - <span class="hljs-number">1</span>] &amp;&amp; nums[mid] &gt; nums[mid + <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; nums[mid - <span class="hljs-number">1</span>] &amp;&amp; nums[mid] &lt; nums[mid + <span class="hljs-number">1</span>]) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &gt; nums[<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>] &gt; nums[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> l + <span class="hljs-number">1</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将峰值限制在左边界和右边界之间即可,主要考虑特殊情况</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>101. 对称二叉树</title>
    <link href="/2020/09/06/LeetCode/101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/09/06/LeetCode/101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/symmetric-tree/">本题链接</a></p><h2 id="迭代-层序遍历"><a href="#迭代-层序遍历" class="headerlink" title="迭代+层序遍历"></a>迭代+层序遍历</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        vector&lt;string&gt; tmp;<br>        queue&lt;TreeNode*&gt; node_queue;<br>        TreeNode* cur_node;<br>        <span class="hljs-comment">//中序遍历存储到数组</span><br><br>        node_queue.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!node_queue.<span class="hljs-built_in">empty</span>())&#123;<br><br>            <span class="hljs-keyword">int</span> size = node_queue.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">if</span>(tmp.<span class="hljs-built_in">capacity</span>() &lt; size) tmp.<span class="hljs-built_in">resize</span>(size,<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//如果tmp空间不足 扩容</span><br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; size;++i)&#123;<br><br>                cur_node = node_queue.<span class="hljs-built_in">front</span>();node_queue.<span class="hljs-built_in">pop</span>();<br><br>                <span class="hljs-keyword">if</span>(!cur_node)&#123;<span class="hljs-comment">//如果节点为空</span><br>                    tmp[i] = <span class="hljs-string">&quot;null&quot;</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果节点不为空</span><br>                    tmp[i] = cur_node-&gt;val;<br>                    node_queue.<span class="hljs-built_in">push</span>(cur_node-&gt;left);<br>                    node_queue.<span class="hljs-built_in">push</span>(cur_node-&gt;right);<br>                &#125;<br><br>            &#125;<br>            <br>            <span class="hljs-comment">//进行比较</span><br>            <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = size - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(left &lt;= right)<br>                <span class="hljs-keyword">if</span>(tmp[left++] != tmp[right--]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果不相等</span><br>            tmp.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//清空</span><br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一棵二叉树如果是镜像对称的，那么它的每一层都是对称的，实际上就是回文。那么可以按照层序遍历的思路，在每一层都进行回文比较。</p><h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isCheck</span>(root,root);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isCheck</span><span class="hljs-params">(TreeNode* p1,TreeNode* p2)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!p1 &amp;&amp; !p2) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//两个都为空</span><br>        <span class="hljs-keyword">if</span>(!p1 || !p2) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//其中一个为空</span><br><br>        <span class="hljs-keyword">if</span>(p1-&gt;val != p2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//若两者的值不相等</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isCheck</span>(p1-&gt;left,p2-&gt;right) &amp;&amp; <span class="hljs-built_in">isCheck</span>(p1-&gt;right,p2-&gt;left);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>具体看官方解析<a href="https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution/">https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution/</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代</tag>
      
      <tag>层序遍历</tag>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>231. 2 的幂</title>
    <link href="/2020/09/03/LeetCode/231.%202%20%E7%9A%84%E5%B9%82/"/>
    <url>/2020/09/03/LeetCode/231.%202%20%E7%9A%84%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/power-of-two/">本题链接</a></p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> n &amp; (n - <span class="hljs-number">1</span>) ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果n的二进制表示中只有一个1，那么n就是2的幂次方。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>415. 字符串相加</title>
    <link href="/2020/09/03/LeetCode/415.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/"/>
    <url>/2020/09/03/LeetCode/415.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/add-strings/">本题链接</a></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">addStrings</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br><br>        <span class="hljs-comment">//异常情况</span><br>        <span class="hljs-keyword">if</span>(!num1.<span class="hljs-built_in">size</span>() &amp;&amp; !num2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span>(!num1.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> num2;<span class="hljs-comment">//如果num1为空</span><br>        <span class="hljs-keyword">if</span>(!num2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> num1;<span class="hljs-comment">//如果num2为空</span><br>        <span class="hljs-comment">//预处理</span><br>        <span class="hljs-keyword">int</span> max_size = <span class="hljs-built_in">max</span>(num1.<span class="hljs-built_in">size</span>(),num2.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-function">string <span class="hljs-title">res</span><span class="hljs-params">(max_size + <span class="hljs-number">1</span>,<span class="hljs-string">&#x27;0&#x27;</span>)</span></span>;<br>        <span class="hljs-comment">//统一num1和num2的长度</span><br>        <span class="hljs-keyword">if</span>(num1.<span class="hljs-built_in">size</span>() == max_size) num2 = <span class="hljs-built_in">string</span>(max_size - num2.<span class="hljs-built_in">size</span>(),<span class="hljs-string">&#x27;0&#x27;</span>) + num2;<br>        <span class="hljs-keyword">else</span> num1 = <span class="hljs-built_in">string</span>(max_size - num1.<span class="hljs-built_in">size</span>(),<span class="hljs-string">&#x27;0&#x27;</span>) + num1;<br>        <span class="hljs-comment">//下标</span><br>        <span class="hljs-keyword">int</span> num1_index = num1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> num2_index = num2.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> res_index = res.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> dig = <span class="hljs-number">0</span>;<span class="hljs-comment">//进位</span><br><br>        <span class="hljs-keyword">while</span>(res_index &gt; <span class="hljs-number">0</span>)&#123;<br><br>            <span class="hljs-keyword">int</span> cur_dig = (num1[num1_index] - <span class="hljs-string">&#x27;0&#x27;</span>) +<br>                          (num2[num2_index] - <span class="hljs-string">&#x27;0&#x27;</span>) +<br>                          dig;<br><br>            <span class="hljs-keyword">if</span>(cur_dig &gt;= <span class="hljs-number">10</span>)&#123;<span class="hljs-comment">//如果有进位</span><br>                dig = <span class="hljs-number">1</span>;<br>                res[res_index] = (cur_dig % <span class="hljs-number">10</span>) + <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果没有进位</span><br>                dig = <span class="hljs-number">0</span>;<br>                res[res_index] = cur_dig + <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br><br>            res_index--;num1_index--;num2_index--;<br>        &#125;<br><br>        <span class="hljs-comment">//判断最后是否需要进位</span><br>        dig == <span class="hljs-number">1</span> ? res[res_index] = <span class="hljs-string">&#x27;1&#x27;</span> : ++res_index;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>(res.<span class="hljs-built_in">begin</span>()+res_index,res.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路就是模拟两个整数的加法操作，关键点在于需要保存<strong>进位</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>190. 颠倒二进制位</title>
    <link href="/2020/09/02/LeetCode/190.%20%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"/>
    <url>/2020/09/02/LeetCode/190.%20%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/reverse-bits/">本题链接</a></p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">reverseBits</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">uint32_t</span> res = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">32</span>;++i)&#123;<br><br>            res &lt;&lt;= <span class="hljs-number">1</span>;<br>            res += n &amp; <span class="hljs-number">1</span>;<br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在for循环的每次迭代中，都将n的最低位复制到res的最低位。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>64. 最小路径和</title>
    <link href="/2020/09/01/LeetCode/64.%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2020/09/01/LeetCode/64.%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/">本题链接</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br><br>        <span class="hljs-comment">//对边界进行处理</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">1</span>;r &lt; grid.<span class="hljs-built_in">size</span>();++r)<br>            grid[r][<span class="hljs-number">0</span>] += grid[r<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]; <br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">1</span>;c &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();++c)<br>            grid[<span class="hljs-number">0</span>][c] += grid[<span class="hljs-number">0</span>][c<span class="hljs-number">-1</span>]; <br>        <br>        <span class="hljs-comment">//设置每个位置的最小值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">1</span>;r &lt; grid.<span class="hljs-built_in">size</span>();++r)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">1</span>;c &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();++c)<br>                grid[r][c] += <span class="hljs-built_in">min</span>(grid[r - <span class="hljs-number">1</span>][c],grid[r][c<span class="hljs-number">-1</span>]);<br>            <br>        <span class="hljs-keyword">return</span> grid[grid.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>][grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>依照题目很容易推出状态方程：</p><script type="math/tex; mode=display">dp[r][c]+=min(dp[r - 1][c],dp[r][c-1]);</script><p>其中，$dp[r][c]$​​的值为到达这个点的最短路径，由于在原数组中，每一个值被遍历后的状态一定是固定的，不会回溯，所以可以用原数组<strong>grid</strong>来当作<strong>dp</strong>数组使用。</p><p>所以整体思路就是对每一个位置求出到达该处的最短路径，然后返回所需要的那个位置即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>148. 排序链表</title>
    <link href="/2020/08/29/LeetCode/148.%20%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/08/29/LeetCode/148.%20%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/sort-list/">本题链接</a></p><h2 id="借助辅助空间排序"><a href="#借助辅助空间排序" class="headerlink" title="借助辅助空间排序"></a>借助辅助空间排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; dig_vec;<br>        <br>        <span class="hljs-comment">//读取链表中的所有数到数组里</span><br>        ListNode* dig = head;<br>        <span class="hljs-keyword">while</span>(dig)&#123;<br>            dig_vec.<span class="hljs-built_in">push_back</span>(dig-&gt;val);<br>            dig = dig-&gt;next;<br>        &#125;<br><br>        <span class="hljs-comment">//对数组排序</span><br>        <span class="hljs-built_in">sort</span>(dig_vec.<span class="hljs-built_in">begin</span>(),dig_vec.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-comment">//将数组的值回写到链表</span><br>        ListNode* in = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;dig_vec.<span class="hljs-built_in">size</span>();++i)&#123;<br>            in-&gt;val = dig_vec[i];<br>            in = in-&gt;next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>简单粗暴，避免了对链表操作的断链续链问题。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>448. 找到所有数组中消失的数字</title>
    <link href="/2020/08/29/LeetCode/448.%20%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2020/08/29/LeetCode/448.%20%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">本题链接</a></p><h2 id="就地-数组下标"><a href="#就地-数组下标" class="headerlink" title="就地+数组下标"></a>就地+数组下标</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findDisappearedNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>            nums[<span class="hljs-built_in">abs</span>(nums[i]) - <span class="hljs-number">1</span>] = -<span class="hljs-built_in">abs</span>(nums[<span class="hljs-built_in">abs</span>(nums[i]) - <span class="hljs-number">1</span>]);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">1</span>);<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>很简单，就是依靠数组的下标和数组元素的正负值来判断数组下标的这个数有没有出现，算一个小技巧，没有额外空间。也可以直接用哈希表，不过这样有额外空间。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>就地算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>腾讯云访问github</title>
    <link href="/2020/08/26/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AE%BF%E9%97%AEgithub/"/>
    <url>/2020/08/26/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AE%BF%E9%97%AEgithub/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo vi /etc/hosts<br></code></pre></div></td></tr></table></figure><p>添加：</p><figure class="highlight accesslog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs accesslog"># github<br><span class="hljs-number">204.232.175.78</span> http://documentcloud.github.com<br><span class="hljs-number">207.97.227.239</span> http://github.com<br><span class="hljs-number">204.232.175.94</span> http://gist.github.com<br><span class="hljs-number">107.21.116.220</span> http://help.github.com<br><span class="hljs-number">207.97.227.252</span> http://nodeload.github.com<br><span class="hljs-number">199.27.76.130</span> http://raw.github.com<br><span class="hljs-number">107.22.3.110</span> http://status.github.com<br><span class="hljs-number">204.232.175.78</span> http://training.github.com<br><span class="hljs-number">207.97.227.243</span> http://www.github.com<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. 无重复字符的最长子串</title>
    <link href="/2020/08/22/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2020/08/22/LeetCode/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">本题链接</a></p><h2 id="哈希表-队列"><a href="#哈希表-队列" class="headerlink" title="哈希表+队列"></a>哈希表+队列</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">size</span>();<br><br>        unordered_set&lt;<span class="hljs-keyword">char</span>&gt; hash;<br>        queue&lt;<span class="hljs-keyword">char</span>&gt; que;<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">find</span>(s[i]) == hash.<span class="hljs-built_in">end</span>())&#123;<span class="hljs-comment">//如果队列里没有该字符</span><br>                hash.<span class="hljs-built_in">emplace</span>(s[i]);<span class="hljs-comment">//将该字符加入哈希表</span><br>                que.<span class="hljs-built_in">push</span>(s[i]);<span class="hljs-comment">//将该字符加入队列</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                <span class="hljs-keyword">if</span>(que.<span class="hljs-built_in">size</span>() &gt; res) res = que.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//更新长度</span><br>  <br>                <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>() &amp;&amp; que.<span class="hljs-built_in">front</span>() != s[i])&#123;<span class="hljs-comment">//直到队列中重复字母的前一个字符</span><br>                    hash.<span class="hljs-built_in">erase</span>(que.<span class="hljs-built_in">front</span>());<span class="hljs-comment">//将字符从哈希表中去除</span><br>                    que.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//将该元素出队</span><br>                &#125;<br>                que.<span class="hljs-built_in">push</span>(que.<span class="hljs-built_in">front</span>());que.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//将该元素从队头更换至队尾</span><br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(que.<span class="hljs-built_in">size</span>() &gt; res) res = que.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>保持队列里的连续字串没有重复字母</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>        unordered_set&lt;<span class="hljs-keyword">char</span>&gt; hash;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> end = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            <span class="hljs-comment">//去掉重复的字符</span><br>            <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span>) hash.<span class="hljs-built_in">erase</span>(s[i - <span class="hljs-number">1</span>]);  <br><br>            <span class="hljs-keyword">while</span>(end + <span class="hljs-number">1</span> &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; !hash.<span class="hljs-built_in">count</span>(s[end + <span class="hljs-number">1</span>]))&#123;<br>                <span class="hljs-comment">//移动最右侧的指针</span><br>                hash.<span class="hljs-built_in">insert</span>(s[end + <span class="hljs-number">1</span>]);<br>                ++end;<br>            &#125;<br><br>            res = <span class="hljs-built_in">max</span>(res,end - i + <span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>使用滑动窗口，让窗口内的字符串保持没有重复字符。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>字符串</tag>
      
      <tag>队列</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>42. 接雨水</title>
    <link href="/2020/08/16/LeetCode/42.%20%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <url>/2020/08/16/LeetCode/42.%20%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/">本题链接</a></p><h2 id="暴力-单指针"><a href="#暴力-单指针" class="headerlink" title="暴力+单指针"></a>暴力+单指针</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; height)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> size;<br>        <span class="hljs-comment">//空向量判断</span><br>        <span class="hljs-keyword">if</span>((size = height.<span class="hljs-built_in">size</span>()) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//迭代器</span><br>        vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator p = height.<span class="hljs-built_in">begin</span>();<br>        vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator last = height.<span class="hljs-built_in">end</span>();<br>        <span class="hljs-comment">//当前层数</span><br>        <span class="hljs-keyword">int</span> cur_floor_count = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//空格总数</span><br>        <span class="hljs-keyword">int</span> null_count = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//当前层空格数</span><br>        <span class="hljs-keyword">int</span> floor_null_count = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//p迭代器遍历方向</span><br>        <span class="hljs-keyword">bool</span> statue = <span class="hljs-literal">true</span>;<span class="hljs-comment">//true为正向,false为反向</span><br>        <span class="hljs-comment">//数组元素和</span><br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><br>            <span class="hljs-keyword">if</span>(p==height.<span class="hljs-built_in">end</span>())<br>            &#123;<br>                cur_floor_count -= <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>                <br>            <br>            <span class="hljs-keyword">if</span>(*p != <span class="hljs-number">0</span>)<br>                sum += *p;<br><br>            <br><br>            <span class="hljs-comment">//如果碰到柱子</span><br>            <span class="hljs-keyword">if</span>(  (*p) &gt;= cur_floor_count)<br>            &#123;   <br>                <span class="hljs-comment">//判断是不是之前那个柱子，是的话直接退出</span><br>                <span class="hljs-keyword">if</span>(last == p)&#123;<br>                    null_count += floor_null_count;<br>                    sum = sum - *p - (*last-cur_floor_count);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;     <br>                <br>                <span class="hljs-comment">//如果正向遍历，转为反向。</span><br>                <span class="hljs-keyword">if</span>(statue)&#123;<br>                    last = p;<br>                    statue = <span class="hljs-literal">false</span>;<br>                    p = --height.<span class="hljs-built_in">end</span>();&#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">//合计空白块</span><br>                    null_count += floor_null_count;<br>                    <span class="hljs-comment">//置零</span><br>                    floor_null_count = <span class="hljs-number">0</span>;<br>                    <span class="hljs-comment">//遍历层数加1</span><br>                    cur_floor_count ++;<br>                    <span class="hljs-comment">//将迭代器归位</span><br>                    p = height.<span class="hljs-built_in">begin</span>();<br>                    last = height.<span class="hljs-built_in">end</span>();<br>                    <span class="hljs-comment">//重置方向</span><br>                    statue = <span class="hljs-literal">true</span>;<br>                    sum = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;      <br>                <br>            &#125;<span class="hljs-keyword">else</span><br>            &#123;   <br>                floor_null_count++;<br>                statue ? p++ : p--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> size*cur_floor_count - null_count - sum;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a26b608a43eeafca4a79a91a35564a8a-92b3c.png"  /></p><p>依靠一根指针，在每一层找到头尾两根柱子，找到后再往上一层。这样做的用意是找到图中白色区域的数量。</p><p>最后的结果就是这个图中去掉白色和黑色的大小。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刷题笔记</title>
    <link href="/2020/08/14/LeetCode/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/08/14/LeetCode/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h2><ul><li>将全局最优分为局部最优处理</li><li>每一步的最优解一定包含上一步的最优解，上一步之前的最优解无需记录</li><li>贪心不能保证求得的最后解是最佳的，复杂度低</li><li>如果把所有的子问题看成一棵树的话，贪心从根出发，每次向下遍历最优子树即可，这里的最优是贪心意义上的最优。此时不需要知道一个节点的所有子树情况，于是构不成一棵完整的树</li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul><li>全局最优解中一定包含某个局部最优解，但不一定包含上一步的局部最优解，因此需要记录之前的所有的局部最优解</li><li>动态规划需要对每一个子树求最优解，直至下面的每一个叶子的值，最后得到一棵完整的树，在所有子树都得到最优解后，将他们组合成答案</li><li>动态规划本质是<strong>穷举法</strong>，可以保证结果是<strong>最佳的</strong>，<strong>复杂度高</strong></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>对于迭代中，步长可能超过容器边界的情况，可以在预处理时添加哨兵。</li><li>排序需要考虑是否保持元素间的相对次序</li><li>二分查找<ul><li>每次缩减不能排除潜在答案</li><li>对于单调序列使用二分查找十分快捷</li></ul></li><li>如果是求最终状态，那么使用动态规划搜索会比较方便。如果需要所有的路径，那么使用带有状态记录的优先搜索会比较方便。</li></ul><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ul><li>异或^<ul><li>a ^ b ^ c  &lt;=&gt;  a ^ c ^ b  交换律</li><li>x ^ x = 0</li><li>x ^ 0 = x</li></ul></li><li>与&amp;<ul><li>获取n的最低位：n&amp;1</li></ul></li></ul><h2 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h2><h3 id="公因数与公倍数"><a href="#公因数与公倍数" class="headerlink" title="公因数与公倍数"></a>公因数与公倍数</h3><h4 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h4><p>辗转相除法可以获得两个数的<strong>最大公因数</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b,a % b);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>将两个数相乘再除以最大公因数就可以得到<strong>最小公倍数</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a * b ? <span class="hljs-built_in">gcd</span>(a,b);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h3><h4 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h4><blockquote><p>埃氏筛法是非常常用的，判断一个整数是否是质数的方法。并且它可以在判断一个整数n时，同时判断所小于n的整数。其原理也十分易懂：从1到n遍历，假设当前遍历到m，则把所有小于n的、且是m的倍数的整数标记为和数；遍历完成后，没有被标记为和数的数字即为质数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">prime</span><span class="hljs-params">(n + <span class="hljs-number">1</span>,<span class="hljs-literal">true</span>)</span></span>;<span class="hljs-comment">//假设n之前的所有数都为质数</span><br>        <span class="hljs-keyword">int</span> cnt = n - <span class="hljs-number">2</span>;<span class="hljs-comment">//去掉不是质数的0和1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= n; ++i)&#123;<span class="hljs-comment">//从2开始对n遍历</span><br>            <span class="hljs-keyword">if</span>(prime[i])&#123;<span class="hljs-comment">//如果i是质数</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span> * i;j &lt; n;j += i)&#123;<span class="hljs-comment">//寻找i的倍数j</span><br>                    <span class="hljs-keyword">if</span>(prime[j])&#123;<span class="hljs-comment">//如果j依然被标记为质数</span><br>                        prime[j] = <span class="hljs-literal">false</span>;<span class="hljs-comment">//将j的质数标记去除</span><br>                        --cnt;<span class="hljs-comment">//计数-1</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="char和int的互相转换"><a href="#char和int的互相转换" class="headerlink" title="char和int的互相转换"></a>char和int的互相转换</h3><ul><li>char转int：int = char - ‘0’ ；</li><li>int转char：char = int + ‘0’；</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>如果需要一个频繁获取极值并对极值进行操作的容器的话，可以考虑红黑树或堆</li></ul><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>以leetCode210举例</p><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/4188b09cd062e56104d760479ec31ce5-5f753.png" alt=""></p><ul><li>对于有向图基于深度优先搜索的拓扑排序，可总结为：<ul><li>对有向图建立邻接矩阵，并对每个点设置三种遍历情况：<ul><li>未搜索</li><li>搜索中</li><li>搜索完成</li></ul></li><li>遍历邻接矩阵中的每个点，找到未搜索的点，进行深度优先搜索<ul><li>将自己的情况设置为搜索中</li><li>遍历自己的所有邻接节点，逐一对其进行深度优先搜索</li><li>若碰到处于“搜索中”的节点，说明图中出现了环</li><li>对自己的邻接节点遍历完后，此时可以根据需求处理自己，然后将自己的情况设置为搜索完成</li></ul></li></ul></li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    <span class="hljs-comment">//有向图的存储</span><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; edges;<br>    <span class="hljs-comment">//标记每个节点的状态 0:未搜索 1:搜索中 2:已完成</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; visited;<br>    <span class="hljs-comment">//用数组来模拟栈，下标0为栈底，n-1为栈顶</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; result;<br>    <span class="hljs-comment">//判断有向图中是否有环</span><br>    <span class="hljs-keyword">bool</span> valid = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br><br>        <span class="hljs-comment">//对节点状态数组初始化</span><br>        visited.<span class="hljs-built_in">resize</span>(numCourses);<br>        <span class="hljs-comment">//对有向图数组初始化 </span><br>        edges.<span class="hljs-built_in">resize</span>(numCourses);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; info : prerequisites)&#123;<br>            edges[info[<span class="hljs-number">1</span>]].<span class="hljs-built_in">emplace_back</span>(info[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-comment">//每次挑选一个未搜索的节点,开始进行深度优先搜索</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; numCourses &amp;&amp; valid;++i)&#123;<br>            <span class="hljs-keyword">if</span>(!visited[i])&#123;<br>                <span class="hljs-built_in">dfs</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!valid) <span class="hljs-keyword">return</span> &#123;&#125;;<span class="hljs-comment">//如果有环,代表没有拓扑排序</span><br><br>        <span class="hljs-comment">//由于数组是模仿栈的行为,所以应该在返回结果前将数组反转</span><br>        <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(),result.<span class="hljs-built_in">end</span>());<br>        <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;<br><br>        <span class="hljs-comment">//将节点标记为搜索中</span><br>        visited[u] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//搜索其相邻节点</span><br>        <span class="hljs-comment">//只要发现有环，立即停止搜索</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v:edges[u])&#123;<br><br>            <span class="hljs-keyword">if</span>(visited[v] == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//如果这个相邻节点处于未遍历的状态</span><br>                <span class="hljs-built_in">dfs</span>(v);<span class="hljs-comment">//对该节点进行深度优先搜索</span><br>                <span class="hljs-keyword">if</span>(!valid) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//如果过程中出现了环</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(visited[v] == <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//如果这个相邻节点处于正在搜索的状态,那么就说明图中有环出现</span><br>                valid = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//对相邻节点搜索完毕后</span><br>        <span class="hljs-comment">//将自己设置成搜索完成</span><br>        visited[u] = <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//将自己入栈</span><br>        result.<span class="hljs-built_in">push_back</span>(u);<br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><ul><li>对于有向图基于广度优先搜索的拓扑排序，可总结为：<ul><li>创建有向图的邻接矩阵，并创建有向图每个节点的入度表</li><li>将所有入度为0的节点放入队列中</li><li>在队列中，节点的每个邻接节点的入度数量减一<ul><li>若邻接节点的入度数量减一后为0，就将该邻接节点入队</li></ul></li><li>将自己出队</li><li>直到队列为空</li></ul></li><li>若入队的节点数量不等于有向图中的点数，说明图中出现了环路</li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-comment">// 存储有向图</span><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; edges;<br>    <span class="hljs-comment">// 存储每个节点的入度</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; indeg;<br>    <span class="hljs-comment">// 存储答案 </span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br><br>       <span class="hljs-comment">// 入度表初始化</span><br>       indeg.<span class="hljs-built_in">resize</span>(numCourses);<br>       <span class="hljs-comment">// 有向图初始化</span><br>       edges.<span class="hljs-built_in">resize</span>(numCourses);<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; info : prerequisites)&#123;<br>           edges[info[<span class="hljs-number">1</span>]].<span class="hljs-built_in">emplace_back</span>(info[<span class="hljs-number">0</span>]);<br>           ++indeg[info[<span class="hljs-number">0</span>]];<br>       &#125;<br><br>       <span class="hljs-comment">//节点队列</span><br>       queue&lt;<span class="hljs-keyword">int</span>&gt; node_queue;<br>       <span class="hljs-comment">// 将所有入度为0的节点放入队列中</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; numCourses;++i)&#123;<br>           <span class="hljs-keyword">if</span>(indeg[i] == <span class="hljs-number">0</span>)&#123;<br>               node_queue.<span class="hljs-built_in">push</span>(i);<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-keyword">while</span>(!node_queue.<span class="hljs-built_in">empty</span>())&#123;<br>           <span class="hljs-comment">// 从队首取出一个节点</span><br>           <span class="hljs-keyword">int</span> u = node_queue.<span class="hljs-built_in">front</span>();node_queue.<span class="hljs-built_in">pop</span>();<br>           <span class="hljs-comment">// 放入答案中</span><br>           res.<span class="hljs-built_in">emplace_back</span>(u);<br>           <span class="hljs-comment">// 遍历自己的邻接节点</span><br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v:edges[u])&#123;<br>               --indeg[v];<span class="hljs-comment">//将自己邻接节点的入度数量减一</span><br>               <span class="hljs-keyword">if</span>(indeg[v] == <span class="hljs-number">0</span>) node_queue.<span class="hljs-built_in">push</span>(v);<span class="hljs-comment">//如果相邻节点的入度为0,就把相邻节点入队</span><br>           &#125;<br>       &#125;<br><br>       <span class="hljs-comment">//若还有节点的入度不为0 那么说明图中出现了环路</span><br>       <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() != numCourses) <span class="hljs-keyword">return</span> &#123;&#125;;<br><br>       <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>Dijkstra算法是从一个顶点到另一个顶点的最短路径算法，只适用于节点的边都是正数的带权有向图。整体思路 偏向于贪心策略</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/cf5c3906c19ee268200a7f07370b58b3-bbe70.png" style="zoom:50%;" /></p><ul><li>每次从未标记的节点中选择距离出发点最近的节点，标记，收录到最优路径集合中</li><li>计算刚加入节点A的邻近节点B的距离（不包含标记节点），若（节点A的距离+节点A到节点B的边长）&lt; 节点B的距离，就更新节点B的距离和前面点。</li></ul><h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><p>Floyd算法可用于负权值带权图，但是无法解决带有负权<strong>回路</strong>的图。整体思路偏向于动态规划</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5b10b145603e747fd7528464a4434297-d95ce.png" style="zoom:50%;" /></p><p>参考：<a href="https://www.youtube.com/watch?v=XzmTiO3j6p0">最短路径问题 Floyd算法</a></p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> src 0 <span class="hljs-comment">//源节点</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> tar 1 <span class="hljs-comment">//指向的节点</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dist 2 <span class="hljs-comment">//两个节点之间的距离</span></span><br><span class="hljs-comment">//...</span><br><span class="hljs-comment">//Floyd算法</span><br>        <span class="hljs-comment">//中转节点表path 初始化时将所有节点的中转节点设置为-1,因为数组的下标不可能为-1</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">path</span>(n,vector&lt;<span class="hljs-keyword">int</span>&gt;(n,<span class="hljs-number">-1</span>));<br>        <span class="hljs-comment">//最短路径表A 初始化时将所有节点之间的距离设置为无穷大</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">A</span>(n,vector&lt;<span class="hljs-keyword">int</span>&gt;(n,INT_MAX));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; info : edges)&#123;<br>            <span class="hljs-comment">//设置连通节点之间的距离 (无向图) 若是有向图只需设置一个</span><br>            A[info[src]][info[tar]] = info[dist];<br>            A[info[tar]][info[src]] = info[dist];<br>        &#125;<br>        <span class="hljs-comment">//将自己到自己的距离设置为0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; A.<span class="hljs-built_in">size</span>();++i)&#123;<br>            A[i][i] = <span class="hljs-number">0</span>;<br>        &#125;   <br><br><br>        <span class="hljs-comment">//Floyd算法主流程</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;t &lt; n;++t)&#123;<span class="hljs-comment">//逐次的将每个节点当成中转点 </span><br>            <span class="hljs-comment">//对A表中的每个点进行遍历</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;row &lt; n;++row)&#123;<span class="hljs-comment">//逐行 row行表示点A</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>;col &lt; n;++col)&#123;<span class="hljs-comment">//逐列 col列表示点B</span><br>                    <span class="hljs-keyword">if</span>(A[row][t] == INT_MAX || A[t][col] == INT_MAX) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-comment">//如果点A经过中转点到点B的距离比点A直接到点B还小</span><br>                    <span class="hljs-keyword">if</span>(A[row][t] + A[t][col] &lt; A[row][col])&#123;<br>                        A[row][col] = A[row][t] + A[t][col];<span class="hljs-comment">//更新最小的距离</span><br>                        path[row][col] = t;<span class="hljs-comment">//并更新点A到B的中转点</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br><span class="hljs-comment">//...</span><br></code></pre></div></td></tr></table></figure><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">my_priority</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">my_priority</span>()&#123;&#125;<br>    <span class="hljs-built_in">my_priority</span>(<span class="hljs-keyword">int</span> size)&#123;<br>        heap.<span class="hljs-built_in">reserve</span>(size);<br>    &#125;<br><br>    <span class="hljs-comment">//返回堆顶</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span>&amp; <span class="hljs-title">top</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> heap[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-comment">//加入新元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>        heap.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-built_in">swim</span>(heap.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//弹出堆顶</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br><br>        heap[<span class="hljs-number">0</span>] = heap.<span class="hljs-built_in">back</span>();<br>        heap.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-built_in">sink</span>(<span class="hljs-number">0</span>);<br><br>    &#125;<br>    <br>    <span class="hljs-comment">//上滤</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swim</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(pos &gt; <span class="hljs-number">0</span> &amp;&amp; heap[<span class="hljs-built_in">parent</span>(pos)] &lt; heap[pos])&#123;<span class="hljs-comment">//如果大于它的父亲</span><br>            <span class="hljs-built_in">swap</span>(heap[<span class="hljs-built_in">parent</span>(pos)],heap[pos]);<span class="hljs-comment">//交换</span><br>            pos = <span class="hljs-built_in">parent</span>(pos);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//下滤</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sink</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos)</span></span>&#123;<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isLegal</span>(<span class="hljs-built_in">leftChild</span>(pos)))&#123;<span class="hljs-comment">//如果左孩子存在</span><br><br>            <span class="hljs-comment">//选取父子三者中的最大者</span><br>            <span class="hljs-keyword">int</span> max_pos = <span class="hljs-built_in">leftChild</span>(pos);<span class="hljs-comment">//假设最大者是左孩子</span><br>            <span class="hljs-keyword">if</span>(heap[max_pos] &lt;= heap[pos])&#123;<span class="hljs-comment">//如果它比左孩子大</span><br>                max_pos = pos;<span class="hljs-comment">//将新下标更新为自己</span><br>            &#125;<br>            <span class="hljs-comment">//如果右孩子存在 且他的右孩子比他大</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isLegal</span>(<span class="hljs-built_in">rightChild</span>(pos)) &amp;&amp; heap[<span class="hljs-built_in">rightChild</span>(pos)] &gt; heap[max_pos])&#123;<br>                max_pos = <span class="hljs-built_in">rightChild</span>(pos);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(max_pos == pos) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//如果自己是最大者</span><br>            <span class="hljs-built_in">swap</span>(heap[max_pos],heap[pos]);<br>            pos = max_pos;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">//父节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">parent</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; pos)</span> <span class="hljs-keyword">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> (pos - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//左孩子</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">leftChild</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; pos)</span> <span class="hljs-keyword">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + (pos &lt;&lt; <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//右孩子</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rightChild</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; pos)</span> <span class="hljs-keyword">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> + pos) &lt;&lt; <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//是否合法</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isLegal</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; pos)</span> <span class="hljs-keyword">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &lt;= pos &amp;&amp; pos &lt; heap.<span class="hljs-built_in">size</span>();<br>    &#125; <br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; heap;<br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>130. 被围绕的区域</title>
    <link href="/2020/08/13/LeetCode/130.%20%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/"/>
    <url>/2020/08/13/LeetCode/130.%20%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/surrounded-regions/">本题链接</a></p><h2 id="BFS-递归"><a href="#BFS-递归" class="headerlink" title="BFS+递归"></a>BFS+递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> sint;<br>    <span class="hljs-keyword">typedef</span> pair&lt;sint,sint&gt; point;<br>    sint row,col,head,tail,last;<br>    sint dirc[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<span class="hljs-comment">//上 右 下 左</span><br>    vector&lt;point&gt; state_vec;<br>    point new_p;<br>    <span class="hljs-keyword">bool</span> is_touch_J = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br><br>        row = board.<span class="hljs-built_in">size</span>();<br>        col = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); <br>        <br>        <span class="hljs-comment">//异常情况</span><br>        <span class="hljs-keyword">if</span>(row &lt;= <span class="hljs-number">2</span> || col &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-built_in">init</span>(board);<span class="hljs-comment">//O状态:O:空闲 B:待办 J:倒霉</span><br>     <br>        <span class="hljs-keyword">for</span>(sint r = <span class="hljs-number">1</span>;r &lt; row;++r)<br>            <span class="hljs-keyword">for</span>(sint c = <span class="hljs-number">1</span>;c &lt; col;++c)<br>                <span class="hljs-keyword">if</span>(board[r][c] == <span class="hljs-string">&#x27;O&#x27;</span>)&#123;<span class="hljs-built_in">setB</span>(&#123;r,c&#125;,board);<span class="hljs-built_in">bfs</span>(&#123;r,c&#125;,board);<span class="hljs-built_in">isTouchJ</span>(board);<span class="hljs-built_in">setStateVec</span>();&#125;<br>            <br>        <span class="hljs-built_in">draw</span>(board);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStateVec</span><span class="hljs-params">()</span></span>&#123;<br>        last = head = tail = state_vec.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> ;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isTouchJ</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span></span>&#123;<br><br>         <span class="hljs-keyword">if</span>(is_touch_J)&#123;<br>            <span class="hljs-keyword">for</span>(sint i = state_vec.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i &gt; last;--i)<br>                board[state_vec[i].first][state_vec[i].second] = <span class="hljs-string">&#x27;J&#x27;</span>; <br>            is_touch_J = <span class="hljs-literal">false</span>;<br>         &#125;<br>                 <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span></span>&#123;<span class="hljs-comment">//重新还原</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = state_vec.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span> ;--i)&#123;<br>            board[state_vec[i].first][state_vec[i].second] = board[state_vec[i].first][state_vec[i].second] == <span class="hljs-string">&#x27;J&#x27;</span>?<span class="hljs-string">&#x27;O&#x27;</span>:<span class="hljs-string">&#x27;X&#x27;</span>;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setB</span><span class="hljs-params">(<span class="hljs-keyword">const</span> point&amp; p,vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span></span>&#123;<br>        board[p.first][p.second] = <span class="hljs-string">&#x27;B&#x27;</span>;<span class="hljs-comment">//设置该点状态</span><br>        state_vec.<span class="hljs-built_in">push_back</span>(p);<span class="hljs-comment">//保存该点状态</span><br>        ++tail;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> point&amp; p,vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span></span>&#123;<br><br>        <span class="hljs-comment">//对四个方向遍历</span><br>        <span class="hljs-keyword">for</span>(sint d = <span class="hljs-number">0</span>;d &lt; <span class="hljs-number">4</span>;++d)&#123;<br><br>            new_p.first = p.first + dirc[d];<br>            new_p.second = p.second + dirc[d+<span class="hljs-number">1</span>];<br><br>            <span class="hljs-keyword">if</span>(board[new_p.first][new_p.second] != <span class="hljs-string">&#x27;O&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(board[new_p.first][new_p.second] == <span class="hljs-string">&#x27;J&#x27;</span>) is_touch_J = <span class="hljs-literal">true</span>;<span class="hljs-comment">//如果碰到倒霉蛋</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">setB</span>(new_p,board);<br><br>        &#125;<br><br>        <span class="hljs-comment">//广度优先搜索完之后</span><br>        <span class="hljs-keyword">while</span>(++head &lt; state_vec.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-built_in">bfs</span>(&#123;state_vec[head].first,state_vec[head].second&#125;,board);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span></span>&#123;<br><br>        <span class="hljs-comment">//预处理:设置所有边界的O为&quot;倒霉&quot;</span><br>        <span class="hljs-keyword">for</span>(sint i = <span class="hljs-number">0</span>,tmp_row = row - <span class="hljs-number">1</span>;i &lt; col; ++i)&#123;<span class="hljs-comment">//行</span><br>            <span class="hljs-keyword">if</span>(board[<span class="hljs-number">0</span>][i] == <span class="hljs-string">&#x27;O&#x27;</span>)&#123;<br>                state_vec.<span class="hljs-built_in">push_back</span>(point&#123;<span class="hljs-number">0</span>,i&#125;);<br>                board[<span class="hljs-number">0</span>][i] = <span class="hljs-string">&#x27;J&#x27;</span>;<br>            &#125; <br>            <span class="hljs-keyword">if</span>(board[tmp_row][i] == <span class="hljs-string">&#x27;O&#x27;</span>)&#123;<br>                state_vec.<span class="hljs-built_in">push_back</span>(point&#123;tmp_row,i&#125;);<br>                board[tmp_row][i] = <span class="hljs-string">&#x27;J&#x27;</span>;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">for</span>(sint i = <span class="hljs-number">0</span>,tmp_col = col - <span class="hljs-number">1</span>;i &lt; row; ++i)&#123;<span class="hljs-comment">//列</span><br>            <span class="hljs-keyword">if</span>(board[i][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span>)&#123;<br>                state_vec.<span class="hljs-built_in">push_back</span>(point&#123;i,<span class="hljs-number">0</span>&#125;);<br>                board[i][<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;J&#x27;</span>;<br>            &#125; <br>            <span class="hljs-keyword">if</span>(board[i][tmp_col] == <span class="hljs-string">&#x27;O&#x27;</span>)&#123;<br>                state_vec.<span class="hljs-built_in">push_back</span>(point&#123;i,tmp_col&#125;);<br>                board[i][tmp_col] = <span class="hljs-string">&#x27;J&#x27;</span>;<br>            &#125; <br>        &#125;<br><br>        <span class="hljs-built_in">setStateVec</span>();<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将原数组的O设置成三种状态：</p><ul><li>‘O’：没有遍历过的O</li><li>‘B’：遍历过的O</li><li>‘J’：失效的O</li></ul><p>在对一个状态为’O’的O进行广度优先搜索后，只要在过程中碰到一个’J’，那么此次广度优先搜索所涉及的所有O都设置为失效。那么当对所有的点都进行了BFS后，数组中状态为’O’的元素就是被围绕的O。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>图</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>155. 最小栈</title>
    <link href="/2020/08/10/LeetCode/155.%20%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <url>/2020/08/10/LeetCode/155.%20%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/min-stack/">本题链接</a></p><h2 id="两个栈实现"><a href="#两个栈实现" class="headerlink" title="两个栈实现"></a>两个栈实现</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-built_in">MinStack</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br><br>        <span class="hljs-comment">//将参数放入</span><br>        var_s.<span class="hljs-built_in">push</span>(val);<br><br>        <span class="hljs-keyword">int</span> size = var_s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(!min_s.<span class="hljs-built_in">empty</span>() &amp;&amp; min_s.<span class="hljs-built_in">top</span>() &lt; val)&#123;<span class="hljs-comment">//直到min_s.top() &gt;= val</span><br>            var_s.<span class="hljs-built_in">push</span>(min_s.<span class="hljs-built_in">top</span>());<br>            min_s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        min_s.<span class="hljs-built_in">push</span>(val);<span class="hljs-comment">//放入最小栈</span><br>        size = var_s.<span class="hljs-built_in">size</span>() - size;<span class="hljs-comment">//回放次数</span><br>        <span class="hljs-keyword">while</span>(size &gt; <span class="hljs-number">0</span>)&#123;<br>            min_s.<span class="hljs-built_in">push</span>(var_s.<span class="hljs-built_in">top</span>());<br>            var_s.<span class="hljs-built_in">pop</span>();<br>            --size;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(var_s.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">int</span> top = var_s.<span class="hljs-built_in">top</span>();<br>        var_s.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-comment">//找到min_s中与top相等的元素</span><br>        <span class="hljs-keyword">int</span> size = var_s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(top != min_s.<span class="hljs-built_in">top</span>())&#123;<br>            var_s.<span class="hljs-built_in">push</span>(min_s.<span class="hljs-built_in">top</span>());<br>            min_s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-comment">//找到后</span><br>        size = var_s.<span class="hljs-built_in">size</span>() - size;<br>        <span class="hljs-comment">//弹出</span><br>        min_s.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//回写</span><br>        <span class="hljs-keyword">while</span>(size &gt; <span class="hljs-number">0</span>)&#123;<br>            min_s.<span class="hljs-built_in">push</span>(var_s.<span class="hljs-built_in">top</span>());<br>            var_s.<span class="hljs-built_in">pop</span>();<br>            --size;<br>        &#125;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> var_s.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> min_s.<span class="hljs-built_in">top</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><br>    stack&lt;<span class="hljs-keyword">int</span>&gt; var_s;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; min_s;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack* obj = new MinStack();</span><br><span class="hljs-comment"> * obj-&gt;push(val);</span><br><span class="hljs-comment"> * obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * int param_4 = obj-&gt;getMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>var_s用于按照入栈顺序存放的数值</li><li>min_s用于按照元素大小存放的数值，栈顶一定为最小元素</li></ul><p>但是极端情况下太慢了…..</p><h2 id="记录每个时刻的栈最小值"><a href="#记录每个时刻的栈最小值" class="headerlink" title="记录每个时刻的栈最小值"></a>记录每个时刻的栈最小值</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> &#123;</span><br><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>        <span class="hljs-keyword">int</span> var;<br>        <span class="hljs-keyword">int</span> min;<br>    &#125;stact_var;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-built_in">MinStack</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        s.<span class="hljs-built_in">push</span>(&#123;val,s.<span class="hljs-built_in">empty</span>() || val &lt;= <span class="hljs-built_in">getMin</span>() ? val : <span class="hljs-built_in">getMin</span>()&#125;);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        s.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ((stact_var)s.<span class="hljs-built_in">top</span>()).var;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ((stact_var)s.<span class="hljs-built_in">top</span>()).min;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    stack&lt;stact_var&gt; s;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack* obj = new MinStack();</span><br><span class="hljs-comment"> * obj-&gt;push(val);</span><br><span class="hljs-comment"> * obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * int param_4 = obj-&gt;getMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>使用一个栈，然后这个栈的元素由两部分组成，一个是传入的值，还有一个为当前时刻栈中的最小值（包括传入的值）。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Picgo设置腾讯云COS图床</title>
    <link href="/2020/08/09/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Picgo%E8%AE%BE%E7%BD%AE%E8%85%BE%E8%AE%AF%E4%BA%91COS%E5%9B%BE%E5%BA%8A/"/>
    <url>/2020/08/09/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Picgo%E8%AE%BE%E7%BD%AE%E8%85%BE%E8%AE%AF%E4%BA%91COS%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-设置COS版本"><a href="#1-设置COS版本" class="headerlink" title="1. 设置COS版本"></a>1. 设置COS版本</h2><p>设置为v5</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-04_18-43-06.png" alt="设置COS版本"></p><h2 id="2-设置SecretId、SecretKey和APPID"><a href="#2-设置SecretId、SecretKey和APPID" class="headerlink" title="2. 设置SecretId、SecretKey和APPID"></a>2. 设置SecretId、SecretKey和APPID</h2><p>打开腾讯云COS控制台，进入API密钥管理。找到<strong>SecretId</strong>、<strong>SecretKey</strong>和<strong>APPID</strong>并填入。若无密钥请先新建。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-04_18-44-10.png" alt="密钥管理"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-04_18-45-34.png" alt="密钥管理"></p><h2 id="3-设置存储空间名和存储区域"><a href="#3-设置存储空间名和存储区域" class="headerlink" title="3. 设置存储空间名和存储区域"></a>3. 设置存储空间名和存储区域</h2><p>创建存储桶时，关键的一步是要将权限设置为公有读私有写。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-04_18-52-11.png" alt="创建存储桶"></p><p><strong>存储空间名</strong>填入<strong>存储桶名称</strong>，然后<strong>存储区域</strong>填入<strong>所属地域</strong>，后面括号里面的内容。比如我的是ap-shanghai。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-04_18-53-10.png" alt="存储桶列表"></p><h2 id="4-设置指定存储路径"><a href="#4-设置指定存储路径" class="headerlink" title="4. 设置指定存储路径"></a>4. 设置指定存储路径</h2><p>这个存储路径指的是，你上传的文件在COS存储桶中所存放的位置。比如我的存储桶名称是左上角的images-12577xxxxx，然后我在这个存储桶中创建了一个blogs文件夹。现在我想把我上传的图片放在blogs文件夹里，那PicGo中的存储路径就要填入<strong>blogs/</strong>(bilogs后面的<strong>/</strong>不能省略)。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-04_18-55-26.png" alt="设置指定存储路径"></p><h2 id="5-设定自定义域名"><a href="#5-设定自定义域名" class="headerlink" title="5. 设定自定义域名"></a>5. 设定自定义域名</h2><p>这个自定义域名与PicGo在你上传图片成功后返回的网址相关，格式为<strong><a href="https://存储桶名称.cos.存储区域.myqcloud.com">https://存储桶名称.cos.存储区域.myqcloud.com</a></strong>。</p><p>比如我的是<a href="https://images-1257780535.cos.ap-shanghai.myqcloud.com。">https://images-1257780535.cos.ap-shanghai.myqcloud.com。</a></p><p>当我上传图片以后，PicGo返回给我一个<strong><a href="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-04_18-55-26.png">https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/Snipaste_2021-02-04_18-55-26.png</a></strong>这个网址，将这个网址粘贴到你写的markdown文件即可。</p><h2 id="6-最终效果"><a href="#6-最终效果" class="headerlink" title="6. 最终效果"></a>6. 最终效果</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210204192315.png" alt="最终效果1"  /></p><p>图片上传后，在腾讯云COS中的指定路径下能找到上传的图片，就说明成功了。</p>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>腾讯云</tag>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>48. 旋转图像</title>
    <link href="/2020/07/23/LeetCode/48.%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <url>/2020/07/23/LeetCode/48.%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="本题链接"><a href="#本题链接" class="headerlink" title="本题链接]"></a><a href="https://leetcode-cn.com/problems/rotate-image/">本题链接]</a></h1><h2 id="普通矩阵"><a href="#普通矩阵" class="headerlink" title="普通矩阵"></a>普通矩阵</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;r &lt; (n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;++r)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;c &lt; n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;++c)&#123;<br>                <span class="hljs-built_in">swap</span>(matrix[r][c],matrix[c][n-r]);<br>                <span class="hljs-built_in">swap</span>(matrix[r][c],matrix[n-r][n-c]);<br>                <span class="hljs-built_in">swap</span>(matrix[r][c],matrix[n-c][r]);<br>            &#125;<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>画图后观察发现，对一个矩阵的旋转只需要操作其中的前面四分之一区域(边长为奇数和偶数有细微差别)，每次迭代操作只需要互相交换4个点的值即可。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>70. 爬楼梯</title>
    <link href="/2020/07/23/LeetCode/70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <url>/2020/07/23/LeetCode/70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/climbing-stairs/">本题链接</a></p><h2 id="动态规划-剪枝-哈希表"><a href="#动态规划-剪枝-哈希表" class="headerlink" title="动态规划+剪枝+哈希表"></a>动态规划+剪枝+哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br><br>        map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; cs_map&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;&#125;;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>;i &lt;= n + <span class="hljs-number">1</span>;++i)<br>            cs_map.<span class="hljs-built_in">insert</span>(&#123;i,cs_map[i<span class="hljs-number">-1</span>] + cs_map[i<span class="hljs-number">-2</span>]&#125;);<br>            <br>        <span class="hljs-keyword">return</span> cs_map[n+<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题实际上就是斐波那契数列…</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br><br>        <span class="hljs-keyword">int</span> p1 = <span class="hljs-number">1</span>,p2 = <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt; n;++i)&#123;<br>            p2 = p1 + p2;<br>            p1 = p2 - p1;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p2;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这题实际上就是斐波那契数列…</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>动态规划</tag>
      
      <tag>剪枝</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>33. 搜索旋转排序数组</title>
    <link href="/2020/07/01/LeetCode/33.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2020/07/01/LeetCode/33.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">本题链接</a></p><h2 id="二分搜索-分治"><a href="#二分搜索-分治" class="headerlink" title="二分搜索+分治"></a>二分搜索+分治</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,mid;<br><br>        <span class="hljs-comment">//分情况讨论</span><br>        <span class="hljs-keyword">if</span>(target &gt; nums[<span class="hljs-number">0</span>])&#123;<span class="hljs-comment">//如果target在断层前</span><br><br>            <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br><br>                mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(nums[mid] &gt;= nums[left])&#123;<span class="hljs-comment">//[left,right)区间连续</span><br><br>                    <span class="hljs-keyword">if</span>(target &lt; nums[mid]) right = mid - <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &gt; nums[mid]) left = mid + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br><br>                &#125;<span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>;<span class="hljs-comment">//[left,right)区间不连续</span><br>                <br>            &#125;<br><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &lt; nums[<span class="hljs-number">0</span>])&#123;<span class="hljs-comment">//如果target在断层后</span><br><br>            <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br><br>                mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(nums[mid] &lt; nums[right])&#123;<span class="hljs-comment">//[left,right)区间连续</span><br><br>                    <span class="hljs-keyword">if</span>(target &lt; nums[mid]) right = mid - <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &gt; nums[mid]) left = mid + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br><br>                &#125;<span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//[left,right)区间不连续</span><br>            &#125;<br><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//直接命中</span><br>        <br>        <span class="hljs-keyword">return</span> nums[left] == target ? left:<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>整体复杂度已经达到进阶的$O(log_2{n})$​​。先满足[left,right)区间连续，再使用正常的二分搜索就行。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>二分搜索</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>136. 只出现一次的数字</title>
    <link href="/2020/06/30/LeetCode/136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2020/06/30/LeetCode/136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/single-number/">本题链接</a></p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; num:nums)&#123;<br>            res ^= num;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据异或的性质：</p><ul><li>a ^ b ^ c &lt;=&gt; a ^ c ^ b 交换律</li><li>a ^ a = 0</li><li>a ^ 0 = a</li></ul><p>不停的异或数组里的所有值，由于两个相同的数异或会等于0，那么最后剩下的结果就是数组中个数只有一个的数。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>26. 删除有序数组中的重复项</title>
    <link href="/2020/06/27/LeetCode/26.%20%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <url>/2020/06/27/LeetCode/26.%20%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">本题链接</a></p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="版本一：从前至后"><a href="#版本一：从前至后" class="headerlink" title="版本一：从前至后"></a>版本一：从前至后</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">int</span> org = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> next = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(next &lt;= nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[org] == nums[next]) nums.<span class="hljs-built_in">erase</span>(nums.<span class="hljs-built_in">begin</span>()+next);<br>            <span class="hljs-keyword">else</span> &#123;++org;++next;&#125;<br>        &#125;<br><br><br>        <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>从前至后太慢了…vector的属性导致它删除会有$O(n)$的复杂度！</li></ul><h3 id="版本二：从后至前"><a href="#版本二：从后至前" class="headerlink" title="版本二：从后至前"></a>版本二：从后至前</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">int</span> org = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> prev = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">while</span>( prev &gt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[org] == nums[prev]) nums.<span class="hljs-built_in">erase</span>(nums.<span class="hljs-built_in">begin</span>() + prev);<br>            --org;<br>            --prev;<br>        &#125;<br><br><br>        <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用双指针判断前后两个值是否相等。</p><p>版本一和版本二的差距很明显：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/ea0f37690922c0803905879f8dbcd0cc-5bf58.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>912. 排序数组</title>
    <link href="/2020/06/26/LeetCode/912.%20%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2020/06/26/LeetCode/912.%20%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/sort-an-array/">本题链接</a></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <br>        <span class="hljs-comment">//归并排序 </span><br>        <span class="hljs-comment">//创建辅助空间</span><br>        <span class="hljs-keyword">int</span>* buf = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>((nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>));<br>        <span class="hljs-built_in">merge</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>,buf);<br>        <span class="hljs-built_in">free</span>(buf);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> lo,<span class="hljs-keyword">int</span> hi,<span class="hljs-keyword">int</span>* buf)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(hi == lo) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//递归基</span><br>        <span class="hljs-keyword">if</span>(lo + <span class="hljs-number">1</span> == hi)<span class="hljs-comment">//特殊情况:两个元素</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[lo] &gt; nums[hi]) <span class="hljs-built_in">swap</span>(nums[lo],nums[hi]);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//排序左边</span><br>        <span class="hljs-built_in">merge</span>(nums,lo,mid,buf);<br>        <span class="hljs-comment">//排序右边 </span><br>        <span class="hljs-built_in">merge</span>(nums,mid+<span class="hljs-number">1</span>,hi,buf);<br><br>        <span class="hljs-keyword">int</span> pos = hi-mid<span class="hljs-number">-1</span>;<span class="hljs-comment">//指向缓冲区的指针</span><br>        <span class="hljs-comment">//将右边存入缓冲区</span><br>        <span class="hljs-built_in">memcpy</span>((<span class="hljs-keyword">char</span>*)buf,(<span class="hljs-keyword">char</span>*)&amp;nums[mid+<span class="hljs-number">1</span>],(pos+<span class="hljs-number">1</span>)*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>));<br>        <br>        <span class="hljs-keyword">while</span>(mid &gt;= lo &amp;&amp; pos &gt;= <span class="hljs-number">0</span>)&#123;<br><br>            <span class="hljs-keyword">if</span>(*(buf + pos) &lt; nums[mid]) nums[hi--] = nums[mid--];<br>            <span class="hljs-keyword">else</span> nums[hi--] = *(buf + pos--);<br><br>        &#125;<br>        <span class="hljs-comment">//如果缓冲区还有元素</span><br>        <span class="hljs-keyword">while</span>(pos &gt;= <span class="hljs-number">0</span>) nums[hi--] = *(buf + pos--);<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>比较重要的是需要将右边区间的元素放入缓冲区，然后从整个区间的最后开始遍历,逐一覆盖。最后需要判断缓冲区内是否还有剩余元素未判断，若有的话需要将这些元素放入原来的区间内。</p><h2 id="起泡排序跳跃版"><a href="#起泡排序跳跃版" class="headerlink" title="起泡排序跳跃版"></a>起泡排序跳跃版</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">//起泡排序跳跃版</span><br><br>        <span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>,hi = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,last;<br>        <span class="hljs-keyword">while</span>(hi &gt; (lo = <span class="hljs-number">0</span>))&#123;<br>            <br>            <span class="hljs-keyword">while</span>(lo &lt; hi)&#123;<br><br>                <span class="hljs-keyword">if</span>(nums[lo] &gt; nums[lo + <span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-built_in">swap</span>(nums[lo], nums[lo + <span class="hljs-number">1</span>]);<br>                    last = ++lo;<br>                &#125;<span class="hljs-keyword">else</span> ++lo;<br><br>            &#125;<br>            hi = --last;<br>        &#125;<br>       <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>重要的不是思路，重要的是超时了…..</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">//快速排序</span><br>        <span class="hljs-built_in">quickSearch</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> nums; <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSearch</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> lo,<span class="hljs-keyword">int</span> hi)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!(lo &lt; hi)) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">swap</span>(nums[lo], nums[lo + <span class="hljs-built_in">rand</span>() % ( hi - lo )]);<br>        <span class="hljs-keyword">int</span> target = nums[lo];<br>        <span class="hljs-keyword">int</span> len = hi  + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> mi = lo ;<span class="hljs-comment">//边界</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = lo + <span class="hljs-number">1</span>;i &lt; len; ++i)<br>            <span class="hljs-keyword">if</span>(nums[i] &lt;= target) <span class="hljs-built_in">swap</span>(nums[++mi],nums[i]);<br>          <br>        <span class="hljs-comment">//轴点归位</span><br>        <span class="hljs-built_in">swap</span>(nums[mi],nums[lo]);<br>        <span class="hljs-comment">//对L区间进行快速搜索</span><br>        <span class="hljs-built_in">quickSearch</span>(nums,lo,mi - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//对G区间进行快速搜索</span><br>        <span class="hljs-built_in">quickSearch</span>(nums,mi + <span class="hljs-number">1</span>,hi);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>遵循分而治之的策略，先将轴点进行归位，此时的轴点之前是小于等于轴点的元素，轴点之后是大于轴点的元素。</p><p>然后分别对轴点的左边和右边进行快速搜索。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  Parent(i)         ( ( ( i ) - 1 ) &gt;&gt; 1 ) <span class="hljs-comment">//PQ[i]的父节点（floor((i-1)/2)，i无论正负）</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  LChild(i)         ( 1 + ( ( i ) &lt;&lt; 1 ) ) <span class="hljs-comment">//PQ[i]的左孩子</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  RChild(i)         ( ( 1 + ( i ) ) &lt;&lt; 1 ) <span class="hljs-comment">//PQ[i]的右孩子</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  InHeap(n, i)      ( ( ( -1 ) &lt; ( i ) ) &amp;&amp; ( ( i ) &lt; ( n ) ) ) <span class="hljs-comment">//判断PQ[i]是否合法</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  LChildValid(n, i) InHeap( n, LChild( i ) ) <span class="hljs-comment">//判断PQ[i]是否有一个（左）孩子</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  RChildValid(n, i) InHeap( n, RChild( i ) ) <span class="hljs-comment">//判断PQ[i]是否有两个孩子</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  Smaller(PQ, i, j)  ( !lt( PQ[i], PQ[j] ) ? j : i ) <span class="hljs-comment">//取大者（等时前者优先）</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  ProperParent(PQ, n, i) <span class="hljs-comment">/*父子（至多）三者中的大者*/</span> \</span><br><span class="hljs-meta">            ( RChildValid(n, i) ? Smaller( PQ, Smaller( PQ, i, LChild(i) ), RChild(i) ) : \</span><br><span class="hljs-meta">            ( LChildValid(n, i) ? Smaller( PQ, i, LChild(i) ) : i \</span><br><span class="hljs-meta">            ) \</span><br><span class="hljs-meta">            ) <span class="hljs-comment">//相等时父节点优先，如此可避免不必要的交换</span></span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">lt</span> <span class="hljs-params">( T&amp; a, T&amp; b )</span> </span>&#123; <span class="hljs-keyword">return</span> a &lt; b; &#125; <span class="hljs-comment">//less than</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(nums.size(),<span class="hljs-number">0</span>)</span></span>;<br><br>        <span class="hljs-comment">//堆排序</span><br>        <span class="hljs-comment">//先建堆 floyd算法 自下而上的进行下滤 排除叶子节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = nums.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<span class="hljs-number">0</span> &lt;= i;--i)<br>            <span class="hljs-built_in">percolateDown</span>(nums,i,nums.<span class="hljs-built_in">size</span>());<br>        <br>        <span class="hljs-comment">//自上而下的下滤</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; res.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            res[i] = nums[<span class="hljs-number">0</span>];<br>            nums[<span class="hljs-number">0</span>] = nums[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> - i];<br>            <span class="hljs-built_in">percolateDown</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>() - i - <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">//下滤操作 将较大的数进行下滤</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">percolateDown</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; num,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> numSize)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> j; <span class="hljs-comment">//i及其（至多两个）孩子中，堪为父者</span><br>        <span class="hljs-keyword">while</span> ( i != ( j = <span class="hljs-built_in">ProperParent</span> (num,numSize, i)))  <span class="hljs-comment">//只要i非j，则</span><br>            <span class="hljs-built_in">swap</span>(num[i], num[j] ); i = j; <span class="hljs-comment">//二者换位，并继续考查下降后的i</span><br>        <span class="hljs-keyword">return</span> i; <span class="hljs-comment">//返回下滤抵达的位置（亦i亦j）</span><br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>先对原数组从尾巴到头的下滤操作，完成后数组的形式是个小顶堆。然后依次将堆顶元素（最小）取出，将此时的堆的最后一个元素放到堆顶（为了保持堆序性，同样也是从原数组的末尾开始向前遍历），再进行对堆顶的下滤操作。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <br>    <span class="hljs-comment">//选择排序</span><br>        <span class="hljs-keyword">int</span> min;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;nums.<span class="hljs-built_in">size</span>();++i)&#123;<br><br>            min = i;<br>            <span class="hljs-comment">//找到最小的</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i;j &lt;nums.<span class="hljs-built_in">size</span>();++j)<br>                <span class="hljs-keyword">if</span>(nums[min] &gt;= nums[j]) min = j;<br><br>            <span class="hljs-built_in">swap</span>(nums[min],nums[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>重要的不是思路，重要的是超时了…..</p><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">//计数排序</span><br>        map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; i_map;<br>        <span class="hljs-comment">//先存放数组到map中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">if</span>(i_map.<span class="hljs-built_in">find</span>(nums[i]) == i_map.<span class="hljs-built_in">end</span>()) i_map.<span class="hljs-built_in">insert</span>(&#123;nums[i],<span class="hljs-number">1</span>&#125;);<br>            <span class="hljs-keyword">else</span> ++i_map[nums[i]];<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;pair:i_map)&#123;<br><br>            <span class="hljs-keyword">while</span>(pair.second != <span class="hljs-number">0</span>)&#123;<br>                nums[pos++] = pair.first;<br>                --pair.second;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>先保存每个数出现的次数到map中，然后再依次从map取出对应数量的每个数到原数组中。</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br><span class="hljs-keyword">typedef</span> multimap&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;::iterator multimapit;<br><span class="hljs-keyword">typedef</span> pair&lt;multimapit,multimapit&gt; pairit;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        multimap&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; p_multimap;<br>        <br>        <span class="hljs-comment">//基数排序</span><br>        <span class="hljs-comment">//获得最大值</span><br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(nums[i]) &gt; max) max = <span class="hljs-built_in">abs</span>(nums[i]);<br>        &#125;<br>        <span class="hljs-comment">//获得最高的位数</span><br>        <span class="hljs-keyword">int</span> max_digit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">do</span>&#123;<br>            max = max/<span class="hljs-number">10</span>;<br>            ++max_digit;<br>        &#125;<span class="hljs-keyword">while</span>(max != <span class="hljs-number">0</span>);<br>       <br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> digit = <span class="hljs-number">1</span>;digit &lt;= max_digit;++digit)&#123;<br><br>            <span class="hljs-keyword">int</span> get_remainder = <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,digit);<span class="hljs-comment">//求余</span><br>            <span class="hljs-keyword">int</span> get_quotient = get_remainder/<span class="hljs-number">10</span>;<span class="hljs-comment">//求商</span><br>            <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<span class="hljs-comment">//数组索引</span><br><br>            <span class="hljs-comment">//遍历整个数组</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;index &lt; nums.<span class="hljs-built_in">size</span>();++index)<br>                p_multimap.<span class="hljs-built_in">insert</span>(&#123;nums[index]%get_remainder/get_quotient,nums[index]&#125;);<br><br>            <span class="hljs-comment">//从multimap取出到nums</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">-9</span>;i &lt;= <span class="hljs-number">9</span>;++i)&#123;<br><br>                <span class="hljs-keyword">if</span>(p_multimap.<span class="hljs-built_in">find</span>(i) == p_multimap.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">continue</span>;<br><br>                <span class="hljs-comment">//获得key</span><br>                pairit pit = p_multimap.<span class="hljs-built_in">equal_range</span>(i);<br>                <span class="hljs-keyword">for</span>(multimapit mit = pit.first;mit!=pit.second;++mit)&#123;<br>                    nums[pos++] = mit-&gt;second;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">//清空</span><br>            p_multimap.<span class="hljs-built_in">clear</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums;   <br>    &#125;   <br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>按照低位到高位的顺序进行排序，可优化的地方很多。</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DIFFERENCE_VALUE 1000 <span class="hljs-comment">//桶中的元素以1000来分隔</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">//桶排序</span><br>        map&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;*&gt; t_map;<br>        <br>        <span class="hljs-comment">//入桶</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>            <span class="hljs-keyword">int</span> key = <span class="hljs-built_in">get_key</span>(nums[i]);<br>            <span class="hljs-keyword">if</span>(t_map.<span class="hljs-built_in">find</span>(key) == t_map.<span class="hljs-built_in">end</span>()) t_map.<span class="hljs-built_in">insert</span>(&#123;key,<span class="hljs-keyword">new</span> vector&#123;nums[i]&#125;&#125;);<br>            <span class="hljs-keyword">else</span> ((vector&lt;<span class="hljs-keyword">int</span>&gt;*)t_map[key])-&gt;<span class="hljs-built_in">push_back</span>(nums[i]);<br>        &#125;<br><br>        <span class="hljs-comment">//桶排序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; bucket:t_map)<br>            <span class="hljs-built_in">sort</span>(((vector&lt;<span class="hljs-keyword">int</span>&gt;*)bucket.second)-&gt;<span class="hljs-built_in">begin</span>(),((vector&lt;<span class="hljs-keyword">int</span>&gt;*)bucket.second)-&gt;<span class="hljs-built_in">end</span>());<br>        <br>        <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//出桶</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; bucket:t_map)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; digit:*((vector&lt;<span class="hljs-keyword">int</span>&gt;*)bucket.second))<br>                nums[pos++] = digit;<br><br>            <span class="hljs-built_in"><span class="hljs-keyword">delete</span></span> (vector&lt;<span class="hljs-keyword">int</span>&gt;*)bucket.second;<br>        &#125;<br>            <br>        <span class="hljs-keyword">return</span> nums;   <br>    &#125;   <br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get_key</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; k)</span> <span class="hljs-keyword">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> k?k/DIFFERENCE_VALUE:<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>本想使用hash_map，自定义哈希函数,编译不通过…原因是hash_map不是STL所提供使用的，他只是个底层容器。</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">//希尔排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = <span class="hljs-number">0x3FFFFFFF</span>; <span class="hljs-number">0</span> &lt; d; d &gt;&gt;= <span class="hljs-number">1</span> )&#123;<span class="hljs-comment">//构建素数&#123; 1, 3, 7, 15, ..., 1073741823 &#125;</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = d; j &lt; nums.<span class="hljs-built_in">size</span>(); j++ ) &#123;<br>                <span class="hljs-keyword">int</span> tmp = nums[j],i = j - d;<span class="hljs-comment">//tmp为当前数组值,i为该列的第一个值的下标</span><br>                <span class="hljs-keyword">while</span>(<span class="hljs-number">0</span> &lt;= i &amp;&amp; nums[i]&gt;tmp)&#123;<span class="hljs-comment">//从列的下方开始,若条件满足,则往上交换</span><br>                    nums[i+d] = nums[i];<br>                    i-=d;<br>                &#125; <br>                nums[i+d] = tmp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;   <br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>当步长集合中，其中的各项并非互素，因此每一轮的排序都有大量的精力浪费于对前一轮排序工作的重复之上。所以，步长集合中，相邻项需要尽可能的互素。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>快速排序</tag>
      
      <tag>计数排序</tag>
      
      <tag>归并排序</tag>
      
      <tag>起泡排序</tag>
      
      <tag>堆排序</tag>
      
      <tag>选择排序</tag>
      
      <tag>基数排序</tag>
      
      <tag>桶排序</tag>
      
      <tag>希尔排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>633. 平方数之和</title>
    <link href="/2020/06/25/LeetCode/633.%20%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2020/06/25/LeetCode/633.%20%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/">本题链接</a></p><h2 id="双指针-暴力"><a href="#双指针-暴力" class="headerlink" title="双指针+暴力"></a>双指针+暴力</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judgeSquareSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123;<br><br>        <span class="hljs-keyword">long</span> l = <span class="hljs-number">0</span>,r = (<span class="hljs-keyword">long</span>)<span class="hljs-built_in">sqrt</span>(c),res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l &lt;= r)<br>        &#123;   <br>            res = l*l + r*r;<br><br>            <span class="hljs-keyword">if</span>(res == c) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res &gt; c) r--;<br>            <span class="hljs-keyword">else</span> l++;<br>            <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res == c;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>前后双指针的边界分别是0和目标值的开方。然后每次迭代两边的指针根据结果和目标值的对比进行移动。</p><h2 id="双平方定理"><a href="#双平方定理" class="headerlink" title="双平方定理"></a>双平方定理</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judgeSquareSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(c &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">//素因数分解</span><br>        <span class="hljs-keyword">while</span>(c % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) c = c/<span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">int</span> p = <span class="hljs-number">3</span>,index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(p*p &lt;= c)<br>        &#123;<br>            index = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(c % p == <span class="hljs-number">0</span>)<br>            &#123;<br>               ++index;<br>               c = c / p; <br>            &#125;<br><br>            <span class="hljs-keyword">if</span>( p % <span class="hljs-number">4</span> == <span class="hljs-number">3</span> &amp;&amp; index % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>            p+=<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c % <span class="hljs-number">4</span> == <span class="hljs-number">1</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>双指针</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>113. 路径总和 II</title>
    <link href="/2020/06/20/LeetCode/113.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20II/"/>
    <url>/2020/06/20/LeetCode/113.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20II/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/path-sum-ii/">本题链接</a></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-keyword">int</span> targetSum) &#123;<br>        <span class="hljs-built_in">hasPathSum</span>(root,targetSum);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;   <br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; targetSum)</span> </span>&#123;<br><br>        <span class="hljs-comment">//出现在节点只有一个孩子的向下递归情况</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <br>        tmp.<span class="hljs-built_in">push_back</span>(root-&gt;val);<span class="hljs-comment">//保存自己的值</span><br><br>        <span class="hljs-comment">//出现在叶子节点</span><br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;<br>            <span class="hljs-keyword">if</span>(targetSum == root-&gt;val) res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">hasPathSum</span>(root-&gt;left,targetSum - root-&gt;val);<br>            <span class="hljs-built_in">hasPathSum</span>(root-&gt;right,targetSum - root-&gt;val);  <br>        &#125;<br>        <br>        tmp.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//返回上一个函数时拿出自己的值</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题思路与&lt;&lt;<strong>112. 路径总和</strong>&gt;&gt;一致。特别注意的是递归到当前时刻的条件不可被改变，所以加了个<strong>const</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>167. 两数之和 II - 输入有序数组</title>
    <link href="/2020/06/14/LeetCode/167.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2020/06/14/LeetCode/167.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">本题链接</a></p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">int</span> r = numbers.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; <br><br>        <span class="hljs-keyword">while</span>(l!=r)&#123;<br><br>            <span class="hljs-keyword">if</span>((numbers[l] + numbers[r]) == target) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((numbers[l] + numbers[r]) &gt; target) r--;<br>            <span class="hljs-keyword">else</span> l++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;l+<span class="hljs-number">1</span>,r+<span class="hljs-number">1</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为是排好序的数组，所以只要两个指针分别从头尾往内移动，然后判断和目标值的大小，来决定要移动哪个指针。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 两数之和</title>
    <link href="/2020/06/12/LeetCode/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2020/06/12/LeetCode/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/two-sum/">本题链接</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br><br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; dig_map;<br>        <br>        <span class="hljs-comment">//以&#123;nums[i],i&#125;的形式存入哈希表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;nums.<span class="hljs-built_in">size</span>();++i)<br>            <span class="hljs-keyword">if</span>(dig_map.<span class="hljs-built_in">find</span>(nums[i]) == dig_map.<span class="hljs-built_in">end</span>())<span class="hljs-comment">//如果哈希表没记录</span><br>                dig_map[nums[i]] = i;<span class="hljs-comment">//存入哈希表</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*nums[i] == target)<span class="hljs-comment">//如果哈希表有记录,判断是否这个值的两倍是否为目标值</span><br>                <span class="hljs-keyword">return</span> &#123;dig_map[nums[i]],i&#125;;<br>                <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; [digit,_]:dig_map)<br>            <span class="hljs-keyword">if</span>(dig_map.<span class="hljs-built_in">find</span>(target - digit) != dig_map.<span class="hljs-built_in">end</span>())<span class="hljs-comment">//找到目标值</span><br>                <span class="hljs-keyword">return</span> &#123;dig_map[target - digit],dig_map[digit]&#125;;<br><br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用哈希表存储值和它的下标，然后再去哈希表中查找是否有两者值的和为目标值的元素，若存在，就返回。</p><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;++i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>;j &lt; nums.<span class="hljs-built_in">size</span>();++j)<br>                <span class="hljs-keyword">if</span>(nums[i] + nums[j] == target) <span class="hljs-keyword">return</span> &#123;i,j&#125;;<br><br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>思路不重要，思路很直观，如果数据量很小的话感觉暴力算法甚至更快</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>暴力</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15.三数之和</title>
    <link href="/2020/06/12/LeetCode/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2020/06/12/LeetCode/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/3sum/">本题链接</a></p><h2 id="双指针-暴力"><a href="#双指针-暴力" class="headerlink" title="双指针+暴力"></a>双指针+暴力</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;  <br>        <br>        <span class="hljs-comment">//异常情况</span><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-comment">//结果</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>        <span class="hljs-comment">//排序数组</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">//记录上一个开始的数,防止出现对同一个第一个值,以导致重复结果的出现</span><br>        <span class="hljs-keyword">int</span> last_first = nums[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//双指针搜索</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i)&#123;<span class="hljs-comment">//设置第一个值</span><br><br>            <span class="hljs-comment">//如果和上一趟遍历的值相同,就跳过此次循环</span><br>            <span class="hljs-comment">//避免数组为&#123;-3,-3,1,2&#125;,i = 0和i = 1的情况时</span><br>            <span class="hljs-comment">//重复写入&#123;-3,1,2&#125;的情况发生</span><br>            <span class="hljs-keyword">if</span>(last_first == nums[i]) <span class="hljs-keyword">continue</span>;<br>            last_first = nums[i];<span class="hljs-comment">//设置上一次开始的数</span><br>            <span class="hljs-keyword">int</span> target = <span class="hljs-number">0</span> - nums[i];<span class="hljs-comment">//设置目标值</span><br>            <span class="hljs-keyword">int</span> last_second = nums[i] - <span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> last_third = nums[i] - <span class="hljs-number">1</span>;<span class="hljs-comment">//设置上一次保存的结果值</span><br>            <span class="hljs-keyword">int</span> left = i + <span class="hljs-number">1</span>,right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-comment">//设置头尾指针</span><br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br><br>                <span class="hljs-keyword">int</span> loop_res = nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span>(loop_res == target)&#123;<br>                    <span class="hljs-comment">//如果与上一次的保存的结果值不相等</span><br>                    <span class="hljs-comment">//避免数组为&#123;-3,1,1,2,2&#125;,i = 0的情况时</span><br>                    <span class="hljs-comment">//重复写入&#123;-3,1,2&#125;的情况发生</span><br>                    <span class="hljs-keyword">if</span>(nums[left] != last_second &amp;&amp; nums[right] != last_third)&#123;<br>                        res.<span class="hljs-built_in">push_back</span>(&#123;nums[i],nums[left],nums[right]&#125;);<span class="hljs-comment">//保存结果</span><br>                        last_second = nums[left];last_third = nums[right];<span class="hljs-comment">//设置此次的结果</span><br>                    &#125;<br>                    ++left;--right;<span class="hljs-comment">//排序后的数组不会出现跳过隐藏答案的情况</span><br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(loop_res &gt; target) --right;  <br>                <span class="hljs-keyword">else</span> ++left;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先对原数组排序，然后使用两次循环，第一层循环选择一个目标值，第二层循环在数组中寻找两个与目标值相加等于0的元素。</p><p>注意需要保存上一次第一层循环选择的数，和第二层循环加入结果的两个值，这三个用于去重操作。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>18. 四数之和</title>
    <link href="/2020/06/12/LeetCode/18.%20%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2020/06/12/LeetCode/18.%20%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/4sum/">本题链接</a></p><h2 id="双指针-暴力"><a href="#双指针-暴力" class="headerlink" title="双指针+暴力"></a>双指针+暴力</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target) &#123;<br><br>        <span class="hljs-comment">//异常情况</span><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-comment">//结果</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>        <span class="hljs-comment">//排序数组</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <br>        <span class="hljs-keyword">int</span> last_first = nums[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">3</span>;++i)&#123;<span class="hljs-comment">//设置第一个值</span><br><br>            <span class="hljs-keyword">if</span>(last_first == nums[i]) <span class="hljs-keyword">continue</span>;<br>            last_first = nums[i];<span class="hljs-comment">//设置上一次开始的数</span><br><br>            <span class="hljs-keyword">int</span> last_second = nums[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>;j &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>;++j)&#123;<span class="hljs-comment">//设置第二个值</span><br><br>                <span class="hljs-keyword">if</span>(last_second == nums[j]) <span class="hljs-keyword">continue</span>;<br>                last_second = nums[j];<span class="hljs-comment">//设置上一次开始的数</span><br><br>                <span class="hljs-keyword">int</span> loop_target = target - (nums[i] + nums[j]);<span class="hljs-comment">//设置目标值</span><br>                <span class="hljs-keyword">int</span> last_third = nums[i] - <span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> last_fourth = nums[i] - <span class="hljs-number">1</span>;<span class="hljs-comment">//设置上一次保存的结果值</span><br>                <span class="hljs-keyword">int</span> left = j + <span class="hljs-number">1</span>,right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-comment">//设置头尾指针</span><br>                <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br><br>                    <span class="hljs-keyword">int</span> loop_res = nums[left] + nums[right];<br>                    <span class="hljs-keyword">if</span>(loop_res == loop_target)&#123;<br>                        <span class="hljs-comment">//如果与上一次的保存的结果值不相等</span><br>                        <span class="hljs-keyword">if</span>(nums[left] != last_third &amp;&amp; nums[right] != last_fourth)&#123;<br>                            res.<span class="hljs-built_in">push_back</span>(&#123;nums[i],nums[j],nums[left],nums[right]&#125;);<span class="hljs-comment">//保存结果</span><br>                            last_third = nums[left];last_fourth = nums[right];<span class="hljs-comment">//设置此次的结果</span><br>                        &#125;<br>                        ++left;--right;<span class="hljs-comment">//排序后的数组不会出现跳过隐藏答案的情况</span><br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(loop_res &gt; loop_target) --right;  <br>                    <span class="hljs-keyword">else</span> ++left;<br>            &#125; <br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路与&lt;&lt;<strong>15. 三数之和</strong>&gt;&gt;一样。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.两数相加</title>
    <link href="/2020/06/12/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <url>/2020/06/12/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/add-two-numbers/">本题链接</a></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;<br>        ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>,head);<br><br>        <span class="hljs-keyword">while</span>(l1||l2)&#123;<br><br>            tmp = (l1 ? l1-&gt;val : <span class="hljs-number">0</span>) + (l2 ? l2-&gt;val : <span class="hljs-number">0</span>) + t;<br>            tmp &gt;= <span class="hljs-number">10</span> ? (tmp = tmp % <span class="hljs-number">10</span> , t=<span class="hljs-number">1</span> ) : t=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(l1) l1 = l1-&gt;next;<br>            <span class="hljs-keyword">if</span>(l2) l2 = l2-&gt;next;<br><br><br>            node-&gt;next-&gt;val = tmp;<br>            node-&gt;next-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>            node = node-&gt;next;     <br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(t==<span class="hljs-number">1</span>) <br>            node-&gt;next-&gt;val = t;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">delete</span> node-&gt;next;<br>            node-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>            <br><br>        <span class="hljs-keyword">return</span> head; <br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>只要保存好进位就行，然后注意判断某个链表先空的情况。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解释器模式</title>
    <link href="/2020/06/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%A2%86%E5%9F%9F%E8%A7%84%E5%88%99%EF%BC%9A%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%A2%86%E5%9F%9F%E8%A7%84%E5%88%99%EF%BC%9A%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，如果某一特定领域的问题比较复杂，类似的结构不断重复出现，如果使用普通的编程方式来实现将面临非常频繁的变化。</li><li>在这种情况下，将特定领域的问题表达为某种语法规则下的句子，然后构建一个解释器来解释这样的句子，从而达到解决问题的目的。</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表达来解释语言中的句子。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>以下模拟计算算术表达式（只有加法和减法）：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Expression</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; var)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Expression</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//变量表达式</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VarExpression</span>:</span> <span class="hljs-keyword">public</span> Expression &#123;<br>    <br>    <span class="hljs-keyword">char</span> key;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">VarExpression</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>&amp; key)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;key = key;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; var)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> var[key];<br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-comment">//符号表达式</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SymbolExpression</span> :</span> <span class="hljs-keyword">public</span> Expression &#123;<br>    <br>    <span class="hljs-comment">// 运算符左右两个参数</span><br><span class="hljs-keyword">protected</span>:<br>    Expression* left;<br>    Expression* right;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SymbolExpression</span>( Expression* left,  Expression* right):<br>        <span class="hljs-built_in">left</span>(left),<span class="hljs-built_in">right</span>(right)&#123;<br>        <br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-comment">//加法运算</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddExpression</span> :</span> <span class="hljs-keyword">public</span> SymbolExpression &#123;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">AddExpression</span>(Expression* left, Expression* right):<br>        <span class="hljs-built_in">SymbolExpression</span>(left,right)&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; var)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> left-&gt;<span class="hljs-built_in">interpreter</span>(var) + right-&gt;<span class="hljs-built_in">interpreter</span>(var);<br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-comment">//减法运算</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubExpression</span> :</span> <span class="hljs-keyword">public</span> SymbolExpression &#123;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SubExpression</span>(Expression* left, Expression* right):<br>        <span class="hljs-built_in">SymbolExpression</span>(left,right)&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; var)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> left-&gt;<span class="hljs-built_in">interpreter</span>(var) - right-&gt;<span class="hljs-built_in">interpreter</span>(var);<br>    &#125;<br>    <br>&#125;;<br><br><br><br><span class="hljs-function">Expression*  <span class="hljs-title">analyse</span><span class="hljs-params">(string expStr)</span> </span>&#123;<br>    <br>    stack&lt;Expression*&gt; expStack;<br>    Expression* left = <span class="hljs-literal">nullptr</span>;<br>    Expression* right = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;expStr.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>(expStr[i])<br>        &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                <span class="hljs-comment">// 加法运算</span><br>                left = expStack.<span class="hljs-built_in">top</span>();<br>                right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">VarExpression</span>(expStr[++i]);<br>                expStack.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">AddExpression</span>(left, right));<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                <span class="hljs-comment">// 减法运算</span><br>                left = expStack.<span class="hljs-built_in">top</span>();<br>                right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">VarExpression</span>(expStr[++i]);<br>                expStack.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">SubExpression</span>(left, right));<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-comment">// 变量表达式</span><br>                expStack.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">VarExpression</span>(expStr[i]));<br>        &#125;<br>    &#125;<br>   <br>    Expression* expression = expStack.<span class="hljs-built_in">top</span>();<br><br>    <span class="hljs-keyword">return</span> expression;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">(Expression* expression)</span></span>&#123;<br>    <br>    <span class="hljs-comment">//释放表达式树的节点内存...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;<br>    <br>    <br>    string expStr = <span class="hljs-string">&quot;a+b-c+d-e&quot;</span>;<br>    map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; var;<br>    var.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">5</span>));<br>    var.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">2</span>));<br>    var.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">1</span>));<br>    var.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-number">6</span>));<br>    var.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-number">10</span>));<br><br>    <br>    Expression* expression= <span class="hljs-built_in">analyse</span>(expStr);<br>    <br>    <span class="hljs-keyword">int</span> result=expression-&gt;<span class="hljs-built_in">interpreter</span>(var);<br>    <br>    cout&lt;&lt;result&lt;&lt;endl;<br>    <br>    <span class="hljs-built_in">release</span>(expression);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a81690cc50fbd0dc2f1b5dbf2208a81e-ad92d.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Interpreter模式的应用场合是Interpreter模式应用中的难点，只有满足”业务规则频繁变化，且类似的结构不断重复出现，并且容易抽象为语法规则的问题“才适合使用Interpreter模式。</li><li>使用Interpreter模式来表示文法规则，从而可以使用面向对象技巧来方便地”扩展“文法。</li><li>Interpreter模式比较适合简单的文法表示，对于复杂的文法表示，Interpreter模式会产生比较大的类层次结构，需要求助于语法分析生成器这样的标准工具。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>领域规则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令模式</title>
    <link href="/2020/06/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%8F%98%E5%8C%96%EF%BC%9A%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%8F%98%E5%8C%96%EF%BC%9A%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，”行为请求者“与”行为实现者“通常呈现一种”紧耦合“。但在某些场合，比如需要对行为进行”记录、撤销/重(undo/redo)、事务“等处理，这种无法抵御变化的紧耦合是不合适的。</li><li>在这种情况下，如何将”行为请求者“与”行为实现者“解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>将一个请求（行为）封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Command</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteCommand1</span> :</span> <span class="hljs-keyword">public</span> Command<br>&#123;<br>    string arg;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ConcreteCommand1</span>(<span class="hljs-keyword">const</span> string &amp; a) : <span class="hljs-built_in">arg</span>(a) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt; <span class="hljs-string">&quot;#1 process...&quot;</span>&lt;&lt;arg&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteCommand2</span> :</span> <span class="hljs-keyword">public</span> Command<br>&#123;<br>    string arg;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ConcreteCommand2</span>(<span class="hljs-keyword">const</span> string &amp; a) : <span class="hljs-built_in">arg</span>(a) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt; <span class="hljs-string">&quot;#2 process...&quot;</span>&lt;&lt;arg&lt;&lt;endl;<br>    &#125;<br>&#125;;<br>        <br>        <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MacroCommand</span> :</span> <span class="hljs-keyword">public</span> Command<br>&#123;<br>    vector&lt;Command*&gt; commands;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addCommand</span><span class="hljs-params">(Command *c)</span> </span>&#123; commands.<span class="hljs-built_in">push_back</span>(c); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c : commands)<br>        &#123;<br>            c-&gt;<span class="hljs-built_in">execute</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br>                <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-function">ConcreteCommand1 <span class="hljs-title">command1</span><span class="hljs-params">(receiver, <span class="hljs-string">&quot;Arg ###&quot;</span>)</span></span>;<br>    <span class="hljs-function">ConcreteCommand2 <span class="hljs-title">command2</span><span class="hljs-params">(receiver, <span class="hljs-string">&quot;Arg $$$&quot;</span>)</span></span>;<br>    <br>    MacroCommand macro;<br>    macro.<span class="hljs-built_in">addCommand</span>(&amp;command1);<br>    macro.<span class="hljs-built_in">addCommand</span>(&amp;command2);<br>    <br>    macro.<span class="hljs-built_in">execute</span>();<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/54df981e468227d271d5f54e9d39c869-77569.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Command模式的根本目的在于将”行为请求者“与”行为实现者“解耦，在面向对象语言中，常见的实现手段是”将行为抽象为对象“。</li><li>实现<code>Command</code>接口的具体命令对象<code>ConcreteCommand</code>有时候根据需要可能会保存一些额外的状态信息。通过使用Composite模式，可以将多个”命令“封装为一个”复合命令“<code>MacroCommand</code>。</li><li>Command模式与C++中的函数对象有些类似。但两者定义行为接口的规范有所区别：Command以面向对象中的”接口-实现“来定义行为接口规范，更严格，但有性能损失；C++函数对象以函数签名来定义行为接口规范，更灵活，性能更高。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>行为变化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>访问器模式</title>
    <link href="/2020/06/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%8F%98%E5%8C%96%EF%BC%9A%E8%AE%BF%E9%97%AE%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%8F%98%E5%8C%96%EF%BC%9A%E8%AE%BF%E9%97%AE%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，由于需求的改变，某些类层次结构中常常需要增加新的行为（方法），如果在基类中做这样的更改，将会给子类带来很繁重的变更负担，甚至破坏原有设计。</li><li>如何在不改变类层次结构的前提下，在运行时根据需要透明地为类层次结构上的各个类动态添加新的操作，从而避免上述问题？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>表示一个作用于某对象结构中的各元素的操作。使得可以在不改变（稳定）各元素的类的前提下定义（扩展）作用于这些元素的新操作（变化）。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用访问器模式之前：</strong></p><p>如果后期需求的变动，需要<code>Element</code>派生类需要添加功能，那么不仅在<code>Element</code>中需要添加，同时<code>Element</code>派生类中也需要添加，违反了开闭原则。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visitor</span>;</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Element</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Func1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Func3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//...</span><br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Element</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementA</span> :</span> <span class="hljs-keyword">public</span> Element<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func1</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementB</span> :</span> <span class="hljs-keyword">public</span> Element<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func1</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <span class="hljs-comment">//***</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">//***</span><br>    &#125;<br>    <br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>运用访问器模式之后：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visitor</span>;</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Element</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor&amp; visitor)</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//第一次多态辨析</span><br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Element</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementA</span> :</span> <span class="hljs-keyword">public</span> Element<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor &amp;visitor)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        visitor.<span class="hljs-built_in">visitElementA</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <br><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementB</span> :</span> <span class="hljs-keyword">public</span> Element<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor &amp;visitor)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        visitor.<span class="hljs-built_in">visitElementB</span>(*<span class="hljs-keyword">this</span>); <span class="hljs-comment">//第二次多态辨析</span><br>    &#125;<br><br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visitor</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitElementA</span><span class="hljs-params">(ElementA&amp; element)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitElementB</span><span class="hljs-params">(ElementB&amp; element)</span> </span>= <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Visitor</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//==================================</span><br><br><span class="hljs-comment">//扩展1</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visitor1</span> :</span> <span class="hljs-keyword">public</span> Visitor&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visitElementA</span><span class="hljs-params">(ElementA&amp; element)</span> <span class="hljs-keyword">override</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Visitor1 is processing ElementA&quot;</span> &lt;&lt; endl;<br>    &#125;<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visitElementB</span><span class="hljs-params">(ElementB&amp; element)</span> <span class="hljs-keyword">override</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Visitor1 is processing ElementB&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br>     <br><span class="hljs-comment">//扩展2</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visitor2</span> :</span> <span class="hljs-keyword">public</span> Visitor&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visitElementA</span><span class="hljs-params">(ElementA&amp; element)</span> <span class="hljs-keyword">override</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Visitor2 is processing ElementA&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visitElementB</span><span class="hljs-params">(ElementB&amp; element)</span> <span class="hljs-keyword">override</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Visitor2 is processing ElementB&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br>        <br>    <br><br>        <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Visitor2 visitor;<br>    ElementB elementB;<br>    elementB.<span class="hljs-built_in">accept</span>(visitor);<span class="hljs-comment">// double dispatch</span><br>    <br>    ElementA elementA;<br>    elementA.<span class="hljs-built_in">accept</span>(visitor);<br><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果此时需要为Element派生类添加新功能，只需要将Visitor再派生出一个子类出来，让这个子类来解决即可。</p><p>但是这个模式看起来会比较不灵活，原因是Element必须是稳定的，在设计之初就应该确定好，后期不能再更改了；同样的Element派生类的数量也需要稳定不变。</p><p>用白话解释就是：将我交给别人执行，只是别人很懒，不愿意我有任何改动。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/2c641454658042ce3af98cbf658b4bc2-476f4.png" alt="结构"></p><p>从整体看感觉有点像在代码层面模仿类的虚函数实现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Visitor存在的前提是Element派生类的个数确定。也就是说当Element的派生数量不稳定，剧烈变化，访问器模式就不适用了。</li><li>Visitor模式通过所谓的双重分发（double dispatch）来实现在不更改（不添加新的操作-编译时）Element类层次结构的前提下，在运行时透明地为类层次结构上的各个类动态添加新的操作（支持变化）。</li><li>所谓双重分发即Visitor模式中间包括了两个多态分发（注意其中的多态机制）：第一个为accept方法的多态辨析；第二个为visitElementX方法的多态辨析。</li><li>Visitor模式的最大缺点在于扩展类层次结构（增添新的Element子类），会导致Visitor模式的改变。因此Visitor模式适用于”Element类层次结构稳定，而其中的操作却经常面临频繁改动”。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>行为变化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>职责链</title>
    <link href="/2020/05/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%81%8C%E8%B4%A3%E9%93%BE/"/>
    <url>/2020/05/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%81%8C%E8%B4%A3%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，一个请求可能被多个对象处理，但是每个请求在运行时只能有一个接收者，如果显示指定，将必不可少地带来请求发送者与接收者的紧耦合。</li><li>如何使请求的发送者不需要指定具体的接收者？让请求的接受者自己在运行时决定来处理请求，从而使两者解耦？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>类似于安卓中的事件分发机制</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//请求类型</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RequestType</span></span><br><span class="hljs-class">&#123;</span><br>    REQ_HANDLER1,<br>    REQ_HANDLER2,<br>    REQ_HANDLER3<br>&#125;;<br><span class="hljs-comment">//请求</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reqest</span></span><br><span class="hljs-class">&#123;</span><br>    string description;<br>    RequestType reqType;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Reqest</span>(<span class="hljs-keyword">const</span> string &amp; desc, RequestType type) : <span class="hljs-built_in">description</span>(desc), <span class="hljs-built_in">reqType</span>(type) &#123;&#125;<br>    <span class="hljs-function">RequestType <span class="hljs-title">getReqType</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> reqType; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">const</span> string&amp; <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> description; &#125;<br>&#125;;<br><span class="hljs-comment">//接受请求的类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChainHandler</span>&#123;</span><br>    <br>    <span class="hljs-comment">//设置下一个接受节点</span><br>    ChainHandler *nextChain;<br>    <span class="hljs-comment">//发送请求到下一个节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendReqestToNextHandler</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (nextChain != <span class="hljs-literal">nullptr</span>)<br>            nextChain-&gt;<span class="hljs-built_in">handle</span>(req);<br>    &#125;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">//判断是否接受请求</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">canHandleRequest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//请求处理</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ChainHandler</span>() &#123; nextChain = <span class="hljs-literal">nullptr</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setNextChain</span><span class="hljs-params">(ChainHandler *next)</span> </span>&#123; nextChain = next; &#125;<br>    <br>   <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">canHandleRequest</span>(req))<br>            <span class="hljs-built_in">processRequest</span>(req);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">sendReqestToNextHandler</span>(req);<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler1</span> :</span> <span class="hljs-keyword">public</span> ChainHandler&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canHandleRequest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> req.<span class="hljs-built_in">getReqType</span>() == RequestType::REQ_HANDLER1;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Handler1 is handle reqest: &quot;</span> &lt;&lt; req.<span class="hljs-built_in">getDescription</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;;<br>        <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler2</span> :</span> <span class="hljs-keyword">public</span> ChainHandler&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canHandleRequest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> req.<span class="hljs-built_in">getReqType</span>() == RequestType::REQ_HANDLER2;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Handler2 is handle reqest: &quot;</span> &lt;&lt; req.<span class="hljs-built_in">getDescription</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler3</span> :</span> <span class="hljs-keyword">public</span> ChainHandler&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canHandleRequest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> req.<span class="hljs-built_in">getReqType</span>() == RequestType::REQ_HANDLER3;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Reqest &amp; req)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Handler3 is handle reqest: &quot;</span> &lt;&lt; req.<span class="hljs-built_in">getDescription</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Handler1 h1;<br>    Handler2 h2;<br>    Handler3 h3;<br>    h1.<span class="hljs-built_in">setNextChain</span>(&amp;h2);<br>    h2.<span class="hljs-built_in">setNextChain</span>(&amp;h3);<br>    <br>    <span class="hljs-function">Reqest <span class="hljs-title">req</span><span class="hljs-params">(<span class="hljs-string">&quot;process task ... &quot;</span>, RequestType::REQ_HANDLER3)</span></span>;<br>    h1.<span class="hljs-built_in">handle</span>(req);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5e3f3c6bc4af6c127e12ad584fccf3cf-63458.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Chain of Responsibility模式的应用场合在于”一个请求可能有多个接受者，但是最后真正的接受者只有一个“，这时候请求发送者就接受者的耦合有可能出现”变化脆弱“的症状，职责链的目的就是将二者解耦，从而更好地应对变化。</li><li>应用了Chain of Responsibility模式后，对象的职责分派将更具灵活性。我们可以在运行时动态添加/修改请求的职责。</li><li>如果请求传递到职责链的末尾仍得不到处理，应该有一个合理的缺省机制。这也是每一个接受对象的责任，而不是发出请求的对象的责任。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合模式</title>
    <link href="/2020/05/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/05/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件的某些情况下，客户代码过多地依赖于对象容器复杂的内部实现结构，对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。</li><li>如何将”客户代码与复杂的对象容器结构“解耦？让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>将对象组合成树形结构以表示”部分-整体“的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性（稳定）。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>内部呈现一种树状结构，可以想象成文件系统，把<code>Composite</code>视为文件目录，<code>Leaf</code>视为文件。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Component</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//树节点</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Composite</span> :</span> <span class="hljs-keyword">public</span> Component&#123;<br>    <br>    string name;<br>    list&lt;Component*&gt; elements;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Composite</span>(<span class="hljs-keyword">const</span> string &amp; s) : <span class="hljs-built_in">name</span>(s) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Component* element)</span> </span>&#123;<br>        elements.<span class="hljs-built_in">push_back</span>(element);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Component* element)</span></span>&#123;<br>        elements.<span class="hljs-built_in">remove</span>(element);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>&#123;<br>        <br>        <span class="hljs-comment">//1. process current node</span><br>        <br>        <br>        <span class="hljs-comment">//2. process leaf nodes</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;e : elements)<br>            e-&gt;<span class="hljs-built_in">process</span>(); <span class="hljs-comment">//多态调用</span><br>         <br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//叶子节点</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leaf</span> :</span> <span class="hljs-keyword">public</span> Component&#123;<br>    string name;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Leaf</span>(string s) : <span class="hljs-built_in">name</span>(s) &#123;&#125;<br>            <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//process current node</span><br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Invoke</span><span class="hljs-params">(Component &amp; c)</span></span>&#123;<br>    <span class="hljs-comment">//...</span><br>    c.<span class="hljs-built_in">process</span>();<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-function">Composite <span class="hljs-title">root</span><span class="hljs-params">(<span class="hljs-string">&quot;root&quot;</span>)</span></span>;<br>    <span class="hljs-function">Composite <span class="hljs-title">treeNode1</span><span class="hljs-params">(<span class="hljs-string">&quot;treeNode1&quot;</span>)</span></span>;<br>    <span class="hljs-function">Composite <span class="hljs-title">treeNode2</span><span class="hljs-params">(<span class="hljs-string">&quot;treeNode2&quot;</span>)</span></span>;<br>    <span class="hljs-function">Composite <span class="hljs-title">treeNode3</span><span class="hljs-params">(<span class="hljs-string">&quot;treeNode3&quot;</span>)</span></span>;<br>    <span class="hljs-function">Composite <span class="hljs-title">treeNode4</span><span class="hljs-params">(<span class="hljs-string">&quot;treeNode4&quot;</span>)</span></span>;<br>    <span class="hljs-function">Leaf <span class="hljs-title">leat1</span><span class="hljs-params">(<span class="hljs-string">&quot;left1&quot;</span>)</span></span>;<br>    <span class="hljs-function">Leaf <span class="hljs-title">leat2</span><span class="hljs-params">(<span class="hljs-string">&quot;left2&quot;</span>)</span></span>;<br>    <br>    root.<span class="hljs-built_in">add</span>(&amp;treeNode1);<br>    treeNode1.<span class="hljs-built_in">add</span>(&amp;treeNode2);<br>    treeNode2.<span class="hljs-built_in">add</span>(&amp;leaf1);<br>    <br>    root.<span class="hljs-built_in">add</span>(&amp;treeNode3);<br>    treeNode3.<span class="hljs-built_in">add</span>(&amp;treeNode4);<br>    treeNode4.<span class="hljs-built_in">add</span>(&amp;leaf2);<br>    <br>    <span class="hljs-built_in">process</span>(root);<br>    <span class="hljs-built_in">process</span>(leaf2);<br>    <span class="hljs-built_in">process</span>(treeNode3);<br>  <br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/0abe476e99639c4f5f496e3e26560435-14578.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>组合模式的核心是多态的递归调用</strong></li><li>Composite模式采用树形结构来实现普遍存在的对象容器，从而将”一对多“的关系转化为”一对一“的关系，使得客户代码可以一致地（复用）处理对象和对象容器，无需关心处理的是单个的对象，还是组合的对象容器。<ul><li>一对多：即上例的，若<code>Leaf</code>也实现父类的虚函数，然后<code>Composite</code>的成员函数<code>process</code>中的<code>for</code>循环去掉或改写，对于客户而言，直接面对的就是这两个类型。</li><li>一对一：即上例。对于客户而言，客户仅需要使用<code>Component</code>类型即可，且不知道内部的数据是按照何种的数据结构组装。</li></ul></li><li>将”客户代码与复杂的对象容器结构“解耦是Composite的核心思想，解耦之后，客户代码将与纯粹的抽象接口，而非对象容器的内部实现结构发生依赖，从而更能”应对变化“。（比如上例的<code>invoke</code>方法）</li><li>Composite模式在具体实现中，可以让父对象中的子对象反向追溯；如果父对象有频繁的遍历需求，可使用缓存技巧来改善效率。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迭代器</title>
    <link href="/2020/05/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2020/05/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="数据结构：迭代器"><a href="#数据结构：迭代器" class="headerlink" title="数据结构：迭代器"></a>数据结构：迭代器</h1><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素；同时这种”透明遍历“也为”同一种算法在多种集合对象上进行操作“提供了可能。</li><li>使用面向对象技术将这种遍历机制抽象为”迭代器对象“为”应对变化中的集合对象“提供了一种优雅的fan</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露（稳定）该对象的内部表示。</p><p>——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Iterator</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">first</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T&amp; <span class="hljs-title">current</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCollection</span>&#123;</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function">Iterator&lt;T&gt; <span class="hljs-title">GetIterator</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectionIterator</span> :</span> <span class="hljs-keyword">public</span> Iterator&lt;T&gt;&#123;<br>    MyCollection&lt;T&gt; mc;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">CollectionIterator</span>(<span class="hljs-keyword">const</span> MyCollection&lt;T&gt; &amp; c): <span class="hljs-built_in">mc</span>(c)&#123; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">first</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function">T&amp; <span class="hljs-title">current</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyAlgorithm</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    MyCollection&lt;<span class="hljs-keyword">int</span>&gt; mc;<br>    <br>    Iterator&lt;<span class="hljs-keyword">int</span>&gt; iter= mc.<span class="hljs-built_in">GetIterator</span>();<br>    <br>    <span class="hljs-keyword">for</span> (iter.<span class="hljs-built_in">first</span>(); !iter.<span class="hljs-built_in">isDone</span>(); iter.<span class="hljs-built_in">next</span>())&#123;<br>        cout &lt;&lt; iter.<span class="hljs-built_in">current</span>() &lt;&lt; endl;<br>    &#125;<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/2c55fc126b3e7f7a0938bd54ea0af498-feb82.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>迭代器模式在C++已经过时了<ul><li>缺点是面向对象的迭代器的虚函数调用（动态绑定）需要性能成本，而泛型编程的多态是静态绑定。</li><li>有了泛型编程的迭代器，就没有了面向对象的迭代器了。</li></ul></li><li>迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示</li><li>迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。</li><li>迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Clion配置git</title>
    <link href="/2020/05/21/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Clion%E9%85%8D%E7%BD%AEgit/"/>
    <url>/2020/05/21/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Clion%E9%85%8D%E7%BD%AEgit/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文标题虽然是CLion配置Git，但是亲测全家桶下的其他软件也能按照同样的方法进行配置</p><p>在开始之前，需要确保你有Git账号且在本地环境已经配置好Git</p><h2 id="1-创建本地仓库"><a href="#1-创建本地仓库" class="headerlink" title="1. 创建本地仓库"></a>1. 创建本地仓库</h2><p>打开CLion，导航栏-&gt;VCS-&gt;Create Git Repository，选择你需要作为Git仓库的文件夹</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416141113.png" alt="选择文件夹"></p><p>之后打开我们选择的文件夹，发现已经被初始化</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416141350.png" alt="文件夹被初始化"></p><p>然后CLion的导航栏也相应发生了变化</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416141442.png" alt="导航栏变化"></p><h2 id="2-关联远程仓库"><a href="#2-关联远程仓库" class="headerlink" title="2. 关联远程仓库"></a>2. 关联远程仓库</h2><p>先复制我们Github上需要关联仓库的地址</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416142138.png" alt="点击复制"></p><p>接着打开CLion，依次Git-&gt;Manage Remotes</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416141653.png" alt="Manage Remotes"></p><p>点击加号，将刚才复制的git地址填入并确认</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416142253.png" alt="填入地址"></p><p>等待即可</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416142357.png" alt="等待"></p><h2 id="3-使用方法"><a href="#3-使用方法" class="headerlink" title="3. 使用方法"></a>3. 使用方法</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416155818.png" alt="提交"></p>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>IDE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>适配器模式</title>
    <link href="/2020/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件系统中，由于应用环境的变化，常常需要将”一些现存的对象“放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。</li><li>如何应对这种”迁移的变化“？如何既能利用现有对象的良好实现，同时又满足新的应用环境所要求的接口？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用适配器模式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//目标接口（新接口）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ITarget</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">//遗留接口（老接口）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IAdaptee</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">//遗留类型</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OldClass</span>:</span> <span class="hljs-keyword">public</span> IAdaptee&#123;<br>    <span class="hljs-comment">//....</span><br>&#125;;<br><br><span class="hljs-comment">//对象适配器</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span>:</span> <span class="hljs-keyword">public</span> ITarget&#123; <span class="hljs-comment">//继承</span><br><span class="hljs-keyword">protected</span>:<br>    IAdaptee* pAdaptee;<span class="hljs-comment">//组合</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">Adapter</span>(IAdaptee* pAdaptee)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;pAdaptee=pAdaptee;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> data=pAdaptee-&gt;<span class="hljs-built_in">bar</span>();<br>        pAdaptee-&gt;<span class="hljs-built_in">foo</span>(data);<br>        <br>    &#125;<br>    <br>    <br>&#125;;<br><br><span class="hljs-comment">//类适配器</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span>:</span> <span class="hljs-keyword">public</span> ITarget,<br>               <span class="hljs-keyword">protected</span> OldClass&#123; <span class="hljs-comment">//多继承</span><br>               <br>               <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//实例化一个老版本的类</span><br>    IAdaptee* pAdaptee=<span class="hljs-keyword">new</span> <span class="hljs-built_in">OldClass</span>();<br>    <br>    <span class="hljs-comment">//利用适配器对这个老版本的类进行适配</span><br>    ITarget* pTarget=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Adapter</span>(pAdaptee);<br>    pTarget-&gt;<span class="hljs-built_in">process</span>();<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/75286f661f0eec847beeb6ccf5239ff3-fd5be.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Adapter模式主要应用于”希望复用一些现存的类，但是接口又与复用环境要求不一致的情况“，在遗留代码复用、类库迁移等方面非常有用。</li><li>GoF23定义了两种Adapter模式的实现结构：对象适配器和类适配器。但类适配器采用”多继承“的实现方式，一般不推荐使用。对象适配器采用”对象组合“的方式，更符合松耦合精神。</li><li>Adapter模式可以实现的非常灵活，不必拘泥于GoF23中定义的两种结构。例如，完全可以将Adapter模式中的”现存对象“作为新的接口方法参数，来达到适配的目的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口隔离</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备忘录模式</title>
    <link href="/2020/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%EF%BC%9A%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%EF%BC%9A%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，某些对象的状态在转换过程中，可能由于某种需要，要求程序能够回溯到对象之前处于某个点时的状态。如果使用一些公有接口来让其他对象得到对象的状态，便会暴露对象的细节实现。</li><li>如何实现对象状态的良好保存与恢复？但同时又不会因此而破坏对象本身的封装性？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原本保存的状态。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Memento</span></span><br><span class="hljs-class">&#123;</span><br>    string state;<br>    <span class="hljs-comment">//..</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Memento</span>(<span class="hljs-keyword">const</span> string &amp; s) : <span class="hljs-built_in">state</span>(s) &#123;&#125;<br>    <span class="hljs-function">string <span class="hljs-title">getState</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> state; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp; s)</span> </span>&#123; state = s; &#125;<br>&#125;;<br><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Originator</span></span><br><span class="hljs-class">&#123;</span><br>    string state;<br>    <span class="hljs-comment">//....</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Originator</span>() &#123;&#125;<br>    <span class="hljs-function">Memento <span class="hljs-title">createMomento</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">Memento <span class="hljs-title">m</span><span class="hljs-params">(state)</span></span>;<br>        <span class="hljs-keyword">return</span> m;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setMomento</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Memento &amp; m)</span> </span>&#123;<br>        state = m.<span class="hljs-built_in">getState</span>();<br>    &#125;<br>&#125;;<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Originator orginator;<br>    <br>    <span class="hljs-comment">//捕获对象状态，存储到备忘录</span><br>    Memento mem = orginator.<span class="hljs-built_in">createMomento</span>();<br>    <br>    <span class="hljs-comment">//... 改变orginator状态</span><br>    <br>    <span class="hljs-comment">//从备忘录中恢复</span><br>    orginator.<span class="hljs-built_in">setMomento</span>(memento);<br>   <br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a8c463389b28bf24c925f7dd4b745f7f-b47ff.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>备忘录(Memento)存储原发器(Originator)对象的内部状态，在需要时恢复原发器状态。</li><li>Memento模式的核心是信息隐藏，即Originator需要向外界隐藏信息，保持其封装性。但同时又需要将状态保持到外界（Memento）。</li><li>由于现代语言运行时（如C#、JAVA等）都具有相当的对象序列化支持，因此往往采用效率较高、又较容易正确实现的序列化方案来实现Memento模式。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>状态变化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状态模式</title>
    <link href="/2020/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%EF%BC%9A%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%EF%BC%9A%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，某些对象的状态如果改变，其行为也会随之而发生变化，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。</li><li>如何在运行时根据对象的状态透明地更改对象的行为，而不会为对象操作和状态转化之间引入紧耦合？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>允许一个对象在其内部状态改变时改变它的行为。从而使对象看起来似乎修改了行为。</p><p>——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用状态模式之前：</strong>（出现大量的if-else）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NetworkState</span></span><br><span class="hljs-class">&#123;</span><br>    Network_Open,<br>    Network_Close,<br>    Network_Connect,<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkProcessor</span>&#123;</span><br>    <br>    NetworkState state;<br><br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (state == Network_Open)&#123;<br><br>            <span class="hljs-comment">//**********</span><br>            state = Network_Close;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == Network_Close)&#123;<br><br>            <span class="hljs-comment">//..........</span><br>            state = Network_Connect;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == Network_Connect)&#123;<br><br>            <span class="hljs-comment">//$$$$$$$$$$</span><br>            state = Network_Open;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span> (state == Network_Open)&#123;<br>            <br>            <span class="hljs-comment">//**********</span><br>            state = Network_Connect;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == Network_Close)&#123;<br><br>            <span class="hljs-comment">//.....</span><br>            state = Network_Open;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == Network_Connect)&#123;<br><br>            <span class="hljs-comment">//$$$$$$$$$$</span><br>            state = Network_Close;<br>        &#125;<br>    <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>运用状态模式之后：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkState</span>&#123;</span><br><br><span class="hljs-keyword">public</span>:<br>    NetworkState* pNext;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">NetworkState</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//结合单例模式</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenState</span> :</span><span class="hljs-keyword">public</span> NetworkState&#123;<br>    <br>    <span class="hljs-keyword">static</span> NetworkState* m_instance;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> NetworkState* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (m_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>            m_instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">OpenState</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> m_instance;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span></span>&#123;<br>        <br>        <span class="hljs-comment">//**********</span><br>        pNext = CloseState::<span class="hljs-built_in">getInstance</span>();<span class="hljs-comment">//更改下一个状态</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span></span>&#123;<br>        <br>        <span class="hljs-comment">//..........</span><br>        pNext = ConnectState::<span class="hljs-built_in">getInstance</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span></span>&#123;<br>        <br>        <span class="hljs-comment">//$$$$$$$$$$</span><br>        pNext = OpenState::<span class="hljs-built_in">getInstance</span>();<br>    &#125;<br>    <br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloseState</span>:</span><span class="hljs-keyword">public</span> NetworkState&#123; &#125;<br><span class="hljs-comment">//...</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkProcessor</span>&#123;</span><br>    <br>    NetworkState* pState;<br>    <br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">NetworkProcessor</span>(NetworkState* pState)&#123;<br>        <br>        <span class="hljs-keyword">this</span>-&gt;pState = pState;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>        pState-&gt;<span class="hljs-built_in">Operation1</span>();<br>        pState = pState-&gt;pNext;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>        pState-&gt;<span class="hljs-built_in">Operation2</span>();<br>        pState = pState-&gt;pNext;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>        pState-&gt;<span class="hljs-built_in">Operation3</span>();<br>        pState = pState-&gt;pNext;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/be1b2752ed766f77c6f6f53a5dff29f9-c8dc1.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>状态模式倾向于结合单例模式</li><li>虚函数的本质实际上是运行时的if-else</li><li>State模式将所有与一个特定状态相关的行为都放入一个State的子类对象中，在对象状态切换的时候，切换相应的对象；但同时维持State的接口，这样实现了具体操作与状态转换之间的解耦。</li><li>为不同的状态引入不同的对象使得状态转换变得更加明确，而且可以保证不会出现状态不一致的情况，因为转换是原子性的，即要么彻底转换过来，要么不转换。</li><li>如果State对象没有实例变量，那么各个上下文可以共享同一个State对象，从而节省对象开销。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>状态变化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中介者模式</title>
    <link href="/2020/05/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/05/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，经常会出现多个对象相互关联交互的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。</li><li>在这种情况下，我们可以使用一个”中介对象“来管理对象间的关联关系，避免互相交互的对象之间的紧耦合引用关系，从而更好地抵御变化。</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>用一个中介对象来封装（封装变化）一系列的对象交互。中介者使各对象不需要显示的互相引用（编译时依赖-&gt;运行时依赖），从而使其耦合松散（管理变化），而且可以独立地改变它们之间的交互。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/c847ecd4609b6c48b916c0e25874ff44-15be6.png" alt="实例"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6c5c6f834db0f241439220930281478b-39b5b.png" alt="实例"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>与门面模式的区别：<ul><li>门面模式：系统内部和系统外部的隔离</li><li>中介者模式：系统内部的隔离</li></ul></li><li>将多个对象间复杂的关联关系解耦，Mediator模式将多个对象间的控制逻辑进行集中管理，变“多个对象互相关联”为“多个对象和一个中介者关联”，简化了系统的维护，抵御了可能的变化。</li><li>随着控制逻辑的复杂化，Mediator模式具体对象的实现可能相当复杂。这时候可以对Mediator模式对象进行分解处理。</li><li>Facade模式是解耦系统间（单项）的对象关联关系；Mediator模式是解耦系统内各个对象之间（双向）的关联关系。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口隔离</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理模式</title>
    <link href="/2020/05/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/05/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在面向对象系统中，有些对象由于某种原因（比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等），直接访问会给使用者、或者系统结构带来很多麻烦。</li><li>如何在不失透明操作对象的同时来管理/控制这些对象特有的复杂性？增加一层间接层是软件开发中常见的解决方式</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>为其他对象提供一种代理以控制（隔离，使用接口）对这个对象的访问 </p><p>——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>使用代理模式之前：</strong></p><p>直接使用功能类</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISubject</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-comment">//功能类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealSubject</span>:</span> <span class="hljs-keyword">public</span> ISubject&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//....</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientApp</span>&#123;</span><br>    <br>    ISubject* subject;<br>    <br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">ClientApp</span>()&#123;<br>        subject=<span class="hljs-keyword">new</span> <span class="hljs-built_in">RealSubject</span>();<span class="hljs-comment">//直接使用</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoTask</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>        subject-&gt;<span class="hljs-built_in">process</span>();<br>        <br>        <span class="hljs-comment">//....</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>使用代理模式之后：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISubject</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><br><span class="hljs-comment">//Proxy的设计，添加了一层间接层</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubjectProxy</span>:</span> <span class="hljs-keyword">public</span> ISubject&#123;<br>    <br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//对RealSubject的一种间接访问，在其中可以进行安全控制等.</span><br>        <span class="hljs-comment">//....</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientApp</span>&#123;</span><br>    <br>    ISubject* subject;<br>    <br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">ClientApp</span>()&#123;<br>        subject=<span class="hljs-keyword">new</span> <span class="hljs-built_in">SubjectProxy</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoTask</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>        subject-&gt;<span class="hljs-built_in">process</span>();<br>        <br>        <span class="hljs-comment">//....</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/70792f3a5d1deb63a5ead7eca014ebc9-550f9.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>”增加一层间接层“是软件系统中对许多复杂问题的一种常见解决方法。在面向对象系统中，直接使用某些对象会带来很多问题，作为间接层的Proxy对象便是解决这一问题的常用手段。</li><li>具体Proxy设计模式的实现方法、实现粒度都相差很大，有些可能对单个对象做细粒度的控制，如copy-on-write技术，有些可能对组件模块提供抽象代理层，在架构层次对对象做proxy。</li><li><strong>Proxy并不一定要求保持接口完整的一致性，只要能够实现间接控制，有时候损及一些透明性是可以接受的。</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口隔离</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>门面模式</title>
    <link href="/2020/05/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/05/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7a3928dde4ef2752ff9b4bb248907763-21c79.png" alt="动机"></p><ul><li>上述A方案的问题在于组件的客户和组件中各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。</li><li>如何简化外部客户程序和系统间的交互接口？如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解耦？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>为子系统中的一组接口提供一个一致（稳定）的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用（复用）。——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/aaeb3252ee3997fa8d7ddb24e46ea28c-49978.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>门面模式实际上是一种开发素养，在考虑问题时需要一种边界的划分。面向使用者需要表示稳定，面向设计者需要快速的迭代</li><li>从客户程序的角度来看,Facade模式简化了整个组件系统的接口，对于组件内部与外部客户程序来说，达到一种”解耦“的效果。内部子系统的任何变化不会影响到Facade接口的变化。</li><li>Facade设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Facade很多时候更是一种<strong>架构设计模式</strong>。</li><li>Facade设计模式并非一个集装箱，可以任意地放进任何多个对象。Facade模式中组件的内部应该是”相互耦合关系比较大的一系列组件“，而不是一个简单的功能集合。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口隔离</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序</title>
    <link href="/2020/05/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/05/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/148a31f713059a4740a31f968d85ecd3-acb31.png" style="zoom:50%;" /></p><ul><li>快速排序基于的思想是分而治之。</li><li>快速排序的核心，就是如何快速的确定轴点。但是在原始序列中，轴点未必存在。 对此可知：<ul><li>快速排序的必要条件：轴点必定已然就位</li><li>特别地：在有序序列中，所有元素皆为轴点，反之亦然</li><li>所以，快速排序就是将所有元素逐个转换为轴点的过程</li><li>通过适当交换，可使任意元素转换为轴点</li></ul></li></ul><h3 id="单调性和不变性"><a href="#单调性和不变性" class="headerlink" title="单调性和不变性"></a>单调性和不变性</h3><ul><li><p>将首元素作为候选轴点</p></li><li><p>$L\le pivot \le G$​；$U=[lo,hi]$​中，$[lo]$​和$[hi]$​​交替空闲。</p></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/39aece574515f0e81c9dbaeb593bc3b1-74d9f.png" style="zoom:50%;" /></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/4f6fea55f2afb37b5b7dcd646416a714-dd0b3.png" style="zoom:33%;" /></p><p>由此可见，虽然只需要$O(1)$​​​的辅助空间，但是由于<strong>lo/hi</strong>的移动方向<strong>相反</strong>，<strong>左/右侧</strong>的<strong>大/小</strong>重复元素可能<strong>前/后</strong>颠倒，所以快速排序是不稳定的。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//轴点构造算法：通过调整元素位置构造区间[lo, hi)的轴点，并返回其秩</span><br>Rank Vector&lt;T&gt;::<span class="hljs-built_in">partition</span> ( Rank lo, Rank hi ) &#123; <span class="hljs-comment">//LUG版本：基本形式</span><br>   <span class="hljs-built_in">swap</span> ( _elem[lo], _elem[ lo + <span class="hljs-built_in">rand</span>() % ( hi - lo ) ] ); <span class="hljs-comment">//任选一个元素与首元素交换</span><br>   hi--; T pivot = _elem[lo]; <span class="hljs-comment">//以首元素为候选轴点——经以上交换，等效于随机选取</span><br>   <span class="hljs-keyword">while</span> ( lo &lt; hi ) &#123; <span class="hljs-comment">//从向量的两端交替地向中间扫描</span><br>      <span class="hljs-keyword">while</span> ( ( lo &lt; hi ) &amp;&amp; ( pivot &lt;= _elem[hi] ) ) <span class="hljs-comment">//在不小于pivot的前提下</span><br>         hi--; <span class="hljs-comment">//向左拓展右端子向量</span><br>      _elem[lo] = _elem[hi]; <span class="hljs-comment">//小于pivot者归入左侧子序列</span><br>      <span class="hljs-keyword">while</span> ( ( lo &lt; hi ) &amp;&amp; ( _elem[lo] &lt;= pivot ) ) <span class="hljs-comment">//在不大于pivot的前提下</span><br>         lo++; <span class="hljs-comment">//向右拓展左端子向量</span><br>      _elem[hi] = _elem[lo]; <span class="hljs-comment">//大于pivot者归入右侧子序列</span><br>   &#125; <span class="hljs-comment">//assert: lo == hi</span><br>   _elem[lo] = pivot; <span class="hljs-comment">//将备份的轴点记录置于前、后子向量之间</span><br>   <span class="hljs-keyword">return</span> lo; <span class="hljs-comment">//返回轴点的秩</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p><strong>最好情况：</strong>每次划分都（接近）平均，轴点总是（接近）中央，即</p><script type="math/tex; mode=display">T(n)=2*T((n-1)/2)+O(n)=O(nlog_2{n})</script><p><strong>最坏情况：</strong>每次划分都极不均衡。比如，轴点总是最小/大元素，即</p><script type="math/tex; mode=display">T(n)=T(n-1)+T(0)+O(n)=O(n^2)</script><p>最坏情况下，复杂度与与起泡排序相当。</p><p>即便采用随机选取、(Unix)三者去中之类的策略，也只能<strong>降低</strong>最坏情况的<strong>概率</strong>，而<strong>无法杜绝</strong>。</p><p><strong>平均情况：</strong>$O(log_2{n})=O(1.39*log_2{n})$</p><ul><li>这样小的常系数，也保证了快速排序算法在<strong>通常情况</strong>下的优异性能。</li></ul><h2 id="快速排序变种"><a href="#快速排序变种" class="headerlink" title="快速排序变种"></a>快速排序变种</h2><h3 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h3><ul><li><p>依然将首元素作为候选轴点</p></li><li><p>$[k]$​不小于轴点？直接G扩展：G滚动后移，L拓展。即</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">pivot &lt;= S[k] ? k++ : <span class="hljs-built_in">swap</span>(S[++mi],S[k++])<br></code></pre></div></td></tr></table></figure></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/2ebc70932cd3cb5fdc0505e7fffcbedd-fbeda.png" style="zoom:33%;" /></p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//轴点构造算法：通过调整元素位置构造区间[lo, hi)的轴点，并返回其秩</span><br>Rank Vector&lt;T&gt;::<span class="hljs-built_in">partition</span> ( Rank lo, Rank hi ) &#123; <span class="hljs-comment">//LGU版</span><br>   <span class="hljs-built_in">swap</span> ( _elem[lo], _elem[ lo + <span class="hljs-built_in">rand</span>() % ( hi - lo ) ] ); <span class="hljs-comment">//任选一个元素与首元素交换</span><br>   T pivot = _elem[lo]; <span class="hljs-comment">//以首元素为候选轴点——经以上交换，等效于随机选取</span><br>   <span class="hljs-keyword">int</span> mi = lo;<br>   <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> k = lo + <span class="hljs-number">1</span>; k &lt; hi; k++ ) <span class="hljs-comment">//自左向右扫描</span><br>      <span class="hljs-keyword">if</span> ( _elem[k] &lt; pivot ) <span class="hljs-comment">//若当前元素_elem[k]小于pivot，则</span><br>         <span class="hljs-built_in">swap</span> ( _elem[++mi], _elem[k] ); <span class="hljs-comment">//将_elem[k]交换至原mi之后，使L子序列向右扩展</span><br>   <span class="hljs-built_in">swap</span> ( _elem[lo], _elem[mi] ); <span class="hljs-comment">//候选轴点归位</span><br>   <span class="hljs-keyword">return</span> mi; <span class="hljs-comment">//返回轴点的秩</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b7a40b64d0eb40a8bd4e406fe53317eb-ee722.png" alt="实例" style="zoom:33%;" /></p><p>由此可见该算法也具有不稳定性。</p><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>每一个元素只需要花费常数时间，所以这个新的快速排序算法总体只需要$O(n)$。​</p><h2 id="选取：众数"><a href="#选取：众数" class="headerlink" title="选取：众数"></a>选取：众数</h2><p>在无序向量中，若有一半以上的元素同为m，则称之为众数。</p><ul><li>必要性：众数若存在，则必为中位数。因为众数所对应的那个区间，必然会覆盖中位数。所以只有中位数才是众数的唯一可能候选。</li><li>频繁数：众数若存在，则必是频繁数。</li></ul><p>摩尔投票算法是基于这个事实：每次从序列里选择两个不相同的数字删除掉（或称为“抵消”），最后剩下一个数字或几个相同的数字，就是出现次数大于总数一半的那个。</p><blockquote><p>核心就是<strong>对拼消耗</strong>。</p><p>玩一个诸侯争霸的游戏，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利。</p><p>那就大混战呗，最差所有人都联合起来对付你（对应你每次选择作为计数器的数都是众数），或者其他国家也会相互攻击（会选择其他数作为计数器的数），但是只要你们不要内斗，最后肯定你赢。</p></blockquote><p>参考：<a href="https://www.zhihu.com/question/49973163">如何理解摩尔投票算法？</a></p><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function">T <span class="hljs-title">majEleCandidate</span> <span class="hljs-params">( Vector&lt;T&gt; A )</span> </span>&#123; <span class="hljs-comment">//选出具备必要条件的众数候选者</span><br>   T maj; <span class="hljs-comment">//众数候选者</span><br><span class="hljs-comment">// 线性扫描：借助计数器c，记录maj与其它元素的数量差额</span><br>   <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++ )<br>      <span class="hljs-keyword">if</span> ( <span class="hljs-number">0</span> == c ) &#123; <span class="hljs-comment">//每当c归零，都意味着此时的前缀P可以剪除</span><br>         maj = A[i]; c = <span class="hljs-number">1</span>; <span class="hljs-comment">//众数候选者改为新的当前元素</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-comment">//否则</span><br>         maj == A[i] ? c++ : c--; <span class="hljs-comment">//相应地更新差额计数器</span><br>   <span class="hljs-keyword">return</span> maj; <span class="hljs-comment">//至此，原向量的众数若存在，则只能是maj —— 尽管反之不然</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><ul><li>希尔排序在对矩阵逐列排序时，所使用的算法本身未必需要十分高效，而更重要的是应该具有输入敏感的特性。所以更倾向于使用插入排序。</li><li>当步长集合中，其中的各项并非互素，因此每一轮的排序都有大量的精力浪费于对前一轮排序工作的重复之上。所以，步长集合中，相邻项需要尽可能的互素。</li><li><p>任何一个原先已是g-ordered的序列，在此后经过h-sorting之后，依然保持是g-ordered。也就是说相对于任何一个固定间隔而言的有序性，在希尔排序的过程中，将会不断的保持，并且持续的积累下来。</p></li><li><p>如果是一个序列是g-ordered同时也是h-ordered，那么这个序列也满足(g+h)-ordered，同时也满足(ng+mh)-ordered。由此可得到一个结论，凡是间距可以表示为<strong>线性组合</strong>的任何一对元素必然是顺序的。</p></li><li>邮资问题：在g和h两种面值的钞票组合中，它们只能组成大于$(g-1)(h-1)-1$​的面值。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速排序</tag>
      
      <tag>希尔排序</tag>
      
      <tag>摩尔投票法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>享元模式</title>
    <link href="/2020/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E6%80%A7%E8%83%BD%EF%BC%9A%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E6%80%A7%E8%83%BD%EF%BC%9A%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件系统采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行时代价：主要指内存需求方面的代价。</li><li>如何在避免大量细粒度对象问题的同时，让外部客户程序仍然能够透明地使用面向对象的方式来进行操作？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>运用共享技术有效地支持大量细粒度的对象</p><p>——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用享元模式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Font</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-comment">//unique object key</span><br>    string key;<br>    <br>    <span class="hljs-comment">//object state</span><br>    <span class="hljs-comment">//....</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Font</span>(<span class="hljs-keyword">const</span> string&amp; key)&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;;<br>ß<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FontFactory</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//使用map存放，可以根据实际情况更换数据结构</span><br>    map&lt;string,Font* &gt; fontPool;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Font* <span class="hljs-title">GetFont</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp; key)</span></span>&#123;<br><br>        map&lt;string,Font*&gt;::iterator item=fontPool.<span class="hljs-built_in">find</span>(key);<br>        <br>        <span class="hljs-keyword">if</span>(item!=footPool.<span class="hljs-built_in">end</span>())&#123;<span class="hljs-comment">//如果有</span><br>            <span class="hljs-keyword">return</span> fontPool[key];<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果没有</span><br>            Font* font = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Font</span>(key);<span class="hljs-comment">//创建一个新的对象</span><br>            fontPool[key]= font;<br>            <span class="hljs-keyword">return</span> font;<br>        &#125;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/74b3290484036b5227b72f08956d1b60-8f07f.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>用一种共享的方式创建对象，有就返回，没有就创建</li><li>一般来讲，对象的状态尽可能的实现只读的方式</li><li>面向对象很好地解决了抽象性的问题，但是作为一个运行在机器中的程序实体，我们需要考虑对象的代价问题。Flyweight主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。</li><li>Flyweight采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体实现方面，要注意对象状态的处理。</li><li>对象的数量太大从而导致对象内存开销加大，什么样的数量才算大？这需要我们仔细的根据具体应用情况进行评估，而不能凭空臆断。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对象性能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2020/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E6%80%A7%E8%83%BD%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E6%80%A7%E8%83%BD%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率。</li><li>如果绕过常规的构造器，提供一种机制来保证一个类只有一个实例？这应该是类设计者的责任，而不是使用者的责任。也就是说不应该规范使用者的使用方式，而是让类设计者在设计的时候就需要考虑。</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>保证一个类仅有一个实例，并提供一个该实例的全局访问点。</p><p>——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用单例模式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>();<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-keyword">const</span> Singleton&amp; other);<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">static</span> Singleton* m_instance;<br>&#125;;<br><br>Singleton* Singleton::m_instance=<span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-comment">//线程非安全版本</span><br><span class="hljs-function">Singleton* <span class="hljs-title">Singleton::getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (m_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>        m_instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> m_instance;<br>&#125;<br><br><span class="hljs-comment">//线程安全版本，但锁的代价过高</span><br><span class="hljs-function">Singleton* <span class="hljs-title">Singleton::getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    Lock lock;<br>    <span class="hljs-keyword">if</span> (m_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>        m_instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> m_instance;<br>&#125;<br><br><span class="hljs-comment">//双检查锁，但由于内存读写reorder不安全</span><br><span class="hljs-function">Singleton* <span class="hljs-title">Singleton::getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">if</span>(m_instance==<span class="hljs-literal">nullptr</span>)&#123;<br>        Lock lock;<br>        <span class="hljs-keyword">if</span> (m_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>            m_instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> m_instance;<br>&#125;<br><br><span class="hljs-comment">//C++ 11版本之后的跨平台实现 (volatile)</span><br>std::atomic&lt;Singleton*&gt; Singleton::m_instance;<br>std::mutex Singleton::m_mutex;<br><br><span class="hljs-function">Singleton* <span class="hljs-title">Singleton::getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    Singleton* tmp = m_instance.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>    std::<span class="hljs-built_in">atomic_thread_fence</span>(std::memory_order_acquire);<span class="hljs-comment">//获取内存fence</span><br>    <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mutex)</span></span>;<br>        tmp = m_instance.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>        <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span>) &#123;<br>            tmp = <span class="hljs-keyword">new</span> Singleton;<br>            std::<span class="hljs-built_in">atomic_thread_fence</span>(std::memory_order_release);<span class="hljs-comment">//释放内存fence</span><br>            m_instance.<span class="hljs-built_in">store</span>(tmp, std::memory_order_relaxed);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里需要特别注意双检查锁会发生的reorder问题：<br><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//双检查锁，但由于内存读写reorder不安全</span><br><span class="hljs-function">Singleton* <span class="hljs-title">Singleton::getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">if</span>(m_instance==<span class="hljs-literal">nullptr</span>)&#123;<span class="hljs-comment">//1</span><br>        Lock lock;<br>        <span class="hljs-keyword">if</span> (m_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>            m_instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<span class="hljs-comment">//2</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> m_instance;<span class="hljs-comment">//3</span><br>&#125;<br></code></pre></div></td></tr></table></figure></p><p>假设此时有两个线程A和B，且没有<code>Singleton</code>实例。</p><p>当A执行到<strong>代码行2</strong>时，由于编译器的优化，<strong>可能</strong>会将<code>new</code>本来的内部执行顺序从<strong>开辟内存-&gt;执行构造-&gt;赋予指针</strong>转变为<strong>开辟内存-&gt;赋予指针-&gt;执行构造</strong>，那么当A执行完<strong>赋予指针</strong>（即此时的<code>m_instance</code>已经被赋予地址了），并处于即将<strong>执行构造</strong>的时刻，B开始了。B执行到<strong>代码行1</strong>时，由于此时<code>m_instance</code>不是<code>nullptr</code>，所以B会直接执行<strong>代码行3</strong>，返回一块什么东西都没有的内存。若此时B中对<code>m_instance</code>进行操作，将会报错。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>构造和拷贝构造设置为私有的</li><li>Singleton模式中的实例构造器可以设置为protected以允许子类派生。</li><li>Singleton模式一般不要支持拷贝构造函数和Clone接口，因为这有可能导致多个对象实例，与Singleton模式的初衷违背。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对象性能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构建器</title>
    <link href="/2020/05/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%9A%E6%9E%84%E5%BB%BA%E5%99%A8/"/>
    <url>/2020/05/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%9A%E6%9E%84%E5%BB%BA%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定</li><li>如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>将一个复杂对象的构建与其表示相分离，使得同样的构建过程(稳定)可以创建不同的表示(变化)。</p><p> ——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>建房子一般的流程都是一样的，从地基开始，等等….假设流程固定，但是整个流程却很庞大，如果把房子的属性和创建过程放在同一个类里，整个类会非常的臃肿。所以可以尝试将构建过程提取出来。</p><p><strong>运用构建器模式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//House：显示的部分</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">House</span>&#123;</span><br>    <span class="hljs-comment">//....</span><br>&#125;;<br><span class="hljs-comment">//HouseBuilder:创建细节</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HouseBuilder</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">House* <span class="hljs-title">GetResult</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> pHouse;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">HouseBuilder</span>()&#123;&#125;<br><span class="hljs-keyword">protected</span>:<br>    <br>    House* pHouse;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart1</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart2</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart3</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart4</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart5</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StoneHouse</span>:</span> <span class="hljs-keyword">public</span> House&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StoneHouseBuilder</span>:</span> <span class="hljs-keyword">public</span> HouseBuilder&#123;<br><span class="hljs-keyword">protected</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//pHouse-&gt;Part1 = ...;</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart2</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart3</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart4</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart5</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-comment">//HouseDirector：具体构造过程</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HouseDirector</span>&#123;</span><br>    <br><span class="hljs-keyword">public</span>:<br>    HouseBuilder* pHouseBuilder;<br>    <br>    <span class="hljs-built_in">HouseDirector</span>(HouseBuilder* pHouseBuilder)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;pHouseBuilder=pHouseBuilder;<br>    &#125;<br>    <br>    <span class="hljs-function">House* <span class="hljs-title">Construct</span><span class="hljs-params">()</span></span>&#123;<br>        <br>        pHouseBuilder-&gt;<span class="hljs-built_in">BuildPart1</span>();<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br>            pHouseBuilder-&gt;<span class="hljs-built_in">BuildPart2</span>();<br>        &#125;<br>        <br>        <span class="hljs-keyword">bool</span> flag=pHouseBuilder-&gt;<span class="hljs-built_in">BuildPart3</span>();<br>        <br>        <span class="hljs-keyword">if</span>(flag)&#123;<br>            pHouseBuilder-&gt;<span class="hljs-built_in">BuildPart4</span>();<br>        &#125;<br>        <br>        pHouseBuilder-&gt;<span class="hljs-built_in">BuildPart5</span>();<br>        <br>        <span class="hljs-keyword">return</span> pHouseBuilder-&gt;<span class="hljs-built_in">GetResult</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//实现（以伪代码形式）</span><br><span class="hljs-comment">//初始化House子类...添加属性等</span><br><span class="hljs-comment">//初始化HouseBuilder子类...在之前需实现创建过程中的具体细节...</span><br><span class="hljs-comment">//实例化HouseDirector，即HouseDirector(HouseBuilder)</span><br><span class="hljs-comment">//让HouseDirector执行创建流程Construct，并返回House类型</span><br><span class="hljs-comment">//至此一个House类型对象被创建出来</span><br></code></pre></div></td></tr></table></figure><p>注意：<code>HouseBuilder</code>和<code>HouseDirector</code>有些时候可以合并，依据实际业务场景或者类的设计。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6822e8f448c550326024214c80d01abd-c01d0.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p><strong>父类构造函数中调用虚函数是静态绑定，是不会去调用子类实现的虚函数的。</strong>若为动态绑定，那么子类构造时先调用父类的构造函数，父类的构造函数又调用子类实现的虚函数，这样做违背”伦理“。因为子类并没有构造出来，却被调用了其中的方法。</p></li><li><p>构建过程太过复杂，导致类变得很肥大。可以考虑将构建过程提取出来</p></li><li>Builder模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。</li><li>变化点在哪里，封装哪里—— Builder模式主要在于应对“复杂对象各个部分”的频繁需求变动。其缺点在于难以应对“分步骤构建算法”的需求变动。</li><li>在Builder模式中，要注意不同语言中构造器内调用虚函数的差别 （C++ vs. C#) 。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对象创建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型模式</title>
    <link href="/2020/05/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%9A%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/05/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%9A%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件系统中，经常面临着”某些结构复杂的对象“的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是它们却拥有比较稳定一致的接口。</li><li>如何应对这种变化？如何向”客户程序（使用这些对象的程序）“隔离出”这些易变对象“，从而使得”依赖这些易变对象的客户程序“不随着需求改变而改变？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象</p><p> ——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用原型模型前：</strong>（借用<strong>工厂模式</strong>的代码，需求和工厂模式一样，只是在本例中，ISplitter的派生类除了有稳定的部分，假设也有剧烈改动的部分）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//抽象类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ISplitter</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//工厂基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SplitterFactory</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">SplitterFactory</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//具体类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySplitter</span> :</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-comment">//具体工厂</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinarySplitter</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TxtSplitter</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">PictureSplitter</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">VideoSplitter</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//mainform</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form<br>&#123;<br>    SplitterFactory*  factory;<span class="hljs-comment">//工厂</span><br><br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">MainForm</span>(SplitterFactory*  factory)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;factory=factory;<br>    &#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span></span>&#123;<br><br>ISplitter * splitter=<br>            factory-&gt;<span class="hljs-built_in">CreateSplitter</span>(); <span class="hljs-comment">//多态new</span><br>        <br>        splitter-&gt;<span class="hljs-built_in">split</span>();<br><br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>但是假设<code>ISplitter</code>派生类构造时需要非常多的资源，比如硬件资源和数据资源，而现在的需求场景又需要不断的创建派生类。这种把资源花费在创建开销上非常的奢侈（比如频繁创建一个数据库实例），所以由此引出一种可以克隆原来已有实例的原型模式，通过克隆降低频繁构造时带来的影响。</p><p><strong>运用原型模式后：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//抽象类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>; <span class="hljs-comment">//通过克隆自己来创建对象</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ISplitter</span>()&#123;&#125;<br><br>&#125;;<br><br><span class="hljs-comment">//具体类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySplitter</span> :</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinarySplitter</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TxtSplitter</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">PictureSplitter</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">VideoSplitter</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form<br>&#123;<br>    ISplitter*  prototype;<span class="hljs-comment">//原型对象</span><br><br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">MainForm</span>(ISplitter*  prototype)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;prototype=prototype;<br>    &#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span></span>&#123;<br><br>ISplitter * splitter=<br>            prototype-&gt;<span class="hljs-built_in">clone</span>(); <span class="hljs-comment">//克隆原型</span><br>        <br>        splitter-&gt;<span class="hljs-built_in">split</span>();<br>        <br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/910596454b87a89a0dd626669ff6d942-d51ba.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>通过克隆自己来创建对象</li><li><strong>Prototype</strong>模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类“拥有”稳定的接口“。</li><li><strong>Prototype</strong>模式对于”如何创建易变类的实体对象“采用”原型克隆“的方法来做，它使得我们可以非常灵活地动态创建”拥有某些稳定接口“的新对象，所需工作仅仅是注册一个新类的对象（即原型），然后在任何需要的地方Clone。</li><li><strong>Prototype</strong>模式中的Clone方法可以利用某些框架中的序列化来实现深拷贝。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对象创建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>串</title>
    <link href="/2020/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E4%B8%B2/"/>
    <url>/2020/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="串匹配"><a href="#串匹配" class="headerlink" title="串匹配"></a>串匹配</h2><h3 id="蛮力算法1"><a href="#蛮力算法1" class="headerlink" title="蛮力算法1"></a>蛮力算法1</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/******************************************************************************************</span><br><span class="hljs-comment"> * Text     :  0   1   2   .   .   .   i-j .   .   .   .   i   .   .   n-1</span><br><span class="hljs-comment"> *             ------------------------|-------------------|------------</span><br><span class="hljs-comment"> * Pattern  :                          0   .   .   .   .   j   .   .</span><br><span class="hljs-comment"> *                                     |-------------------|</span><br><span class="hljs-comment"> ******************************************************************************************/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">match</span> <span class="hljs-params">( <span class="hljs-keyword">char</span>* P, <span class="hljs-keyword">char</span>* T )</span> </span>&#123; <span class="hljs-comment">//串匹配算法（Brute-force-1）</span><br>   <span class="hljs-keyword">size_t</span> n = <span class="hljs-built_in">strlen</span> ( T ), i = <span class="hljs-number">0</span>; <span class="hljs-comment">//文本串长度、当前接受比对字符的位置</span><br>   <span class="hljs-keyword">size_t</span> m = <span class="hljs-built_in">strlen</span> ( P ), j = <span class="hljs-number">0</span>; <span class="hljs-comment">//模式串长度、当前接受比对字符的位置</span><br>   <span class="hljs-keyword">while</span> ( j &lt; m &amp;&amp; i &lt; n ) <span class="hljs-comment">//自左向右逐个比对字符</span><br>      <span class="hljs-comment">/*DSA*/</span>&#123;<br>      <span class="hljs-comment">/*DSA*/</span><span class="hljs-built_in">showProgress</span> ( T, P, i - j, j );   <span class="hljs-built_in">getchar</span>();<br>      <span class="hljs-keyword">if</span> ( T[i] == P[j] ) <span class="hljs-comment">//若匹配</span><br>         &#123; i ++;  j ++; &#125; <span class="hljs-comment">//则转到下一对字符</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-comment">//否则</span><br>         &#123; i -= j - <span class="hljs-number">1</span>; j = <span class="hljs-number">0</span>; &#125; <span class="hljs-comment">//文本串回退、模式串复位</span><br>      <span class="hljs-comment">/*DSA*/</span>&#125;<br>   <span class="hljs-keyword">return</span> i - j; <span class="hljs-comment">//如何通过返回值，判断匹配结果？</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="蛮力算法2"><a href="#蛮力算法2" class="headerlink" title="蛮力算法2"></a>蛮力算法2</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/******************************************************************************************</span><br><span class="hljs-comment"> * Text     :  0   1   2   .   .   .   i   i+1 .   .   .   i+j .   .   n-1</span><br><span class="hljs-comment"> *             ------------------------|-------------------|------------</span><br><span class="hljs-comment"> * Pattern  :                          0   1   .   .   .   j   .   .</span><br><span class="hljs-comment"> *                                     |-------------------|</span><br><span class="hljs-comment"> ******************************************************************************************/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">match</span> <span class="hljs-params">( <span class="hljs-keyword">char</span>* P, <span class="hljs-keyword">char</span>* T )</span> </span>&#123; <span class="hljs-comment">//串匹配算法（Brute-force-2）</span><br>   <span class="hljs-keyword">size_t</span> n = <span class="hljs-built_in">strlen</span> ( T ), i = <span class="hljs-number">0</span>; <span class="hljs-comment">//文本串长度、与模式串首字符的对齐位置</span><br>   <span class="hljs-keyword">size_t</span> m = <span class="hljs-built_in">strlen</span> ( P ), j; <span class="hljs-comment">//模式串长度、当前接受比对字符的位置</span><br>   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; n - m + <span class="hljs-number">1</span>; i++ ) &#123; <span class="hljs-comment">//文本串从第i个字符起，与</span><br>      <span class="hljs-keyword">for</span> ( j = <span class="hljs-number">0</span>; j &lt; m; j++ ) <span class="hljs-comment">//模式串中对应的字符逐个比对</span><br>         <span class="hljs-comment">/*DSA*/</span>&#123;<span class="hljs-built_in">showProgress</span> ( T, P, i, j ); <span class="hljs-built_in">getchar</span>();<br>         <span class="hljs-keyword">if</span> ( T[i + j] != P[j] ) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//若失配，模式串整体右移一个字符，再做一轮比对</span><br>         <span class="hljs-comment">/*DSA*/</span>&#125;<br>      <span class="hljs-keyword">if</span> ( j &gt;= m ) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//找到匹配子串</span><br>   &#125;<br>   <span class="hljs-keyword">return</span> i; <span class="hljs-comment">//如何通过返回值，判断匹配结果？</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>在最坏情况下，每次迭代模式串m中的m-1个字符都会参与文本串n的比对，才能在最后一个位置发现失配，而蛮力算法的主要成本，也主要消耗于失配字符的前缀中。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/896074d3b792e61c0a5ac4f8cb68ec84-d072d.png" style="zoom:50%;" /></p><p>当字母表m的长度越大，蛮力算法的复杂度越接近线性。</p><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/1431e66c1cfda4c49d435914edfb7c86-d6a42.png" style="zoom:50%;" /></p><h3 id="优化效果"><a href="#优化效果" class="headerlink" title="优化效果"></a>优化效果</h3><ul><li>大幅度的向后滑动模式串</li><li>避免重复比对</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>预处理：</p><ul><li>构造查询表<code>next[o,m)</code>：在任意位置<strong>p[j]</strong>处失败后，将<strong>j</strong>替换为<code>next[j]</code>。</li></ul><p>这个过程与文本串无关，与模式串有关。</p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/440716fc3eda4cba60d5923f7c3c180d-0e647.png" style="zoom: 33%;" /></p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>快速右移的根本就是<strong>模式串自身的匹配性</strong>。</p><p>如果最大公共前后缀长度为n，那么模式串的n+1号位与主串的当前位进行比较。</p><p>KMP所舍弃的对齐位置，是除了最长公共前后缀的其余公共前后缀，因为这些公共前后缀在模式串中位移较小，会不安全。</p><p>对于长度为n的文本串和长度为m的模式串，KMP算法的时间复杂度为：$O(m+n)$</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>next表构造算法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">buildNext</span> <span class="hljs-params">( <span class="hljs-keyword">char</span>* P )</span> </span>&#123; <span class="hljs-comment">//构造模式串P的next表（改进版本）</span><br>   <span class="hljs-keyword">size_t</span> m = <span class="hljs-built_in">strlen</span> ( P ), j = <span class="hljs-number">0</span>; <span class="hljs-comment">//“主”串指针</span><br>   <span class="hljs-keyword">int</span>* N = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m]; <span class="hljs-comment">//next表</span><br>   <span class="hljs-keyword">int</span> t = N[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>; <span class="hljs-comment">//模式串指针</span><br>   <span class="hljs-keyword">while</span> ( j &lt; m - <span class="hljs-number">1</span> )<br>      <span class="hljs-keyword">if</span> ( <span class="hljs-number">0</span> &gt; t || P[j] == P[t] ) &#123; <span class="hljs-comment">//匹配</span><br>         N[j] = ( P[++j] != P[++t] ? t : N[t] ); <span class="hljs-comment">//注意此句与未改进之前的区别</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-comment">//失配</span><br>         t = N[t];<br>   <span class="hljs-comment">/*DSA*/</span><span class="hljs-built_in">printString</span> ( P ); <span class="hljs-built_in">printf</span> ( <span class="hljs-string">&quot;\n&quot;</span> );<br>   <span class="hljs-comment">/*DSA*/</span><span class="hljs-built_in">printNext</span> ( N, <span class="hljs-number">0</span>, <span class="hljs-built_in">strlen</span> ( P ) );<br>   <span class="hljs-keyword">return</span> N;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>整体算法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">match</span> <span class="hljs-params">( <span class="hljs-keyword">char</span>* P, <span class="hljs-keyword">char</span>* T )</span> </span>&#123;  <span class="hljs-comment">//KMP算法</span><br>   <span class="hljs-keyword">int</span>* next = <span class="hljs-built_in">buildNext</span> ( P ); <span class="hljs-comment">//构造next表</span><br>   <span class="hljs-keyword">int</span> n = ( <span class="hljs-keyword">int</span> ) <span class="hljs-built_in">strlen</span> ( T ), i = <span class="hljs-number">0</span>; <span class="hljs-comment">//文本串指针</span><br>   <span class="hljs-keyword">int</span> m = ( <span class="hljs-keyword">int</span> ) <span class="hljs-built_in">strlen</span> ( P ), j = <span class="hljs-number">0</span>; <span class="hljs-comment">//模式串指针</span><br>   <span class="hljs-keyword">while</span> ( j &lt; m  &amp;&amp; i &lt; n ) <span class="hljs-comment">//自左向右逐个比对字符</span><br>      <span class="hljs-keyword">if</span> ( <span class="hljs-number">0</span> &gt; j || T[i] == P[j] ) <span class="hljs-comment">//若匹配，或P已移出最左侧（两个判断的次序不可交换）</span><br>         &#123; i ++;  j ++; &#125; <span class="hljs-comment">//则转到下一字符</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-comment">//否则</span><br>         j = next[j]; <span class="hljs-comment">//模式串右移（注意：文本串不用回退）</span><br>      <span class="hljs-comment">/*DSA*/</span>&#125;<br>   <span class="hljs-keyword">delete</span> [] next; <span class="hljs-comment">//释放next表</span><br>   <span class="hljs-keyword">return</span> i - j;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="美中不足"><a href="#美中不足" class="headerlink" title="美中不足"></a>美中不足</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/ffc9d6c084e73d94d074cf2876dc47a2-079bc.png" style="zoom:50%;" /></p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>KMP算法在最坏的情况下为$O(2n)=O(n)$</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>只有在字符集很小的情况下，KMP算法的性能才能很好的展示。</p><p>如果字符集很大，蛮力算法的线性时间复杂度出现的情况会更高。</p><h2 id="BM家族"><a href="#BM家族" class="headerlink" title="BM家族"></a>BM家族</h2><h3 id="BC算法"><a href="#BC算法" class="headerlink" title="BC算法"></a>BC算法</h3><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7f17bef9a01bf72993f12315b4b4de5c-fe150.png" alt="实例" style="zoom: 33%;" /></p><h4 id="坏字符"><a href="#坏字符" class="headerlink" title="坏字符"></a>坏字符</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/ff34dcd12e41169de5987932372eeb10-ee47c.png" alt="坏字符" style="zoom:50%;" /></p><ul><li>注意：位移量取决于失配位置j，以及X在P中的秩，而与T和i无关。</li><li>若令$bc[x] = rank[x] = j -shift$，则bc[]总计有$s=|\sum|$​项，且可事先计算，并制表待查。</li></ul><p>特殊情况：</p><ul><li>若模式串P中有多个X，选用最靠后的那个X，也就是秩最大的那个。（为了避免回溯，在安全的情况下需要让位移量尽可能的小）</li><li>当模式串中根本没有X，使用假想的通配哨兵，将通配哨兵与失配字符匹配。 </li><li>当模式串中的X的秩大于j，那么就将模式串整体右移一个单位。（下图）<img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/3ed04188eaaa7a2650c78a2c8a534c47-ebb1f.png"  /></li></ul><h4 id="构造BC表"><a href="#构造BC表" class="headerlink" title="构造BC表"></a>构造BC表</h4><p>任何一个字符所对应表项得最终取值，是取决于它在模式串中出现位置<strong>最靠后</strong>的那一次。（画家算法）</p><h5 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">buildBC</span> <span class="hljs-params">( <span class="hljs-keyword">char</span>* P )</span> </span>&#123; <span class="hljs-comment">//构造Bad Charactor Shift表：O(m + 256)</span><br>   <span class="hljs-keyword">int</span>* bc = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">256</span>]; <span class="hljs-comment">//BC表，与字符表等长</span><br>   <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">size_t</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">256</span>; j ++ ) bc[j] = <span class="hljs-number">-1</span>; <span class="hljs-comment">//初始化：首先假设所有字符均未在P中出现</span><br>   <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">size_t</span> m = <span class="hljs-built_in">strlen</span> ( P ), j = <span class="hljs-number">0</span>; j &lt; m; j ++ ) <span class="hljs-comment">//自左向右扫描模式串P</span><br>      bc[ P[j] ] = j; <span class="hljs-comment">//将字符P[j]的BC项更新为j（单调递增）——画家算法</span><br>   <span class="hljs-comment">/*DSA*/</span><span class="hljs-built_in">printBC</span> ( bc );<br>   <span class="hljs-keyword">return</span> bc;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h4><h5 id="最好情况"><a href="#最好情况" class="headerlink" title="最好情况"></a>最好情况</h5><ul><li>$O(n/m)$</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7693ba999c51879f9b9451f2c00d1eae-1d1f7.png" alt="最好情况"></p><p>一般地，只要P不含$T[i+j]$，即可直接移动m个字符。仅需单次比较，即可排除掉m个对齐位置。</p><p><strong>结论：单次匹配概率越小，性能优势越明显。</strong>比如大字母表：ASCII+UniCode。</p><p>与KMP算法相比：</p><ul><li>KMP善于利用经验</li><li>BM乐于借鉴教训</li></ul><h5 id="最坏情况"><a href="#最坏情况" class="headerlink" title="最坏情况"></a>最坏情况</h5><ul><li>$O(n*m)$，直接退化成蛮力算法</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5e6369aed52dd9ee9b197786e6e23a08-c179b.png" alt="最坏情况"></p><h2 id="各算法总览"><a href="#各算法总览" class="headerlink" title="各算法总览"></a>各算法总览</h2><ul><li>Pr为字母表长度</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/01cf0f7b8fc23f1cbd1420c1324fdad6-30f06.png" alt=""></p><h2 id="Karp-Rabin算法"><a href="#Karp-Rabin算法" class="headerlink" title="Karp-Rabin算法"></a>Karp-Rabin算法</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/36d42e5aff10c2dbf4c77469a6dfb5ed-fcc99.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>KMP算法</tag>
      
      <tag>BM-BC算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象工厂模式</title>
    <link href="/2020/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%9A%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%9A%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作。</li><li>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一 种“封装机制”来避免客户程序和这种“多系列具体对象创建工作” 的紧耦合？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。</p><p> ——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>现在的需求是：创建一个数据库的初始化类，数据库选择SQL Server，其中有三个方法：</p><ul><li><code>ConnectionString()</code></li><li><code>CommandText(...)</code></li><li><code>ExecuteReader()</code></li></ul><p>假设不管初始化哪种数据库，都需要通过这三个方法</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeDAO</span>&#123;</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;EmployeeDO&gt; <span class="hljs-title">GetEmployees</span><span class="hljs-params">()</span></span>&#123;<br>        SqlConnection* connection =<br>            <span class="hljs-keyword">new</span> <span class="hljs-built_in">SqlConnection</span>();<br>        connection-&gt;<span class="hljs-built_in">ConnectionString</span>(...);<br><br>        SqlCommand* command =<br>            <span class="hljs-keyword">new</span> <span class="hljs-built_in">SqlCommand</span>();<br>        command-&gt;<span class="hljs-built_in">CommandText</span>(...);<br>        command-&gt;<span class="hljs-built_in">SetConnection</span>(connection);<br><br>        SqlDataReader* reader = command-&gt;<span class="hljs-built_in">ExecuteReader</span>();<br>        <span class="hljs-keyword">while</span> (reader-&gt;<span class="hljs-built_in">Read</span>())&#123;<br><br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>虽然说这样写能够实现，但是如果要更换数据库的时候，比如更换成MySql时，就需要按照上面的代码重新再写一遍。而且现实中，对于同样类型的业务操作一般都提供了对外的接口，所以需要重构代码，将数据库的调用方式以多态的方式实现。</p><p>所以现在可以尝试使用工厂模式。</p><p><strong>运用工厂模式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//数据库访问有关的基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBConnection</span>&#123;</span><br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBConnectionFactory</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBConnection* <span class="hljs-title">CreateDBConnection</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBCommand</span>&#123;</span><br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBCommandFactory</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBCommand* <span class="hljs-title">CreateDBCommand</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDataReader</span>&#123;</span><br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDataReaderFactory</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDataReader* <span class="hljs-title">CreateDataReader</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><br><br><span class="hljs-comment">//支持SQL Server</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlConnection</span>:</span> <span class="hljs-keyword">public</span> IDBConnection&#123;<br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlConnectionFactory</span>:</span><span class="hljs-keyword">public</span> IDBConnectionFactory&#123;<br>    <br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlCommand</span>:</span> <span class="hljs-keyword">public</span> IDBCommand&#123;<br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlCommandFactory</span>:</span><span class="hljs-keyword">public</span> IDBCommandFactory&#123;<br>    <br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDataReader</span>:</span> <span class="hljs-keyword">public</span> IDataReader&#123;<br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDataReaderFactory</span>:</span><span class="hljs-keyword">public</span> IDataReaderFactory&#123;<br>    <br>&#125;;<br><br><span class="hljs-comment">//支持Oracle</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleConnection</span>:</span> <span class="hljs-keyword">public</span> IDBConnection&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleCommand</span>:</span> <span class="hljs-keyword">public</span> IDBCommand&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleDataReader</span>:</span> <span class="hljs-keyword">public</span> IDataReader&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeDAO</span>&#123;</span><br>    IDBConnectionFactory* dbConnectionFactory;<br>    IDBCommandFactory* dbCommandFactory;<br>    IDataReaderFactory* dataReaderFactory;<br>    <br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;EmployeeDO&gt; <span class="hljs-title">GetEmployees</span><span class="hljs-params">()</span></span>&#123;<br>        IDBConnection* connection =<br>            dbConnectionFactory-&gt;<span class="hljs-built_in">CreateDBConnection</span>();<br>        connection-&gt;<span class="hljs-built_in">ConnectionString</span>(<span class="hljs-string">&quot;...&quot;</span>);<br><br>        IDBCommand* command =<br>            dbCommandFactory-&gt;<span class="hljs-built_in">CreateDBCommand</span>();<br>        command-&gt;<span class="hljs-built_in">CommandText</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>        command-&gt;<span class="hljs-built_in">SetConnection</span>(connection); <span class="hljs-comment">//关联性</span><br><br>        IDBDataReader* reader = command-&gt;<span class="hljs-built_in">ExecuteReader</span>(); <span class="hljs-comment">//关联性</span><br>        <span class="hljs-keyword">while</span> (reader-&gt;<span class="hljs-built_in">Read</span>())&#123;<br><br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>虽然说对于<code>EmployeeDAO</code>类已经解除了静态绑定，通过三个指针转换成了更灵活的动态绑定，但是分析后发现：</p><ul><li>有了对象的接口，也有对象对应的工厂接口</li><li>这三个对象是同组的可以搭配的，有关联性，比如都是SQL Server的</li></ul><p>通过工厂模式的处理固然是好的，但是并不是最好的。虽然<code>EmployeeDAO</code>更灵活了，但是牺牲的是对于三个指针以及他们类型的处理。既然三个指针的类型实际上都是关联操作，那么可以将他们再进一步的抽象</p><p><strong>运用抽象工厂模式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//数据库访问有关的基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBConnection</span>&#123;</span><br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBCommand</span>&#123;</span><br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDataReader</span>&#123;</span><br>    <br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBFactory</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBConnection* <span class="hljs-title">CreateDBConnection</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBCommand* <span class="hljs-title">CreateDBCommand</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDataReader* <span class="hljs-title">CreateDataReader</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <br>&#125;;<br><br><br><span class="hljs-comment">//支持SQL Server</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlConnection</span>:</span> <span class="hljs-keyword">public</span> IDBConnection&#123;<br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlCommand</span>:</span> <span class="hljs-keyword">public</span> IDBCommand&#123;<br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDataReader</span>:</span> <span class="hljs-keyword">public</span> IDataReader&#123;<br>    <br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDBFactory</span>:</span><span class="hljs-keyword">public</span> IDBFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBConnection* <span class="hljs-title">CreateDBConnection</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBCommand* <span class="hljs-title">CreateDBCommand</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDataReader* <span class="hljs-title">CreateDataReader</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br> <br>&#125;;<br><br><span class="hljs-comment">//支持Oracle</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleConnection</span>:</span> <span class="hljs-keyword">public</span> IDBConnection&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleCommand</span>:</span> <span class="hljs-keyword">public</span> IDBCommand&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleDataReader</span>:</span> <span class="hljs-keyword">public</span> IDataReader&#123;<br>    <br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeDAO</span>&#123;</span><br>    IDBFactory* dbFactory;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;EmployeeDO&gt; <span class="hljs-title">GetEmployees</span><span class="hljs-params">()</span></span>&#123;<br>        IDBConnection* connection =<br>            dbFactory-&gt;<span class="hljs-built_in">CreateDBConnection</span>();<br>        connection-&gt;<span class="hljs-built_in">ConnectionString</span>(<span class="hljs-string">&quot;...&quot;</span>);<br><br>        IDBCommand* command =<br>            dbFactory-&gt;<span class="hljs-built_in">CreateDBCommand</span>();<br>        command-&gt;<span class="hljs-built_in">CommandText</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>        command-&gt;<span class="hljs-built_in">SetConnection</span>(connection); <span class="hljs-comment">//关联性</span><br><br>        IDBDataReader* reader = command-&gt;<span class="hljs-built_in">ExecuteReader</span>(); <span class="hljs-comment">//关联性</span><br>        <span class="hljs-keyword">while</span> (reader-&gt;<span class="hljs-built_in">Read</span>())&#123;<br><br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>将三个关联性强的对象封装到工厂类里，也就是把三个容易变化的东西关在笼子里。这样一来，不管是后续再增加何种类型的数据库，都能灵活应对。但是这种方法，却无法解决对新需求的变动。比如，无法在</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDBFactory</span>:</span><span class="hljs-keyword">public</span> IDBFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBConnection* <span class="hljs-title">CreateDBConnection</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBCommand* <span class="hljs-title">CreateDBCommand</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDataReader* <span class="hljs-title">CreateDataReader</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br> <span class="hljs-comment">//无法添加.</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><p><code>SqlDBFactory</code>类里添加新的方法，因为这样会打破稳定。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/dbdf13cd830891883ced46289edb0fbf-ded07.png" alt="结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>一个模式稳定的部分，就是它的缺点</li><li>工厂模式是抽象工厂模式的特例</li><li>如果没有应对“多系列对象构建”的需求变化，则没有必要使用Abstract Factory**模式，这时候使用简单的工厂完全可以。</li><li>“系列对象”指的是在某一特定系列下的对象之间有相互依赖、 或作用的关系。不同系列的对象之间不能相互依赖。</li><li><strong>Abstract Factory</strong>模式主要在于应对“新系列”的需求变动。其缺点在于难以应对“新对象”的需求变动</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对象创建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工厂模式</title>
    <link href="/2020/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件系统中，经常面临着创建对象的工作；由于需求的变化， 需要创建的对象的具体类型经常变化</li><li>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一 种“封装机制”来避免客户程序和这种“具体对象创建工作”的紧耦合？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。 Factory Method使得一个类的实例化延迟（目的：解耦；手段：虚函数）到子类。 ——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>假设现在有个文件分割器，并且按照需求派生了不同的子类</p><p><strong>运用工厂模式之前：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ISplitter</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySplitter</span> :</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form<br>&#123;<br>TextBox* txtFilePath;<br>TextBox* txtFileNumber;<br>ProgressBar* progressBar;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span></span>&#123;<br><br>ISplitter * splitter=<br>            <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinarySplitter</span>();<span class="hljs-comment">//依赖具体类，编译时绑定，与BinarySplitter为紧耦合</span><br><br>        splitter-&gt;<span class="hljs-built_in">split</span>();<br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>此时的<code>MainForm</code>里面，由于指定了<code>BinarySplitter</code>，导致了编译时绑定。</li><li><code>BinarySplitter</code>为<code>ISplitter</code>的派生类，而业务需求的变动实际上是对<code>BinarySplitter</code>的改变，即<code>ISplitter</code>的派生类为改动范围。所以根据依赖倒置原则，可以把<code>ISplitter</code>的派生类的<code>new</code>操作向上提取成一个抽象类。</li></ul><p><strong>运用工厂模式之后：</strong></p><ul><li>在代码中创建一个工厂，这个工厂的作用是：你需要什么类，我就把什么类返回给你</li><li>抽象这个工厂<code>SplitterFactory</code>，并且将它在<code>MainForm</code>中以组合的形式封装。对于<code>SplitterFactory</code>，由于它是抽象类的指针，所以在<code>MainForm</code>属于运行时绑定。</li><li>需要什么样的<code>ISplitter</code>派生类，就创建一个生产该类的工厂，并在<code>MainForm</code>中赋值。当<code>MainForm</code>需要该派生类时，就从<code>MainForm</code>中的工厂取。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//抽象类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ISplitter</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//工厂基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SplitterFactory</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">SplitterFactory</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//具体类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySplitter</span> :</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter&#123;<br>    <br>&#125;;<br><br><span class="hljs-comment">//具体工厂</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinarySplitter</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TxtSplitter</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">PictureSplitter</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitterFactory</span>:</span> <span class="hljs-keyword">public</span> SplitterFactory&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">VideoSplitter</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//mainform</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form<br>&#123;<br>    SplitterFactory*  factory;<span class="hljs-comment">//工厂</span><br><br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">MainForm</span>(SplitterFactory*  factory)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;factory=factory;<br>    &#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span></span>&#123;<br><br>ISplitter * splitter=<br>            factory-&gt;<span class="hljs-built_in">CreateSplitter</span>(); <span class="hljs-comment">//多态new</span><br>        <br>        splitter-&gt;<span class="hljs-built_in">split</span>();<br><br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a76e6c6e79c2e106686805f7d28c8b05-b8379.png" alt="结构"></p><p>上图中：</p><ul><li><strong>Product</strong>：代表<code>ISplitter</code></li><li><strong>ConcreteProuct</strong>：代表<code>ISplitter</code>派生类</li><li><strong>Creator</strong>：代表<code>SplitterFactory</code></li><li><strong>ConcreteCreator</strong>：代表<code>SplitterFactory</code>派生类</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>Factory Method</strong>模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导致软件的脆弱。</li><li><strong>Factory Method</strong>模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。</li><li><strong>Factory Method</strong>模式解决“单个对象”的需求变化。<strong>缺点在于要求创建方法/参数相同</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对象创建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>桥模式</title>
    <link href="/2020/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%EF%BC%9A%E6%A1%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%EF%BC%9A%E6%A1%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度，乃至多个纬度的变化。</li><li>如何应对这种“多维度的变化”？如何利用面向对象技术来使得类型可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度？</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>将抽象部分(业务功能)与实现部分(平台实现)分离，使它们都可以独立地变化。 ——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用桥模式之前：</strong></p><p><code>Messager</code>类为父类，由父类派生出来的类用来实现不同平台，而这些<strong>平台类</strong>派生出来的<strong>业务类</strong>，用于完善<strong>平台类</strong>。但是站在<code>Messager</code>的角度来看，<strong>平台类</strong>和<strong>业务类</strong>都是用来完善<code>Messager</code>类。所以<code>Messager</code>类中声明了<strong>平台类</strong>和<strong>业务类</strong>所需的纯虚函数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Messager</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(string username, string password)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(string message)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span></span>=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Messager</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//平台实现 个数n</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerBase</span> :</span> <span class="hljs-keyword">public</span> Messager&#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//**********</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//**********</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//**********</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//**********</span><br>    &#125;<br>&#125;;<br><span class="hljs-comment">//平台实现</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerBase</span> :</span> <span class="hljs-keyword">public</span> Messager&#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//==========</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//==========</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//==========</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//==========</span><br>    &#125;<br>&#125;;<br><br><br><span class="hljs-comment">//业务抽象 个数m</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerLite</span> :</span> <span class="hljs-keyword">public</span> PCMessagerBase &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(string username, string password)</span></span>&#123;<br>        <br>        PCMessagerBase::<span class="hljs-built_in">Connect</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(string message)</span></span>&#123;<br>        <br>        PCMessagerBase::<span class="hljs-built_in">WriteText</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span></span>&#123;<br>        <br>        PCMessagerBase::<span class="hljs-built_in">DrawShape</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerPerfect</span> :</span> <span class="hljs-keyword">public</span> PCMessagerBase &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(string username, string password)</span></span>&#123;<br>        <br>        PCMessagerBase::<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        PCMessagerBase::<span class="hljs-built_in">Connect</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(string message)</span></span>&#123;<br>        <br>        PCMessagerBase::<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        PCMessagerBase::<span class="hljs-built_in">WriteText</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span></span>&#123;<br>        <br>        PCMessagerBase::<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        PCMessagerBase::<span class="hljs-built_in">DrawShape</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerLite</span> :</span> <span class="hljs-keyword">public</span> MobileMessagerBase &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(string username, string password)</span></span>&#123;<br>        <br>        MobileMessagerBase::<span class="hljs-built_in">Connect</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(string message)</span></span>&#123;<br>        <br>        MobileMessagerBase::<span class="hljs-built_in">WriteText</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span></span>&#123;<br>        <br>        MobileMessagerBase::<span class="hljs-built_in">DrawShape</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerPerfect</span> :</span> <span class="hljs-keyword">public</span> MobileMessagerBase &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(string username, string password)</span></span>&#123;<br>        <br>        MobileMessagerBase::<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        MobileMessagerBase::<span class="hljs-built_in">Connect</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(string message)</span></span>&#123;<br>        <br>        MobileMessagerBase::<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        MobileMessagerBase::<span class="hljs-built_in">WriteText</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span></span>&#123;<br>        <br>        MobileMessagerBase::<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        MobileMessagerBase::<span class="hljs-built_in">DrawShape</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//所有类的个数：1+n+m*n</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//编译时装配</span><br>        Messager *m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MobileMessagerPerfect</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>分析以上代码可得：</p><ul><li><p>由于<code>MobileMessagerBase</code>和<code>PCMessagerBase</code>有未实现的虚函数，所以它们依然是纯虚基类，无法实例化</p></li><li><p>分析<code>Messager</code>以及它派生出来的类，会发现实际上<code>Messager</code>这个类设计得不合理，主要功能应该分为两大块：</p><ul><li>由<code>Messager</code>派生的<code>XXXMessagerBase</code>实现的：<code>Login</code>、<code>SendMessage</code>、<code>SendPicture</code></li><li>由<code>XXXMessagerBase</code>派生的<code>XXXMessagerPerfect/Lite</code>实现的：<code>PlaySound</code>、<code>DrawShape</code>、<code>WriteText</code>、<code>Connect</code></li></ul></li><li><p>在本例中，变化方向有两个：</p><ul><li>平台实现：PC端、Mobile端，以后可能还有会Watch端….</li><li>业务抽象：Perfect版、Lite版，同样以后可能还有会EE版….</li></ul><p>所以这两个不同的变化方向，带动了行为的多态实现，也应该往两个方向走，而不应该放在同一个类里。</p></li></ul><p><strong>运用桥模式之后：</strong></p><ul><li>根据变化的维度，分离原先父类里的纯虚函数。此例中，根据<strong>平台实现</strong>和<strong>业务抽象</strong>进行分离。</li><li>参考装饰模式的方法，提取子类中相同类型的变量，往上提出</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Messager</span>&#123;</span><br><span class="hljs-keyword">protected</span>:<br>     MessagerImp* messagerImp;<span class="hljs-comment">//...</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">Messager</span>(MessagerImp* messagerImp)&#123;<span class="hljs-comment">//......</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(string username, string password)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(string message)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span></span>=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Messager</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerImp</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">MessagerImp</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><br><br><span class="hljs-comment">//平台实现 n</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerImp</span> :</span> <span class="hljs-keyword">public</span> MessagerImp&#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//**********</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//**********</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//**********</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//**********</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerImp</span> :</span> <span class="hljs-keyword">public</span> MessagerImp&#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//==========</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//==========</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//==========</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//==========</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//业务抽象 m</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerLite</span> :</span><span class="hljs-keyword">public</span> Messager &#123;<br><br>    <br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(string username, string password)</span></span>&#123;<br>        <br>        messagerImp-&gt;<span class="hljs-built_in">Connect</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(string message)</span></span>&#123;<br>        <br>        messagerImp-&gt;<span class="hljs-built_in">WriteText</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span></span>&#123;<br>        <br>        messagerImp-&gt;<span class="hljs-built_in">DrawShape</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerPerfect</span>  :</span><span class="hljs-keyword">public</span> Messager &#123;<br>      <br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(string username, string password)</span></span>&#123;<br>        <br>        messagerImp-&gt;<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        messagerImp-&gt;<span class="hljs-built_in">Connect</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(string message)</span></span>&#123;<br>        <br>        messagerImp-&gt;<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        messagerImp-&gt;<span class="hljs-built_in">WriteText</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span></span>&#123;<br>        <br>        messagerImp-&gt;<span class="hljs-built_in">PlaySound</span>();<br>        <span class="hljs-comment">//********</span><br>        messagerImp-&gt;<span class="hljs-built_in">DrawShape</span>();<br>        <span class="hljs-comment">//........</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//类的数目：1+n+m</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//运行时装配</span><br>    MessagerImp* mImp=<span class="hljs-keyword">new</span> <span class="hljs-built_in">PCMessagerImp</span>();<br>    Messager *m =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Messager</span>(mImp);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5d5d18da351868d348b7ed3f2df29f44-16294.png" alt="稳定部分"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>Bridge</strong>模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们。</li><li><strong>Bridge</strong>模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（<strong>即一个类只有一个变化的原因</strong>），复用性比较差。 Bridge模式是比多继承方案更好的解决方法。</li><li>Bridge模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单一职责</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装饰模式</title>
    <link href="/2020/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%EF%BC%9A%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%EF%BC%9A%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li><p>在某些情况下我们可能会“过度地使用继承来扩展对象的功能” ，由于<strong>继承为类型引入的静态特质</strong>，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。 </p></li><li><p>如何使“对象功能的扩展”能够根据需要来动态地实现？同时避免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能扩展变化”所导致的影响将为最低？</p></li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码 &amp; 减少子类个数）。 ——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用装饰模式之前：</strong></p><p>主体类负责文件、网络、内存流的读取控制，而扩展功能类目前只添加了加密和缓冲以及加密+缓冲的操作…</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//业务操作</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stream</span>&#123;</span><br><span class="hljs-keyword">public</span>：<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span></span>=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Stream</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//主体类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileStream</span>:</span> <span class="hljs-keyword">public</span> Stream&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;<br>        <span class="hljs-comment">//读文件流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span></span>&#123;<br>        <span class="hljs-comment">//定位文件流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span></span>&#123;<br>        <span class="hljs-comment">//写文件流</span><br>    &#125;<br><br>&#125;;<br><br><span class="hljs-comment">//主体类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkStream</span> :</span><span class="hljs-keyword">public</span> Stream&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;<br>        <span class="hljs-comment">//读网络流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span></span>&#123;<br>        <span class="hljs-comment">//定位网络流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span></span>&#123;<br>        <span class="hljs-comment">//写网络流</span><br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-comment">//主体类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemoryStream</span> :</span><span class="hljs-keyword">public</span> Stream&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;<br>        <span class="hljs-comment">//读内存流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span></span>&#123;<br>        <span class="hljs-comment">//定位内存流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span></span>&#123;<br>        <span class="hljs-comment">//写内存流</span><br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-comment">//扩展操作：加密</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoFileStream</span> :</span><span class="hljs-keyword">public</span> FileStream&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;<br>       <br>        <span class="hljs-comment">//额外的加密操作...</span><br>        FileStream::<span class="hljs-built_in">Read</span>(number);<span class="hljs-comment">//读文件流</span><br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span></span>&#123;<br>        <span class="hljs-comment">//额外的加密操作...</span><br>        FileStream::<span class="hljs-built_in">Seek</span>(position);<span class="hljs-comment">//定位文件流</span><br>        <span class="hljs-comment">//额外的加密操作...</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span></span>&#123;<br>        <span class="hljs-comment">//额外的加密操作...</span><br>        FileStream::<span class="hljs-built_in">Write</span>(data);<span class="hljs-comment">//写文件流</span><br>        <span class="hljs-comment">//额外的加密操作...</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//扩展操作：加密</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoNetworkStream</span> :</span> :<span class="hljs-keyword">public</span> NetworkStream&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;<br>        <br>        <span class="hljs-comment">//额外的加密操作...</span><br>        NetworkStream::<span class="hljs-built_in">Read</span>(number);<span class="hljs-comment">//读网络流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span></span>&#123;<br>        <span class="hljs-comment">//额外的加密操作...</span><br>        NetworkStream::<span class="hljs-built_in">Seek</span>(position);<span class="hljs-comment">//定位网络流</span><br>        <span class="hljs-comment">//额外的加密操作...</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span></span>&#123;<br>        <span class="hljs-comment">//额外的加密操作...</span><br>        NetworkStream::<span class="hljs-built_in">Write</span>(data);<span class="hljs-comment">//写网络流</span><br>        <span class="hljs-comment">//额外的加密操作...</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//扩展操作：加密</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoMemoryStream</span> :</span> <span class="hljs-keyword">public</span> MemoryStream&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;<br>        <br>        <span class="hljs-comment">//额外的加密操作...</span><br>        MemoryStream::<span class="hljs-built_in">Read</span>(number);<span class="hljs-comment">//读内存流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span></span>&#123;<br>        <span class="hljs-comment">//额外的加密操作...</span><br>        MemoryStream::<span class="hljs-built_in">Seek</span>(position);<span class="hljs-comment">//定位内存流</span><br>        <span class="hljs-comment">//额外的加密操作...</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span></span>&#123;<br>        <span class="hljs-comment">//额外的加密操作...</span><br>        MemoryStream::<span class="hljs-built_in">Write</span>(data);<span class="hljs-comment">//写内存流</span><br>        <span class="hljs-comment">//额外的加密操作...</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//扩展操作：缓冲</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedFileStream</span> :</span> <span class="hljs-keyword">public</span> FileStream&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;;<br><span class="hljs-comment">//扩展操作：缓冲</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedNetworkStream</span> :</span> <span class="hljs-keyword">public</span> NetworkStream&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;;<br><span class="hljs-comment">//扩展操作：缓冲</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedMemoryStream</span> :</span> <span class="hljs-keyword">public</span> MemoryStream&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//扩展操作：加密+缓冲</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoBufferedFileStream</span> :</span><span class="hljs-keyword">public</span> FileStream&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;<br>        <br>        <span class="hljs-comment">//额外的加密操作...</span><br>        <span class="hljs-comment">//额外的缓冲操作...</span><br>        FileStream::<span class="hljs-built_in">Read</span>(number);<span class="hljs-comment">//读文件流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span></span>&#123;<br>        <span class="hljs-comment">//额外的加密操作...</span><br>        <span class="hljs-comment">//额外的缓冲操作...</span><br>        FileStream::<span class="hljs-built_in">Seek</span>(position);<span class="hljs-comment">//定位文件流</span><br>        <span class="hljs-comment">//额外的加密操作...</span><br>        <span class="hljs-comment">//额外的缓冲操作...</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span></span>&#123;<br>        <span class="hljs-comment">//额外的加密操作...</span><br>        <span class="hljs-comment">//额外的缓冲操作...</span><br>        FileStream::<span class="hljs-built_in">Write</span>(data);<span class="hljs-comment">//写文件流</span><br>        <span class="hljs-comment">//额外的加密操作...</span><br>        <span class="hljs-comment">//额外的缓冲操作...</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//...同上</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-comment">//编译时装配</span><br>    CryptoFileStream *fs1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CryptoFileStream</span>();<br><br>    BufferedFileStream *fs2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BufferedFileStream</span>();<br><br>    CryptoBufferedFileStream *fs3 =<span class="hljs-keyword">new</span> <span class="hljs-built_in">CryptoBufferedFileStream</span>();<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于以上代码：</p><ul><li>代码冗余过多，对于扩展功能的添加实际上也添加了大量重复的代码</li><li>如果未来功能接着添加，需求多的情况下，以继承方式派生出来的扩展功能类会原来越多</li><li>扩展功能之间若互相组合，那么派生类的数量将难以估计，对于代码的维护是个严重的问题</li></ul><p>分析：</p><ul><li>扩展功能类里的主体类类型实际上都是指向同一个父类。所以可以根据这个特点，把<strong>编译期绑定</strong>转换为<strong>运行期绑定</strong></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/e679af366119bd43783a7379482dc4f6-305e49.png" alt="运用装饰模式之前："></p><p><strong>运用装饰模式第一步</strong>：</p><p>将扩展功能类的<strong>编译期绑定</strong>转换为<strong>运行期绑定</strong>，即将<code>FileStream::Read(number);</code>变为<code>stream-&gt;Read(number);</code>，并且在类里添加<code>stream*</code>类型的<strong>变量</strong>和相应的<strong>ctor</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//业务操作</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stream</span>&#123;</span><br><br><span class="hljs-keyword">public</span>：<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span></span>=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Stream</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//主体类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileStream</span>:</span> <span class="hljs-keyword">public</span> Stream&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;<br>        <span class="hljs-comment">//读文件流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span></span>&#123;<br>        <span class="hljs-comment">//定位文件流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span></span>&#123;<br>        <span class="hljs-comment">//写文件流</span><br>    &#125;<br><br>&#125;;<br><span class="hljs-comment">//主体类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkStream</span> :</span><span class="hljs-keyword">public</span> Stream&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;<br>        <span class="hljs-comment">//读网络流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span></span>&#123;<br>        <span class="hljs-comment">//定位网络流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span></span>&#123;<br>        <span class="hljs-comment">//写网络流</span><br>    &#125;<br>    <br>&#125;;<br><span class="hljs-comment">//主体类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemoryStream</span> :</span><span class="hljs-keyword">public</span> Stream&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;<br>        <span class="hljs-comment">//读内存流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span></span>&#123;<br>        <span class="hljs-comment">//定位内存流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span></span>&#123;<br>        <span class="hljs-comment">//写内存流</span><br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-comment">//扩展操作</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;<br>    <br>    Stream* stream;<span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CryptoStream</span>(Stream* stm):<span class="hljs-built_in">stream</span>(stm)&#123;<br>    <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;<br>       <br>        <span class="hljs-comment">//额外的加密操作...</span><br>        stream-&gt;<span class="hljs-built_in">Read</span>(number);<span class="hljs-comment">//读文件流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span></span>&#123;<br>        <span class="hljs-comment">//额外的加密操作...</span><br>        stream::<span class="hljs-built_in">Seek</span>(position);<span class="hljs-comment">//定位文件流</span><br>        <span class="hljs-comment">//额外的加密操作...</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span></span>&#123;<br>        <span class="hljs-comment">//额外的加密操作...</span><br>        stream::<span class="hljs-built_in">Write</span>(data);<span class="hljs-comment">//写文件流</span><br>        <span class="hljs-comment">//额外的加密操作...</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedStream</span> :</span> <span class="hljs-keyword">public</span> Stream&#123;<br>    <br>    Stream* stream;<span class="hljs-comment">//...</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BufferedStream</span>(Stream* stm):<span class="hljs-built_in">stream</span>(stm)&#123;<br>        <br>    &#125;<br>    <span class="hljs-comment">//...</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-comment">//运行时装配</span><br>    FileStream* s1=<span class="hljs-keyword">new</span> <span class="hljs-built_in">FileStream</span>();<br>    CryptoStream* s2=<span class="hljs-keyword">new</span> <span class="hljs-built_in">CryptoStream</span>(s1);<br>    <br>    BufferedStream* s3=<span class="hljs-keyword">new</span> <span class="hljs-built_in">BufferedStream</span>(s1);<br>    <br>    BufferedStream* s4=<span class="hljs-keyword">new</span> <span class="hljs-built_in">BufferedStream</span>(s2);<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;<br>    <br>    Stream* stream;<span class="hljs-comment">//...</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;<br>        <span class="hljs-comment">//额外的加密操作...</span><br>        stream-&gt;<span class="hljs-built_in">Read</span>(number);<span class="hljs-comment">//读文件流</span><br>    &#125;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>扩展功能类不仅拥有<code>Stream*</code>类型的成员变量，体现出一种委托行为，而且还继承了<code>Stream</code>。原因是只有继承了，才能实现<code>Stream</code>中的虚函数，遵守接口规范。</p><p>经过第一步改进，代码量明显减少。现在已经不需要再为每个主体类单独的设计扩展功能类了。</p><p>同样的，这个时候分析发现，虽然代码量较之前少了一大部分冗余，但是仍有一小部分是重复的。比如每个扩展功能类都会有的：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;<br>    <br>    Stream* stream;<span class="hljs-comment">//...</span><br>    <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果能把这部分向上提取，并且以接口或者继承的形式体现，不仅会消除冗余，也更加的规范，使得代码的维护更加高效。</p><p><strong>运用装饰模式第二步：</strong></p><p>将第一步中仍然冗余的代码提取成<code>DecoratorStream</code></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//业务操作</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stream</span>&#123;</span><br><br><span class="hljs-keyword">public</span>：<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span></span>=<span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Stream</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//主体类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileStream</span>:</span> <span class="hljs-keyword">public</span> Stream&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;<br>        <span class="hljs-comment">//读文件流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span></span>&#123;<br>        <span class="hljs-comment">//定位文件流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span></span>&#123;<br>        <span class="hljs-comment">//写文件流</span><br>    &#125;<br><br>&#125;;<br><span class="hljs-comment">//主体类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkStream</span> :</span><span class="hljs-keyword">public</span> Stream&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;<br>        <span class="hljs-comment">//读网络流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span></span>&#123;<br>        <span class="hljs-comment">//定位网络流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span></span>&#123;<br>        <span class="hljs-comment">//写网络流</span><br>    &#125;<br>    <br>&#125;;<br><span class="hljs-comment">//主体类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemoryStream</span> :</span><span class="hljs-keyword">public</span> Stream&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;<br>        <span class="hljs-comment">//读内存流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span></span>&#123;<br>        <span class="hljs-comment">//定位内存流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span></span>&#123;<br>        <span class="hljs-comment">//写内存流</span><br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-comment">//扩展操作</span><br>DecoratorStream: <span class="hljs-keyword">public</span> Stream&#123;<br><span class="hljs-keyword">protected</span>:<br>    Stream* stream;<span class="hljs-comment">//...</span><br>    <br>    <span class="hljs-built_in">DecoratorStream</span>(Stream * stm):<span class="hljs-built_in">stream</span>(stm)&#123;<br>    <br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoStream</span>:</span> <span class="hljs-keyword">public</span> DecoratorStream &#123;<br> <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CryptoStream</span>(Stream* stm):<span class="hljs-built_in">DecoratorStream</span>(stm)&#123;<br>    <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;<br>       <br>        <span class="hljs-comment">//额外的加密操作...</span><br>        stream-&gt;<span class="hljs-built_in">Read</span>(number);<span class="hljs-comment">//读文件流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span></span>&#123;<br>        <span class="hljs-comment">//额外的加密操作...</span><br>        stream::<span class="hljs-built_in">Seek</span>(position);<span class="hljs-comment">//定位文件流</span><br>        <span class="hljs-comment">//额外的加密操作...</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span></span>&#123;<br>        <span class="hljs-comment">//额外的加密操作...</span><br>        stream::<span class="hljs-built_in">Write</span>(data);<span class="hljs-comment">//写文件流</span><br>        <span class="hljs-comment">//额外的加密操作...</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedStream</span> :</span> <span class="hljs-keyword">public</span> DecoratorStream&#123;<br>    <br>    Stream* stream;<span class="hljs-comment">//...</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BufferedStream</span>(Stream* stm):<span class="hljs-built_in">DecoratorStream</span>(stm)&#123;<br>        <br>    &#125;<br>    <span class="hljs-comment">//...</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-comment">//运行时装配</span><br>    FileStream* s1=<span class="hljs-keyword">new</span> <span class="hljs-built_in">FileStream</span>();<br>    <br>    CryptoStream* s2=<span class="hljs-keyword">new</span> <span class="hljs-built_in">CryptoStream</span>(s1);<br>    <br>    BufferedStream* s3=<span class="hljs-keyword">new</span> <span class="hljs-built_in">BufferedStream</span>(s1);<br>    <br>    BufferedStream* s4=<span class="hljs-keyword">new</span> <span class="hljs-built_in">BufferedStream</span>(s2);<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b26eea47de8ac1454dd7e88ad1f36a22-effe64.png" alt="装饰"></p><p>这样一个装饰模式的完整形式已经出来了，只要未来有更多的功能需要扩展，只需要继承<code>DecoratorStream</code>便可实现。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f8eaebad0236db29d73997d9732b0aaf-a18b23.png" alt="装饰模式"></p><p>红色为稳定的部分，蓝色为不稳定的部分</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>代码冗余，消除重复：<ul><li>当一个变量的组合类型都是以子类的形式，可以考虑他们的父类。把编译时的东西转换成运行时的东西</li><li>如果某个类的两个或以上的子类有同样的字段，那么就应该把这个字段往上提。可以设置一个中间类</li></ul></li><li>组合优于继承：<ul><li>用组合的方式来应对未来多态的变化，即编译时一样，运行时不一样</li><li>继承：静态特质。组合：动态特质。</li><li>对继承的不良使用会导致派生类爆炸式增长</li><li>主体操作该写几个类就写几个类，扩展操作有需要再增加，运行时再组合装配起来</li></ul></li><li>通过采用组合而非继承的手法，Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题” 。</li><li>Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类。</li><li>Decorator模式的目的并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”的含义。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单一职责</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优先级队列</title>
    <link href="/2020/05/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
    <url>/2020/05/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="完全二叉堆"><a href="#完全二叉堆" class="headerlink" title="完全二叉堆"></a>完全二叉堆</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/670cc7f1c1fd393d6c1672f80b9a8ff4-fc4f5.png" alt="完全二叉堆" style="zoom:50%;" /></p><ul><li>逻辑上，等同于完全二叉树</li><li>物理上，直接借助向量实现</li><li>逻辑节点与物理元素，依层次遍历次序彼此对应</li></ul><p><strong>即完全二叉堆在物理上是向量，其所存储的元素次序是完全二叉树的层次遍历次序。</strong></p><p>在完全二叉堆中（大顶堆）：</p><ul><li>任何节点的数值不超过其父亲</li><li>兄弟节点之间的没有确定的大小关系</li><li>节点的数值不超过其任何一个祖先</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Parent(i) ((i-1)&gt;&gt;1)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LChild(i) (1+((i)&lt;&lt;1))</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RChild(i) ((1+(i))&lt;&lt;1)</span><br></code></pre></div></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>继承了优先级队列和向量</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Vector/Vector.h&quot;</span> <span class="hljs-comment">//借助多重继承机制，基于向量</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;PQ/PQ.h&quot;</span> <span class="hljs-comment">//按照优先级队列ADT实现的</span></span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PQ_ComplHeap</span> :</span> <span class="hljs-keyword">public</span> PQ&lt;T&gt;, <span class="hljs-keyword">public</span> Vector&lt;T&gt; &#123; <span class="hljs-comment">//完全二叉堆</span><br>   <span class="hljs-comment">/*DSA*/</span><span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UniPrint</span>;</span> <span class="hljs-comment">//演示输出使用，否则不必设置友类</span><br>   <span class="hljs-built_in">PQ_ComplHeap</span>() &#123; &#125; <span class="hljs-comment">//默认构造</span><br>   <span class="hljs-built_in">PQ_ComplHeap</span> ( T* A, Rank n ) &#123; <span class="hljs-built_in">copyFrom</span> ( A, <span class="hljs-number">0</span>, n ); <span class="hljs-built_in">heapify</span> ( _elem, n ); &#125; <span class="hljs-comment">//批量构造</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span> <span class="hljs-params">( T )</span></span>; <span class="hljs-comment">//按照比较器确定的优先级次序，插入词条</span><br>   <span class="hljs-function">T <span class="hljs-title">getMax</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//读取优先级最高的词条</span><br>   <span class="hljs-function">T <span class="hljs-title">delMax</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//删除优先级最高的词条</span><br>&#125;; <span class="hljs-comment">//PQ_ComplHeap</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span> <span class="hljs-params">( T* A, Rank n )</span></span>; <span class="hljs-comment">//Floyd建堆算法</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function">Rank <span class="hljs-title">percolateDown</span> <span class="hljs-params">( T* A, Rank n, Rank i )</span></span>; <span class="hljs-comment">//下滤</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function">Rank <span class="hljs-title">percolateUp</span> <span class="hljs-params">( T* A, Rank i )</span></span>; <span class="hljs-comment">//上滤</span><br><br><span class="hljs-comment">/*DSA*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;PQ_ComplHeap_macro.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;PQ_ComplHeap_implementation.h&quot;</span></span><br></code></pre></div></td></tr></table></figure><h3 id="堆序性"><a href="#堆序性" class="headerlink" title="堆序性"></a>堆序性</h3><ul><li>数值上，只要$0&lt;i$，必满足：$H[i]\le H[Parent(i)]$​​。</li><li>$H[0]$​就是全局最大元素</li></ul><p><strong>即堆中的任意节点都优于它的所有孩子</strong>。</p><p><strong>返回最大元：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>PQ_ComplHeap&lt;T&gt;::<span class="hljs-built_in">getMax</span>()&#123;<span class="hljs-keyword">return</span> _elem[<span class="hljs-number">0</span>];&#125;<br></code></pre></div></td></tr></table></figure><h3 id="插入与上滤"><a href="#插入与上滤" class="headerlink" title="插入与上滤"></a>插入与上滤</h3><p>插入词条e，只需将e作为末元素接入向量。其中：</p><ul><li>只有e和其父节点才有可能违反堆序性，这时候将e与其父节点换位即可。</li><li>若再次违反堆序性，那么再次将e和它的新父亲换位。</li><li>直到<ul><li>e与其父亲满足堆序性</li><li>或者e到达栈顶（没有父亲）</li></ul></li></ul><p>e每次和它的父亲换位，就表示e的高度上升一层。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b0a618b4702bdccd87976acc8f4ee65e-31e6d.png" style="zoom:50%;" /></p><p>这一过程，就是<strong>上滤</strong>。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/e517ccffa2d474ede5b3037a43c1e597-0d0d2.png" alt="实例" style="zoom:50%;" /></p><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> PQ_ComplHeap&lt;T&gt;::<span class="hljs-built_in">insert</span> ( T e ) &#123; <span class="hljs-comment">//将词条插入完全二叉堆中</span><br>   Vector&lt;T&gt;::<span class="hljs-built_in">insert</span> ( e ); <span class="hljs-comment">//首先将新词条接至向量末尾</span><br>   <span class="hljs-built_in">percolateUp</span> ( _elem, _size - <span class="hljs-number">1</span> ); <span class="hljs-comment">//再对该词条实施上滤调整</span><br>&#125;<br><span class="hljs-comment">//对向量中的第i个词条实施上滤操作，i &lt; _size</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function">Rank <span class="hljs-title">percolateUp</span> <span class="hljs-params">( T* A, Rank i )</span> </span>&#123;<br>   <span class="hljs-keyword">while</span> ( <span class="hljs-number">0</span> &lt; i ) &#123; <span class="hljs-comment">//在抵达堆顶之前，反复地</span><br>      Rank j = <span class="hljs-built_in">Parent</span> ( i ); <span class="hljs-comment">//考查[i]之父亲[j]</span><br>      <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">lt</span> ( A[i], A[j] ) ) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//一旦父子顺序，上滤旋即完成；否则</span><br>      <span class="hljs-built_in">swap</span> ( A[i], A[j] ); i = j; <span class="hljs-comment">//父子换位，并继续考查上一层</span><br>   &#125; <span class="hljs-comment">//while</span><br>   <span class="hljs-keyword">return</span> i; <span class="hljs-comment">//返回上滤最终抵达的位置</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>整个算法在完全二叉堆的每一层次上最多只需做一步迭代，又因为完全二叉树是理想平衡二叉树，其树高可以严格的控制在$log_2{n}$的范围内，而每一步迭代只需常数时间，因此所有的迭代所需的时间累计不过$log_2{n}$。</p><p>但是对于常系数意义而言，swap操作每次都会调用三条语句，所以复杂度为$3*log_2{n}$。</p><p>所以新的改进办法是：先将e备份，然后和父节点对比。如果有必要交换，只是将父节点下移。如此迭代，直到无需交换为止，再将e纳入最终的位置。这样的改进将$3*log_2{n}$变为了$log_2{n}+2$​。</p><h3 id="删除与下滤"><a href="#删除与下滤" class="headerlink" title="删除与下滤"></a>删除与下滤</h3><p>最大元素始终在堆顶，删除堆顶实际上是摘除向量的首元素，然后代之以末元素e。其中：</p><ul><li>若e与孩子们违背堆序性，那么将e和孩子们中的最大者进行交换</li><li>若依然违反，则继续交换，直到最后一个或者无需交换，结束过程</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/633535647dda09f1c50e88020bcc6ee9-ed26b.png" alt="删除与下滤" style="zoom:50%;" /></p><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/457b42e99458ae80fcf6c404bfb57895-b9a04.png" style="zoom: 33%;" /></p><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  ProperParent(PQ, n, i) <span class="hljs-comment">/*父子（至多）三者中的大者*/</span> \</span><br><span class="hljs-meta">            ( RChildValid(n, i) ? Bigger( PQ, Bigger( PQ, i, LChild(i) ), RChild(i) ) : \</span><br><span class="hljs-meta">            ( LChildValid(n, i) ? Bigger( PQ, i, LChild(i) ) : i \</span><br><span class="hljs-meta">            ) \</span><br><span class="hljs-meta">            ) <span class="hljs-comment">//相等时父节点优先，如此可避免不必要的交换</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; T PQ_ComplHeap&lt;T&gt;::<span class="hljs-built_in">delMax</span>() &#123; <span class="hljs-comment">//删除非空完全二叉堆中优先级最高的词条</span><br>   T maxElem = _elem[<span class="hljs-number">0</span>]; _elem[<span class="hljs-number">0</span>] = _elem[ --_size ]; <span class="hljs-comment">//摘除堆顶（首词条），代之以末词条</span><br>   <span class="hljs-built_in">percolateDown</span> ( _elem, _size, <span class="hljs-number">0</span> ); <span class="hljs-comment">//对新堆顶实施下滤</span><br>   <span class="hljs-keyword">return</span> maxElem; <span class="hljs-comment">//返回此前备份的最大词条</span><br>&#125;<br><br><span class="hljs-comment">//对向量前n个词条中的第i个实施下滤，i &lt; n</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function">Rank <span class="hljs-title">percolateDown</span> <span class="hljs-params">( T* A, Rank n, Rank i )</span> </span>&#123;<br>   Rank j; <span class="hljs-comment">//i及其（至多两个）孩子中，堪为父者</span><br>   <span class="hljs-keyword">while</span> ( i != ( j = <span class="hljs-built_in">ProperParent</span> ( A, n, i ) ) ) <span class="hljs-comment">//只要i非j，则</span><br>      &#123; <span class="hljs-built_in">swap</span> ( A[i], A[j] ); i = j; &#125; <span class="hljs-comment">//二者换位，并继续考查下降后的i</span><br>   <span class="hljs-keyword">return</span> i; <span class="hljs-comment">//返回下滤抵达的位置（亦i亦j）</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h4><p>和上滤过程一样，复杂度也是$O(log_2{n})$​。</p><p>但是在常系数意义下，下滤过程中的每一步迭代所涉及的都是一个节点以及它的两个孩子，即每一次迭代都有两次比较。</p><h2 id="批量建堆"><a href="#批量建堆" class="headerlink" title="批量建堆"></a>批量建堆</h2><h3 id="自上而下的上滤"><a href="#自上而下的上滤" class="headerlink" title="自上而下的上滤"></a>自上而下的上滤</h3><h4 id="蛮力算法"><a href="#蛮力算法" class="headerlink" title="蛮力算法"></a>蛮力算法</h4><p>按照层次遍历次序逐一上滤，每个节点都需要遍历一次。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/3936c1183b7f455b0bb4ca8370924192-1c4f7.png" style="zoom:33%;" /></p><h4 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h4><p>最坏情况下，每个节点都要上滤到根，所需成本线性正比于其深度。所以总体的时间成本是每一个节点<strong>深度</strong>的总和。</p><p>如果只需考虑底层的情况，n/2个叶节点，深度均为$O(log_2{n})$​​，所以累计耗时$O(nlog_2{n})$​​​​，这个时间成本是无法接受的。这些时间足以全排序！</p><p><strong>QA：</strong></p><ul><li>现有n个元素需要组织成一个完全二叉堆，若使用不断插入所有元素的方法，整个过程是:<ul><li>自上而下的上滤</li></ul></li></ul><h3 id="自下而上的下滤"><a href="#自下而上的下滤" class="headerlink" title="自下而上的下滤"></a>自下而上的下滤</h3><ul><li>任意给定堆$H_0$​和$H_1$​，以及节点p。为得到堆$H_0\cup{p}\cup H_1$​​，只需要将$r_0$​和$r_1$当作[的孩子，对p下滤即可。</li><li>自下而上，自右而左的逐个处理</li><li>对每一个节点，只需做一次下滤</li><li>对于叶子节点而言，下滤没有意义。所以只考虑所有的内部节点。所以第一个处理的应该是最后一个内部节点。</li><li>如果全堆的规模为n，那么最末尾的内部节点在向量中的秩为$\lfloor n/2 \rfloor-1$​​。​​</li><li>实质效果等同于将左右子堆合并起来，即各子堆逐层向上合并，规模不断增加的过程。当根节点的下滤也完成后，所有节点也自然在整体上构成了一个完全二叉堆。</li></ul><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/e40907b8530c0873b36485332660caa7-dc81a.png" style="zoom: 33%;" /></p><h4 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span> <span class="hljs-params">( T* A, <span class="hljs-keyword">const</span> Rank n )</span> </span>&#123; <span class="hljs-comment">//Floyd建堆算法，O(n)时间</span><br>   <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = n/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>; <span class="hljs-number">0</span> &lt;= i; i-- ) <span class="hljs-comment">//自底而上，依次（排除了叶节点）</span><br>      <span class="hljs-built_in">percolateDown</span> ( A, n, i ); <span class="hljs-comment">//下滤各内部节点</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function">Rank <span class="hljs-title">percolateDown</span> <span class="hljs-params">( T* A, Rank n, Rank i )</span> </span>&#123;<br>   Rank j; <span class="hljs-comment">//i及其（至多两个）孩子中，堪为父者</span><br>   <span class="hljs-keyword">while</span> ( i != ( j = <span class="hljs-built_in">ProperParent</span> ( A, n, i ) ) ) <span class="hljs-comment">//只要i非j，则</span><br>      &#123; <span class="hljs-built_in">swap</span> ( A[i], A[j] ); i = j; &#125; <span class="hljs-comment">//二者换位，并继续考查下降后的i</span><br>   <span class="hljs-keyword">return</span> i; <span class="hljs-comment">//返回下滤抵达的位置（亦i亦j）</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="复杂度-3"><a href="#复杂度-3" class="headerlink" title="复杂度"></a>复杂度</h4><p>每个内部节点所需的调整时间，正比于其高度而非深度。</p><p>所以整个Floyd算法的计算成本无非就是每一个节点所对应<strong>高度</strong>的总和，这个总和在渐进意义上为$O(n)$。</p><p>与蛮力算法的对比：</p><ul><li>蛮力算法是对所有节点深度的求和，而Floyd算法是高度。</li><li>两者复杂度的对比差异如此之大，实际上是因为在完全二叉树中，越是靠近底层，节点越多；而越是靠近顶层，节点也就越少。因此，如果以深度作为成本的指标，那么累计的总和也自然会更大。</li></ul><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/629a78dc5126e3427ff5cbcc29b39c9f-77c01.png" style="zoom:50%;" /></p><p>建堆后不断调用<code>delMax()</code>：</p><ul><li>先对一个向量进行Floyd算法，得到一个完全二叉堆，完成算法的预处理。</li><li>主体循环：删除堆顶，然后将删除后的堆顶放入已排序的部分。接着将堆的最后一个元素挪到堆顶，做一次下滤。然后接着删除堆顶…不停迭代，直到排序完成。</li></ul><p>只要将完全二叉堆和已排序的部分放在同一个向量里，那么空间复杂度就能做到常数级别。</p><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p>对于任何的向量，这个算法都可以对其中任意指定的区间进行排序。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> Vector&lt;T&gt;::<span class="hljs-built_in">heapSort</span> ( Rank lo, Rank hi ) &#123; <span class="hljs-comment">//0 &lt;= lo &lt; hi &lt;= size</span><br>   T* A = _elem + lo; Rank n = hi - lo; <span class="hljs-built_in">heapify</span>( A, n ); <span class="hljs-comment">//将待排序区间建成一个完全二叉堆，O(n)</span><br>   <span class="hljs-keyword">while</span> ( <span class="hljs-number">0</span> &lt; --n ) <span class="hljs-comment">//反复地摘除最大元并归入已排序的后缀，直至堆空</span><br>      &#123; <span class="hljs-built_in">swap</span>( A[<span class="hljs-number">0</span>], A[n] ); <span class="hljs-built_in">percolateDown</span>( A, n, <span class="hljs-number">0</span> ); &#125; <span class="hljs-comment">//堆顶与末元素对换，再下滤</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5b7aa1438c77aeb47c315036685ccd22-9b994.png" alt=""></p><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>建堆：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/41e0fff06eedc61a9cde5042b35d2549-8b48c.png" style="zoom: 33%;" /></p><p>排序：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/3fc93531ba507e6653b6fcd2193e7eca-a943c.png" style="zoom:33%;" /></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a7f02f20ae44af14428140121890cab6-16501.png" style="zoom:33%;" /></p><h3 id="复杂度-4"><a href="#复杂度-4" class="headerlink" title="复杂度"></a>复杂度</h3><p>所谓堆排序就是每次取堆的根结点为最大值，然后将最后一个节点作为根节点，进行堆调整，堆排序的时间等于建堆$O(n)$和进行堆调整（<code>delMax()</code>然后迭代…即每次调整一个元素是$O(log_2{n}$)）的时间，所以堆排序的时间复杂度是$O(n<em>log_2{n}+ n) =O(n</em>log_2{n})$，在渐进时间复杂度上与归并排序相同。</p><h2 id="左式堆"><a href="#左式堆" class="headerlink" title="左式堆"></a>左式堆</h2><p><strong>左式堆：在拓扑形态上更倾向于向左倾斜的一种堆。</strong></p><p>引入左式堆的动机：为了能够有效地完成堆合并。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6b8d6803be494073cc07582aebb250e0-9f93a.png" style="zoom:33%;" /></p><p>单侧倾斜：保持堆序性，附加新条件，使得在堆合并过程中，只需调整很少部分的节点。即堆将右侧肩部的长度严格控制在大O意义下的$O(log_2{n})$​。</p><p>新条件：</p><ul><li>节点分布偏向左侧</li><li>合并操作只涉及右侧</li></ul><p>左式堆从拓扑上不见得是完全二叉树，已经破坏了结构性。但是实际上，结构性并非堆结构的本质要求，只有堆序性才是其本质要求。在必要的时候，结构性是完全可以牺牲掉的。</p><h3 id="空节点路径长度"><a href="#空节点路径长度" class="headerlink" title="空节点路径长度"></a>空节点路径长度</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b8dfe97b14c3aa0ac065453e1820171a-8597d.png" style="zoom:50%;" /></p><p><strong>NPL（Null Path Length）</strong>：度量堆结构倾斜性的指标。</p><ul><li>消除一度节点</li><li>转为真二叉树</li></ul><p>性质：</p><ul><li><strong>npl(null) = 0</strong>。即外部节点的空节点路径长度为0。</li><li><strong>npl(x)</strong> = <code>1 + min( npl(lc(x),npl(rc(x)))</code>。即x节点的空节点路径长度等于它两个孩子中最小的空节点路径长度再加上一。</li></ul><p>所以：</p><ul><li><strong>npl(x)</strong>：x到外部节点的最近距离。</li><li><strong>npl(x)</strong> = 以x为根的最大<strong>满子树</strong>的<strong>高度</strong>。</li></ul><h3 id="左倾性"><a href="#左倾性" class="headerlink" title="左倾性"></a>左倾性</h3><p><strong>左倾：对任何内节点x,都有$npl(lc(x))\ge npl(rc(x))$​。即对任何一个内节点X，如果在NPL的意义上，它的左孩子不小于它的右孩子。</strong></p><p>在一个堆中，如果任何一个节点都是左倾的，那么这个堆就称为左倾堆，或者左式堆，左撇子堆。所以只需要考虑每个节点的右孩子，而忽略他的右孩子，就可以得出：</p><p><strong>推论：对任何内节点x，都有$npl(x)=1+npl(rc(x))$​。</strong></p><p>注意：左倾性与堆序性并不矛盾。</p><p>既然左倾性是处处满足的，所以任何左式堆的任何一个子堆必定是左式堆。</p><p>左式堆倾向于将更多的节点分布于左侧分支。但是这个只是一个大致的倾向，事实情况未必严格如此。即在一个左式堆中，左子堆的规模和高度未必大于右子堆。</p><h3 id="右侧链"><a href="#右侧链" class="headerlink" title="右侧链"></a>右侧链</h3><p>对于左式堆而言，左子堆和右子堆在规模和高度上的差异并不是那么的重要，真正重要的是全堆的右侧链。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/ae66e5d63b4258bc3f04321ed5898140-ee212.png" alt="右侧链" style="zoom:50%;" /></p><p><strong>rChain(x)：</strong>从节点x出发，一致沿右分支前进。</p><p>特别地，<strong>rChain(root)</strong>的终点，必为全堆中最浅的外部节点。即存在一棵以r为根，高度为d的满子树。</p><script type="math/tex; mode=display">npl(r)\equiv |rChain(r)| =d</script><p>右侧链长为d的左式堆，至少包含：</p><ul><li>$2^d-1$个内部节点</li><li>$2^{d+1}-1$​个节点</li></ul><p><strong>所以，在包含n个节点的左式堆中，右侧链的长度$d \le \lfloor log_2{n+1} \rfloor -1 = O(log_2{n})$​。​​</strong></p><p>即相对于根节点r，不仅意味着这个外部节点的<strong>深度</strong>为d，更重要的是存在一棵以r为根，高度为d的<strong>极大满子树</strong>。这一点对左式堆来说至关重要，事实上这就意味着在左式堆中应该包含足够多个节点。反过来，如果将左式堆的规模固定为n，那么右侧链的长度d也就至多不过$log_2{n}$，因此进一步的，如果我们所设计的堆合并算法的确能将操作的范围限定为右侧链，那么相关算法的复杂度也同样可以控制在$log_2{n}$​范围内。</p><h3 id="实现与接口"><a href="#实现与接口" class="headerlink" title="实现与接口"></a>实现与接口</h3><p>由于左式堆不满足结构性，物理结构不再保持紧凑性，所以采用树形结构来作为派生的基类。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PQ_LeftHeap</span> :</span> <span class="hljs-keyword">public</span> PQ&lt;T&gt;, <span class="hljs-keyword">public</span> BinTree&lt;T&gt; &#123; <span class="hljs-comment">//基于二叉树，以左式堆形式实现的PQ</span><br>   <span class="hljs-comment">/*DSA*/</span><span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UniPrint</span>;</span> <span class="hljs-comment">//演示输出使用，否则不必设置友类</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">PQ_LeftHeap</span>() &#123; &#125; <span class="hljs-comment">//默认构造</span><br>   <span class="hljs-built_in">PQ_LeftHeap</span> ( T* E, <span class="hljs-keyword">int</span> n ) <span class="hljs-comment">//批量构造：可改进为Floyd建堆算法</span><br>   &#123;  <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++ ) <span class="hljs-built_in">insert</span> ( E[i] );  &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span> <span class="hljs-params">( T )</span></span>; <span class="hljs-comment">//按照比较器确定的优先级次序插入元素</span><br>   <span class="hljs-function">T <span class="hljs-title">getMax</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//取出优先级最高的元素</span><br>   <span class="hljs-function">T <span class="hljs-title">delMax</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//删除优先级最高的元素</span><br>&#125;; <span class="hljs-comment">//PQ_LeftHeap</span><br></code></pre></div></td></tr></table></figure><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/cffff34800f2b5f187610f6dae962960-59f2a.png" style="zoom:33%;" /></p><p>待合并的两个堆分别以a和b为根，并假设在抵达递归基之前，它们的左右子堆都是存在的。 整个流程就是将a的右子堆取出，并且递归地与刚才的堆b完成合并，合并所得到的结果继续作为a的右子堆。为了保证a在此后继续满足左倾性，在这次合并返回之后，还需比较a的左子堆与合并之后这个堆的npl值。如果有必要，还需令二者互换位置。</p><h5 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//根据相对优先级确定适宜的方式，合并以a和b为根节点的两个左式堆</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> BinNodePosi&lt;T&gt; <span class="hljs-title">merge</span> <span class="hljs-params">( BinNodePosi&lt;T&gt; a, BinNodePosi&lt;T&gt; b )</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> ( ! a ) <span class="hljs-keyword">return</span> b; <span class="hljs-comment">//退化情况</span><br>   <span class="hljs-keyword">if</span> ( ! b ) <span class="hljs-keyword">return</span> a; <span class="hljs-comment">//退化情况</span><br>   <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">lt</span> ( a-&gt;data, b-&gt;data ) ) <span class="hljs-built_in">swap</span> ( a, b ); <span class="hljs-comment">//一般情况：首先确保b不大</span><br>   ( a-&gt;rc = <span class="hljs-built_in">merge</span> ( a-&gt;rc, b ) )-&gt;parent = a; <span class="hljs-comment">//将a的右子堆，与b合并</span><br>   <span class="hljs-keyword">if</span> ( !a-&gt;lc || a-&gt;lc-&gt;npl &lt; a-&gt;rc-&gt;npl ) <span class="hljs-comment">//若有必要</span><br>      <span class="hljs-built_in">swap</span> ( a-&gt;lc, a-&gt;rc ); <span class="hljs-comment">//交换a的左、右子堆，以确保右子堆的npl不大</span><br>   a-&gt;npl = a-&gt;rc ? a-&gt;rc-&gt;npl + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>; <span class="hljs-comment">//更新a的npl</span><br>   <span class="hljs-keyword">return</span> a; <span class="hljs-comment">//返回合并后的堆顶</span><br>&#125; <span class="hljs-comment">//本算法只实现结构上的合并，堆的规模须由上层调用者负责更新</span><br></code></pre></div></td></tr></table></figure><p>合并左式堆A和左式堆B，其中A的最大元素比B中所有元素都大，则递归的步骤为合并A的右子堆和B。</p><h5 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/08a51ccaace6d3ec61dc72d815600e13-c22cd.png" style="zoom:50%;" /></p><h5 id="插入即合并"><a href="#插入即合并" class="headerlink" title="插入即合并"></a>插入即合并</h5><p>将这个新的节点视作只含一个节点的左式堆，那么插入操作就是一个合并操作。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/17a55013bef8df49634a775a099cf440-554d3.png" alt="插入即合并" style="zoom: 50%;" /></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> PQ_LeftHeap&lt;T&gt;::<span class="hljs-built_in">insert</span> ( T e ) &#123;<br>   _root = <span class="hljs-built_in">merge</span>( _root, <span class="hljs-keyword">new</span> BinNode&lt;T&gt;( e, <span class="hljs-literal">NULL</span> ) ); <span class="hljs-comment">//将e封装为左式堆，与当前左式堆合并</span><br>   _size++; <span class="hljs-comment">//更新规模</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="删除亦合并"><a href="#删除亦合并" class="headerlink" title="删除亦合并"></a>删除亦合并</h5><p>每次删除操作首先将这个根节点在物理上摘除掉，而接下来的任务也无非是将分离出来的左子堆和右子堆合并。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/226d96857a9043b77082f3f54c20258a-517da.png" style="zoom: 25%;" /></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; T PQ_LeftHeap&lt;T&gt;::<span class="hljs-built_in">delMax</span>() &#123;<br>   BinNodePosi&lt;T&gt; lHeap = _root-&gt;lc; <span class="hljs-keyword">if</span> (lHeap) lHeap-&gt;parent = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//左子堆</span><br>   BinNodePosi&lt;T&gt; rHeap = _root-&gt;rc; <span class="hljs-keyword">if</span> (rHeap) rHeap-&gt;parent = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//右子堆</span><br>   T e = _root-&gt;data; <span class="hljs-keyword">delete</span> _root; _size--; <span class="hljs-comment">//删除根节点</span><br>   _root = <span class="hljs-built_in">merge</span> ( lHeap, rHeap ); <span class="hljs-comment">//合并原左、右子堆</span><br>   <span class="hljs-keyword">return</span> e; <span class="hljs-comment">//返回原根节点的数据项</span><br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>优先级队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>观察者模式</title>
    <link href="/2020/04/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%EF%BC%9A%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/04/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%EF%BC%9A%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系” ——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密， 将使软件不能很好地抵御变化。——《设计模式》GoF</li><li>使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>以下代码为文件分割器。主要流程是<code>MainForm</code>调用<code>FileSplitter</code>来分割文件，<code>FileSplitter</code>在分割文件的过程中将计算出来的进度传给<code>MainForm</code>，由<code>MainForm</code>在界面上显示具体进度。</p><p>运用观察者模式之前：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span></span><br><span class="hljs-class">&#123;</span><br>string m_filePath;<br><span class="hljs-keyword">int</span> m_fileNumber;<br>ProgressBar* m_progressBar;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">FileSplitter</span>(<span class="hljs-keyword">const</span> string&amp; filePath, <span class="hljs-keyword">int</span> fileNumber, ProgressBar* progressBar) :<br><span class="hljs-built_in">m_filePath</span>(filePath), <br><span class="hljs-built_in">m_fileNumber</span>(fileNumber),<br><span class="hljs-built_in">m_progressBar</span>(progressBar)&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span></span>&#123;<br><br><span class="hljs-comment">//1.读取大文件</span><br><br><span class="hljs-comment">//2.分批次向小文件中写入</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++)&#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">float</span> progressValue = m_fileNumber;<br>progressValue = (i + <span class="hljs-number">1</span>) / progressValue;<br>m_progressBar-&gt;<span class="hljs-built_in">setValue</span>(progressValue);<br>&#125;<br><br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form<br>&#123;<br>TextBox* txtFilePath;<br>TextBox* txtFileNumber;<br>ProgressBar* progressBar;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span></span>&#123;<br><br>string filePath = txtFilePath-&gt;<span class="hljs-built_in">getText</span>();<br><span class="hljs-keyword">int</span> number = <span class="hljs-built_in">atoi</span>(txtFileNumber-&gt;<span class="hljs-built_in">getText</span>().<span class="hljs-built_in">c_str</span>());<br><br><span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number, progressBar)</span></span>;<br><br>splitter.<span class="hljs-built_in">split</span>();<br><br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>运用观察者模式之后：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IProgress</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span></span>=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IProgress</span>()&#123;&#125;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span></span><br><span class="hljs-class">&#123;</span><br>string m_filePath;<br><span class="hljs-keyword">int</span> m_fileNumber;<br><br>List&lt;IProgress*&gt;  m_iprogressList; <span class="hljs-comment">// 抽象通知机制，支持多个观察者</span><br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">FileSplitter</span>(<span class="hljs-keyword">const</span> string&amp; filePath, <span class="hljs-keyword">int</span> fileNumber) :<br><span class="hljs-built_in">m_filePath</span>(filePath), <br><span class="hljs-built_in">m_fileNumber</span>(fileNumber)&#123;<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span></span>&#123;<br><br><span class="hljs-comment">//1.读取大文件</span><br><br><span class="hljs-comment">//2.分批次向小文件中写入</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++)&#123;<br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">float</span> progressValue = m_fileNumber;<br>progressValue = (i + <span class="hljs-number">1</span>) / progressValue;<br><span class="hljs-built_in">onProgress</span>(progressValue);<span class="hljs-comment">//发送通知</span><br>&#125;<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addIProgress</span><span class="hljs-params">(IProgress* iprogress)</span></span>&#123;<br>m_iprogressList.<span class="hljs-built_in">push_back</span>(iprogress);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeIProgress</span><span class="hljs-params">(IProgress* iprogress)</span></span>&#123;<br>m_iprogressList.<span class="hljs-built_in">remove</span>(iprogress);<br>&#125;<br><br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span></span>&#123;<br><br>List&lt;IProgress*&gt;::iterator itor=m_iprogressList.<span class="hljs-built_in">begin</span>();<br><br><span class="hljs-keyword">while</span> (itor != m_iprogressList.<span class="hljs-built_in">end</span>() )<br>(*itor)-&gt;<span class="hljs-built_in">DoProgress</span>(value); <span class="hljs-comment">//更新进度条</span><br>itor++;<br>&#125;<br>&#125;<br>&#125;;<br><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span> :</span> <span class="hljs-keyword">public</span> Form, <span class="hljs-keyword">public</span> IProgress<br>&#123;<br>TextBox* txtFilePath;<br>TextBox* txtFileNumber;<br><br>ProgressBar* progressBar;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span></span>&#123;<br><br>string filePath = txtFilePath-&gt;<span class="hljs-built_in">getText</span>();<br><span class="hljs-keyword">int</span> number = <span class="hljs-built_in">atoi</span>(txtFileNumber-&gt;<span class="hljs-built_in">getText</span>().<span class="hljs-built_in">c_str</span>());<br><br>ConsoleNotifier cn;<br><br><span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;<br><br>splitter.<span class="hljs-built_in">addIProgress</span>(<span class="hljs-keyword">this</span>); <span class="hljs-comment">//订阅通知</span><br>splitter.<span class="hljs-built_in">addIProgress</span>(&amp;cn)； <span class="hljs-comment">//订阅通知</span><br><br>splitter.<span class="hljs-built_in">split</span>();<br><br>splitter.<span class="hljs-built_in">removeIProgress</span>(<span class="hljs-keyword">this</span>);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span></span>&#123;<br>progressBar-&gt;<span class="hljs-built_in">setValue</span>(value);<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsoleNotifier</span> :</span> <span class="hljs-keyword">public</span> IProgress &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;.&quot;</span>;<br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>比较上面两段代码，在运用观察者模式之前：</p><ul><li><code>MainForm</code>与<code>FileSplitter</code>高耦合，从两者的初始化过程和相互之间捆绑的<code>ProgressBar</code>类型指针就可看出，牵一发而动全身。</li><li>对于<code>ProgressBar</code>，这种设计思路十分不妥。如果客户需求更改，使用其他的形式来显示进度，那么<code>ProgressBar</code>需要更换成其他的实现类。可以看出，此例违反了依赖倒置原则。</li></ul><p>在运用观察者模式之后：</p><ul><li>将<code>ProgressBar</code>抽象成一个父类，作为接口<code>IProgress</code>。经过这样的处理，不仅将<code>MainForm</code>和<code>FileSplitter</code>从紧耦合优化成了松耦合，还可以灵活的支持不同的进度显示。</li><li>对于<code>FileSplitter</code>来说，<code>MainForm</code>是接收<code>FileSplitter</code>通知（上例的通知就是进度）的一份子。只要在<code>FileSplitter</code>中注册过，那么每当<code>FileSplitter</code>发送通知，所有已经注册过的<code>MainForm</code>就会接收（继承的接口中实现的虚函数<code>DoProgress</code>被调用）到通知。此处，<code>FileSplitter</code>为<strong>“被观察者”</strong>，<code>MainForm</code>为<strong>“观察者”</strong>。</li><li>对于观察者而言：只要你注册了，就可以接收到通知。</li><li>对于被观察者而言：发送通知时，只要在被观察者内部注册过，都会进行发送</li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/26a238c797118c47e2d6c9190cac73dd-8d1f4c.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>C++虽然有多继承，但是不推荐使用，因为会带来耦合。而如果继承的是一个父类加上多个接口就可以。</li><li>对于现实需求有变化的实体，比如本文的进度条。有很多种方式可以表示进度，比如直接用数字表示。对于这种情况一般可以把容易变化的对象进行更深层次的抽象。对于本文中未运用观察者模式之前的代码，已经违反了依赖倒置原则。</li><li>有些框架是把Observer的注册、删除、通知放在一个基类里。</li><li>使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合。</li><li>目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。</li><li>观察者自己决定是否需要订阅通知，目标对象对此一无所知。</li><li>Observer模式是基于事件的UI框架中非常常用的设计模式，也是 MVC模式的一个重要组成部分。</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组件协作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板方法</title>
    <link href="/2020/04/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"/>
    <url>/2020/04/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>定义一个操作中的算法的骨架(稳定)，而将一些步骤延迟(变化)到子类中。Template Method使得子类可以不改变(复用)一个算法的结构即可重定义(override重写)该算法的某些特定步骤。——《设计模式》GoF</p></blockquote><p><strong>注意：除了可以灵活应对子步骤的变化外，“不要调用我，让我来调用你”的反向控制结构是Template Method的典型应用。</strong></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运用模板方法之前：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//lib.cpp</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Library</span>&#123;</span><br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step1</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//...</span><br>&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step3</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step5</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//main.cpp</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//...</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//由应用开发人员来编写流程</span><br><span class="hljs-function">Library <span class="hljs-title">lib</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">Application <span class="hljs-title">app</span><span class="hljs-params">()</span></span>;<br><br>lib.<span class="hljs-built_in">Step1</span>();<br><br><span class="hljs-keyword">if</span> (app.<span class="hljs-built_in">Step2</span>())&#123;<br>lib.<span class="hljs-built_in">Step3</span>();<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br>app.<span class="hljs-built_in">Step4</span>();<br>&#125;<br><br>lib.<span class="hljs-built_in">Step5</span>();<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210708102904.png" alt="运用模板方法之前"></p><p><strong>运用模板方法之后：</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//lib</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Library</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//稳定 template method</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span></span>&#123;<br>        <br>        <span class="hljs-built_in">Step1</span>();<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Step2</span>()) &#123; <span class="hljs-comment">//支持变化 ==&gt; 虚函数的多态调用</span><br>            <span class="hljs-built_in">Step3</span>(); <br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br>            <span class="hljs-built_in">Step4</span>(); <span class="hljs-comment">//支持变化 ==&gt; 虚函数的多态调用</span><br>        &#125;<br><br>        <span class="hljs-built_in">Step5</span>();<br><br>    &#125;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Library</span>()&#123; &#125;<br><br><span class="hljs-keyword">protected</span>:<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//稳定</span><br>        <span class="hljs-comment">//.....</span><br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step3</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//稳定</span><br>        <span class="hljs-comment">//.....</span><br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step5</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//稳定</span><br><span class="hljs-comment">//.....</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-comment">//变化</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>=<span class="hljs-number">0</span>; <span class="hljs-comment">//变化</span><br>&#125;;<br><br><span class="hljs-comment">//main</span><br><span class="hljs-comment">//应用程序开发人员</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> :</span> <span class="hljs-keyword">public</span> Library &#123;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//... 子类重写实现</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//... 子类重写实现</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Library* pLib=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Application</span>();<br>    lib-&gt;<span class="hljs-built_in">Run</span>();<br><br><span class="hljs-keyword">delete</span> pLib;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210708110113.png" alt="应用模板方法后"></p><p>在前后的对比中，实质上是运用了虚函数来推迟具体步骤（变化）的实现，但是总体的流程（稳定）是已经事先写好的。运用虚函数的机制将绑定延迟，交由子类实现</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210708110317.png" alt="早绑定与晚绑定"></p><p>早绑定实际上就是在日常开发中，我们调用别人事先写好的库。晚绑定则相反</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>可以通过寻找稳定点来设计并运用模式</li><li>在具体实现方面，被Template Method调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将它们设置为protected方法。</li><li>任何一个基类的析构函数都应该写成虚的</li><li>大多数的设计模式实质上都是“稳定中有变化”</li><li>如果结构中所有的东西都在变化，那么不建议使用设计模式，因为设计模式假设结构中至少有一个稳定点。同样，若是结构中的所有东西都是稳定的，那么运用设计模式也是没有意义的，因为设计模式是在稳定和变化中寻找隔离点。</li><li>稳定是相对的，考量相对的方法也是不一样的。比如A和B，A一年一次变化，而B一周一次变化，那么A对于B是稳定的。</li><li>Template Method模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制（虚函数的多态性）为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组件协作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>策略模式</title>
    <link href="/2020/04/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/04/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂； 而且有时候支持不使用的算法也是一个性能负担。</p><p>如何在运行时根据需要透明地更改对象的算法？将算法与对象本 身解耦，从而避免上述问题？</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程 序(稳定)而变化（扩展，子类化）。 ——《设计模式》GoF</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>运用策略模式之前：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TaxBase</span> &#123;</span><br>CN_Tax,<br>US_Tax,<br>DE_Tax,<br>FR_Tax       <span class="hljs-comment">//更改</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span>&#123;</span><br>    TaxBase tax;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>        <br>        <span class="hljs-keyword">if</span> (tax == CN_Tax)&#123;<br>            <span class="hljs-comment">//CN***********</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tax == US_Tax)&#123;<br>            <span class="hljs-comment">//US***********</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tax == DE_Tax)&#123;<br>            <span class="hljs-comment">//DE***********</span><br>        &#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tax == FR_Tax)&#123;  <span class="hljs-comment">//更改</span><br><span class="hljs-comment">//...</span><br>&#125;<br><br>        <span class="hljs-comment">//....</span><br>     &#125;<br>    <br>&#125;;<br></code></pre></div></td></tr></table></figure><p>运用策略模式之后：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaxStrategy</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">TaxStrategy</span>()&#123;&#125;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CNTax</span> :</span> <span class="hljs-keyword">public</span> TaxStrategy&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span></span>&#123;<br>        <span class="hljs-comment">//***********</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">USTax</span> :</span> <span class="hljs-keyword">public</span> TaxStrategy&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span></span>&#123;<br>        <span class="hljs-comment">//***********</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DETax</span> :</span> <span class="hljs-keyword">public</span> TaxStrategy&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span></span>&#123;<br>        <span class="hljs-comment">//***********</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//扩展</span><br><span class="hljs-comment">//*********************************</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FRTax</span> :</span> <span class="hljs-keyword">public</span> TaxStrategy&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span></span>&#123;<br><span class="hljs-comment">//.........</span><br>&#125;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    TaxStrategy* strategy;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SalesOrder</span>(StrategyFactory* strategyFactory)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;strategy = strategyFactory-&gt;<span class="hljs-built_in">NewStrategy</span>();<br>    &#125;<br>    ~<span class="hljs-built_in">SalesOrder</span>()&#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;strategy;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-function">Context <span class="hljs-title">context</span><span class="hljs-params">()</span></span>;<br>        <br>        <span class="hljs-keyword">double</span> val = <br>            strategy-&gt;<span class="hljs-built_in">Calculate</span>(context); <span class="hljs-comment">//多态调用</span><br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <br>&#125;;<br></code></pre></div></td></tr></table></figure><p>即：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5191ec8f720daee9fb5a2cdf2f6819c4-c2caee.png" alt="结构"></p><p>运用策略模式之前，代码违反开闭原则，不停的修改if-else。</p><p><strong>问题：</strong>if-else虽然更改了，但是更改的也只是在后面添加，前面的if-else不是也被复用了吗？</p><p><strong>答：</strong>复用性一般讲的是编译方面二进制的复用性。虽然只在后面添加，但是代码需要重新编译。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>面向过程的分而治之一般可以用面向对象的抽象来解决</p></li><li><p>当控制语句（if-else或switch）出现的时候，若出现控制语句会不停的修改，那么就可以考虑应用设计模式。相反的，绝对稳定不变的（比如一周有七天，周一干什么周二干什么…）可以保留控制语句</p></li><li>Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。</li><li>Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需 要Strategy模式。</li><li>如果Strategy对象没有实例变量，那么各个上下文可以共享同一个 Strategy对象，从而节省对象开销。（单例模式）</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组件协作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>散列</title>
    <link href="/2020/04/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E6%95%A3%E5%88%97/"/>
    <url>/2020/04/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E6%95%A3%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/c5836ab5a77fcdbfef6cf3e024b5dc5a-39fda.png" alt="原理" style="zoom:50%;" /></p><p>若存放总数设置为N：</p><ul><li>桶bucket：直接存放或间接指向一个词条</li><li>桶数组bucket array/散列表hash table，容量为M<ul><li>M与N同阶</li><li>空间效率取决于M与N的比值，这个比值也称为空间装填因子</li><li>$N&lt;M&lt;&lt;R$</li><li>空间 = $O(N+M)$​ = $O(N)$​</li></ul></li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6e3ce35c8c4af9bd39adfa30428405d8-e610d.png" alt="实例" style="zoom:50%;" /></p><h3 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h3><p>散列冲突：<code>key1 != key2</code>，但是<code>hash(key1) = hash(key2)</code></p><ul><li>将散列表长度<strong>变长</strong>能降低散列冲突的概率，但是这种冲突几乎是不能杜绝的</li></ul><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>对于散列函数$hash()：S-&gt;A$​​，不可能是单射。原因：</p><script type="math/tex; mode=display">|S| = R>>M = |A|</script><p>所以只能采用近似的单射。</p><p>所以需要：</p><ul><li>精心设计散列表及散列函数，尽可能降低冲突的概率</li><li>执行可行的预案，以便在发生冲突时，能够尽快予以排解</li></ul><h2 id="评价标准与设计原则"><a href="#评价标准与设计原则" class="headerlink" title="评价标准与设计原则"></a>评价标准与设计原则</h2><ul><li>确定determinism：同一关键码总是被映射至同一地址</li><li>快速efficiency：expercted-$O(1)$</li><li>满射surjection：尽可能充分地覆盖整个散列空间</li><li>均匀uniformity：关键码映射到散列表各位置的概率尽量接近，可有效避免聚集clustering现象</li></ul><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><h4 id="除余法"><a href="#除余法" class="headerlink" title="除余法"></a>除余法</h4><script type="math/tex; mode=display">hash(key) = key % M</script><ul><li><p>若取$M=2^k$，其效果相当于截取key的最后k位（bit），前面的$n-k$​位对地址没有影响。</p></li><li><p>若取$M\ne2^k$​，缺陷有所改善。特别是M为素数时，数据对散列表的覆盖最充分，分布最均匀。​</p></li></ul><p>缺点：</p><ul><li>不动点：无论表长<strong>M</strong>取值如何，总有$hash(0)\equiv0$​​。</li><li>零阶均匀：$[0,R)$​的关键码，平均分配至<strong>M</strong>个桶；但相邻关键码的散列地址也必相邻。</li></ul><h4 id="MAD法"><a href="#MAD法" class="headerlink" title="MAD法"></a>MAD法</h4><ul><li>一阶均匀：邻近的关键码，散列地址不再邻近。</li></ul><p>取M为素数，$a&gt;0，b&gt;0，a \% M \ne 0$​​：（a视为步长，b视为偏移）</p><script type="math/tex; mode=display">hash(key) = (a*key+b)\%M</script><h4 id="数字分析"><a href="#数字分析" class="headerlink" title="数字分析"></a>数字分析</h4><p>抽取key中的某几位，构成地址。比如，取十进制表示的奇数位：</p><script type="math/tex; mode=display">hash(^1{2}^3{4}^5{6}^7{8}^9) = 1 3 5 7 9</script><h4 id="平方取中"><a href="#平方取中" class="headerlink" title="平方取中"></a>平方取中</h4><p>取$key^2$的中间若干位，构成地址</p><script type="math/tex; mode=display">hash(123) = 512//保留key^2 = 123^2 = 15129的中间3位</script><h4 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h4><p>将key分割成等宽的若干段，取其总和作为地址</p><script type="math/tex; mode=display">hash(123^{456^{789}}) = 1368//注释：123+456+789</script><h4 id="位异或法XOR"><a href="#位异或法XOR" class="headerlink" title="位异或法XOR"></a>位异或法XOR</h4><p>将key分割成等宽的二进制段，经异或运算得到地址</p><script type="math/tex; mode=display">hash(111^{011^{011}})=110_b</script><h2 id="散列码"><a href="#散列码" class="headerlink" title="散列码"></a>散列码</h2><p>原始数据的关键码不一定是整数，因此需要先做一个预处理，将其转化为整数，称作散列码<strong>hashcode</strong>。</p><h3 id="多项式法：字符串处理"><a href="#多项式法：字符串处理" class="headerlink" title="多项式法：字符串处理"></a>多项式法：字符串处理</h3><script type="math/tex; mode=display">hash(s=x_0x_1...x_{n-1}) = x_0*a^{n-1}+x_1*a^{n-2}+...+x_{n-2}*a^1+x_{n-1}</script><p>比如：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">hashCode</span><span class="hljs-params">(<span class="hljs-keyword">char</span> s[])</span></span>&#123;<br><span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> n = <span class="hljs-built_in">strlen</span>(s),i= <span class="hljs-number">0</span>;i &lt; n;i++)<br>&#123; h = (h&lt;&lt;<span class="hljs-number">5</span>)|(h&gt;&gt;<span class="hljs-number">27</span>); h += (<span class="hljs-keyword">int</span>)s[i];&#125;<br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">size_t</span>)h;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="排解冲突"><a href="#排解冲突" class="headerlink" title="排解冲突"></a>排解冲突</h2><h3 id="多槽位"><a href="#多槽位" class="headerlink" title="多槽位"></a>多槽位</h3><p>将桶单元细分为若干槽位，存放（与同一单元）冲突的词条。只要槽位数目不多，依然可以保证$O(1)$的时间效率。</p><p>但是需要为每个桶配备多少个槽，才能保证$O(1)$​呢？这种情况难以预测，因为预留过多，会造成空间浪费；而无论预留多少，极端情况下仍有可能不够。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/0e3d4d09a656484cff71bbbbd195fe32-d0955.png" alt="多槽位" style="zoom:50%;" /></p><h3 id="独立链"><a href="#独立链" class="headerlink" title="独立链"></a>独立链</h3><p>每个桶存放一个指针，冲突的词条，组织成<strong>列表</strong>。</p><p>优点：</p><ul><li>无需为每个桶预备多个槽位</li><li>任意多次的冲突都可以解决</li><li>删除操作实现简单、统一</li></ul><p>但是指针需要额外空间，节点需要动态申请、更重要的是空间未必连续分布，<strong>系统缓存</strong>几乎失效。对于大规模数据集，会有大量的IO操作。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8c6487003da4a666598b0786141b6cbc-7b7dc.png" alt="独立链" style="zoom:50%;" /></p><h3 id="线性试探（开放定址）"><a href="#线性试探（开放定址）" class="headerlink" title="线性试探（开放定址）"></a>线性试探（开放定址）</h3><p>为每个桶都事先约定若干备用桶，它们构成一个查找链（一段连续的地址空间，没有任何的空桶缝隙）。</p><p>优点：</p><ul><li>无需附加的（指针、链表或溢出区等）空间</li><li>查找链具有局部性，可充分利用<strong>系统缓存</strong>，有效减少IO</li></ul><p>缺点：</p><ul><li>大部分试探的位置都集中于某一个相对很小的局部</li></ul><h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><p>沿着查找链，逐个转向下一桶单元，直到：</p><ul><li>命中成功</li><li>抵达一个空桶（已遍历所有冲突的词条），失败</li></ul><p>整个过程视为：$[hash(key)+1]\%M-&gt;[hash(key)+2]\%M-&gt;[hash(key)+3]\%M…$​</p><p>但是，操作时间大于$O(1)$​​。原因是冲突增多，以往的冲突，会导致后续的冲突。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/05d5b4472d3f292c22932c626c59354c-42619.png" alt="开放定址" style="zoom:50%;" /></p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>将待删除的元素做删除标记即可，并不是真的将它从桶中删除。否则查找链将被切断。之后，若有：</p><ul><li>查找操作，那么将越过这个标记，从下一个位置继续查找</li><li>插入操作，那么将清除这个标记，将新的元素插入到该位置</li></ul><h3 id="平方试探"><a href="#平方试探" class="headerlink" title="平方试探"></a>平方试探</h3><p>为了解决开放定址中，大部分试探的位置都集中于某一个相对很小的局部的缺点。所以平方试探将以平方数作为距离（距离将按照<strong>算数级数</strong>递增），确定下一个试探桶单元。</p><p>整个操作可视为：$[hash(key)+1^2]\%M-&gt;[hash(key)+2^2]\%M-&gt;[hash(key)+3^2]\%M…$</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/633d5d2911b0f7f596649d40e5b43d46-e694a.png" alt="平方试探" style="zoom:50%;" /></p><p>虽然很大程度上缓解了数据聚集现象，但是破坏数据访问的局部性。若涉及外存，IO将激增。</p><p>不过因为缓存页面的大小对于散列表的长度来说，相对较大，所以这种现象还不算很严重。除非运气不好，连续冲突的次数很大才会造成IO读取。</p><p>所以可以说，平方探测所增加的试探位置间距是适度的。</p><p><strong>平方试探的缺点：</strong>只要散列表中有空桶，那么这种试探方式将永远不会发现空桶的存在。</p><h4 id="装填因子"><a href="#装填因子" class="headerlink" title="装填因子"></a>装填因子</h4><p><strong>例子1：</strong></p><p>${0,1,2,3,4,5,…}^2 \%12 = {0,1,4,9}$​</p><p><img src="C:\Users\15606\AppData\Roaming\Typora\typora-user-images\image-20210723172208572.png" alt="image-20210723172208572" style="zoom:50%;" /></p><p><strong>结论：M若为素数，$n^2\%M$可能的取值必然少于$\lceil M/2 \rceil$​种​</strong>。</p><p><strong>例子2：</strong></p><p>${0,1,2,3,4,5,…}^2 \%11 = {0,1,4,9,5,3}$</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8c553134a36d7ca2d0cedefb8194a09d-38a9e.png" alt="**例子2：**" style="zoom:50%;" /></p><p><strong>结论：M若为素数，$n^2\%M$可能的取值恰好会有$\lceil M/2 \rceil$种。此时，恰由查找链的前$\lceil M/2 \rceil$​项取遍。</strong></p><p><strong>定理：若M是素数，且装填因子$\le0.5$​​，就一定能找出；否则，不见得。</strong></p><p><strong>所以，只要将散列表的长度M取做素数，同时将装填因子控制在50%以下，那么就能保证，在起始于任何位置的平方探测序列中，前面的$\lceil M/2 \rceil$位置中，必然是彼此互异的。</strong></p><h3 id="双向平方试探"><a href="#双向平方试探" class="headerlink" title="双向平方试探"></a>双向平方试探</h3><p>自冲突位置起，依次向后试探：$[hash(key)+1^2]\%M-&gt;[hash(key)-1^2]\%M-&gt;[hash(key)+2^2]\%M-&gt;[hash(key)-2^2]\%M…$</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/be4ee0d6ab86eed5e51d1a2b1d311082-d3b3f.png" alt="双向平方试探" style="zoom:50%;" /></p><p>正向和逆向的子查找链，各包含$\lceil M/2 \rceil$个互异的桶。​</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/c66cba93eab4bb06aed06d6fb3712e99-8e639.png" alt="双向平方试探" style="zoom:50%;" /></p><p>根据上图可知，对于双向平方试探法而言，采用某些素数表长可以行之有效，但是采用另外一些素数的表长却非常糟糕。</p><p><strong>根据双平方定理，可得到结论：表长取做素数$M=4*k+3$​，即M取模4余3的素数，必然可以保证查找链的前M项均互异。</strong></p><h2 id="桶-计数排序"><a href="#桶-计数排序" class="headerlink" title="桶/计数排序"></a>桶/计数排序</h2><p>这类算法的性能取决于：</p><ul><li>待排序序列的长度n</li><li>待排序元素的取值范围M </li></ul><p>所以M的范围越有限，这类算法的优势就越明显。  </p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/375b5097e34d4ea1bc1b68c693300eb6-37442.png" alt="桶/计数排序" style="zoom:50%;" /></p><p><strong>QA:</strong></p><ul><li>对[0, 11)中的整数{ 10, 4, 2, 9, 3, 1, 2, 2, 4, 9, 8, 5, 9, 10, 7, 6, 9 }用计数排序，得到的accum[]表为：<ul><li>{0, 1, 4, 5, 7, 8, 9, 10, 11, 15, 17}</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>计数排序</tag>
      
      <tag>桶排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象设计原则</title>
    <link href="/2020/04/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <url>/2020/04/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="依赖倒置（DIP）"><a href="#依赖倒置（DIP）" class="headerlink" title="依赖倒置（DIP）"></a>依赖倒置（DIP）</h2><ul><li>高层模块(稳定)不应该依赖于低层模块（变化），二者应依赖于抽象（稳定）</li><li>抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）</li></ul><p><strong>注：这里所说的依赖是编译式依赖</strong></p><p>现在需要我们写一个能画指定图形的方法，我们通常在脑海里会有如下思路：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">line</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">line</span>();<br>~<span class="hljs-built_in">line</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">rect</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">rect</span>();<br>~<span class="hljs-built_in">rect</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawShape</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string type)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;line&quot;</span>)<br>&#123;<br>line l;<br>l.<span class="hljs-built_in">draw</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;rect&quot;</span>)<br>&#123;<br>rect r;<br>r.<span class="hljs-built_in">draw</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">drawShape</span>(<span class="hljs-string">&quot;line&quot;</span>);<span class="hljs-comment">/*画直线*/</span><br><span class="hljs-built_in">drawShape</span>(<span class="hljs-string">&quot;rect&quot;</span>);<span class="hljs-comment">/*画矩形*/</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><br>这时候，需求变了，需要再添加一个画圆形的方法，那么上面的代码需要改成：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">line</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">line</span>();<br>~<span class="hljs-built_in">line</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">rect</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">rect</span>();<br>~<span class="hljs-built_in">rect</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">circle</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">circle</span>();<br>~<span class="hljs-built_in">circle</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawShape</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string type)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;line&quot;</span>)<br>&#123;<br>line l;<br>l.<span class="hljs-built_in">draw</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;rect&quot;</span>)<br>&#123;<br>rect r;<br>r.<span class="hljs-built_in">draw</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;circle&quot;</span>)<span class="hljs-comment">/*此处改动*/</span><br>&#123;<br>circle c;<br>c.<span class="hljs-built_in">draw</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">drawShape</span>(<span class="hljs-string">&quot;line&quot;</span>);<span class="hljs-comment">/*画直线*/</span><br><span class="hljs-built_in">drawShape</span>(<span class="hljs-string">&quot;rect&quot;</span>);<span class="hljs-comment">/*画矩形*/</span><br><span class="hljs-built_in">drawShape</span>(<span class="hljs-string">&quot;circle&quot;</span>);<span class="hljs-comment">/*画圆形*/</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​        看起来没毛病，逻辑上符合我们的需求。在实际应用场景中，高层模块通常调用低层模块。在上述代码里，我们可以把main函数看成高层模块，line，rect，circle等具体实现类看成低层模块。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道在开发中，需求是不断在变化的。今天让你添加一个画圆形的需求，明天又让你添加一个画梯形的需求。从需求的角度看，低层模块不断在变化，这是其一。其二，代码修改的原因不仅限于需求变更。从低层模块的内部出发，不同的平台，不同的硬件，不同的API或者调用方法，都会导致低层模块的实现随时更改。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据这两点，我们可以得出低层模块是不稳定的，是随时会更改的。此时我们再来看上面的代码，会发现高层模块直接依赖于低层模块，这将导致高层模块也变得不稳定，不符合依赖倒置原则。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210415173908.png" alt="不符合依赖倒置原则"><br>        为了满足依赖倒置原则，我们从面向对象设计的一个核心出发：抽象。我们把低层模块抽象成一个基类，即shape，并让所有需求实现接口draw()。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shape</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">shape</span>();<br>~<span class="hljs-built_in">shape</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">line</span>:</span><span class="hljs-keyword">public</span> shape<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">line</span>();<br>~<span class="hljs-built_in">line</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">rect</span> :</span><span class="hljs-keyword">public</span> shape<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">rect</span>();<br>~<span class="hljs-built_in">rect</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>shape* s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">rect</span>();<br>s-&gt;<span class="hljs-built_in">draw</span>();<span class="hljs-comment">/*画矩形*/</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​        如果再添加一个画圆形的需求，和line、rect这两个类一样，我们只要负责实现circle这个类就行，而我们抽象出来的shape这个类是不需要改变的，也就是说这个抽象类是稳定的，通过接口隔离了高低两个模块。此时高层模块依赖于抽象，低层模块也依赖于抽象。</p><p>​        若此时我们需要修改画直线的方法，只要修改line类中的draw方法即可，抽象出来的shape我们无需改动。也就是说，抽象不关心你是如何实现的（抽象不依赖于实现细节），但是你要实现什么，由抽象来决定（实现细节应该依赖于抽象）。<br><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210415180439.png" alt="图2"></p><h2 id="开放封闭原则（OCP）"><a href="#开放封闭原则（OCP）" class="headerlink" title="开放封闭原则（OCP）"></a>开放封闭原则（OCP）</h2><ul><li>对扩展开放，对更改封闭</li><li>类模块应该是可扩展的，但是不可修改</li></ul><p>依旧是这段代码，只是稍加修改：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">line</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">line</span>();<br>~<span class="hljs-built_in">line</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">rect</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">rect</span>();<br>~<span class="hljs-built_in">rect</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">drawShape</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">drawShape</span>();<br>~<span class="hljs-built_in">drawShape</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string type)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;line&quot;</span>)<br>&#123;<br>line l;<br>l.<span class="hljs-built_in">draw</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;rect&quot;</span>)<br>&#123;<br>rect r;<br>r.<span class="hljs-built_in">draw</span>();<br>&#125;<br>&#125;<br><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>drawShape d;<br>d.<span class="hljs-built_in">draw</span>(<span class="hljs-string">&quot;line&quot;</span>);<span class="hljs-comment">/*画直线*/</span><br>d.<span class="hljs-built_in">draw</span>(<span class="hljs-string">&quot;rect&quot;</span>);<span class="hljs-comment">/*画矩形*/</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><br>此时同样新增了一个画圆形的需求：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">line</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">line</span>();<br>~<span class="hljs-built_in">line</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">rect</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">rect</span>();<br>~<span class="hljs-built_in">rect</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">circle</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">circle</span>();<br>~<span class="hljs-built_in">circle</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">drawShape</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">drawShape</span>();<br>~<span class="hljs-built_in">drawShape</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string type)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;line&quot;</span>)<br>&#123;<br>line l;<br>l.<span class="hljs-built_in">draw</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;rect&quot;</span>)<br>&#123;<br>rect r;<br>r.<span class="hljs-built_in">draw</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">&quot;circle&quot;</span>)<span class="hljs-comment">/*此处更改*/</span><br>&#123;<br>circle c;<br>c.<span class="hljs-built_in">draw</span>();<br>&#125;<br>&#125;<br><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>drawShape ds;<br>ds.<span class="hljs-built_in">draw</span>(<span class="hljs-string">&quot;line&quot;</span>);<span class="hljs-comment">/*画直线*/</span><br>ds.<span class="hljs-built_in">draw</span>(<span class="hljs-string">&quot;rect&quot;</span>);<span class="hljs-comment">/*画矩形*/</span><br>ds.<span class="hljs-built_in">draw</span>(<span class="hljs-string">&quot;circle&quot;</span>);<span class="hljs-comment">/*画圆形*/</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​        这样的写法在逻辑上没有任何问题，也符合我们的需求。但是当有新的需求不断出现，drawShape类中的draw方法就得不停的修改。这种做法不仅会让开发效率低下，而且还违反了开放封闭原则（对更改封闭）。<br>​        为了满足开放封闭原则，我们同样采取抽象的办法：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shape</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">shape</span>();<br>~<span class="hljs-built_in">shape</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">line</span> :</span><span class="hljs-keyword">public</span> shape<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">line</span>();<br>~<span class="hljs-built_in">line</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">rect</span> :</span><span class="hljs-keyword">public</span> shape<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">rect</span>();<br>~<span class="hljs-built_in">rect</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">circle</span>:</span><span class="hljs-keyword">public</span> shape<br>&#123;<br><span class="hljs-built_in">circle</span>();<br>~<span class="hljs-built_in">circle</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*具体实现*/</span><br>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">drawShape</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">drawShape</span>();<br>~<span class="hljs-built_in">drawShape</span>();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(shape* s)</span></span><br><span class="hljs-function"></span>&#123;<br>s-&gt;<span class="hljs-built_in">draw</span>();<br>&#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>drawShape ds;<br>ds.<span class="hljs-built_in">draw</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">rect</span>());<span class="hljs-comment">/*画矩形*/</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>​        我们添加了一个shape抽象类，原有的drawShape中的draw方法重写，修改成依赖于shape提供的接口draw。这时你的需求无论怎么添加（对扩展开放），drawShape这个类始终不用修改（对更改封闭）。<br>​        开放封闭原则和依赖倒置原则，在抽象这个角度上都有一定的相似性。借用另外一位博主的话：“开放封闭原则通过抽象来避免代码发生更改，而依赖倒置原则更偏向于层和层之间的解耦”。</p><h2 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h2><ul><li>一个类应该仅有一个引起它变化的原因</li><li>变化的方向隐含着类的责任</li></ul><p>字面意思，说白了就是一个类应该只有一种职责，避免责任太多导致的代码臃肿（比如上帝类）。</p><h2 id="Liskov替换原则（LSP）"><a href="#Liskov替换原则（LSP）" class="headerlink" title="Liskov替换原则（LSP）"></a>Liskov替换原则（LSP）</h2><ul><li>子类必须能够替换它们的基类（IS-A）</li><li>继承表达类型抽象<br>所有需要父类的地方，子类都可以传过去。</li></ul><h2 id="GOF模式分类"><a href="#GOF模式分类" class="headerlink" title="GOF模式分类"></a>GOF模式分类</h2><p>从目的来看：</p><ol><li>创建型</li><li>结构型</li><li>行为型</li></ol><p>从范围来看：</p><ol><li>类模式处理类与子类的静态关系</li><li>对象模式处理对象间的动态关系</li></ol><hr><h3 id="从封装变化角度对模式分类"><a href="#从封装变化角度对模式分类" class="headerlink" title="从封装变化角度对模式分类"></a>从封装变化角度对模式分类</h3><div class="table-container"><table><thead><tr><th style="text-align:left">类别</th><th>模式</th></tr></thead><tbody><tr><td style="text-align:left">组件协作</td><td>Template Method,Strategy,Observer/Event</td></tr><tr><td style="text-align:left">单一职责</td><td>Decoraror,Bridge</td></tr><tr><td style="text-align:left">对象创建</td><td>Factory Method,Abstract Factory,Prototype,Builder</td></tr><tr><td style="text-align:left">对象性能</td><td>Singleton,Flyweight</td></tr><tr><td style="text-align:left">接口隔离</td><td>Facade,Proxy,Mediator, Adapter</td></tr><tr><td style="text-align:left">状态变化</td><td>Memento,State</td></tr><tr><td style="text-align:left">数据结构</td><td>Composite,Iterator,Chain of Resposibility</td></tr><tr><td style="text-align:left">行为变化</td><td>Command,Visitor</td></tr><tr><td style="text-align:left">领域问题</td><td>Interpreter</td></tr></tbody></table></div><ul><li>组件协作：现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过晚期绑定，来实现框架与应用程序之 间的松耦合，是二者之间协作时常用的模式。</li><li>单一职责：在软件组件的设计中，如果责任划分的不清晰，使用继承得到的 结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。</li><li>对象创建：通过“对象创建” 模式绕开new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。</li><li>对象性能：面向对象很好地解决了”抽象“的问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面对对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。</li><li>接口隔离：在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。</li><li>状态变化：在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？”状态变化“模式为这一问题提供了一种解决方案。</li><li>数据结构：常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。</li><li>行为变化：在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。”行为变化“模式将组件的行为和组件本身进行解耦，从而支持组件行为的变化，实现两者之间的松耦合。</li><li>领域规则：在特定领域中，某些变化虽然频繁，但可以抽象为某种规则。这时候，结合特定领域，将问题抽象为语法规则，将问题抽象为语法规则，从而给出在该领域下的一般性解决方案。</li></ul><h2 id="重构获得模式"><a href="#重构获得模式" class="headerlink" title="重构获得模式"></a>重构获得模式</h2><p>即通过修正来得到一种良好的解决方案</p><p>重构技巧：（以下五点实际上是同一回事）</p><ul><li>静态-&gt;动态</li><li>早绑定-&gt;晚绑定</li><li>继承-&gt;组合</li><li>编译时依赖-&gt;运行时依赖</li><li>紧耦合-&gt;松耦合</li></ul><p>重构要点：</p><ol><li>寻找变化点，在变化点处应用设计模式。将变化和稳定分离开</li></ol><h2 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h2><ul><li>不要为了模式而模式</li><li>关注抽象类&amp;接口</li><li>理清变化点和稳定点</li><li>审视依赖关系</li><li>要有Framework和Application的区隔思维</li><li>良好的设计是演化的结果</li></ul><h2 id="什么时候不用模式"><a href="#什么时候不用模式" class="headerlink" title="什么时候不用模式"></a>什么时候不用模式</h2><ul><li>代码可读性很差时</li><li>需求理解还很浅时</li><li>变化没有显现时</li><li>不是系统的关键依赖点</li><li>项目没有复用价值时</li><li>项目将要发布时</li></ul><blockquote><p>参考：<br><a href="https://blog.csdn.net/tjiyu/article/details/76551307">面向对象设计原则（三）：里氏替换原则（LSP）</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树</title>
    <link href="/2020/04/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2020/04/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>红黑树是由红、黑两类节点组成的BST，统一增设<strong>外部节点NULL</strong>，使之成为<strong>真二叉树</strong>。其中：</p><ul><li>树根：必为黑色</li><li>外部节点：均为黑色</li><li>其余节点：若为红，则只能有黑孩子。即红节点的父子皆黑（这条规则旨在控制红黑树的深度）</li><li>外部节点到根：途中黑节点数目相等（这条规则旨在控制红黑树的平衡性）</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5f98af1aeafaf0be8e8de8f64d68b79f-129b9.png" alt="实例"></p><h3 id="提升变换"><a href="#提升变换" class="headerlink" title="提升变换"></a>提升变换</h3><ul><li>将每一个红色的节点都向上提升至与它的父亲平齐。提升后，两个红色节点一定不会紧邻，中间一定有一个黑色节点，也就是它们此前的父亲。</li></ul><p><strong>提升前：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/491128180ded5a3046bd418889a18b65-cf721.png" alt="提升前："></p><p><strong>提升后：</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5e88b968deed88d6ffd4d0d3b1cd29ac-63493.png" alt="提升后："></p><p>提升后，所有底层的节点都变成沿同一水平高度平齐的高度。</p><h3 id="2-4-树-红黑树"><a href="#2-4-树-红黑树" class="headerlink" title="(2,4)树 == 红黑树"></a>(2,4)树 == 红黑树</h3><p>红黑树提升变换：</p><ul><li>提升各红节点，使之与其（黑）父亲等高，于是每棵红黑树，都对应于一棵$(2,4)$-树。</li><li>将黑节点与其红孩子视作（关键码并合并为）超级节点</li><li>无非四种组合，分别对应于4阶B-树的一类内部节点</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f9031e9cb7d0db148e54c98cfda668f5-e890c.png" alt="(2,4)树 == 红黑树"></p><h3 id="红黑树-in-BBST"><a href="#红黑树-in-BBST" class="headerlink" title="红黑树$\in$BBST"></a>红黑树$\in$BBST</h3><ul><li><p>由等价性，既然B-树是平衡的，红黑树自然也是。</p></li><li><p>定理：包含n个内部节点（n+1个外部节点）的红黑树T，高度$h=O(log_2{n})$</p><script type="math/tex; mode=display">log_2{(n+1)}\le h \le 2*log_2{(n+1)}</script></li><li><p>若：T高度为h，黑高度为H，则$h=R+H\le2H$</p></li><li>若：T所对应的B-树为$T_B$，则H即是$T_B$的高度。</li><li>$T_B$的每个节点（超级节点），包含且仅含包含T的一个黑节点。</li></ul><p>结论：</p><script type="math/tex; mode=display">H \le log_{\lceil 4/2 \rceil}{\frac{n+1}2}+1 \le log_2{(n+1)}</script><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/4016730bec94307a9bd2108ea1059b49-a9f12.png" alt="红黑树$\in$BBST"></p><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;BST/BST.h&quot;</span> <span class="hljs-comment">//基于BST实现RedBlack</span></span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedBlack</span> :</span> <span class="hljs-keyword">public</span> BST&lt;T&gt; &#123; <span class="hljs-comment">//RedBlack树模板类</span><br><span class="hljs-keyword">protected</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solveDoubleRed</span> <span class="hljs-params">( BinNodePosi&lt;T&gt; x )</span></span>; <span class="hljs-comment">//双红修正</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solveDoubleBlack</span> <span class="hljs-params">( BinNodePosi&lt;T&gt; x )</span></span>; <span class="hljs-comment">//双黑修正</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateHeight</span> <span class="hljs-params">( BinNodePosi&lt;T&gt; x )</span></span>; <span class="hljs-comment">//更新节点x的高度</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function">BinNodePosi&lt;T&gt; <span class="hljs-title">insert</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> T&amp; e )</span></span>; <span class="hljs-comment">//插入（重写）</span><br>   <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">remove</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> T&amp; e )</span></span>; <span class="hljs-comment">//删除（重写）</span><br><span class="hljs-comment">// BST::search()等其余接口可直接沿用</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h3 id="双红缺陷"><a href="#双红缺陷" class="headerlink" title="双红缺陷"></a>双红缺陷</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f863fa73beea06c7e634373355fc5e3e-f2249.png" alt="双红缺陷"></p><h4 id="u-gt-color-B"><a href="#u-gt-color-B" class="headerlink" title="u-&gt;color == B"></a>u-&gt;color == B</h4><ul><li>此时，x、p、g的四个孩子（可能都是外部节点）全为黑，且<strong>黑高度相同</strong></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/284da46cbe498c23ef89bd19222e0c7d-7098d.png" alt="u-&gt;color == B"></p><p><strong>解决办法：做局部3+4重构</strong></p><ol><li>将节点x、p、g及其四棵子树，按中序组合为：</li></ol><script type="math/tex; mode=display">T_0<a<T_1<b<T_2<c<T_3</script><ol><li>染色<ul><li>b转黑</li><li>a或c转红</li></ul></li></ol><p>效果如下：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/919c82f669783cd2931278203696161d-70c03.png" alt="效果" style="zoom:50%;" /></p><ul><li>调整前之所以非法，是因为在某个三叉节点中插入红关键码，使得原黑关键码不再居中。即<strong>RRB</strong>或<strong>BRR</strong>，出现相邻的红关键码。</li><li>调整之后的效果相当于<strong>B-树的拓扑结构不变</strong>，但在新的四叉节点中，三个关键码的颜色改为<strong>RBR</strong>。</li><li>虽然红黑树的拓扑结构有所调整，但仅限于局部。更重要的是，这种调整是一蹴而就的，无需任何进一步的调整。因此，就全树的拓扑连接关系变化量而言，必然是不超过$O(1)$。</li></ul><h4 id="u-gt-color-R"><a href="#u-gt-color-R" class="headerlink" title="u-&gt;color == R"></a>u-&gt;color == R</h4><ul><li>在B-树中，等效于超级节点发生上溢</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/3ebe25c99bb4ee0c20317672d7ec17b6-a2012.png" alt="u-&gt;color == R"></p><p>修复这种情况下的双红缺陷，可以看作是修复B-树中的上溢。</p><p><strong>解决办法：</strong></p><ul><li>p与u转黑</li><li>g转红</li></ul><p>在B-树中，等效于节点分裂，关键码g上升一层。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/4871f7c2d7a0987ac9cecd2caa12a993-d52cf.png" alt="解决办法"></p><p>在B树角度来看，这种调整过程发生了拓扑结构变化。但是从红黑树的角度来看，除了若干个节点的颜色会发生改变，全树的拓扑连接关系并没有任何变化。也就是说虽然重染色的操作可能会达到$O(log_2{n})$，但是拓扑结构的操作只会$O(1)$。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>重构操作对<strong>持久化结构</strong>而言至关重要</li><li>实际上AVL树的插入操作也能达到这要求</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/cd4d920d0ab67d6c3a08b543064217ae-0c793.png" alt="总结"></p><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> RedBlack&lt;T&gt;::<span class="hljs-built_in">solveDoubleRed</span> ( BinNodePosi&lt;T&gt; x ) &#123; <span class="hljs-comment">//x当前必为红</span><br>   <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">IsRoot</span> ( *x ) ) <span class="hljs-comment">//若已（递归）转至树根，则将其转黑，整树黑高度也随之递增</span><br>      &#123;  _root-&gt;color = RB_BLACK; _root-&gt;height++; <span class="hljs-keyword">return</span>;  &#125; <span class="hljs-comment">//否则，x的父亲p必存在</span><br>   BinNodePosi&lt;T&gt; p = x-&gt;parent; <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">IsBlack</span> ( p ) ) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//若p为黑，则可终止调整。否则</span><br>   BinNodePosi&lt;T&gt; g = p-&gt;parent; <span class="hljs-comment">//既然p为红，则x的祖父必存在，且必为黑色</span><br>   BinNodePosi&lt;T&gt; u = <span class="hljs-built_in">uncle</span> ( x ); <span class="hljs-comment">//以下，视x叔父u的颜色分别处理</span><br>   <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">IsBlack</span> ( u ) ) &#123; <span class="hljs-comment">//u为黑色（含NULL）时 //*DSA*/printf(&quot;  case RR-1:\n&quot;);</span><br>      <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">IsLChild</span> ( *x ) == <span class="hljs-built_in">IsLChild</span> ( *p ) ) <span class="hljs-comment">//若x与p同侧（即zIg-zIg或zAg-zAg），则</span><br>         p-&gt;color = RB_BLACK; <span class="hljs-comment">//p由红转黑，x保持红</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-comment">//若x与p异侧（即zIg-zAg或zAg-zIg），则</span><br>         x-&gt;color = RB_BLACK; <span class="hljs-comment">//x由红转黑，p保持红</span><br>      g-&gt;color = RB_RED; <span class="hljs-comment">//g必定由黑转红</span><br><span class="hljs-comment">///// 以上虽保证总共两次染色，但因增加了判断而得不偿失</span><br><span class="hljs-comment">///// 在旋转后将根置黑、孩子置红，虽需三次染色但效率更高</span><br>      BinNodePosi&lt;T&gt; gg = g-&gt;parent; <span class="hljs-comment">//曾祖父（great-grand parent）</span><br>      BinNodePosi&lt;T&gt; r = <span class="hljs-built_in">FromParentTo</span> ( *g ) = <span class="hljs-built_in">rotateAt</span> ( x ); <span class="hljs-comment">//调整后的子树根节点</span><br>      r-&gt;parent = gg; <span class="hljs-comment">//与原曾祖父联接</span><br>   &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//若u为红色 //*DSA*/printf(&quot;  case RR-2:\n&quot;);</span><br>      p-&gt;color = RB_BLACK; p-&gt;height++; <span class="hljs-comment">//p由红转黑</span><br>      u-&gt;color = RB_BLACK; u-&gt;height++; <span class="hljs-comment">//u由红转黑</span><br>      <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">IsRoot</span> ( *g ) ) g-&gt;color = RB_RED; <span class="hljs-comment">//g若非根，则转红</span><br>      <span class="hljs-built_in">solveDoubleRed</span> ( g ); <span class="hljs-comment">//继续调整g（类似于尾递归，可优化为迭代形式）</span><br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="插入算法"><a href="#插入算法" class="headerlink" title="插入算法"></a>插入算法</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; BinNodePosi&lt;T&gt; RedBlack&lt;T&gt;::<span class="hljs-built_in">insert</span> ( <span class="hljs-keyword">const</span> T&amp; e ) &#123; <span class="hljs-comment">//将e插入红黑树</span><br>   BinNodePosi&lt;T&gt; &amp; x = <span class="hljs-built_in">search</span> ( e ); <br>   <span class="hljs-keyword">if</span> ( x ) <span class="hljs-keyword">return</span> x; <span class="hljs-comment">//确认目标不存在（留意对_hot的设置）</span><br>   x = <span class="hljs-keyword">new</span> BinNode&lt;T&gt; ( e, _hot, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span> ); _size++; <span class="hljs-comment">//创建红节点x：以_hot为父，黑高度0</span><br>   BinNodePosi&lt;T&gt; xOld = x; <span class="hljs-built_in">solveDoubleRed</span> ( x ); <br>   <span class="hljs-keyword">return</span> xOld; <span class="hljs-comment">//经双红修正后，即可返回</span><br>&#125; <span class="hljs-comment">//无论e是否存在于原树中，返回时总有x-&gt;data == e</span><br></code></pre></div></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/83a7121daa0f26853e9641bcb7687e22-57dff.png" alt="过程" style="zoom:50%;" /></p><ul><li>首先按照BST常规算法，执行<code>r = removeAt(x,_hot)</code>，此时将删除节点<strong>x</strong>和替代节点<strong>r</strong>的颜色分情况讨论：（r可能是个外部节点）<ul><li>两者中有一个红色：将<strong>r</strong>染黑即可</li><li>两者都是黑色：发生双黑缺陷。因为违反了规则4（即外部节点到根：途中黑节点数目相等）。</li></ul></li></ul><h3 id="双黑缺陷"><a href="#双黑缺陷" class="headerlink" title="双黑缺陷"></a>双黑缺陷</h3><ul><li>摘除x并代之以r后，全树黑深度不再统一，原B-树中x所属节点下溢</li><li>修复红黑树的双黑缺陷，实际上是修复B-树的下溢</li><li>在新树中，需要考察：<ul><li>r的父亲：<code>p = r-&gt;parent</code></li><li>r的兄弟：<code>s = r == p-&gt;lc ? p&gt;rc : p-&gt;lc</code></li></ul></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/235b5225e6376bbc49b957556b256ab0-3b96d.png" alt="双黑缺陷" style="zoom:50%;" /></p><h4 id="BB-1：S为黑，且至少有一个红孩子t"><a href="#BB-1：S为黑，且至少有一个红孩子t" class="headerlink" title="BB-1：S为黑，且至少有一个红孩子t"></a>BB-1：S为黑，且至少有一个红孩子t</h4><p>这种情况下的修复过程为：</p><ol><li><p>3+4重构：t、s、p重命名为a、b、c</p></li><li><p>r保持黑色</p></li><li><p>a和c染黑</p></li><li><p>b继承p的原色</p></li></ol><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9e577a4f5517b8f84cc0dc65653c16cd-1c9ef.png" style="zoom:50%;" /></p><p>此时红黑树中的黑深度保持一致，全局性质得以恢复。（与zig-zag等类似）</p><p><strong>从B-树的角度看：</strong></p><p>通过关键码的旋转，消除超级节点的下溢。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b18e884e0ed4305d4531aee5278f89ef-071fb.png" alt="**从B-树的角度看：**" style="zoom:50%;" /></p><p>下溢节点从父亲那借得一个关键码，父亲再向下溢节点的兄弟那里借一个关键码，以填补空缺。</p><h4 id="BB-2R：s为黑，且两个孩子均为黑；p为红"><a href="#BB-2R：s为黑，且两个孩子均为黑；p为红" class="headerlink" title="BB-2R：s为黑，且两个孩子均为黑；p为红"></a>BB-2R：s为黑，且两个孩子均为黑；p为红</h4><p>这种情况下的处理办法：（此时的s已处于下溢边缘，无法借出关键码）</p><ol><li><p>r保持黑</p></li><li><p>s转红</p></li><li><p>p转黑</p></li></ol><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/4c43abc0a3453b725e7d5c7577e91907-d8e34.png" alt="BB-2R：s为黑，且两个孩子均为黑；p为红" style="zoom:50%;" /></p><p>在对应的B-树中，等效于下溢节点与兄弟<strong>合并</strong>。合并之前，在p之左或右侧还应有（问号）关键码必为黑色，有且仅有一个。所以失去关键码p后，上层节点并不会发生下溢。</p><h4 id="BB-2B：s为黑，且两个孩子均为黑；p为黑"><a href="#BB-2B：s为黑，且两个孩子均为黑；p为黑" class="headerlink" title="BB-2B：s为黑，且两个孩子均为黑；p为黑"></a>BB-2B：s为黑，且两个孩子均为黑；p为黑</h4><p>这种情况下的处理方法：</p><ol><li><p>s转红</p></li><li><p>r与p保持黑</p></li></ol><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/0bc798b4902f829f7628e9dc777c0ae9-52c2d.png" alt="BB-2B：s为黑，且两个孩子均为黑；p为黑" style="zoom:50%;" /></p><p>从B树的角度来看，如果下层下溢引发上层下溢，且在极端情况下会传播到树根。这时候的重构可能多达$O(log_2{n})$次。但是从红黑树的角度来说，拓扑结构实际上没有任何的改变，所以还是$O(1)$。</p><h4 id="BB-3：s为红（其孩子均为黑）"><a href="#BB-3：s为红（其孩子均为黑）" class="headerlink" title="BB-3：s为红（其孩子均为黑）"></a>BB-3：s为红（其孩子均为黑）</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/425b860e067a2c0f628f9dafc5623062-1ad98.png" alt="BB-3：s为红（其孩子均为黑）" style="zoom:50%;" /></p><p>这种情况下的处理方法：</p><ol><li>zag(p)或zig(p)</li><li>红s转黑</li><li>黑p转红</li></ol><p>虽然此时黑高度依然异常，但r有了一个新的黑兄弟s`。所以可以转化为之前的三种情况，而且：</p><ul><li>p已经转红，接下类绝不会是情况BB-2B，而只能是BB-1或BB-2R</li></ul><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li>每一次删除操作，在每一高度至多只会花费常数时间，即删除操作可以在$O(log_2{n})$​​时间内完成</li><li>其中，至多做：<ol><li>$O(log_2{n})$次重染色</li><li>一次”3+4“重构</li><li>一次单旋</li></ol></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/e6e495226206433e48c6e6c35126f4e6-c5a66.png" alt="总结" style="zoom:50%;" /></p><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> RedBlack&lt;T&gt;::<span class="hljs-built_in">solveDoubleBlack</span> ( BinNodePosi&lt;T&gt; r ) &#123;<br>   BinNodePosi&lt;T&gt; p = r ? r-&gt;parent : _hot; <span class="hljs-keyword">if</span> ( !p ) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//r的父亲</span><br>   BinNodePosi&lt;T&gt; s = ( r == p-&gt;lc ) ? p-&gt;rc : p-&gt;lc; <span class="hljs-comment">//r的兄弟</span><br>   <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">IsBlack</span> ( s ) ) &#123; <span class="hljs-comment">//兄弟s为黑</span><br>      BinNodePosi&lt;T&gt; t = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//s的红孩子（若左、右孩子皆红，左者优先；皆黑时为NULL）</span><br>      <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">IsRed</span> ( s-&gt;rc ) ) t = s-&gt;rc; <span class="hljs-comment">//右子</span><br>      <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">IsRed</span> ( s-&gt;lc ) ) t = s-&gt;lc; <span class="hljs-comment">//左子</span><br>      <span class="hljs-keyword">if</span> ( t ) &#123; <span class="hljs-comment">//黑s有红孩子：BB-1</span><br>         <span class="hljs-comment">//*DSA*/printf(&quot;  case BB-1: Child (&quot;); print(s-&gt;lc); printf(&quot;) of BLACK sibling (&quot;); print(s); printf(&quot;) is RED\n&quot;);</span><br>         RBColor oldColor = p-&gt;color; <span class="hljs-comment">//备份原子树根节点p颜色，并对t及其父亲、祖父</span><br>      <span class="hljs-comment">// 以下，通过旋转重平衡，并将新子树的左、右孩子染黑</span><br>         BinNodePosi&lt;T&gt; b = <span class="hljs-built_in">FromParentTo</span> ( *p ) = <span class="hljs-built_in">rotateAt</span> ( t ); <span class="hljs-comment">//旋转</span><br>         <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">HasLChild</span> ( *b ) ) &#123; b-&gt;lc-&gt;color = RB_BLACK; <span class="hljs-built_in">updateHeight</span> ( b-&gt;lc ); &#125; <span class="hljs-comment">//左子</span><br>         <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">HasRChild</span> ( *b ) ) &#123; b-&gt;rc-&gt;color = RB_BLACK; <span class="hljs-built_in">updateHeight</span> ( b-&gt;rc ); &#125; <span class="hljs-comment">//右子</span><br>         b-&gt;color = oldColor; <span class="hljs-built_in">updateHeight</span> ( b ); <span class="hljs-comment">//新子树根节点继承原根节点的颜色</span><br>         <span class="hljs-comment">//*DSA*/printBinTree(b, 0, 0);</span><br>      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//黑s无红孩子</span><br>         s-&gt;color = RB_RED; s-&gt;height--; <span class="hljs-comment">//s转红</span><br>         <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">IsRed</span> ( p ) ) &#123; <span class="hljs-comment">//BB-2R</span><br>            <span class="hljs-comment">//*DSA*/printf(&quot;  case BB-2R: Both children (&quot;); print(s-&gt;lc); printf(&quot;) and (&quot;); print(s-&gt;rc); printf(&quot;) of BLACK sibling (&quot;); print(s); printf(&quot;) are BLACK, and parent (&quot;); print(p); printf(&quot;) is RED\n&quot;); //s孩子均黑，p红</span><br>            p-&gt;color = RB_BLACK; <span class="hljs-comment">//p转黑，但黑高度不变</span><br>            <span class="hljs-comment">//*DSA*/printBinTree(p, 0, 0);</span><br>         &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//BB-2B</span><br>            <span class="hljs-comment">//*DSA*/printf(&quot;  case BB-2R: Both children (&quot;); print(s-&gt;lc); printf(&quot;) and (&quot;); print(s-&gt;rc); printf(&quot;) of BLACK sibling (&quot;); print(s); printf(&quot;) are BLACK, and parent (&quot;); print(p); printf(&quot;) is BLACK\n&quot;); //s孩子均黑，p黑</span><br>            p-&gt;height--; <span class="hljs-comment">//p保持黑，但黑高度下降</span><br>            <span class="hljs-comment">//*DSA*/printBinTree(p, 0, 0);</span><br>            <span class="hljs-built_in">solveDoubleBlack</span> ( p ); <span class="hljs-comment">//递归上溯</span><br>         &#125;<br>      &#125;<br>   &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//兄弟s为红：BB-3</span><br>      <span class="hljs-comment">//*DSA*/printf(&quot;  case BB-3: sibling (&quot;); print(s); printf(&quot; is RED\n&quot;); //s红（双子俱黑）</span><br>      s-&gt;color = RB_BLACK; p-&gt;color = RB_RED; <span class="hljs-comment">//s转黑，p转红</span><br>      BinNodePosi&lt;T&gt; t = <span class="hljs-built_in">IsLChild</span> ( *s ) ? s-&gt;lc : s-&gt;rc; <span class="hljs-comment">//取t与其父s同侧</span><br>      _hot = p; <span class="hljs-built_in">FromParentTo</span> ( *p ) = <span class="hljs-built_in">rotateAt</span> ( t ); <span class="hljs-comment">//对t及其父亲、祖父做平衡调整</span><br>      <span class="hljs-comment">//*DSA*/printBinTree&lt;T&gt;(s, 0, 0);</span><br>      <span class="hljs-built_in">solveDoubleBlack</span> ( r ); <span class="hljs-comment">//继续修正r处双黑——此时的p已转红，故后续只能是BB-1或BB-2R</span><br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="删除算法"><a href="#删除算法" class="headerlink" title="删除算法"></a>删除算法</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">bool</span> RedBlack&lt;T&gt;::<span class="hljs-built_in">remove</span> ( <span class="hljs-keyword">const</span> T&amp; e ) &#123; <span class="hljs-comment">//从红黑树中删除关键码e</span><br>   BinNodePosi&lt;T&gt; &amp; x = <span class="hljs-built_in">search</span> ( e ); <span class="hljs-keyword">if</span> ( !x ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//确认目标存在（留意_hot的设置）</span><br>   BinNodePosi&lt;T&gt; r = <span class="hljs-built_in">removeAt</span> ( x, _hot ); <span class="hljs-keyword">if</span> ( ! ( --_size ) ) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//实施删除</span><br><span class="hljs-comment">// assert: _hot某一孩子刚被删除，且被r所指节点（可能是NULL）接替。以下检查是否失衡，并做必要调整</span><br>   <span class="hljs-keyword">if</span> ( ! _hot ) <span class="hljs-comment">//若刚被删除的是根节点，则将其置黑，并更新黑高度</span><br>      &#123; _root-&gt;color = RB_BLACK; <span class="hljs-built_in">updateHeight</span> ( _root ); <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br><span class="hljs-comment">// assert: 以下，原x（现r）必非根，_hot必非空</span><br>   <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">BlackHeightUpdated</span> ( *_hot ) ) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//若所有祖先的黑深度依然平衡，则无需调整</span><br>   <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">IsRed</span> ( r ) ) <span class="hljs-comment">//否则，若r为红，则只需令其转黑</span><br>      &#123; r-&gt;color = RB_BLACK; r-&gt;height++; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br><span class="hljs-comment">// assert: 以下，原x（现r）均为黑色</span><br>   <span class="hljs-comment">//*DSA*/printBinTree(_hot, 0, 0);</span><br>   <span class="hljs-built_in">solveDoubleBlack</span> ( r ); <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//经双黑调整后返回</span><br>&#125; <span class="hljs-comment">//若目标节点存在且被删除，返回true；否则返回false</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>红黑树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows环境下的git配置</title>
    <link href="/2020/04/16/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84git%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/04/16/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84git%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-软件的安装"><a href="#1-软件的安装" class="headerlink" title="1.软件的安装"></a>1.软件的安装</h2><h3 id="1-1-软件下载"><a href="#1-1-软件下载" class="headerlink" title="1.1 软件下载"></a>1.1 软件下载</h3><p>下载地址：<a href="http://www.git-scm.com/download/">http://www.git-scm.com/download/</a></p><h3 id="1-2-软件安装"><a href="#1-2-软件安装" class="headerlink" title="1.2 软件安装"></a>1.2 软件安装</h3><p>配置详情：<a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html">https://www.cnblogs.com/xueweisuoyong/p/11914045.html</a></p><h2 id="2-SSH的配置"><a href="#2-SSH的配置" class="headerlink" title="2.SSH的配置"></a>2.SSH的配置</h2><h3 id="1-1-设置公钥私钥（若已有请跳过）"><a href="#1-1-设置公钥私钥（若已有请跳过）" class="headerlink" title="1.1 设置公钥私钥（若已有请跳过）"></a>1.1 设置公钥私钥（若已有请跳过）</h3><p>打开CMD，输入<strong>ssh-keygen -t rsa -C “你的邮箱地址”</strong>，按照提示输入并完成。</p><h3 id="1-2-设置Git"><a href="#1-2-设置Git" class="headerlink" title="1.2 设置Git"></a>1.2 设置Git</h3><p>打开Git CMD，输入<strong>git config —global user.name “用户名”</strong>，<strong>git config —global user.email “你的邮箱地址”</strong>。</p><h3 id="1-3-设置github"><a href="#1-3-设置github" class="headerlink" title="1.3 设置github"></a>1.3 设置github</h3><p>打开github个人主页，在右上角的头像里选择<strong>Settings</strong>，然后依次<strong>SSH and GPG keys</strong>-&gt;<strong>New SSH key</strong>。其中Title中写一个适当的标题，再将本地电脑<strong>C:\Users.ssh\id_rsa.pub</strong>中的内容复制到Key里面即可。</p>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2020/04/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/04/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><div class="row">    <embed src="https://blog.zhongshiyu.xyz/pdf/mindmaster/OperatingSystem.pdf" width="100%" height="550" type="application/pdf"></div><hr><a class="btn" href="https://blog.zhongshiyu.xyz/pdf/mindmaster/OperatingSystem.pdf"  title="在新窗口打开" target="_blank">进入全屏</a><h2 id="随记"><a href="#随记" class="headerlink" title="随记"></a>随记</h2><h3 id="系统调用与函数调用"><a href="#系统调用与函数调用" class="headerlink" title="系统调用与函数调用"></a>系统调用与函数调用</h3><ul><li>系统调用：应用程序和内核拥有各自的堆栈，并且需要进行用户态到内核态的转换</li><li>函数调用：在同一个栈空间里面执行</li></ul><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><ul><li>同步就是整个处理过程顺序执行，当各个过程都执行完毕，并返回结果。是 一种<strong>线性执行</strong>的方式，执行的流程不能跨越。一般用于<strong>流程性比较强</strong>的程序，比如用户登录，需要对用户验证完成后才能登录系统。</li><li>异步则是只是发送了调用的指令，调用者<strong>无需等待</strong>被调用的方法完全执行完毕；而是继续执行下面的流程。是一种并行处理的方式，不必等待一个程序执行完，可以执行其它的任务，比如页面数据加载过程，不需要等所有数据获取后再显示页面。</li></ul><h3 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h3><ul><li>中断（异步）：来源于外设，来自不同的硬件设备的计时器和网络的中断</li><li>异常（同步）：来源于不良的应用程序，非法指令或者其他坏的处理状态。比如内存出错</li></ul><p>中断和异常都有软件和硬件的处理：</p><ul><li><p>软件：因为中断打断程序的执行，所以中断处理过程中需要有保护程序</p><ul><li>保存当前处理状态</li><li>中断服务程序处理</li><li>清楚中断标记</li><li>恢复之前保存的处理状态</li></ul></li><li><p>硬件：不同外设的中断都可以到<strong>中断表</strong>中去查询对应的<strong>中断例程</strong>的起始地址</p><ul><li><p>设置中断标记（CPU初始化）</p><ul><li><p>将内部、外部事件设置中断标记</p></li><li><p>中断事件的ID</p></li></ul></li></ul></li></ul><h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><ul><li><p>物理地址空间：硬件支持的内存空间</p><ul><li>如果程序直接操作物理地址空间，那么程序所使用的内存相互之间没有隔离，无论是恶意的程序还是非恶意的臭虫都会都会修改其他程序的内存数据。</li><li>程序编写时，访问数据和指令跳转的指令都是确定的。如果直接使用物理地址空间，那么每次程序重新装载到内存中，也需要实时的更改程序中对应的数据和指令地址。</li></ul></li><li><p>逻辑地址空间：一个运行的程序<strong>所拥有</strong>的内存范围。它是人们想象出来的地址空间，其实它并不存在。</p><ul><li><p>每个进程都有自己独立的逻辑地址空间，而且每个进程只能访问自己的地址空间，这样就有效地做到了进程的隔离。</p></li><li><p>为了保证地址安全，操作系统使用<strong>基址寄存器</strong>和<strong>界限寄存器</strong>设定逻辑地址空间</p></li></ul></li></ul><h3 id="分段与分页"><a href="#分段与分页" class="headerlink" title="分段与分页"></a>分段与分页</h3><ul><li>分段：基本思路是把一段与程序所需要的内存空间大小的逻辑地址空间映射到某个物理地址空间<ul><li>分段做到了地址隔离</li><li>分段对于内存使用效率的问题没有解决，原因在于分段对内存区域的映射还是按照程序为单位，如果内存不足，被换入换出到磁盘的都是整个程序。这种方法显得粗糙，粒度大。</li></ul></li><li>分页：基本方法是把地址空间人为地等分为固定大小的页，每一页大小由硬件决定，或硬件支持多种大小的页。<ul><li>根据程序的局部性原理，在分段的基础上对内存映射划分了更小的粒度和映射，提高内存使用率</li><li>把进程的逻辑地址空间按页分割，把常用的数据和代码页装载到内存中，把不常用的代码和数据保存在磁盘里，当需要用到的时候再把它从磁盘取出来即可。所以对于某个进程的某个时刻，它经常或正在被使用的数据所在的那一页在内存或缓存中；不经常被使用的数据的页可能会在磁盘内。</li></ul></li></ul><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><ul><li>当线程数量小于等于处理器数量时，线程的并发是真正的并发，即并行。但对于线程数量大于处理器数量的情况，线程的并发会受到一些阻碍，因此此时至少有一个处理器会运行多个线程。在单处理器对应多线程的情况下，并发是一种模拟出来的状态。</li></ul><h2 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程/线程"></a>进程/线程</h2><p>在LINUX上，所有的执行实体（进程或线程）都被称为任务。</p><h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><ul><li><p>操作系统分配资源是以进程为单位，线程只能用所属进程的资源，即线程依赖于进程。</p></li><li><p>线程拥有自己的寄存器和栈空间</p></li></ul><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><ul><li>运行：此时正在执行</li><li>就绪：此时可以立刻运行，但是CPU已经被占用</li><li>等待：此时正在等待某一事件</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>IO密集型：频繁等待的线程</li><li>CPU密集型：很少等待的线程（把时间片用完）的线程</li></ul><p>IO密集型线程总是比CPU密集型线程容易得到优先级的提升</p><p><strong>CPU密集型代码(各种循环处理、计算等等)：使用多进程。IO密集型代码(文件处理、网络爬虫等)：使用多线程</strong></p><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>优先级改变有以下几种方式：</p><ul><li>用户指定优先级</li><li>根据进入等待状态的频繁程度提升或降低优先级</li><li>长时间得不到执行而被提升优先级</li></ul><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>计算机处理数据，需要先将数据从内存中取出，再放到寄存器处理，处理完后再写入内存。</p><p>整个过程会被汇编为多条指令，而在汇编中只有单指令是原子操作。所以当多个线程处理同个临界区时，某个线程可能会在执行某条指令后被调度系统打断，然后计算机开始执行其他线程，而其他线程可能会在执行指令的过程中覆盖掉前一个线程的数据。</p><p>线程同步手段：</p><ul><li>信号量：在整个系统中可以被任意线程获取并释放<ul><li>二元信号量<ul><li>它适合只能被唯一一个线程独占访问的资源</li></ul></li><li>多元信号量<ul><li>一个初始值为N的信号量允许N个线程并发访问</li></ul></li></ul></li><li>互斥量：哪个线程获取了互斥量，哪个线程就要负责释放这个锁</li><li>临界区：作用范围只限于本进程</li><li>读写锁：当读操作比写操作频繁时<ul><li>读写锁又分为共享式和独占式</li></ul></li><li>条件变量：使用条件变量可以让许多线程一起等待某个事件的发生。当事件发生时，所有的线程可以一起恢复执行</li></ul><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p>协程又被称为用户态线程，它是由线程创建的执行体，使用的是用户态的资源，所以操作系统对协程一无所知。</p><p>在创建协程时，需要指定执行入口，底层都会分配执行栈和控制信息；让出执行权时，需要保存执行现场。</p><p>协程思想在于：控制流的<strong>主动让出</strong>和<strong>恢复</strong>。</p><p>协程在IO多路复用中的应用十分广泛。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《操作系统》</li><li><a href="https://space.bilibili.com/114366178/channel/detail?cid=172712&amp;ctype=0">bilibili-从0开始数-操作系统原理</a></li><li><a href="https://github.com/cosen1024/Java-Interview/blob/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md">cosen1024/Java-Interview/操作系统</a></li><li>《程序员的自我修养：链接、装载与库》</li><li><a href="https://www.bilibili.com/video/BV1b5411b7SD?from=search&amp;seid=5551959423038178486&amp;spm_id_from=333.337.0.0">【协程第一话】协程到底是怎样的存在？</a></li><li><a href="https://www.zhihu.com/question/306127044/answer/555327651">进入内核态究竟是什么意思？ - 灵剑的回答 - 知乎 </a></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>B树</title>
    <link href="/2020/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9AB-Tree/"/>
    <url>/2020/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9AB-Tree/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="多路平衡"><a href="#多路平衡" class="headerlink" title="多路平衡"></a>多路平衡</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/340dd4eacd8e6a2f6c230c3a1a9c02c4-de10a.png" alt="多路平衡"></p><h3 id="与AVL树"><a href="#与AVL树" class="headerlink" title="与AVL树"></a>与AVL树</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/ed374cd8facd216134f7baf028ac9605-9971d.png" alt="与AVL树"></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>所谓m阶B-树，即m路平衡搜索树$(m\ge2)$</li><li>所有叶节点的深度统一相等</li><li>外部节点的深度统一相等<ul><li>外节点：叶节点那些数值为空，并不存在的孩子。所以叶节点的深度统一，也就代表外节点的深度统一</li><li>外部节点有时候指向更低层次的B树。借助这个能力，可以将存放于不同存储级别上的B树串接起来，构成更大的B树</li><li>一棵B-树有N个内部节点，那么它有N+1个外部节点</li></ul></li><li>树高h = <strong>外部节点</strong>的深度</li><li>树的超级节点是用向量来存储</li><li>为了与I/O操作的延迟相匹配，每一个节点的大小应该尽可能的设计为与一次IO对换的页面大小相匹配</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a772b722df1b715b198085dc2fbc0566-dc641.png" alt="定义"></p><h4 id="阶次"><a href="#阶次" class="headerlink" title="阶次"></a>阶次</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/87c5f3d6d2b3ee78e0c651564dff1450-953cf.png" alt="阶次"></p><ul><li>阶次m给出了超级节点的上限和下限</li><li>内部节点各有：<ul><li>不超过$m-1$个关键码：$K_1&lt;k_2&lt;…&lt;k_n$</li><li>不超过$m$个分支：$A_0,A_1,A_2,…,A_n$</li></ul></li><li>内部节点的分支数$n+1$也不能太少，具体地：<ul><li>树根：$2\le n+1$</li><li>其余：$\lceil m/2 \rceil\le n+1$</li></ul></li><li>所以B树又被称为$(\lceil m/2 \rceil,m)$-树<ul><li>比如$m=5$时，被称为$(3,5)$-树</li></ul></li></ul><h3 id="BTNode"><a href="#BTNode" class="headerlink" title="BTNode"></a>BTNode</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BTNode</span>;</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">using</span> BTNodePosi = BTNode&lt;T&gt;*; <span class="hljs-comment">//B-树节点位置</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BTNode</span> &#123;</span> <span class="hljs-comment">//B-树节点模板类</span><br>   BTNodePosi&lt;T&gt; parent; <span class="hljs-comment">//父节点</span><br>   Vector&lt;T&gt; key; <span class="hljs-comment">//关键码向量</span><br>   Vector&lt;BTNodePosi&lt;T&gt;&gt; child; <span class="hljs-comment">//孩子向量（其长度总比key多一）</span><br><span class="hljs-comment">// 构造函数（注意：BTNode只能作为根节点创建，而且初始时有0个关键码和1个空孩子指针）</span><br>   <span class="hljs-built_in">BTNode</span>() &#123; parent = <span class="hljs-literal">NULL</span>; child.<span class="hljs-built_in">insert</span> ( <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span> ); &#125;<br>   <span class="hljs-built_in">BTNode</span> ( T e, BTNodePosi&lt;T&gt; lc = <span class="hljs-literal">NULL</span>, BTNodePosi&lt;T&gt; rc = <span class="hljs-literal">NULL</span> ) &#123;<br>      parent = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//作为根节点，而且初始时</span><br>      key.<span class="hljs-built_in">insert</span> ( <span class="hljs-number">0</span>, e ); <span class="hljs-comment">//只有一个关键码，以及</span><br>      child.<span class="hljs-built_in">insert</span> ( <span class="hljs-number">0</span>, lc ); child.<span class="hljs-built_in">insert</span> ( <span class="hljs-number">1</span>, rc ); <span class="hljs-comment">//两个孩子</span><br>      <span class="hljs-keyword">if</span> ( lc ) lc-&gt;parent = <span class="hljs-keyword">this</span>; <span class="hljs-keyword">if</span> ( rc ) rc-&gt;parent = <span class="hljs-keyword">this</span>;<br>   &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="BTree"><a href="#BTree" class="headerlink" title="BTree"></a>BTree</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BTree</span> &#123;</span> <span class="hljs-comment">//B-树模板类</span><br><span class="hljs-keyword">protected</span>:<br>   <span class="hljs-keyword">int</span> _size; <span class="hljs-comment">//存放的关键码总数</span><br>   <span class="hljs-keyword">int</span> _order; <span class="hljs-comment">//B-树的阶次，至少为3——创建时指定，一般不能修改</span><br>   BTNodePosi&lt;T&gt; _root; <span class="hljs-comment">//根节点</span><br>   BTNodePosi&lt;T&gt; _hot; <span class="hljs-comment">//BTree::search()最后访问的非空（除非树空）的节点位置</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solveOverflow</span> <span class="hljs-params">( BTNodePosi&lt;T&gt; )</span></span>; <span class="hljs-comment">//因插入而上溢之后的分裂处理</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solveUnderflow</span> <span class="hljs-params">( BTNodePosi&lt;T&gt; )</span></span>; <span class="hljs-comment">//因删除而下溢之后的合并处理</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">BTree</span> ( <span class="hljs-keyword">int</span> order = <span class="hljs-number">3</span> ) : _order ( order ), _size ( <span class="hljs-number">0</span> ) <span class="hljs-comment">//构造函数：默认为最低的3阶</span><br>   &#123; _root = <span class="hljs-keyword">new</span> BTNode&lt;T&gt;(); &#125;<br>   ~<span class="hljs-built_in">BTree</span>() &#123; <span class="hljs-keyword">if</span> ( _root ) <span class="hljs-built_in">release</span> ( _root ); &#125; <span class="hljs-comment">//析构函数：释放所有节点</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span> <span class="hljs-title">order</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _order; &#125; <span class="hljs-comment">//阶次</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _size; &#125; <span class="hljs-comment">//规模</span><br>   <span class="hljs-function">BTNodePosi&lt;T&gt; &amp; <span class="hljs-title">root</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _root; &#125; <span class="hljs-comment">//树根</span><br>   <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> !_root; &#125; <span class="hljs-comment">//判空</span><br>   <span class="hljs-function">BTNodePosi&lt;T&gt; <span class="hljs-title">search</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> T&amp; e )</span></span>; <span class="hljs-comment">//查找</span><br>   <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">insert</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> T&amp; e )</span></span>; <span class="hljs-comment">//插入</span><br>   <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">remove</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> T&amp; e )</span></span>; <span class="hljs-comment">//删除</span><br>&#125;; <span class="hljs-comment">//BTree</span><br></code></pre></div></td></tr></table></figure><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h4><ul><li>B树的查找，只需载入必需的节点，尽可能地减少I/O操作。</li><li>所谓B树的查找，无非是由一系列在内存中的顺序查找，以及一系列的I/O操作相间隔组成的一个操作序列。</li><li>对于B树的失败查找，必然都失败于最底层叶节点所下属的某个外部节点处。即失败查找必终止于外部节点。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6a0bc1ef29f1e11e4039c4fb0522144d-908b0.png" alt="查找"></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; BTNodePosi&lt;T&gt; BTree&lt;T&gt;::<span class="hljs-built_in">search</span> ( <span class="hljs-keyword">const</span> T&amp; e ) &#123; <span class="hljs-comment">//在B-树中查找关键码e</span><br>   BTNodePosi&lt;T&gt; v = _root; _hot = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//从根节点出发</span><br>   <span class="hljs-keyword">while</span> ( v ) &#123; <span class="hljs-comment">//逐层查找</span><br>      Rank r = v-&gt;key.<span class="hljs-built_in">search</span> ( e ); <span class="hljs-comment">//在当前节点中，找到不大于e的最大关键码</span><br>      <span class="hljs-keyword">if</span> ( ( <span class="hljs-number">0</span> &lt;= r ) &amp;&amp; ( e == v-&gt;key[r] ) ) <span class="hljs-keyword">return</span> v; <span class="hljs-comment">//成功：在当前节点中命中目标关键码</span><br>      _hot = v; v = v-&gt;child[r + <span class="hljs-number">1</span>]; <span class="hljs-comment">//否则，转入对应子树（_hot指向其父）——需做I/O，最费时间</span><br>   &#125; <span class="hljs-comment">//这里在向量内是二分查找，但对通常的_order可直接顺序查找</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//失败：最终抵达外部节点</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="复杂度（待证明）"><a href="#复杂度（待证明）" class="headerlink" title="复杂度（待证明）"></a>复杂度（待证明）</h4><ul><li>由于实际上的m一般取几百，即跟I/O交换的页面相匹配。在这种数量的情况下，向量的二分查找还不如顺序查找</li><li>渐进意义上的复杂度为$O(log_2{n})$</li><li>B树的意义不在于降低搜索的渐进时间复杂度，而是更加关注于常系数意义下的优化。</li><li>当关键码的总数固定时，B树高度的上下浮动范围是非常有限的。</li></ul><h5 id="最大树高"><a href="#最大树高" class="headerlink" title="最大树高"></a>最大树高</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/35a9ea72051f72e69a8b3e8fdaf62338-5c30e.png" alt="最大树高"></p><h5 id="最小树高"><a href="#最小树高" class="headerlink" title="最小树高"></a>最小树高</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/fa761a94cc606bb4b47ded0c58a5999b-721d0.png" alt="最小树高"></p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h4 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">bool</span> BTree&lt;T&gt;::<span class="hljs-built_in">insert</span> ( <span class="hljs-keyword">const</span> T&amp; e ) &#123; <span class="hljs-comment">//将关键码e插入B树中</span><br>   BTNodePosi&lt;T&gt; v = <span class="hljs-built_in">search</span> ( e ); <br>   <span class="hljs-keyword">if</span> ( v ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//确认目标节点不存在（树中查找）</span><br>   Rank r = _hot-&gt;key.<span class="hljs-built_in">search</span> ( e ); <span class="hljs-comment">//在节点_hot的有序关键码向量中查找合适的插入位置（向量查找）</span><br>   _hot-&gt;key.<span class="hljs-built_in">insert</span> ( r + <span class="hljs-number">1</span>, e ); <span class="hljs-comment">//将新关键码插至对应的位置</span><br>   _hot-&gt;child.<span class="hljs-built_in">insert</span> ( r + <span class="hljs-number">2</span>, <span class="hljs-literal">NULL</span> ); <span class="hljs-comment">//创建一个空子树指针或者直接在向量最末端插入也可 以</span><br>   _size++; <span class="hljs-comment">//更新全树规模</span><br>   <span class="hljs-built_in">solveOverflow</span> ( _hot ); <span class="hljs-comment">//如有必要，需做分裂</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//插入成功</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="上溢"><a href="#上溢" class="headerlink" title="上溢"></a>上溢</h4><ul><li><p>注意父节点同样可能发生上溢，并逐层向上传播；纵然最坏情况，亦不过到根</p></li><li><p>当父节点本已饱和，则在接纳被提升的关键码之后，也将上溢。此时，接着套用前法，继续分裂。</p></li><li><p>在一层中的分裂操作只需一次，每一次分裂本身，只不过是一个常数的操作。若分裂向上传播，也不过树高h。<strong>所以整体而言，整个插入算法所需要的时间应该线性正比于B树的高度</strong>，即</p><script type="math/tex; mode=display">O(1) *h=o(h)</script></li><li><p>对于B树的增长情况只有一种可能，就是当上溢到达树根时，插入的节点作为单独的树根而存在。但是这种最坏情况的发生概率非常的小。<strong>即B树高度的增加一定伴随着分裂到根</strong>。</p></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/0bac8188643a6e0c9e826f2cf5ff94c4-c1fb4.png" alt="分裂"></p><h5 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//关键码插入后若节点上溢，则做节点分裂处理</span><br><span class="hljs-keyword">void</span> BTree&lt;T&gt;::<span class="hljs-built_in">solveOverflow</span> ( BTNodePosi&lt;T&gt; v ) &#123;<br>   <span class="hljs-keyword">if</span> ( _order &gt;= v-&gt;child.<span class="hljs-built_in">size</span>() ) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//递归基：当前节点并未上溢</span><br>   Rank s = _order / <span class="hljs-number">2</span>; <span class="hljs-comment">//轴点（此时应有_order = key.size() = child.size() - 1）</span><br>   BTNodePosi&lt;T&gt; u = <span class="hljs-keyword">new</span> BTNode&lt;T&gt;(); <span class="hljs-comment">//注意：新节点已有一个空孩子</span><br>   <span class="hljs-keyword">for</span> ( Rank j = <span class="hljs-number">0</span>; j &lt; _order - s - <span class="hljs-number">1</span>; j++ ) &#123; <span class="hljs-comment">//v右侧_order-s-1个孩子及关键码分裂为右侧节点u</span><br>      u-&gt;child.<span class="hljs-built_in">insert</span> ( j, v-&gt;child.<span class="hljs-built_in">remove</span> ( s + <span class="hljs-number">1</span> ) ); <span class="hljs-comment">//逐个移动效率低</span><br>      u-&gt;key.<span class="hljs-built_in">insert</span> ( j, v-&gt;key.<span class="hljs-built_in">remove</span> ( s + <span class="hljs-number">1</span> ) ); <span class="hljs-comment">//此策略可改进</span><br>   &#125;<br>   u-&gt;child[_order - s - <span class="hljs-number">1</span>] = v-&gt;child.<span class="hljs-built_in">remove</span> ( s + <span class="hljs-number">1</span> ); <span class="hljs-comment">//移动v最靠右的孩子</span><br>   <span class="hljs-keyword">if</span> ( u-&gt;child[<span class="hljs-number">0</span>] ) <span class="hljs-comment">//若u的孩子们非空，则</span><br>      <span class="hljs-keyword">for</span> ( Rank j = <span class="hljs-number">0</span>; j &lt; _order - s; j++ ) <span class="hljs-comment">//令它们的父节点统一</span><br>         u-&gt;child[j]-&gt;parent = u; <span class="hljs-comment">//指向u</span><br>   BTNodePosi&lt;T&gt; p = v-&gt;parent; <span class="hljs-comment">//v当前的父节点p</span><br>   <span class="hljs-keyword">if</span> ( !p ) &#123; _root = p = <span class="hljs-keyword">new</span> BTNode&lt;T&gt;(); p-&gt;child[<span class="hljs-number">0</span>] = v; v-&gt;parent = p; &#125; <span class="hljs-comment">//若p空则创建之</span><br>   Rank r = <span class="hljs-number">1</span> + p-&gt;key.<span class="hljs-built_in">search</span> ( v-&gt;key[<span class="hljs-number">0</span>] ); <span class="hljs-comment">//p中指向v的指针的秩</span><br>   p-&gt;key.<span class="hljs-built_in">insert</span> ( r, v-&gt;key.<span class="hljs-built_in">remove</span> ( s ) ); <span class="hljs-comment">//轴点关键码上升</span><br>   p-&gt;child.<span class="hljs-built_in">insert</span> ( r + <span class="hljs-number">1</span>, u );  u-&gt;parent = p; <span class="hljs-comment">//新节点u与父节点p互联</span><br>   <span class="hljs-built_in">solveOverflow</span> ( p ); <span class="hljs-comment">//上升一层，如有必要则继续分裂——至多递归O(logn)层</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="算法框架-1"><a href="#算法框架-1" class="headerlink" title="算法框架"></a>算法框架</h4><p>删除关键码e：</p><ul><li>若删除的关键码e所处的超级节点v不是叶节点，那么需要找e的直接后继：进入v的右子树中，然后沿着最左侧的分支向下，找到最后一个超级节点u中的最后一个关键码，这个关键码就是e的直接后继。将这两个关键码互换，就是<code>v-&gt;key[r] = u-&gt;key[0]</code>，然后<code>v=u</code>，<code>r=0</code>。这样操作之后，就等效于待删除的关键码e来自于名为v的某一个叶节点中，且v中秩为r的关键码就是待删除者。</li><li>在损失了一个关键码后，当前的节点v，有可能会突破B树关于分支数所设定的下限。这种情况被称为下溢。</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">bool</span> BTree&lt;T&gt;::<span class="hljs-built_in">remove</span> ( <span class="hljs-keyword">const</span> T&amp; e ) &#123; <span class="hljs-comment">//从BTree树中删除关键码e</span><br>   BTNodePosi&lt;T&gt; v = <span class="hljs-built_in">search</span> ( e ); <span class="hljs-keyword">if</span> ( !v ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//确认目标关键码存在</span><br>   Rank r = v-&gt;key.<span class="hljs-built_in">search</span> ( e ); <span class="hljs-comment">//确定目标关键码在节点v中的秩（由上，肯定合法）</span><br>   <span class="hljs-keyword">if</span> ( v-&gt;child[<span class="hljs-number">0</span>] ) &#123; <span class="hljs-comment">//若v非叶子，则e的后继必属于某叶节点</span><br>      BTNodePosi&lt;T&gt; u = v-&gt;child[r+<span class="hljs-number">1</span>]; <span class="hljs-comment">//在右子树中一直向左，即可</span><br>      <span class="hljs-keyword">while</span> ( u-&gt;child[<span class="hljs-number">0</span>] ) u = u-&gt;child[<span class="hljs-number">0</span>]; <span class="hljs-comment">//找出e的后继</span><br>      v-&gt;key[r] = u-&gt;key[<span class="hljs-number">0</span>]; v = u; r = <span class="hljs-number">0</span>; <span class="hljs-comment">//并与之交换位置</span><br>   &#125; <span class="hljs-comment">//至此，v必然位于最底层，且其中第r个关键码就是待删除者</span><br>   v-&gt;key.<span class="hljs-built_in">remove</span> ( r ); v-&gt;child.<span class="hljs-built_in">remove</span> ( r + <span class="hljs-number">1</span> ); _size--; <span class="hljs-comment">//删除e，以及其下两个外部节点之一</span><br>   <span class="hljs-built_in">solveUnderflow</span> ( v ); <span class="hljs-comment">//如有必要，需做旋转或合并</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="下溢"><a href="#下溢" class="headerlink" title="下溢"></a>下溢</h4><h5 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h5><p>节点v下溢时，必恰好包含：$\lceil m/2 \rceil-2$个关键码和$\lceil m/2 \rceil-1$个分支。</p><p>当节点v的左右兄弟可以借出一个节点的时候：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/34fc2e87600c3734b51b5bd2ec41023a-c4278.png" alt="旋转"></p><p>若发生旋转，不仅原下溢节点会得到修复，其余所涉及的节点，无论兄弟还是父亲，都不会因此继而发生下溢。因此这种解决方案是彻底的，整个删除操作至此顺利结束。</p><h5 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h5><p>L和R或者不存在，或者所含的关键码均不足$\lceil m/2 \rceil$个时（注：L和R仍必有其一，且恰含$\lceil m/2 \rceil-1$个关键码）：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20c9f857a2a86107512905d1f01e0620-1409a.png" alt="合并"></p><p>合并操作可能继续向上蔓延，直到树根。若树根节点只含有唯一的一个关键码，在借出这个关键码之后，树根会变为空节点。在这种最坏情况下，树高会减1。</p><h5 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//关键码删除后若节点下溢，则做节点旋转或合并处理</span><br><span class="hljs-keyword">void</span> BTree&lt;T&gt;::<span class="hljs-built_in">solveUnderflow</span> ( BTNodePosi&lt;T&gt; v ) &#123;<br>   <span class="hljs-keyword">if</span> ( ( _order + <span class="hljs-number">1</span> ) / <span class="hljs-number">2</span> &lt;= v-&gt;child.<span class="hljs-built_in">size</span>() ) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//递归基：当前节点并未下溢</span><br>   BTNodePosi&lt;T&gt; p = v-&gt;parent;<br>   <span class="hljs-keyword">if</span> ( !p ) &#123; <span class="hljs-comment">//递归基：已到根节点，没有孩子的下限</span><br>      <span class="hljs-keyword">if</span> ( !v-&gt;key.<span class="hljs-built_in">size</span>() &amp;&amp; v-&gt;child[<span class="hljs-number">0</span>] ) &#123;<br>         <span class="hljs-comment">//但倘若作为树根的v已不含关键码，却有（唯一的）非空孩子，则</span><br>         <span class="hljs-comment">/*DSA*/</span><span class="hljs-built_in">printf</span> ( <span class="hljs-string">&quot;collapse\n&quot;</span> );<br>         _root = v-&gt;child[<span class="hljs-number">0</span>]; _root-&gt;parent = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//这个节点可被跳过</span><br>         v-&gt;child[<span class="hljs-number">0</span>] = <span class="hljs-literal">NULL</span>; <span class="hljs-built_in">release</span> ( v ); <span class="hljs-comment">//并因不再有用而被销毁</span><br>      &#125; <span class="hljs-comment">//整树高度降低一层</span><br>      <span class="hljs-keyword">return</span>;<br>   &#125;<br>   Rank r = <span class="hljs-number">0</span>; <span class="hljs-keyword">while</span> ( p-&gt;child[r] != v ) r++;<br>   <span class="hljs-comment">//确定v是p的第r个孩子——此时v可能不含关键码，故不能通过关键码查找</span><br>   <span class="hljs-comment">//另外，在实现了孩子指针的判等器之后，也可直接调用Vector::find()定位</span><br>   <span class="hljs-comment">/*DSA*/</span><span class="hljs-built_in">printf</span> ( <span class="hljs-string">&quot;\nrank = %d&quot;</span>, r );<br><span class="hljs-comment">// 情况1：向左兄弟借关键码</span><br>   <span class="hljs-keyword">if</span> ( <span class="hljs-number">0</span> &lt; r ) &#123; <span class="hljs-comment">//若v不是p的第一个孩子，则</span><br>      BTNodePosi&lt;T&gt; ls = p-&gt;child[r - <span class="hljs-number">1</span>]; <span class="hljs-comment">//左兄弟必存在</span><br>      <span class="hljs-keyword">if</span> ( ( _order + <span class="hljs-number">1</span> ) / <span class="hljs-number">2</span> &lt; ls-&gt;child.<span class="hljs-built_in">size</span>() ) &#123; <span class="hljs-comment">//若该兄弟足够“胖”，则</span><br>         <span class="hljs-comment">/*DSA*/</span><span class="hljs-built_in">printf</span> ( <span class="hljs-string">&quot; ... case 1\n&quot;</span> );<br>         v-&gt;key.<span class="hljs-built_in">insert</span> ( <span class="hljs-number">0</span>, p-&gt;key[r - <span class="hljs-number">1</span>] ); <span class="hljs-comment">//p借出一个关键码给v（作为最小关键码）</span><br>         p-&gt;key[r - <span class="hljs-number">1</span>] = ls-&gt;key.<span class="hljs-built_in">remove</span> ( ls-&gt;key.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> ); <span class="hljs-comment">//ls的最大关键码转入p</span><br>         v-&gt;child.<span class="hljs-built_in">insert</span> ( <span class="hljs-number">0</span>, ls-&gt;child.<span class="hljs-built_in">remove</span> ( ls-&gt;child.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> ) );<br>         <span class="hljs-comment">//同时ls的最右侧孩子过继给v</span><br>         <span class="hljs-keyword">if</span> ( v-&gt;child[<span class="hljs-number">0</span>] ) v-&gt;child[<span class="hljs-number">0</span>]-&gt;parent = v; <span class="hljs-comment">//作为v的最左侧孩子</span><br>         <span class="hljs-keyword">return</span>; <span class="hljs-comment">//至此，通过右旋已完成当前层（以及所有层）的下溢处理</span><br>      &#125;<br>   &#125; <span class="hljs-comment">//至此，左兄弟要么为空，要么太“瘦”</span><br><span class="hljs-comment">// 情况2：向右兄弟借关键码</span><br>   <span class="hljs-keyword">if</span> ( p-&gt;child.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &gt; r ) &#123; <span class="hljs-comment">//若v不是p的最后一个孩子，则</span><br>      BTNodePosi&lt;T&gt; rs = p-&gt;child[r + <span class="hljs-number">1</span>]; <span class="hljs-comment">//右兄弟必存在</span><br>      <span class="hljs-keyword">if</span> ( ( _order + <span class="hljs-number">1</span> ) / <span class="hljs-number">2</span> &lt; rs-&gt;child.<span class="hljs-built_in">size</span>() ) &#123; <span class="hljs-comment">//若该兄弟足够“胖”，则</span><br>         <span class="hljs-comment">/*DSA*/</span><span class="hljs-built_in">printf</span> ( <span class="hljs-string">&quot; ... case 2\n&quot;</span> );<br>         v-&gt;key.<span class="hljs-built_in">insert</span> ( v-&gt;key.<span class="hljs-built_in">size</span>(), p-&gt;key[r] ); <span class="hljs-comment">//p借出一个关键码给v（作为最大关键码）</span><br>         p-&gt;key[r] = rs-&gt;key.<span class="hljs-built_in">remove</span> ( <span class="hljs-number">0</span> ); <span class="hljs-comment">//rs的最小关键码转入p</span><br>         v-&gt;child.<span class="hljs-built_in">insert</span> ( v-&gt;child.<span class="hljs-built_in">size</span>(), rs-&gt;child.<span class="hljs-built_in">remove</span> ( <span class="hljs-number">0</span> ) );<br>         <span class="hljs-comment">//同时rs的最左侧孩子过继给v</span><br>         <span class="hljs-keyword">if</span> ( v-&gt;child[v-&gt;child.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] ) <span class="hljs-comment">//作为v的最右侧孩子</span><br>            v-&gt;child[v-&gt;child.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]-&gt;parent = v;<br>         <span class="hljs-keyword">return</span>; <span class="hljs-comment">//至此，通过左旋已完成当前层（以及所有层）的下溢处理</span><br>      &#125;<br>   &#125; <span class="hljs-comment">//至此，右兄弟要么为空，要么太“瘦”</span><br><span class="hljs-comment">// 情况3：左、右兄弟要么为空（但不可能同时），要么都太“瘦”——合并</span><br>   <span class="hljs-keyword">if</span> ( <span class="hljs-number">0</span> &lt; r ) &#123; <span class="hljs-comment">//与左兄弟合并</span><br>      <span class="hljs-comment">/*DSA*/</span><span class="hljs-built_in">printf</span> ( <span class="hljs-string">&quot; ... case 3L\n&quot;</span> );<br>      BTNodePosi&lt;T&gt; ls = p-&gt;child[r - <span class="hljs-number">1</span>]; <span class="hljs-comment">//左兄弟必存在</span><br>      ls-&gt;key.<span class="hljs-built_in">insert</span> ( ls-&gt;key.<span class="hljs-built_in">size</span>(), p-&gt;key.<span class="hljs-built_in">remove</span> ( r - <span class="hljs-number">1</span> ) ); p-&gt;child.<span class="hljs-built_in">remove</span> ( r );<br>      <span class="hljs-comment">//p的第r - 1个关键码转入ls，v不再是p的第r个孩子</span><br>      ls-&gt;child.<span class="hljs-built_in">insert</span> ( ls-&gt;child.<span class="hljs-built_in">size</span>(), v-&gt;child.<span class="hljs-built_in">remove</span> ( <span class="hljs-number">0</span> ) );<br>      <span class="hljs-keyword">if</span> ( ls-&gt;child[ls-&gt;child.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] ) <span class="hljs-comment">//v的最左侧孩子过继给ls做最右侧孩子</span><br>         ls-&gt;child[ls-&gt;child.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]-&gt;parent = ls;<br>      <span class="hljs-keyword">while</span> ( !v-&gt;key.<span class="hljs-built_in">empty</span>() ) &#123; <span class="hljs-comment">//v剩余的关键码和孩子，依次转入ls</span><br>         ls-&gt;key.<span class="hljs-built_in">insert</span> ( ls-&gt;key.<span class="hljs-built_in">size</span>(), v-&gt;key.<span class="hljs-built_in">remove</span> ( <span class="hljs-number">0</span> ) );<br>         ls-&gt;child.<span class="hljs-built_in">insert</span> ( ls-&gt;child.<span class="hljs-built_in">size</span>(), v-&gt;child.<span class="hljs-built_in">remove</span> ( <span class="hljs-number">0</span> ) );<br>         <span class="hljs-keyword">if</span> ( ls-&gt;child[ls-&gt;child.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] ) ls-&gt;child[ls-&gt;child.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]-&gt;parent = ls;<br>      &#125;<br>      <span class="hljs-built_in">release</span> ( v ); <span class="hljs-comment">//释放v</span><br>   &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//与右兄弟合并</span><br>      <span class="hljs-comment">/*DSA*/</span><span class="hljs-built_in">printf</span> ( <span class="hljs-string">&quot; ... case 3R\n&quot;</span> );<br>      BTNodePosi&lt;T&gt; rs = p-&gt;child[r + <span class="hljs-number">1</span>]; <span class="hljs-comment">//右兄弟必存在</span><br>      rs-&gt;key.<span class="hljs-built_in">insert</span> ( <span class="hljs-number">0</span>, p-&gt;key.<span class="hljs-built_in">remove</span> ( r ) ); p-&gt;child.<span class="hljs-built_in">remove</span> ( r );<br>      <span class="hljs-comment">//p的第r个关键码转入rs，v不再是p的第r个孩子</span><br>      rs-&gt;child.<span class="hljs-built_in">insert</span> ( <span class="hljs-number">0</span>, v-&gt;child.<span class="hljs-built_in">remove</span> ( v-&gt;child.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> ) );<br>      <span class="hljs-keyword">if</span> ( rs-&gt;child[<span class="hljs-number">0</span>] ) rs-&gt;child[<span class="hljs-number">0</span>]-&gt;parent = rs; <span class="hljs-comment">//v的最右侧孩子过继给rs做最左侧孩子</span><br>      <span class="hljs-keyword">while</span> ( !v-&gt;key.<span class="hljs-built_in">empty</span>() ) &#123; <span class="hljs-comment">//v剩余的关键码和孩子，依次转入rs</span><br>         rs-&gt;key.<span class="hljs-built_in">insert</span> ( <span class="hljs-number">0</span>, v-&gt;key.<span class="hljs-built_in">remove</span> ( v-&gt;key.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> ) );<br>         rs-&gt;child.<span class="hljs-built_in">insert</span> ( <span class="hljs-number">0</span>, v-&gt;child.<span class="hljs-built_in">remove</span> ( v-&gt;child.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> ) );<br>         <span class="hljs-keyword">if</span> ( rs-&gt;child[<span class="hljs-number">0</span>] ) rs-&gt;child[<span class="hljs-number">0</span>]-&gt;parent = rs;<br>      &#125;<br>      <span class="hljs-built_in">release</span> ( v ); <span class="hljs-comment">//释放v</span><br>   &#125;<br>   <span class="hljs-built_in">solveUnderflow</span> ( p ); <span class="hljs-comment">//上升一层，如有必要则继续分裂——至多递归O(logn)层</span><br>   <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>借助旋转和合并这两种手段，足以处理每一次新发生的下溢。即便会继续发生下溢，它的高度相对于此前的那次上溢，也必然会有所提升。整个过程具有单调性。</p><p>因此，整个调整的过程或者在中途停止，或者充其量抵达树根。所以整个修复下溢的过程，累计迭代步数也不超过$O(h)$。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>所谓对B树的访问，无非是有一系列的外存操作和内存操作交替的组成。有多少次外存操作，就有多少次内存操作。因此为了整个访问的高效率，一个基本的原则就是应该使外存操作的代价与内存操作的代价大致相当。</p></li><li><p>在B树中的操作，有两个方向：</p><ul><li>水平方向：它对应的是在每个节点的内部所做的搜索。这种搜索是在内存中进行的。</li><li>垂直方向：它对应的是磁盘操作</li></ul><p>也就是说，在树中每下降一层，都要付出一次IO操作的代价。这种代价相对于内存操作来说，至少高出5个数量级。</p></li><li><p>B树会自己适应这种形态</p></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8d2cf2ec36ef3a4493cbedf26ae8f5f1-e732d.png" alt="总结"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>B树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>伸展树</title>
    <link href="/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E4%BC%B8%E5%B1%95%E6%A0%91/"/>
    <url>/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E4%BC%B8%E5%B1%95%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="逐层伸展"><a href="#逐层伸展" class="headerlink" title="逐层伸展"></a>逐层伸展</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>自适应调整：借助程序的局部性，并且按照链表的思路，将最近访问的元素挪到最前面。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9343a40766e9c6db5405c7c94faba384-e9ac5.png" alt="思路"></p><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><ul><li>节点v一旦被访问，随即转移至树根</li><li>自下而上，逐层单旋</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b787a8befc2a65a0df80edeb02b7b8da-4cb6a.png" alt="策略"></p><p>反复的向上转移，直到到达树根</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>访问333</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/e67cd8d72a67dd83b5aed234bc46a604-b8c78.png" alt="实例"></p><p>经过一系列的zig和zag旋转</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/43324692986deb3e4696241075c219cd-53473.png" alt="经过一系列的zig和zag旋转"></p><h3 id="最坏情况"><a href="#最坏情况" class="headerlink" title="最坏情况"></a>最坏情况</h3><p>旋转次数呈周期性的算术级数演变：每一周期累计$\Omega(n^2)$，分摊$\Omega(n)$。</p><p>它已经退化成了最原始的线性序列！</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/e615003a795a82750a358006a980def8-89535.png" alt="最坏情况"></p><h2 id="双层伸展"><a href="#双层伸展" class="headerlink" title="双层伸展"></a>双层伸展</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>向上追溯两层，而非一层</li><li>反复考察祖孙三代：<code>g = parent(p)</code>，<code>p = parent(v)</code>，<code>v</code></li><li>根据它们的相对位置，经两次旋转使得v上升两层，成为（子）树根。</li></ul><h3 id="zig-zag-zag-zig"><a href="#zig-zag-zag-zig" class="headerlink" title="zig-zag/zag-zig"></a>zig-zag/zag-zig</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/122ecaddddbc822258e296b5f65992e3-e0719.png" alt="zig-zag/zag-zig"></p><p>观察发现：</p><ul><li>与AVL树双旋完全等效</li><li>与逐层伸展别无二致</li></ul><h3 id="zig-zig-zag-zag"><a href="#zig-zig-zag-zag" class="headerlink" title="zig-zig/zag-zag"></a>zig-zig/zag-zag</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/4f5bd21e24d9ac576b5f7d0918c7c156-43de9.png" alt="zig-zig/zag-zag"></p><p>将原本的<strong>zig(p)-&gt;zig(g)</strong>的顺序变为<strong>zig(g)-&gt;zig(p)</strong>的顺序。</p><h3 id="zig-zag"><a href="#zig-zag" class="headerlink" title="zig/zag"></a>zig/zag</h3><p>若是v只有父亲，没有祖父：</p><ul><li>此时必有<code>parent(v) == root(T)</code>，且每轮调整中，这种情况至多（在最后）出现一次。</li><li>视具体形态，做单次旋转<code>zig(r)</code>或<code>zag(r)</code></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/00e91c8f217b7032cb76ba51e6ee12c6-8c069.png" alt="zig/zag"></p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>最坏情况下的初始状态：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a7ac4b163c0a6acf0dbbb376d531c788-d434f.png" alt="实例"></p><p>第一次查找<strong>001</strong>，结果为：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/18f1d2281426bab3cbf717be6cfc70ad-d1750.png" alt="第一次查找**001**"></p><p>经过一次查找及相应的操作，树的高度变为了之前的一半。</p><p>第二次查找<strong>003</strong>：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20ba86c43426c5e135e8f23a72456bb1-643e0.png" alt="第二次查找**003**"></p><p>同样的，树的高度又变为了之前的一半。</p><h3 id="路径折叠"><a href="#路径折叠" class="headerlink" title="路径折叠"></a>路径折叠</h3><ul><li><p>折叠效果：一旦访问坏节点，对应路径的长度将随即减半</p></li><li><p>这种折叠效果，具有对坏节点的修复作用</p></li><li>最坏情况不致<strong>持续</strong>发生</li><li>单趟伸展操作，分摊$O(log_2{n})$时间</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/d970761d982dc3f2d360449fd8e9dadb-be7b8.png" alt="路径折叠"></p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="功能接口"><a href="#功能接口" class="headerlink" title="功能接口"></a>功能接口</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Splay</span> :</span> <span class="hljs-keyword">public</span> BST&lt;T&gt; &#123; <span class="hljs-comment">//由BST派生的Splay树模板类</span><br><span class="hljs-keyword">protected</span>:<br>   <span class="hljs-function">BinNodePosi&lt;T&gt; <span class="hljs-title">splay</span> <span class="hljs-params">( BinNodePosi&lt;T&gt; v )</span></span>; <span class="hljs-comment">//将节点v伸展至根</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function">BinNodePosi&lt;T&gt; &amp; <span class="hljs-title">search</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> T&amp; e )</span></span>; <span class="hljs-comment">//查找（重写）</span><br>   <span class="hljs-function">BinNodePosi&lt;T&gt; <span class="hljs-title">insert</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> T&amp; e )</span></span>; <span class="hljs-comment">//插入（重写）</span><br>   <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">remove</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> T&amp; e )</span></span>; <span class="hljs-comment">//删除（重写）</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="伸展算法"><a href="#伸展算法" class="headerlink" title="伸展算法"></a>伸展算法</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> NodePosi&gt; <span class="hljs-keyword">inline</span> <span class="hljs-comment">//在节点*p与*lc（可能为空）之间建立父（左）子关系</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">attachAsLChild</span> <span class="hljs-params">( NodePosi p, NodePosi lc )</span> </span>&#123; p-&gt;lc = lc; <span class="hljs-keyword">if</span> ( lc ) lc-&gt;parent = p; &#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> NodePosi&gt; <span class="hljs-keyword">inline</span> <span class="hljs-comment">//在节点*p与*rc（可能为空）之间建立父（右）子关系</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">attachAsRChild</span> <span class="hljs-params">( NodePosi p, NodePosi rc )</span> </span>&#123; p-&gt;rc = rc; <span class="hljs-keyword">if</span> ( rc ) rc-&gt;parent = p; &#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//Splay树伸展算法：从节点v出发逐层伸展</span><br>BinNodePosi&lt;T&gt; Splay&lt;T&gt;::<span class="hljs-built_in">splay</span> ( BinNodePosi&lt;T&gt; v ) &#123; <span class="hljs-comment">//v为因最近访问而需伸展的节点位置</span><br>   <span class="hljs-keyword">if</span> ( !v ) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; BinNodePosi&lt;T&gt; p; BinNodePosi&lt;T&gt; g; <span class="hljs-comment">//*v的父亲与祖父</span><br>   <span class="hljs-keyword">while</span> ( ( p = v-&gt;parent ) &amp;&amp; ( g = p-&gt;parent ) ) &#123; <span class="hljs-comment">//自下而上，反复对*v做双层伸展</span><br>      BinNodePosi&lt;T&gt; gg = g-&gt;parent; <span class="hljs-comment">//每轮之后*v都以原曾祖父（great-grand parent）为父</span><br>      <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">IsLChild</span> ( *v ) )<br>         <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">IsLChild</span> ( *p ) ) &#123; <span class="hljs-comment">//zig-zig</span><br>            <span class="hljs-comment">/*DSA*/</span><span class="hljs-built_in">printf</span> ( <span class="hljs-string">&quot;\tzIg-zIg :&quot;</span> ); <span class="hljs-built_in">print</span> ( g ); <span class="hljs-built_in">print</span> ( p ); <span class="hljs-built_in">print</span> ( v ); <span class="hljs-built_in">printf</span> ( <span class="hljs-string">&quot;\n&quot;</span> );<br>            <span class="hljs-built_in">attachAsLChild</span> ( g, p-&gt;rc ); <span class="hljs-built_in">attachAsLChild</span> ( p, v-&gt;rc );<br>            <span class="hljs-built_in">attachAsRChild</span> ( p, g ); <span class="hljs-built_in">attachAsRChild</span> ( v, p );<br>         &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//zig-zag</span><br>            <span class="hljs-comment">/*DSA*/</span><span class="hljs-built_in">printf</span> ( <span class="hljs-string">&quot;\tzIg-zAg :&quot;</span> ); <span class="hljs-built_in">print</span> ( g ); <span class="hljs-built_in">print</span> ( p ); <span class="hljs-built_in">print</span> ( v ); <span class="hljs-built_in">printf</span> ( <span class="hljs-string">&quot;\n&quot;</span> );<br>            <span class="hljs-built_in">attachAsLChild</span> ( p, v-&gt;rc ); <span class="hljs-built_in">attachAsRChild</span> ( g, v-&gt;lc );<br>            <span class="hljs-built_in">attachAsLChild</span> ( v, g ); <span class="hljs-built_in">attachAsRChild</span> ( v, p );<br>         &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">IsRChild</span> ( *p ) ) &#123; <span class="hljs-comment">//zag-zag</span><br>         <span class="hljs-comment">/*DSA*/</span><span class="hljs-built_in">printf</span> ( <span class="hljs-string">&quot;\tzAg-zAg :&quot;</span> ); <span class="hljs-built_in">print</span> ( g ); <span class="hljs-built_in">print</span> ( p ); <span class="hljs-built_in">print</span> ( v ); <span class="hljs-built_in">printf</span> ( <span class="hljs-string">&quot;\n&quot;</span> );<br>         <span class="hljs-built_in">attachAsRChild</span> ( g, p-&gt;lc ); <span class="hljs-built_in">attachAsRChild</span> ( p, v-&gt;lc );<br>         <span class="hljs-built_in">attachAsLChild</span> ( p, g ); <span class="hljs-built_in">attachAsLChild</span> ( v, p );<br>      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//zag-zig</span><br>         <span class="hljs-comment">/*DSA*/</span><span class="hljs-built_in">printf</span> ( <span class="hljs-string">&quot;\tzAg-zIg :&quot;</span> ); <span class="hljs-built_in">print</span> ( g ); <span class="hljs-built_in">print</span> ( p ); <span class="hljs-built_in">print</span> ( v ); <span class="hljs-built_in">printf</span> ( <span class="hljs-string">&quot;\n&quot;</span> );<br>         <span class="hljs-built_in">attachAsRChild</span> ( p, v-&gt;lc ); <span class="hljs-built_in">attachAsLChild</span> ( g, v-&gt;rc );<br>         <span class="hljs-built_in">attachAsRChild</span> ( v, g ); <span class="hljs-built_in">attachAsLChild</span> ( v, p );<br>      &#125;<br>      <span class="hljs-keyword">if</span> ( !gg ) v-&gt;parent = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//若*v原先的曾祖父*gg不存在，则*v现在应为树根</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-comment">//否则，*gg此后应该以*v作为左或右孩子</span><br>         ( g == gg-&gt;lc ) ? <span class="hljs-built_in">attachAsLChild</span> ( gg, v ) : <span class="hljs-built_in">attachAsRChild</span> ( gg, v );<br>      <span class="hljs-built_in">updateHeight</span> ( g ); <span class="hljs-built_in">updateHeight</span> ( p ); <span class="hljs-built_in">updateHeight</span> ( v );<br>   &#125; <span class="hljs-comment">//双层伸展结束时，必有g == NULL，但p可能非空</span><br>   <span class="hljs-keyword">if</span> ( p = v-&gt;parent ) &#123; <span class="hljs-comment">//若p果真非空，则额外再做一次单旋</span><br>      <span class="hljs-comment">/*DSA*/</span><span class="hljs-keyword">if</span> ( <span class="hljs-built_in">IsLChild</span> ( *v ) ) &#123; <span class="hljs-built_in">printf</span> ( <span class="hljs-string">&quot;\tzIg :&quot;</span> ); <span class="hljs-built_in">print</span> ( p ); <span class="hljs-built_in">print</span> ( v ); <span class="hljs-built_in">printf</span> ( <span class="hljs-string">&quot;\n&quot;</span> ); &#125;<br>      <span class="hljs-comment">/*DSA*/</span><span class="hljs-keyword">else</span>              &#123; <span class="hljs-built_in">printf</span> ( <span class="hljs-string">&quot;\tzAg :&quot;</span> ); <span class="hljs-built_in">print</span> ( p ); <span class="hljs-built_in">print</span> ( v ); <span class="hljs-built_in">printf</span> ( <span class="hljs-string">&quot;\n&quot;</span> ); &#125;<br>      <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">IsLChild</span> ( *v ) ) &#123; <span class="hljs-built_in">attachAsLChild</span> ( p, v-&gt;rc ); <span class="hljs-built_in">attachAsRChild</span> ( v, p ); &#125;<br>      <span class="hljs-keyword">else</span>                   &#123; <span class="hljs-built_in">attachAsRChild</span> ( p, v-&gt;lc ); <span class="hljs-built_in">attachAsLChild</span> ( v, p ); &#125;<br>      <span class="hljs-built_in">updateHeight</span> ( p ); <span class="hljs-built_in">updateHeight</span> ( v );<br>   &#125;<br>   v-&gt;parent = <span class="hljs-literal">NULL</span>; <span class="hljs-keyword">return</span> v;<br>&#125; <span class="hljs-comment">//调整之后新树根应为被伸展的节点，故返回该节点的位置以便上层函数更新树根</span><br></code></pre></div></td></tr></table></figure><h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; BinNodePosi&lt;T&gt; &amp; Splay&lt;T&gt;::<span class="hljs-built_in">search</span> ( <span class="hljs-keyword">const</span> T &amp; e ) &#123; <span class="hljs-comment">//在伸展树中查找e</span><br>   BinNodePosi&lt;T&gt; p = BST&lt;T&gt;::<span class="hljs-built_in">search</span> ( e );<br>   _root = <span class="hljs-built_in">splay</span> ( p ? p : _hot ); <span class="hljs-comment">//将最后一个被访问的节点伸展至根</span><br>   <span class="hljs-keyword">return</span> _root;<br>&#125; <span class="hljs-comment">//与其它BST不同，无论查找成功与否，_root都指向最后被访问的节点</span><br></code></pre></div></td></tr></table></figure><ul><li>伸展树的查找操作，与常规BST::search()不同，很可能会改变树的拓扑结构，不再属于静态操作。</li></ul><h3 id="插入算法"><a href="#插入算法" class="headerlink" title="插入算法"></a>插入算法</h3><ul><li>实际上，查找（失败）之后，<code>_hot</code>即是根节点。所以<code>_hot</code>为插入节点的左/右孩子，插入节点最终将变为树根。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/228eb6d5517098e9ba96940fc4b12e58-7baee.png" alt="插入算法"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; BinNodePosi&lt;T&gt; Splay&lt;T&gt;::<span class="hljs-built_in">insert</span> ( <span class="hljs-keyword">const</span> T&amp; e ) &#123; <span class="hljs-comment">//将关键码e插入伸展树中</span><br>   <span class="hljs-keyword">if</span> ( !_root ) &#123; _size++; <span class="hljs-keyword">return</span> _root = <span class="hljs-keyword">new</span> BinNode&lt;T&gt; ( e ); &#125; <span class="hljs-comment">//处理原树为空的退化情况</span><br>   <span class="hljs-keyword">if</span> ( e == <span class="hljs-built_in">search</span> ( e )-&gt;data ) <span class="hljs-keyword">return</span> _root; <span class="hljs-comment">//确认目标节点不存在</span><br>   _size++; BinNodePosi&lt;T&gt; t = _root; <span class="hljs-comment">//创建新节点。以下调整&lt;=7个指针以完成局部重构</span><br>   <span class="hljs-keyword">if</span> ( _root-&gt;data &lt; e ) &#123; <span class="hljs-comment">//插入新根，以t和t-&gt;rc为左、右孩子</span><br>      t-&gt;parent = _root = <span class="hljs-keyword">new</span> BinNode&lt;T&gt; ( e, <span class="hljs-literal">NULL</span>, t, t-&gt;rc ); <span class="hljs-comment">//2 + 3个</span><br>      <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">HasRChild</span> ( *t ) ) &#123; t-&gt;rc-&gt;parent = _root; t-&gt;rc = <span class="hljs-literal">NULL</span>; &#125; <span class="hljs-comment">//&lt;= 2个</span><br>   &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//插入新根，以t-&gt;lc和t为左、右孩子</span><br>      t-&gt;parent = _root = <span class="hljs-keyword">new</span> BinNode&lt;T&gt; ( e, <span class="hljs-literal">NULL</span>, t-&gt;lc, t ); <span class="hljs-comment">//2 + 3个</span><br>      <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">HasLChild</span> ( *t ) ) &#123; t-&gt;lc-&gt;parent = _root; t-&gt;lc = <span class="hljs-literal">NULL</span>; &#125; <span class="hljs-comment">//&lt;= 2个</span><br>   &#125;<br>   <span class="hljs-built_in">updateHeightAbove</span> ( t ); <span class="hljs-comment">//更新t及其祖先（实际上只有_root一个）的高度</span><br>   <span class="hljs-keyword">return</span> _root; <span class="hljs-comment">//新节点必然置于树根，返回之</span><br>&#125; <span class="hljs-comment">//无论e是否存在于原树中，返回时总有_root-&gt;data == e</span><br></code></pre></div></td></tr></table></figure><h3 id="删除算法"><a href="#删除算法" class="headerlink" title="删除算法"></a>删除算法</h3><ul><li><p>通过Splay::search()查找（成功）之后，目标节点即是树根，所以可以直接在树根附近完成对目标节点的删除</p></li><li><p>删除目标节点后，找到右子树中的最小者或左子树中的最大者<strong>m</strong>，作为新的树根</p></li><li>在此之后，作为树根的节点<strong>m</strong>，是与此前被删除的节点非常临近的一个，所以在此后局部性将可以继续得到充分的利用。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/70503458c334693d2ae889e8e01e39b6-67796.png" alt="删除算法"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">bool</span> Splay&lt;T&gt;::<span class="hljs-built_in">remove</span> ( <span class="hljs-keyword">const</span> T&amp; e ) &#123; <span class="hljs-comment">//从伸展树中删除关键码e</span><br>   <span class="hljs-keyword">if</span> ( !_root || ( e != <span class="hljs-built_in">search</span> ( e )-&gt;data ) ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//若树空或目标不存在，则无法删除</span><br>   BinNodePosi&lt;T&gt; w = _root; <span class="hljs-comment">//assert: 经search()后节点e已被伸展至树根</span><br>   <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">HasLChild</span> ( *_root ) ) &#123; <span class="hljs-comment">//若无左子树，则直接删除</span><br>      _root = _root-&gt;rc; <span class="hljs-keyword">if</span> ( _root ) _root-&gt;parent = <span class="hljs-literal">NULL</span>;<br>   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">HasRChild</span> ( *_root ) ) &#123; <span class="hljs-comment">//若无右子树，也直接删除</span><br>      _root = _root-&gt;lc; <span class="hljs-keyword">if</span> ( _root ) _root-&gt;parent = <span class="hljs-literal">NULL</span>;<br>   &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//若左右子树同时存在，则</span><br>      BinNodePosi&lt;T&gt; lTree = _root-&gt;lc;<br>      lTree-&gt;parent = <span class="hljs-literal">NULL</span>; _root-&gt;lc = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//暂时将左子树切除</span><br>      _root = _root-&gt;rc; _root-&gt;parent = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//只保留右子树</span><br>      <span class="hljs-built_in">search</span> ( w-&gt;data ); <span class="hljs-comment">//以原树根为目标，做一次（必定失败的）查找</span><br><span class="hljs-comment">///// assert: 至此，右子树中最小节点必伸展至根，且（因无雷同节点）其左子树必空，于是</span><br>      _root-&gt;lc = lTree; lTree-&gt;parent = _root; <span class="hljs-comment">//只需将原左子树接回原位即可</span><br>   &#125;<br>   <span class="hljs-built_in">release</span> ( w-&gt;data ); <span class="hljs-built_in">release</span> ( w ); _size--; <span class="hljs-comment">//释放节点，更新规模</span><br>   <span class="hljs-keyword">if</span> ( _root ) <span class="hljs-built_in">updateHeight</span> ( _root ); <span class="hljs-comment">//此后，若树非空，则树根的高度需要更新</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//返回成功标志</span><br>&#125; <span class="hljs-comment">//若目标节点存在且被删除，返回true；否则返回false</span><br></code></pre></div></td></tr></table></figure><h2 id="综合评价"><a href="#综合评价" class="headerlink" title="综合评价"></a>综合评价</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>无需记录节点高度或平衡因子，所以编程实现简单易行（优于AVL树）</li><li>分摊复杂度$O(log_2{n})$，与AVL树相当</li><li>局部性强，缓存命中率极高（即$k&lt;&lt;n&lt;&lt;m$）<ul><li>效率甚至可以更高：自适应的$O(log_2{k})$</li><li>任何连续的m次查找，都可以在$O(mlog_2{k}+nlog_2{n})$时间内完成</li></ul></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>仍不能保证单次最坏情况出现</li><li>不适用于对效率敏感的场合（比如手术器械）</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>伸展树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVL树</title>
    <link href="/2020/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9AAVL%E6%A0%91/"/>
    <url>/2020/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9AAVL%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>AVL树是一种BBST（Balanced Binary Search Tree）。</p><p>重平衡：将刚刚失衡的搜索树，重新恢复为一棵BBST的过程。</p><h2 id="平衡因子"><a href="#平衡因子" class="headerlink" title="平衡因子"></a>平衡因子</h2><p><strong>对于二叉树中的任何一个节点v，都可以定义它的平衡因子balanced factor：</strong></p><script type="math/tex; mode=display">balFac(v)=height(lc(v))-height(rc(v))</script><p>即等于它的左子树高度和右子树高度之差。</p><p><strong>AVL树：树中的所有节点的平衡因子都不超过1，也不小于-1：</strong></p><script type="math/tex; mode=display">\forall v，|balFac(v)| \le 1</script><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b3c784ec6e60147313e9f4b2703ef054-37ea3.png" alt="平衡因子"></p><h2 id="适度平衡标准（待证明）"><a href="#适度平衡标准（待证明）" class="headerlink" title="适度平衡标准（待证明）"></a>适度平衡标准（待证明）</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/ef0e74153a6da12771b60a0400032a30-3cbe8.png" alt="适度平衡标准（待证明）"></p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/196ddf31e443e25566c8ccca16fe27a1-bf33b.png" alt="接口"></p><h2 id="失衡到平衡"><a href="#失衡到平衡" class="headerlink" title="失衡到平衡"></a>失衡到平衡</h2><p>在一棵AVL树中：</p><ul><li>插入一个节点之后，有可能会导致若干个祖先失衡</li><li>删除一个节点之后，至多只有一个祖先会失衡<ul><li>考察高度最低的那个祖先：这个祖先尽管失衡了，它的高度却必然保持原样。如果它的失衡是因为它的某个后代被摘除了，那么这个后代在此前也必然属于它那个相对更短的分支；而它的高度则是由它相对更长的那些分支所决定的。因此这个节点的删除，并不至于引起这个祖先高度的变化，这个祖先高度不会变化，那么相对于更高的祖先而言，它们在计算平衡因子时，结果也应该与未删除节点之前是一样的。换而言之，它们也必然是平衡的。</li></ul></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/1839426c1579a15f96f4e94eed01b9ab-37d7c.png" alt="失衡到平衡"></p><p>QA：</p><ul><li>在AVL树中刚插入一个节点后失衡节点个数最多为？<ul><li>$O(lg{n})$</li></ul></li><li>高度为3的AVL树至少包含几个节点？<ul><li>7</li></ul></li></ul><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h3 id="单旋"><a href="#单旋" class="headerlink" title="单旋"></a>单旋</h3><p>像下图的g、p、v三个节点的方向同时往右，又称为zag-zag旋转（对称的，同时往左，称为zig-zig）</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5aa9dab75744d1dbf8240bf7b8c64aec-79f85.png" alt="单旋"></p><h3 id="双旋"><a href="#双旋" class="headerlink" title="双旋"></a>双旋</h3><p>祖孙三代呈<strong>之</strong>字形形式</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6a51fe8b739016a15f6bea1731b15cfa-e3866.png" alt="双旋"></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; BinNodePosi&lt;T&gt; AVL&lt;T&gt;::<span class="hljs-built_in">insert</span> ( <span class="hljs-keyword">const</span> T&amp; e ) &#123; <span class="hljs-comment">//将关键码e插入AVL树中</span><br>   BinNodePosi&lt;T&gt; &amp; x = <span class="hljs-built_in">search</span> ( e ); <span class="hljs-keyword">if</span> ( x ) <span class="hljs-keyword">return</span> x; <span class="hljs-comment">//确认目标节点不存在</span><br>   BinNodePosi&lt;T&gt; xx = x = <span class="hljs-keyword">new</span> BinNode&lt;T&gt; ( e, _hot ); _size++; <span class="hljs-comment">//创建新节点x</span><br><span class="hljs-comment">// 此时，x的父亲_hot若增高，则其祖父有可能失衡</span><br>   <span class="hljs-keyword">for</span> ( BinNodePosi&lt;T&gt; g = _hot; g; g = g-&gt;parent ) <span class="hljs-comment">//从x之父出发向上，逐层检查各代祖先g</span><br>      <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">AvlBalanced</span> ( *g ) ) &#123; <span class="hljs-comment">//一旦发现g失衡，则（采用“3 + 4”算法）使之复衡，并将子树</span><br>         <span class="hljs-built_in">FromParentTo</span> ( *g ) = <span class="hljs-built_in">rotateAt</span> ( <span class="hljs-built_in">tallerChild</span> ( <span class="hljs-built_in">tallerChild</span> ( g ) ) ); <span class="hljs-comment">//重新接入原树</span><br>         <span class="hljs-keyword">break</span>; <span class="hljs-comment">//局部子树复衡后，高度必然复原；其祖先亦必如此，故调整结束</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-comment">//否则（g仍平衡）</span><br>         <span class="hljs-built_in">updateHeight</span> ( g ); <span class="hljs-comment">//只需更新其高度（注意：即便g未失衡，高度亦可能增加）</span><br>   <span class="hljs-keyword">return</span> xx; <span class="hljs-comment">//返回新节点位置</span><br>&#125; <span class="hljs-comment">//无论e是否存在于原树中，总有AVL::insert(e)-&gt;data == e</span><br></code></pre></div></td></tr></table></figure><p>QA：</p><ul><li>AVL树中插入节点引发失衡，经旋转调整后重新平衡，此时包含节点g,p,v的子树高度？<ul><li>不变。故在AVL树中修正插入节点引发的失衡不会出现失衡传播。</li></ul></li></ul><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="单旋-1"><a href="#单旋-1" class="headerlink" title="单旋"></a>单旋</h3><p>$T_0$和$T_1$子树的底部至少有一个节点，而$T_2$子树的底部可能存在一个节点。</p><ul><li>$T_2$子树底部的节点不存在时：相对于原树的高度，调整之后新树的高度，会缩短一个单位。这种情况下，可能会导致它的某个祖先节点的另一个分支更高，即这个祖先节点也失衡了。（失衡传播）</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8e0c83d53546d816402877ff061079cd-04917.png" alt="单旋"></p><h3 id="双旋-1"><a href="#双旋-1" class="headerlink" title="双旋"></a>双旋</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/3616647179747aac0d47061b3cbba7c6-0dd33.png" alt="双旋"></p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">bool</span> AVL&lt;T&gt;::<span class="hljs-built_in">remove</span> ( <span class="hljs-keyword">const</span> T&amp; e ) &#123; <span class="hljs-comment">//从AVL树中删除关键码e</span><br>   BinNodePosi&lt;T&gt; &amp; x = <span class="hljs-built_in">search</span> ( e ); <span class="hljs-keyword">if</span> ( !x ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//确认目标存在（留意_hot的设置）</span><br>   <span class="hljs-built_in">removeAt</span> ( x, _hot ); _size--; <span class="hljs-comment">//先按BST规则删除之（此后，原节点之父_hot及其祖先均可能失衡）</span><br>   <span class="hljs-keyword">for</span> ( BinNodePosi&lt;T&gt; g = _hot; g; g = g-&gt;parent ) &#123; <span class="hljs-comment">//从_hot出发向上，逐层检查各代祖先g</span><br>      <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">AvlBalanced</span> ( *g ) ) <span class="hljs-comment">//一旦发现g失衡，则（采用“3 + 4”算法）使之复衡，并将该子树联至</span><br>         g = <span class="hljs-built_in">FromParentTo</span> ( *g ) = <span class="hljs-built_in">rotateAt</span> ( <span class="hljs-built_in">tallerChild</span> ( <span class="hljs-built_in">tallerChild</span> ( g ) ) ); <span class="hljs-comment">//原父亲</span><br>      <span class="hljs-built_in">updateHeight</span> ( g ); <span class="hljs-comment">//更新高度（注意：即便g未失衡或已恢复平衡，高度均可能降低）</span><br>   &#125; <span class="hljs-comment">//可能需做Omega(logn)次调整——无论是否做过调整，全树高度均可能降低</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//删除成功</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>QA：</p><ul><li>AVL树中删除节点引发失衡，经旋转调整后重新平衡，此时包含节点g,p,v的子树高度？<ul><li>有可能不变也有可能减小1。故在AVL树中修正删除节点引发的失衡有可能出现失衡传播。</li></ul></li></ul><h2 id="3-4-重构"><a href="#3-4-重构" class="headerlink" title="3+4 重构"></a>3+4 重构</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>设g(x)为最低的失衡节点，考察祖孙三代：g~p~v。按照中序遍历次序，将其重命名为：$a&lt;b&lt;c$</li><li>它们总共拥有互不相交的四棵（可能为空的）子树。按照中序遍历次序，将其重命名为：$T_0&lt;T_1&lt;T_2&lt;T_3$</li></ul><p>将这两个序列混合起来，即：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/be012c1198efded490182ccfafe87dfe-1ed98.png" alt="思路"></p><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>rotateAt:</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; BinNodePosi&lt;T&gt; BST&lt;T&gt;::<span class="hljs-built_in">rotateAt</span> ( BinNodePosi&lt;T&gt; v ) &#123; <span class="hljs-comment">//v为非空孙辈节点</span><br>   <span class="hljs-comment">/*DSA*/</span><span class="hljs-keyword">if</span> ( !v ) &#123; <span class="hljs-built_in">printf</span> ( <span class="hljs-string">&quot;\a\nFail to rotate a null node\n&quot;</span> ); <span class="hljs-built_in">exit</span> ( <span class="hljs-number">-1</span> ); &#125;<br>   BinNodePosi&lt;T&gt; p = v-&gt;parent; BinNodePosi&lt;T&gt; g = p-&gt;parent; <span class="hljs-comment">//视v、p和g相对位置分四种情况</span><br>   <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">IsLChild</span> ( *p ) ) <span class="hljs-comment">/* zig */</span><br>      <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">IsLChild</span> ( *v ) ) &#123; <span class="hljs-comment">/* zig-zig */</span> <span class="hljs-comment">//*DSA*/printf(&quot;\tzIg-zIg: &quot;);</span><br>         p-&gt;parent = g-&gt;parent; <span class="hljs-comment">//向上联接</span><br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">connect34</span> ( v, p, g, v-&gt;lc, v-&gt;rc, p-&gt;rc, g-&gt;rc );<br>      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* zig-zag */</span>  <span class="hljs-comment">//*DSA*/printf(&quot;\tzIg-zAg: &quot;);</span><br>         v-&gt;parent = g-&gt;parent; <span class="hljs-comment">//向上联接</span><br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">connect34</span> ( p, v, g, p-&gt;lc, v-&gt;lc, v-&gt;rc, g-&gt;rc );<br>      &#125;<br>   <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* zag */</span><br>      <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">IsRChild</span> ( *v ) ) &#123; <span class="hljs-comment">/* zag-zag */</span> <span class="hljs-comment">//*DSA*/printf(&quot;\tzAg-zAg: &quot;);</span><br>         p-&gt;parent = g-&gt;parent; <span class="hljs-comment">//向上联接</span><br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">connect34</span> ( g, p, v, g-&gt;lc, p-&gt;lc, v-&gt;lc, v-&gt;rc );<br>      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* zag-zig */</span>  <span class="hljs-comment">//*DSA*/printf(&quot;\tzAg-zIg: &quot;);</span><br>         v-&gt;parent = g-&gt;parent; <span class="hljs-comment">//向上联接</span><br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">connect34</span> ( g, v, p, g-&gt;lc, v-&gt;lc, v-&gt;rc, p-&gt;rc );<br>      &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>connect34</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; BinNodePosi&lt;T&gt; BST&lt;T&gt;::<span class="hljs-built_in">connect34</span> (<br>   BinNodePosi&lt;T&gt; a, BinNodePosi&lt;T&gt; b, BinNodePosi&lt;T&gt; c,<br>   BinNodePosi&lt;T&gt; T0, BinNodePosi&lt;T&gt; T1, BinNodePosi&lt;T&gt; T2, BinNodePosi&lt;T&gt; T3<br>) &#123;<br>   a-&gt;lc = T0; <span class="hljs-keyword">if</span> ( T0 ) T0-&gt;parent = a;<br>   a-&gt;rc = T1; <span class="hljs-keyword">if</span> ( T1 ) T1-&gt;parent = a; <span class="hljs-built_in">updateHeight</span> ( a );<br>   c-&gt;lc = T2; <span class="hljs-keyword">if</span> ( T2 ) T2-&gt;parent = c;<br>   c-&gt;rc = T3; <span class="hljs-keyword">if</span> ( T3 ) T3-&gt;parent = c; <span class="hljs-built_in">updateHeight</span> ( c );<br>   b-&gt;lc = a; a-&gt;parent = b;<br>   b-&gt;rc = c; c-&gt;parent = b; <span class="hljs-built_in">updateHeight</span> ( b );<br>   <span class="hljs-keyword">return</span> b; <span class="hljs-comment">//该子树新的根节点</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>无论查找、插入或删除，最坏情况下的复杂度均为$O(log_2{n})$</li><li>存储空间：$O(n)$</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>借助高度或平衡因子，因此需要改造元素结构，或额外封装</li><li>实测复杂度与理论值尚有差距<ul><li>插入/删除后的旋转，成本不菲</li><li>删除操作后，最多需要旋转$\Omega(log_2{n})$次（knuth：平均仅0.21次）</li><li>若需频繁进行插入/删除操作，未免得不偿失</li></ul></li><li>（致命）单次动态调整后，全树拓扑结构的变化量可能高达$\Omega(log_2{n})$</li><li>它的插入操作和删除操作是非常不对等的</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>AVL树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树</title>
    <link href="/2020/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2020/03/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="BST：Binary-Search-Tree"><a href="#BST：Binary-Search-Tree" class="headerlink" title="BST：Binary Search Tree"></a>BST：Binary Search Tree</h2><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><h4 id="循关键码访问"><a href="#循关键码访问" class="headerlink" title="循关键码访问"></a>循关键码访问</h4><p>在BST中，数据项之间，依照各自的关键码彼此区分。关键码之间支持：</p><ul><li>大小比较</li><li>相等比较</li></ul><h5 id="词条"><a href="#词条" class="headerlink" title="词条"></a>词条</h5><p>数据集合中的数据项，统一地表示和实现为词条<strong>entry</strong>形式。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/71a647814721756ad77c41fbc8188733-94724.png" alt="词条"></p><h4 id="组成单位"><a href="#组成单位" class="headerlink" title="组成单位"></a>组成单位</h4><ul><li>节点<ul><li>词条：在节点内<ul><li>关键码：在词条内，且唯一</li></ul></li></ul></li></ul><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><h5 id="顺序性"><a href="#顺序性" class="headerlink" title="顺序性"></a>顺序性</h5><ul><li>顺序性：任意节点均不小于/不大于其左/右后代</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/e143306fb7a6d997cd8e806ba4e3b190-41081.png" alt="特征"></p><ul><li>单个节点的二叉树必然是BST</li><li>只要满足局部顺序性的单分支二叉树，也是BST</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f290fea422806f06a34a3ed03adbaebb-fcda7.png" alt="特征"></p><ol><li>不是BST，因为不是二叉树</li><li>不是BST，因为词条等于3的节点的右后代中，有一个词条等于2的节点，不满足局部顺序性。</li><li>是BST</li><li>是BST</li><li>是BST</li></ol><p>顺序性虽然只是对局部特征的刻画，但由此却可导出某种全局特征：单调性</p><h5 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h5><p>单调性：BST的中序遍历序列，必然单调非降。这个性质也是BST的充要条件。</p><ul><li><p>一棵树中所有节点的垂直投影，就是这棵数的<strong>中序遍历序列</strong>。</p></li><li><p>只要这个序列是单调变化的，那么这棵树必然是BST。</p></li><li><p>BST在微观上处处满足顺序性，在宏观上，整体满足单调性。</p></li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/2986c45cd4384308a5e12e60aa9086cc-d39ef.png" alt="单调性"></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>由<code>BinTree</code>类派生而来</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/******************************************************************************************</span><br><span class="hljs-comment"> * Data Structures in C++</span><br><span class="hljs-comment"> * ISBN: 7-302-33064-6 &amp; 7-302-33065-3 &amp; 7-302-29652-2 &amp; 7-302-26883-3</span><br><span class="hljs-comment"> * Junhui DENG, deng@tsinghua.edu.cn</span><br><span class="hljs-comment"> * Computer Science &amp; Technology, Tsinghua University</span><br><span class="hljs-comment"> * Copyright (c) 2003-2020. All rights reserved.</span><br><span class="hljs-comment"> ******************************************************************************************/</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;BinTree/BinTree.h&quot;</span> <span class="hljs-comment">//引入BinTree</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BST</span> :</span> <span class="hljs-keyword">public</span> BinTree&lt;T&gt; &#123; <span class="hljs-comment">//由BinTree派生BST模板类</span><br><span class="hljs-keyword">protected</span>:<br>   BinNodePosi&lt;T&gt; _hot; <span class="hljs-comment">//“命中”节点的父亲</span><br>   <span class="hljs-function">BinNodePosi&lt;T&gt; <span class="hljs-title">connect34</span> <span class="hljs-params">( <span class="hljs-comment">//按照“3 + 4”结构，联接3个节点及四棵子树</span></span></span><br><span class="hljs-params"><span class="hljs-function">      BinNodePosi&lt;T&gt;, BinNodePosi&lt;T&gt;, BinNodePosi&lt;T&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">      BinNodePosi&lt;T&gt;, BinNodePosi&lt;T&gt;, BinNodePosi&lt;T&gt;, BinNodePosi&lt;T&gt; )</span></span>;<br>   <span class="hljs-function">BinNodePosi&lt;T&gt; <span class="hljs-title">rotateAt</span> <span class="hljs-params">( BinNodePosi&lt;T&gt; x )</span></span>; <span class="hljs-comment">//对x及其父亲、祖父做统一旋转调整</span><br><span class="hljs-keyword">public</span>: <span class="hljs-comment">//基本接口：以virtual修饰，强制要求所有派生类（BST变种）根据各自的规则对其重写</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> BinNodePosi&lt;T&gt; &amp; <span class="hljs-title">search</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> T&amp; e )</span></span>; <span class="hljs-comment">//查找</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> BinNodePosi&lt;T&gt; <span class="hljs-title">insert</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> T&amp; e )</span></span>; <span class="hljs-comment">//插入</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">remove</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> T&amp; e )</span></span>; <span class="hljs-comment">//删除</span><br>   <span class="hljs-comment">/*DSA*/</span><br>   <span class="hljs-comment">/*DSA*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stretchToLPath</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">stretchByZag</span> ( _root ); &#125; <span class="hljs-comment">//借助zag旋转，转化为左向单链</span><br>   <span class="hljs-comment">/*DSA*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stretchToRPath</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">stretchByZig</span> ( _root ); &#125; <span class="hljs-comment">//借助zig旋转，转化为右向单链</span><br>   <span class="hljs-comment">/*DSA*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stretch</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;BST_implementation.h&quot;</span></span><br></code></pre></div></td></tr></table></figure><h2 id="BST：查找"><a href="#BST：查找" class="headerlink" title="BST：查找"></a>BST：查找</h2><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>根据BST的局部顺序性进行查找<strong>22</strong>：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8f74bd2d45f56ebcff0a871aa1d33556-fcc84.png" alt="实例"></p><p>减而治之：从根节点出发，逐步地缩小查找范围，直到发现目标（成功），或查找范围缩小至空树（失败）。</p><p>对照中序遍历序列可以看出，整个过程可视作是在仿效有序向量的二分查找。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/33fd93c942368ecd2020a2280e296b8f-6bd1c.png" alt="实现"></p><p>这个算法每递归一次，当前节点V就会下降一层，因此这个算法在最坏情况下的递归深度不会超过树高。所以这个算法所对应的时间复杂度为$O(h)$。</p><p>在每一次深入递归之前，都会修改<code>hot</code>变量。所以hot变量表示刚刚访问的那个非空的节点。</p><h3 id="接口语义"><a href="#接口语义" class="headerlink" title="接口语义"></a>接口语义</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/46bc3d5b1db8ac6c49cd599aa02a401b-34ff4.png" alt="接口语义"></p><h2 id="BST：插入"><a href="#BST：插入" class="headerlink" title="BST：插入"></a>BST：插入</h2><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/ed34524f0c53195b4ee16be52e3fce0a-ef0bb.png" alt="插入"></p><p>由于事先定义了接口语义，所以每当插入时，只要根据<code>hot</code>变量和<code>search</code>方法返回的空节点，就可以知道插入的位置。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>对于首个节点插入之类的边界情况，均可正确处置。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; BinNodePosi&lt;T&gt; BST&lt;T&gt;::<span class="hljs-built_in">insert</span> ( <span class="hljs-keyword">const</span> T&amp; e ) &#123; <span class="hljs-comment">//将关键码e插入BST树中</span><br>   BinNodePosi&lt;T&gt; &amp; x = <span class="hljs-built_in">search</span> ( e ); <span class="hljs-keyword">if</span> ( x ) <span class="hljs-keyword">return</span> x; <span class="hljs-comment">//确认目标不存在（留意对_hot的设置）</span><br>   x = <span class="hljs-keyword">new</span> BinNode&lt;T&gt; ( e, _hot ); <span class="hljs-comment">//创建新节点x：以e为关键码，以_hot为父</span><br>   _size++; <span class="hljs-comment">//更新全树规模</span><br>   <span class="hljs-built_in">updateHeightAbove</span> ( x ); <span class="hljs-comment">//更新x及其历代祖先的高度</span><br>   <span class="hljs-keyword">return</span> x; <span class="hljs-comment">//新插入的节点，必为叶子</span><br>&#125; <span class="hljs-comment">//无论e是否存在于原树中，返回时总有x-&gt;data == e</span><br></code></pre></div></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间消耗主要集中在<code>search</code>和<code>updateHeightAbove</code>，这两个方法在最坏情况下都不会超过整个树的高度。所以总体而言，<code>insert</code>算法的复杂度不过$O(h)$。</p><h2 id="BST：删除"><a href="#BST：删除" class="headerlink" title="BST：删除"></a>BST：删除</h2><h3 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">bool</span> BST&lt;T&gt;::<span class="hljs-built_in">remove</span> ( <span class="hljs-keyword">const</span> T&amp; e ) &#123; <span class="hljs-comment">//从BST树中删除关键码e</span><br>   BinNodePosi&lt;T&gt; &amp; x = <span class="hljs-built_in">search</span> ( e ); <span class="hljs-keyword">if</span> ( !x ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//确认目标存在（留意_hot的设置）</span><br>   <span class="hljs-built_in">removeAt</span> ( x, _hot ); _size--; <span class="hljs-comment">//实施删除</span><br>   <span class="hljs-built_in">updateHeightAbove</span> ( _hot ); <span class="hljs-comment">//更新_hot及其历代祖先的高度</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-comment">//删除成功与否，由返回值指示</span><br></code></pre></div></td></tr></table></figure><h3 id="元素删除"><a href="#元素删除" class="headerlink" title="元素删除"></a>元素删除</h3><h4 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h4><p>若x将要被删除时：</p><ul><li>x只有左子树</li><li>x只有右子树</li><li>x左右子树都没有</li></ul><p>若被删除的元素的某一子树为空，那么可将其替换为另一子树</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/59c021a7d36b1cdcde59a2547e349ad4-65b25.png" alt="情况一"></p><h4 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h4><p>若此时被删除的节点x有左右孩子：</p><ul><li>x的直接后继是x的右孩子</li><li>x的直接后继是x的右子树中的后代</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/11749e9c912565c172ce1fc417250854-2f8cb.png" alt=""></p><p>处理办法：</p><ol><li>先找到x的直接后继w，并互换数据域，相当于等效地将待删除节点转移位置，而且这个位置只有一个分支，且这个分支只可能是右孩子。原因是在BST中x的直接后继是沿着右子树左侧链下行至最后一个，即x在中序遍历下的直接后继</li><li>并将这个右孩子跟新的父亲之间进行双向连接。</li></ol><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/******************************************************************************************</span><br><span class="hljs-comment"> * BST节点删除算法：删除位置x所指的节点（全局静态模板函数，适用于AVL、Splay、RedBlack等各种BST）</span><br><span class="hljs-comment"> * 目标x在此前经查找定位，并确认非NULL，故必删除成功；与searchIn不同，调用之前不必将hot置空</span><br><span class="hljs-comment"> * 返回值指向实际被删除节点的接替者，hot指向实际被删除节点的父亲——二者均有可能是NULL</span><br><span class="hljs-comment"> ******************************************************************************************/</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">static</span> BinNodePosi&lt;T&gt; <span class="hljs-title">removeAt</span> <span class="hljs-params">( BinNodePosi&lt;T&gt; &amp; x, BinNodePosi&lt;T&gt; &amp; hot )</span> </span>&#123;<br>   BinNodePosi&lt;T&gt; w = x; <span class="hljs-comment">//实际被摘除的节点，初值同x</span><br>   BinNodePosi&lt;T&gt; succ = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//实际被删除节点的接替者</span><br>   <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">HasLChild</span> ( *x ) ) <span class="hljs-comment">//若*x的左子树为空，则可</span><br>      succ = x = x-&gt;rc; <span class="hljs-comment">//直接将*x替换为其右子树</span><br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">HasRChild</span> ( *x ) ) <span class="hljs-comment">//若右子树为空，则可</span><br>      succ = x = x-&gt;lc; <span class="hljs-comment">//对称地处理——注意：此时succ != NULL</span><br>   <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//若左右子树均存在，则选择x的直接后继作为实际被摘除节点，为此需要</span><br>      w = w-&gt;<span class="hljs-built_in">succ</span>(); <span class="hljs-comment">//（在右子树中）找到*x的直接后继*w</span><br>      <span class="hljs-built_in">swap</span> ( x-&gt;data, w-&gt;data ); <span class="hljs-comment">//交换*x和*w的数据元素</span><br>      BinNodePosi&lt;T&gt; u = w-&gt;parent;<br>      ( ( u == x ) ? u-&gt;rc : u-&gt;lc ) = succ = w-&gt;rc; <span class="hljs-comment">//隔离节点*w</span><br>   &#125;<br>   hot = w-&gt;parent; <span class="hljs-comment">//记录实际被删除节点的父亲</span><br>   <span class="hljs-keyword">if</span> ( succ ) succ-&gt;parent = hot; <span class="hljs-comment">//并将被删除节点的接替者与hot相联</span><br>   <span class="hljs-built_in">release</span> ( w-&gt;data ); <span class="hljs-built_in">release</span> ( w ); <span class="hljs-keyword">return</span> succ; <span class="hljs-comment">//释放被摘除节点，返回接替者</span><br>&#125; <span class="hljs-comment">//release()负责释放复杂结构，与算法无直接关系，具体实现详见代码包</span><br></code></pre></div></td></tr></table></figure><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>主要取决于<code>removeAt</code>中第二种情况的<code>succ()</code>，所以不会超过$O(h)$。</p><h2 id="BST：平衡与等价"><a href="#BST：平衡与等价" class="headerlink" title="BST：平衡与等价"></a>BST：平衡与等价</h2><h3 id="极端退化"><a href="#极端退化" class="headerlink" title="极端退化"></a>极端退化</h3><p>BST的极端退化成单链，此时的树高等于节点数-1。即最坏情况下的复杂度为$O(n)$。</p><h3 id="平均高度"><a href="#平均高度" class="headerlink" title="平均高度"></a>平均高度</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/fd7daa219940dc908f042198db476fee-f26b4.png" alt="平均高度"></p><h4 id="随机生成"><a href="#随机生成" class="headerlink" title="随机生成"></a>随机生成</h4><p>当关键码总数为n时，可能的生成序列数量为$n!$。$n!$棵BST平均高度为$log_2{n}$。</p><p>但是用这种方式会有重复，所以不可靠。不同的关键码序列，有可能生成同一棵BST。比如2,1,3和2,3,1。</p><p><strong>推广：中位数或者是越接近中位数的关键码越早的被插入，这棵BST的高度也会更低。</strong></p><h4 id="随机组成"><a href="#随机组成" class="headerlink" title="随机组成"></a>随机组成</h4><p>把n个关键码视作n个互异的积木，可能的生成序列数量为$catalan(n)$，$catalan(n)$棵BST平均高度为$\sqrt{n}$。</p><h3 id="平衡度"><a href="#平衡度" class="headerlink" title="平衡度"></a>平衡度</h3><h4 id="理想平衡"><a href="#理想平衡" class="headerlink" title="理想平衡"></a>理想平衡</h4><p>实际应用中，理想平衡可遇不可求</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/027a38c52c96713bc4fec547ba89dcbc-d2d31.png" alt="理想平衡"></p><h4 id="适度平衡"><a href="#适度平衡" class="headerlink" title="适度平衡"></a>适度平衡</h4><p>在理想平衡上放松标准：高度渐进地不超过$O(log_2{n})$，即可称作适度平衡</p><h3 id="等价变换"><a href="#等价变换" class="headerlink" title="等价变换"></a>等价变换</h3><h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><p><strong>中序遍历序列的歧义性：在两棵结构不同的BST中，它们的中序遍历序列有可能是完全雷同的。</strong></p><p>相互等价的BST：拓扑结构不同，但中序遍历序列却相同的任何一对BST。它们的特点有：</p><ul><li>上下可变：联接关系不尽相同，承袭关系可能颠倒。（垂直方向有一定的自由度）</li><li>左右不乱：中序遍历序列完全一致，全局单调非降。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6e37078640deaf598ec70a23fd9d84f9-8d9d9.png" alt="等价"></p><p>所以可以通过以上两点性质，对失衡的BBST重新转换成平衡的BBST</p><h4 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h4><h5 id="zig变换"><a href="#zig变换" class="headerlink" title="zig变换"></a>zig变换</h5><p>在此局部围绕着节点V做顺时针的旋转</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a1e2c49358d12bed1516d828a1b47232-9b56e.png" alt="zig变换"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; BinNodePosi&lt;T&gt; BinNode&lt;T&gt;::<span class="hljs-built_in">zig</span>() &#123; <span class="hljs-comment">//顺时针旋转</span><br>   BinNodePosi&lt;T&gt; lChild = lc;<br>   lChild-&gt;parent = <span class="hljs-keyword">this</span>-&gt;parent;<br>   <span class="hljs-keyword">if</span> ( lChild-&gt;parent )<br>      ( ( <span class="hljs-keyword">this</span> == lChild-&gt;parent-&gt;rc ) ? lChild-&gt;parent-&gt;rc : lChild-&gt;parent-&gt;lc ) = lChild;<br>   lc = lChild-&gt;rc; <span class="hljs-keyword">if</span> ( lc ) lc-&gt;parent = <span class="hljs-keyword">this</span>;<br>   lChild-&gt;rc = <span class="hljs-keyword">this</span>; <span class="hljs-keyword">this</span>-&gt;parent = lChild;<br><span class="hljs-comment">// update heights ()</span><br>   height = <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span> ( <span class="hljs-built_in">stature</span> ( lc ), <span class="hljs-built_in">stature</span> ( rc ) );<br>   lChild-&gt;height = <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span> ( <span class="hljs-built_in">stature</span> ( lChild-&gt;lc ), <span class="hljs-built_in">stature</span> ( lChild-&gt;rc ) );<br>   <span class="hljs-keyword">for</span> ( BinNodePosi&lt;T&gt; x = lChild-&gt;parent; x; x = x-&gt;parent )<br>      <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">HeightUpdated</span>( *x ) )<br>         <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">else</span><br>         x-&gt;height = <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span> ( <span class="hljs-built_in">stature</span> ( x-&gt;lc ), <span class="hljs-built_in">stature</span> ( x-&gt;rc ) );<br>   <span class="hljs-keyword">return</span> lChild;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="zag变换"><a href="#zag变换" class="headerlink" title="zag变换"></a>zag变换</h5><p>在此局部围绕着节点V做逆时针的旋转</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/0bf077b36f707860879db1855dd36e6e-d4ce0.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; BinNodePosi&lt;T&gt; BinNode&lt;T&gt;::<span class="hljs-built_in">zag</span>() &#123; <span class="hljs-comment">//逆时针旋转</span><br>   BinNodePosi&lt;T&gt; rChild = rc;<br>   rChild-&gt;parent = <span class="hljs-keyword">this</span>-&gt;parent;<br>   <span class="hljs-keyword">if</span> ( rChild-&gt;parent )<br>      ( ( <span class="hljs-keyword">this</span> == rChild-&gt;parent-&gt;lc ) ? rChild-&gt;parent-&gt;lc : rChild-&gt;parent-&gt;rc ) = rChild;<br>   rc = rChild-&gt;lc; <span class="hljs-keyword">if</span> ( rc ) rc-&gt;parent = <span class="hljs-keyword">this</span>;<br>   rChild-&gt;lc = <span class="hljs-keyword">this</span>; <span class="hljs-keyword">this</span>-&gt;parent = rChild;<br><span class="hljs-comment">// update heights</span><br>   height = <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span> ( <span class="hljs-built_in">stature</span> ( lc ), <span class="hljs-built_in">stature</span> ( rc ) );<br>   rChild-&gt;height = <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span> ( <span class="hljs-built_in">stature</span> ( rChild-&gt;lc ), <span class="hljs-built_in">stature</span> ( rChild-&gt;rc ) );<br>   <span class="hljs-keyword">for</span> ( BinNodePosi&lt;T&gt; x = rChild-&gt;parent; x; x = x-&gt;parent )<br>      <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">HeightUpdated</span>( *x ) )<br>         <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">else</span><br>         x-&gt;height = <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span> ( <span class="hljs-built_in">stature</span> ( x-&gt;lc ), <span class="hljs-built_in">stature</span> ( x-&gt;rc ) );<br>   <span class="hljs-keyword">return</span> rChild;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图</title>
    <link href="/2020/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E5%9B%BE/"/>
    <url>/2020/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="邻接-关联"><a href="#邻接-关联" class="headerlink" title="邻接+关联"></a>邻接+关联</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/2e7703f8aba252f1fcbbbf602823f70e-b53763.png" alt="邻接+关联"></p><ul><li><p>顶点集V（有限集），边集E</p></li><li><p>存在两两关系：以连边来表示</p></li><li><p>邻接关系：存在连边的任何两个点，这两个点被称为彼此邻接（V~V）</p></li><li><p>关联关系：参与定义邻接关系的每一个顶点，与这个邻接关系之间的关系，被称为关联关系（V~E）</p></li><li><p>序列结构和树结构是图的一种特例，即图更为一般化</p></li><li>任何两个节点之间都允许存在邻接关系</li></ul><h3 id="无向-有向"><a href="#无向-有向" class="headerlink" title="无向+有向"></a>无向+有向</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/fb9debaddcf0bf04c81051583ac4c1d6-e5e8c5.png" alt="无向+有向"></p><ul><li><p>a：无向图</p><ul><li>若邻接顶点u和v的次序无所谓，则（u，v）为无向边</li><li>所有均无方向的图，即无向图</li></ul></li><li><p>b：有向图</p><ul><li>有向图中均为有向边，u、v分别称作边（u，v）的尾和头</li></ul></li><li>c：混合图<ul><li>不仅有无向边，也有有向边</li></ul></li></ul><h3 id="路径-环路"><a href="#路径-环路" class="headerlink" title="路径+环路"></a>路径+环路</h3><ul><li>简单路径：在一条通路中不含重复节点<ul><li>简单环路：路径的终点和起点重合</li></ul></li><li>欧拉环路：经过所有的边一次，而且恰好一次的环路</li><li>哈密尔顿环路：经过所有的顶点一次，而且恰好一次的环路</li></ul><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><h3 id="Graph模板类"><a href="#Graph模板类" class="headerlink" title="Graph模板类"></a>Graph模板类</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/******************************************************************************************</span><br><span class="hljs-comment"> * Data Structures in C++</span><br><span class="hljs-comment"> * ISBN: 7-302-33064-6 &amp; 7-302-33065-3 &amp; 7-302-29652-2 &amp; 7-302-26883-3</span><br><span class="hljs-comment"> * Junhui DENG, deng@tsinghua.edu.cn</span><br><span class="hljs-comment"> * Computer Science &amp; Technology, Tsinghua University</span><br><span class="hljs-comment"> * Copyright (c) 2003-2020. All rights reserved.</span><br><span class="hljs-comment"> ******************************************************************************************/</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><br><span class="hljs-keyword">using</span> VStatus = <span class="hljs-keyword">enum</span> &#123; UNDISCOVERED, DISCOVERED, VISITED &#125;; <span class="hljs-comment">//顶点状态</span><br><span class="hljs-keyword">using</span> EType = <span class="hljs-keyword">enum</span> &#123; UNDETERMINED, TREE, CROSS, FORWARD, BACKWARD &#125;; <span class="hljs-comment">//边在遍历树中所属的类型</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tv, <span class="hljs-keyword">typename</span> Te&gt; <span class="hljs-comment">//顶点类型、边类型</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> &#123;</span> <span class="hljs-comment">//图Graph模板类</span><br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//所有顶点、边的辅助信息复位</span><br>      <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++ ) &#123; <span class="hljs-comment">//所有顶点的</span><br>         <span class="hljs-built_in">status</span> ( i ) = UNDISCOVERED; <span class="hljs-built_in">dTime</span> ( i ) = <span class="hljs-built_in">fTime</span> ( i ) = <span class="hljs-number">-1</span>; <span class="hljs-comment">//状态，时间标签</span><br>         <span class="hljs-built_in">parent</span> ( i ) = <span class="hljs-number">-1</span>; <span class="hljs-built_in">priority</span> ( i ) = INT_MAX; <span class="hljs-comment">//（在遍历树中的）父节点，优先级数</span><br>         <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++ ) <span class="hljs-comment">//所有边的</span><br>            <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">exists</span> ( i, j ) ) <span class="hljs-built_in">type</span> ( i, j ) = UNDETERMINED; <span class="hljs-comment">//类型</span><br>      &#125;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BFS</span> <span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&amp; )</span></span>; <span class="hljs-comment">//（连通域）广度优先搜索算法</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span> <span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&amp; )</span></span>; <span class="hljs-comment">//（连通域）深度优先搜索算法</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BCC</span> <span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&amp;, Stack&lt;<span class="hljs-keyword">int</span>&gt;&amp; )</span></span>; <span class="hljs-comment">//（连通域）基于DFS的双连通分量分解算法</span><br>   <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">TSort</span> <span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&amp;, Stack&lt;Tv&gt;* )</span></span>; <span class="hljs-comment">//（连通域）基于DFS的拓扑排序算法</span><br>   <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> PU&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PFS</span> <span class="hljs-params">( <span class="hljs-keyword">int</span>, PU )</span></span>; <span class="hljs-comment">//（连通域）优先级搜索框架</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 顶点</span><br>   <span class="hljs-keyword">int</span> n; <span class="hljs-comment">//顶点总数</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span> <span class="hljs-params">( Tv <span class="hljs-keyword">const</span>&amp; )</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//插入顶点，返回编号</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> Tv <span class="hljs-title">remove</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> )</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//删除顶点及其关联边，返回该顶点信息</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> Tv&amp; <span class="hljs-title">vertex</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> )</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//顶点v的数据（该顶点的确存在）</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">inDegree</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> )</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//顶点v的入度（该顶点的确存在）</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">outDegree</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> )</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//顶点v的出度（该顶点的确存在）</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstNbr</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> )</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//顶点v的首个邻接顶点</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextNbr</span> <span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span> )</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//顶点v的（相对于顶点j的）下一邻接顶点</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> VStatus&amp; <span class="hljs-title">status</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> )</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//顶点v的状态</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span>&amp; <span class="hljs-title">dTime</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> )</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//顶点v的时间标签dTime</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span>&amp; <span class="hljs-title">fTime</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> )</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//顶点v的时间标签fTime</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span>&amp; <span class="hljs-title">parent</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> )</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//顶点v在遍历树中的父亲</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span>&amp; <span class="hljs-title">priority</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> )</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//顶点v在遍历树中的优先级数</span><br><span class="hljs-comment">// 边：这里约定，无向边均统一转化为方向互逆的一对有向边，从而将无向图视作有向图的特例</span><br>   <span class="hljs-keyword">int</span> e; <span class="hljs-comment">//边总数</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">exists</span> <span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span> )</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//边(v, u)是否存在</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span> <span class="hljs-params">( Te <span class="hljs-keyword">const</span>&amp;, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span> )</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//在顶点v和u之间插入权重为w的边e</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> Te <span class="hljs-title">remove</span> <span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span> )</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//删除顶点v和u之间的边e，返回该边信息</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> EType &amp; <span class="hljs-title">type</span> <span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span> )</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//边(v, u)的类型</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> Te&amp; <span class="hljs-title">edge</span> <span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span> )</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//边(v, u)的数据（该边的确存在）</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span>&amp; <span class="hljs-title">weight</span> <span class="hljs-params">( <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span> )</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//边(v, u)的权重</span><br><span class="hljs-comment">// 算法</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> )</span></span>; <span class="hljs-comment">//广度优先搜索算法</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> )</span></span>; <span class="hljs-comment">//深度优先搜索算法</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bcc</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> )</span></span>; <span class="hljs-comment">//基于DFS的双连通分量分解算法</span><br>   <span class="hljs-function">Stack&lt;Tv&gt;* <span class="hljs-title">tSort</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> )</span></span>; <span class="hljs-comment">//基于DFS的拓扑排序算法</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">prim</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> )</span></span>; <span class="hljs-comment">//最小支撑树Prim算法</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> )</span></span>; <span class="hljs-comment">//最短路径Dijkstra算法</span><br>   <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> PU&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pfs</span> <span class="hljs-params">( <span class="hljs-keyword">int</span>, PU )</span></span>; <span class="hljs-comment">//优先级搜索框架</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Graph_implementation.h&quot;</span></span><br></code></pre></div></td></tr></table></figure><h3 id="邻接矩阵与关联矩阵"><a href="#邻接矩阵与关联矩阵" class="headerlink" title="邻接矩阵与关联矩阵"></a>邻接矩阵与关联矩阵</h3><h4 id="邻接矩阵-1"><a href="#邻接矩阵-1" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7cd1d83f27412a3fa01164e489575f4a-f8c96.png" alt="邻接矩阵"></p><ul><li>图有<strong>n</strong>个顶点，就构造一个$n*n$的矩阵</li><li>第<strong>i</strong>行第<strong>j</strong>列的那个单元中，存储<strong>顶点i</strong>和<strong>顶点j</strong>的邻接关系。比如<strong>1</strong>代表邻接，<strong>0</strong>代表不邻接</li><li>如果是<strong>无向图</strong>，那么对应的邻接矩阵应该是对称的。也就是说第<strong>i</strong>行第<strong>j</strong>列的元素和第<strong>j</strong>行第<strong>i</strong>列的元素雷同。在对角线上的元素，为<strong>自环</strong>。</li><li>如果是带权图，那么矩阵单元内只需要存储整型的$w$。</li></ul><h4 id="关联矩阵"><a href="#关联矩阵" class="headerlink" title="关联矩阵"></a>关联矩阵</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8e3e1ccfed164227df68afdf3dc481d9-d6690.png" alt="关联矩阵"></p><ul><li>图有<strong>n</strong>个顶点，<strong>e</strong>条边，就构造一个<strong>n</strong>行<strong>e</strong>列的矩阵。</li><li>矩阵单元内存储着对应的点和边之间的关联关系。如果存在关联关系，就存<strong>1</strong>；否则就存<strong>0</strong></li><li>关联矩阵的每一列中，应该恰好只有两个单元的数值为<strong>1</strong>，其余的都是<strong>0</strong></li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/1c38542f9eafdd1a230f4689079c1ddf-ecd0d.png" alt="实例"></p><ul><li>双向边在矩阵内都会有多余的表示</li></ul><h3 id="顶点与边"><a href="#顶点与边" class="headerlink" title="顶点与边"></a>顶点与边</h3><h4 id="顶点的封装"><a href="#顶点的封装" class="headerlink" title="顶点的封装"></a>顶点的封装</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tv&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vertex</span> &#123;</span> <span class="hljs-comment">//顶点对象（为简化起见，并未严格封装）</span><br>   Tv data; <span class="hljs-keyword">int</span> inDegree, outDegree; VStatus status; <span class="hljs-comment">//数据、出入度数、状态</span><br>   <span class="hljs-keyword">int</span> dTime, fTime; <span class="hljs-comment">//时间标签</span><br>   <span class="hljs-keyword">int</span> parent; <span class="hljs-keyword">int</span> priority; <span class="hljs-comment">//在遍历树中的父节点、优先级数</span><br>   <span class="hljs-built_in">Vertex</span> ( Tv <span class="hljs-keyword">const</span>&amp; d = ( Tv ) <span class="hljs-number">0</span> ) : <span class="hljs-comment">//构造新顶点</span><br>      <span class="hljs-built_in">data</span> ( d ), <span class="hljs-built_in">inDegree</span> ( <span class="hljs-number">0</span> ), <span class="hljs-built_in">outDegree</span> ( <span class="hljs-number">0</span> ), <span class="hljs-built_in">status</span> ( UNDISCOVERED ),<br>      <span class="hljs-built_in">dTime</span> ( <span class="hljs-number">-1</span> ), <span class="hljs-built_in">fTime</span> ( <span class="hljs-number">-1</span> ), <span class="hljs-built_in">parent</span> ( <span class="hljs-number">-1</span> ), <span class="hljs-built_in">priority</span> ( INT_MAX ) &#123;&#125; <span class="hljs-comment">//暂不考虑权重溢出</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h4 id="边的封装"><a href="#边的封装" class="headerlink" title="边的封装"></a>边的封装</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Te&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span> <span class="hljs-comment">//边对象（为简化起见，并未严格封装）</span><br>   Te data; <span class="hljs-keyword">int</span> weight; EType type; <span class="hljs-comment">//数据、权重、类型</span><br>   <span class="hljs-built_in">Edge</span> ( Te <span class="hljs-keyword">const</span>&amp; d, <span class="hljs-keyword">int</span> w ) : <span class="hljs-built_in">data</span> ( d ), <span class="hljs-built_in">weight</span> ( w ), <span class="hljs-built_in">type</span> ( UNDETERMINED ) &#123;&#125; <span class="hljs-comment">//构造</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="基于邻接矩阵的图结构"><a href="#基于邻接矩阵的图结构" class="headerlink" title="基于邻接矩阵的图结构"></a>基于邻接矩阵的图结构</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/967cf4db4ebc50f178954ee4fc9b5397-fe2d9.png" alt="基于邻接矩阵的图结构"></p><h3 id="对顶点的静态操作"><a href="#对顶点的静态操作" class="headerlink" title="对顶点的静态操作"></a>对顶点的静态操作</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> Tv&amp; <span class="hljs-title">vertex</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> i )</span> </span>&#123; <span class="hljs-keyword">return</span> V[i].data; &#125; <span class="hljs-comment">//数据</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">inDegree</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> i )</span> </span>&#123; <span class="hljs-keyword">return</span> V[i].inDegree; &#125; <span class="hljs-comment">//入度</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">outDegree</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> i )</span> </span>&#123; <span class="hljs-keyword">return</span> V[i].outDegree; &#125; <span class="hljs-comment">//出度</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstNbr</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> i )</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">nextNbr</span> ( i, n ); &#125; <span class="hljs-comment">//首个邻接顶点</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextNbr</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j )</span> <span class="hljs-comment">//相对于顶点j的下一邻接顶点（改用邻接表可提高效率）</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">while</span> ( ( <span class="hljs-number">-1</span> &lt; j ) &amp;&amp; ( !<span class="hljs-built_in">exists</span> ( i, --j ) ) ); <span class="hljs-keyword">return</span> j; &#125; <span class="hljs-comment">//逆向线性试探</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> VStatus&amp; <span class="hljs-title">status</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> i )</span> </span>&#123; <span class="hljs-keyword">return</span> V[i].status; &#125; <span class="hljs-comment">//状态</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span>&amp; <span class="hljs-title">dTime</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> i )</span> </span>&#123; <span class="hljs-keyword">return</span> V[i].dTime; &#125; <span class="hljs-comment">//时间标签dTime</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span>&amp; <span class="hljs-title">fTime</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> i )</span> </span>&#123; <span class="hljs-keyword">return</span> V[i].fTime; &#125; <span class="hljs-comment">//时间标签fTime</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span>&amp; <span class="hljs-title">parent</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> i )</span> </span>&#123; <span class="hljs-keyword">return</span> V[i].parent; &#125; <span class="hljs-comment">//在遍历树中的父亲</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span>&amp; <span class="hljs-title">priority</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> i )</span> </span>&#123; <span class="hljs-keyword">return</span> V[i].priority; &#125; <span class="hljs-comment">//在遍历树中的优先级数</span><br></code></pre></div></td></tr></table></figure><h4 id="查找顶点的邻居"><a href="#查找顶点的邻居" class="headerlink" title="查找顶点的邻居"></a>查找顶点的邻居</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstNbr</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> i )</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">nextNbr</span> ( i, n ); &#125; <span class="hljs-comment">//首个邻接顶点</span><br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextNbr</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j )</span> <span class="hljs-comment">//相对于顶点j的下一邻接顶点（改用邻接表可提高效率）</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">while</span> ( ( <span class="hljs-number">-1</span> &lt; j ) &amp;&amp; ( !<span class="hljs-built_in">exists</span> ( i, --j ) ) ); <span class="hljs-keyword">return</span> j; &#125; <span class="hljs-comment">//逆向线性试探</span><br></code></pre></div></td></tr></table></figure><ul><li>n为行向量的长度，n可视为一个假想的哨兵</li></ul><h3 id="对边的操作"><a href="#对边的操作" class="headerlink" title="对边的操作"></a>对边的操作</h3><h4 id="边的存在"><a href="#边的存在" class="headerlink" title="边的存在"></a>边的存在</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">exists</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j )</span> <span class="hljs-comment">//边(i, j)是否存在</span></span><br><span class="hljs-function">   </span>&#123; <span class="hljs-keyword">return</span> ( <span class="hljs-number">0</span> &lt;= i ) &amp;&amp; ( i &lt; n ) &amp;&amp; ( <span class="hljs-number">0</span> &lt;= j ) &amp;&amp; ( j &lt; n ) &amp;&amp; E[i][j] != <span class="hljs-literal">NULL</span>; &#125;<br></code></pre></div></td></tr></table></figure><h4 id="边的信息"><a href="#边的信息" class="headerlink" title="边的信息"></a>边的信息</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//边的基本操作：查询顶点i与j之间的联边（0 &lt;= i, j &lt; n且exists(i, j)）</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> EType &amp; <span class="hljs-title">type</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j )</span> </span>&#123; <span class="hljs-keyword">return</span> E[i][j]-&gt;type; &#125; <span class="hljs-comment">//边(i, j)的类型</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> Te&amp; <span class="hljs-title">edge</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j )</span> </span>&#123; <span class="hljs-keyword">return</span> E[i][j]-&gt;data; &#125; <span class="hljs-comment">//边(i, j)的数据</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span>&amp; <span class="hljs-title">weight</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j )</span> </span>&#123; <span class="hljs-keyword">return</span> E[i][j]-&gt;weight; &#125; <span class="hljs-comment">//边(i, j)的权重</span><br></code></pre></div></td></tr></table></figure><h4 id="边的插入"><a href="#边的插入" class="headerlink" title="边的插入"></a>边的插入</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span> <span class="hljs-params">( Te <span class="hljs-keyword">const</span>&amp; edge, <span class="hljs-keyword">int</span> w, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j )</span> </span>&#123; <span class="hljs-comment">//插入权重为w的边e = (i, j)</span><br>   <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">exists</span> ( i, j ) ) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//确保该边尚不存在</span><br>   E[i][j] = <span class="hljs-keyword">new</span> Edge&lt;Te&gt; ( edge, w ); <span class="hljs-comment">//创建新边</span><br>   e++; V[i].outDegree++; V[j].inDegree++; <span class="hljs-comment">//更新边计数与关联顶点的度数</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="边的删除"><a href="#边的删除" class="headerlink" title="边的删除"></a>边的删除</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> Te <span class="hljs-title">remove</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j )</span> </span>&#123; <span class="hljs-comment">//删除顶点i和j之间的联边（exists(i, j)）</span><br>      Te eBak = <span class="hljs-built_in">edge</span> ( i, j ); <span class="hljs-keyword">delete</span> E[i][j]; E[i][j] = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//备份后删除边记录</span><br>      e--; V[i].outDegree--; V[j].inDegree--; <span class="hljs-comment">//更新边计数与关联顶点的度数</span><br>      <span class="hljs-keyword">return</span> eBak; <span class="hljs-comment">//返回被删除边的信息</span><br>   &#125;<br></code></pre></div></td></tr></table></figure><h3 id="对顶点的动态操作"><a href="#对顶点的动态操作" class="headerlink" title="对顶点的动态操作"></a>对顶点的动态操作</h3><h4 id="顶点的插入"><a href="#顶点的插入" class="headerlink" title="顶点的插入"></a>顶点的插入</h4><ol><li>首先将邻接矩阵中，已有的各行分别向后扩展一个单元（即增加一列）。</li><li>在邻接矩阵中增加对应的一行，即增加一行行向量。</li><li>在第一级的边表中，增加一个相应的单元，用来记录新引入的行向量（第二步）。</li><li>在顶点向量中加入一个新的对应元素。</li></ol><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span> <span class="hljs-params">( Tv <span class="hljs-keyword">const</span>&amp; vertex )</span> </span>&#123; <span class="hljs-comment">//插入顶点，返回编号</span><br>      <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++ ) E[j].<span class="hljs-built_in">insert</span> ( <span class="hljs-literal">NULL</span> ); n++; <span class="hljs-comment">//各顶点预留一条潜在的关联边</span><br>      E.<span class="hljs-built_in">insert</span> ( Vector&lt;Edge&lt;Te&gt;*&gt; ( n, n, ( Edge&lt;Te&gt;* ) <span class="hljs-literal">NULL</span> ) ); <span class="hljs-comment">//创建新顶点对应的边向量</span><br>      <span class="hljs-keyword">return</span> V.<span class="hljs-built_in">insert</span> ( Vertex&lt;Tv&gt; ( vertex ) ); <span class="hljs-comment">//顶点向量增加一个顶点</span><br>   &#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/e4795d5a0303e6e2f38daf765003c4fc-8239d.png" alt="顶点的插入"></p><h4 id="顶点的删除"><a href="#顶点的删除" class="headerlink" title="顶点的删除"></a>顶点的删除</h4><p>即顶点插入的逆过程</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> Tv <span class="hljs-title">remove</span> <span class="hljs-params">( <span class="hljs-keyword">int</span> i )</span> </span>&#123; <span class="hljs-comment">//删除第i个顶点及其关联边（0 &lt;= i &lt; n）</span><br>      <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++ ) <span class="hljs-comment">//所有出边</span><br>         <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">exists</span> ( i, j ) ) &#123; <span class="hljs-keyword">delete</span> E[i][j]; V[j].inDegree--; e--; &#125; <span class="hljs-comment">//逐条删除</span><br>      E.<span class="hljs-built_in">remove</span> ( i ); n--; <span class="hljs-comment">//删除第i行</span><br>      Tv vBak = <span class="hljs-built_in">vertex</span> ( i ); V.<span class="hljs-built_in">remove</span> ( i ); <span class="hljs-comment">//删除顶点i</span><br>      <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++ ) <span class="hljs-comment">//所有入边</span><br>         <span class="hljs-keyword">if</span> ( Edge&lt;Te&gt; * x = E[j].<span class="hljs-built_in">remove</span> ( i ) ) &#123; <span class="hljs-keyword">delete</span> x; V[j].outDegree--; e--; &#125; <span class="hljs-comment">//逐条删除</span><br>      <span class="hljs-keyword">return</span> vBak; <span class="hljs-comment">//返回被删除顶点的信息</span><br>   &#125;<br></code></pre></div></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li>判断两点之间是否存在联边：$O(1)$</li><li>获取顶点的（出/入）度数：$O(1)$</li><li>添加、删除边后更新度数：$O(1)$</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>直观，易于理解和实现</li><li>适用范围广泛：<ul><li>digraph</li><li>network</li><li>cyclic</li><li>dense graph</li></ul></li><li>扩展性：得益于Vector良好的空间控制策略，空间溢出等情况可以”透明地“予以处理</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p><strong>平面图：可嵌入于平面的图，相邻的边不会交叉</strong></p><p>欧拉公式中，v：顶点数；e：边数；f：区域面片的总数；c：连通域的总数。</p><script type="math/tex; mode=display">v - e + f - c = 1</script><p>对于平面图来说，它的边数不会超过顶点数n。但是一个邻接矩阵的空间占用达到了$n^2$。此时的空间利用率约等于$1/n$，空间利用率极低。</p><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/d4dd35ad73f0f19d1d2a7314fc671537-9880e.png" alt="策略"></p><ul><li><p>按照与起点S的距离，将所有的顶点划分为等价类</p></li><li><p>在同一等价类的内部，各顶点的边都不会被采纳</p></li><li><p>只有连接相邻等价类的某些边，才会被采纳</p></li><li><p>即避开环路，将原先的图构成一个极大的无环图，也就是树。这棵树中涵盖了图的所有顶点，所以也叫支撑树</p></li><li>这样的遍历过程类似于树的层次遍历</li><li>每个顶点与s之间的那条通路，恰好就是在原图中，这两个顶点之间的那条最短通路</li></ul><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tv, <span class="hljs-keyword">typename</span> Te&gt; <span class="hljs-comment">//广度优先搜索BFS算法（全图）</span><br><span class="hljs-keyword">void</span> Graph&lt;Tv, Te&gt;::<span class="hljs-built_in">bfs</span> ( <span class="hljs-keyword">int</span> s ) &#123; <span class="hljs-comment">//assert: 0 &lt;= s &lt; n</span><br>   <span class="hljs-built_in">reset</span>(); <span class="hljs-keyword">int</span> clock = <span class="hljs-number">0</span>; <span class="hljs-keyword">int</span> v = s; <span class="hljs-comment">//初始化</span><br>   <span class="hljs-keyword">do</span> <span class="hljs-comment">//逐一检查所有顶点</span><br>      <span class="hljs-keyword">if</span> ( UNDISCOVERED == <span class="hljs-built_in">status</span> ( v ) ) <span class="hljs-comment">//一旦遇到尚未发现的顶点</span><br>         <span class="hljs-built_in">BFS</span> ( v, clock ); <span class="hljs-comment">//即从该顶点出发启动一次BFS</span><br>   <span class="hljs-keyword">while</span> ( s != ( v = ( ++v % n ) ) ); <span class="hljs-comment">//按序号检查，故不漏不重</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tv, <span class="hljs-keyword">typename</span> Te&gt; <span class="hljs-comment">//广度优先搜索BFS算法（单个连通域）</span><br><span class="hljs-keyword">void</span> Graph&lt;Tv, Te&gt;::<span class="hljs-built_in">BFS</span> ( <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span>&amp; clock ) &#123; <span class="hljs-comment">//assert: 0 &lt;= v &lt; n</span><br>   Queue&lt;<span class="hljs-keyword">int</span>&gt; Q; <span class="hljs-comment">//引入辅助队列</span><br>   <span class="hljs-built_in">status</span> ( v ) = DISCOVERED; Q.<span class="hljs-built_in">enqueue</span> ( v ); <span class="hljs-comment">//初始化起点</span><br>   <span class="hljs-keyword">while</span> ( !Q.<span class="hljs-built_in">empty</span>() ) &#123; <span class="hljs-comment">//在Q变空之前，不断</span><br>      <span class="hljs-keyword">int</span> v = Q.<span class="hljs-built_in">dequeue</span>(); <span class="hljs-built_in">dTime</span> ( v ) = ++clock; <span class="hljs-comment">//取出队首顶点v</span><br>      <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> u = <span class="hljs-built_in">firstNbr</span> ( v ); <span class="hljs-number">-1</span> &lt; u; u = <span class="hljs-built_in">nextNbr</span> ( v, u ) ) <span class="hljs-comment">//枚举v的所有邻居u</span><br>         <span class="hljs-keyword">if</span> ( UNDISCOVERED == <span class="hljs-built_in">status</span> ( u ) ) &#123; <span class="hljs-comment">//若u尚未被发现，则</span><br>            <span class="hljs-built_in">status</span> ( u ) = DISCOVERED; Q.<span class="hljs-built_in">enqueue</span> ( u ); <span class="hljs-comment">//发现该顶点</span><br>            <span class="hljs-built_in">type</span> ( v, u ) = TREE; <span class="hljs-built_in">parent</span> ( u ) = v; <span class="hljs-comment">//引入树边拓展支撑树</span><br>         &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//若u已被发现，或者甚至已访问完毕，则</span><br>            <span class="hljs-built_in">type</span> ( v, u ) = CROSS; <span class="hljs-comment">//将(v, u)归类于跨边</span><br>         &#125;<br>      <span class="hljs-built_in">status</span> ( v ) = VISITED; <span class="hljs-comment">//至此，当前顶点访问完毕</span><br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="算法细节"><a href="#算法细节" class="headerlink" title="算法细节"></a>算法细节</h4><p>在算法开始时，将除了开始顶点的其余顶点的状态设置<code>UNDISCOVERED</code>，开始顶点的状态设置<code>DISCOVERED</code>并入队。为每条边的状态设置为<code>UNDETERMINED</code>。</p><p>当前顶点v找到的邻居u的状态：</p><ul><li>如果为<code>UNDISCOVERED</code>，即未被发现的状态，那么将u的状态设置为<code>DISCOVERED</code>，再将u入队。并且采纳v和u的边，同时将边的状态设置为<code>TREE</code>。<ul><li>TREE 边的数量总是等于顶点数减去连通分量的数量</li></ul></li><li><p>如果为<code>DISCOVERED</code>，即已经被发现的状态，说明顶点u此时在队列中，或者已出队。那么将v和u的边的状态设置为<code>CROSS</code>。</p></li><li><p>除了开始顶点，其余顶点皆会通过某种处理方式忽略掉父亲</p></li><li>整个遍历的最终产物是一棵遍历支撑树</li><li>顶点v所属的那个连通域，可以被悉数的遍历</li></ul><h3 id="实例（无向图）"><a href="#实例（无向图）" class="headerlink" title="实例（无向图）"></a>实例（无向图）</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6b398d528b0f0bc2b3fa4a5803ade1b8-69eab.png" alt="实例1"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f35f98ae5bd756781af06ec6697fed09-eeed8.png" alt="实例（无向图）"></p><h3 id="多连通域的搜索"><a href="#多连通域的搜索" class="headerlink" title="多连通域的搜索"></a>多连通域的搜索</h3><p>对每个连通域启动并只启动一次广域优先搜索，因此所有花费在搜索上的时间，累计也不过对全图的一次遍历</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/fa37dcb6ecedd1cae1721cefce5b832f-1f3cd.png" alt="多连通"></p><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>由于邻接矩阵采用的Vector在物理上连续，所以访问邻接矩阵中的元素实际上是在高速缓存中，速度会非常的快。因为这个原因，理论上分析的复杂度$O(n^2)$会变为$O(n+e)$。</p><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><h3 id="策略-1"><a href="#策略-1" class="headerlink" title="策略"></a>策略</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/bed59779b197dc31a8413c1b7083499b-e9e79.png" alt="策略"></p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tv, <span class="hljs-keyword">typename</span> Te&gt; <span class="hljs-comment">//深度优先搜索DFS算法（全图）</span><br><span class="hljs-keyword">void</span> Graph&lt;Tv, Te&gt;::<span class="hljs-built_in">dfs</span> ( <span class="hljs-keyword">int</span> s ) &#123; <span class="hljs-comment">//assert: 0 &lt;= s &lt; n</span><br>   <span class="hljs-built_in">reset</span>(); <span class="hljs-keyword">int</span> clock = <span class="hljs-number">0</span>; <span class="hljs-keyword">int</span> v = s; <span class="hljs-comment">//初始化</span><br>   <span class="hljs-keyword">do</span> <span class="hljs-comment">//逐一检查所有顶点</span><br>      <span class="hljs-keyword">if</span> ( UNDISCOVERED == <span class="hljs-built_in">status</span> ( v ) ) <span class="hljs-comment">//一旦遇到尚未发现的顶点</span><br>         <span class="hljs-built_in">DFS</span> ( v, clock ); <span class="hljs-comment">//即从该顶点出发启动一次DFS</span><br>   <span class="hljs-keyword">while</span> ( s != ( v = ( ++v % n ) ) ); <span class="hljs-comment">//按序号检查，故不漏不重</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tv, <span class="hljs-keyword">typename</span> Te&gt; <span class="hljs-comment">//深度优先搜索DFS算法（单个连通域）</span><br><span class="hljs-keyword">void</span> Graph&lt;Tv, Te&gt;::<span class="hljs-built_in">DFS</span> ( <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span>&amp; clock ) &#123; <span class="hljs-comment">//assert: 0 &lt;= v &lt; n</span><br>   <span class="hljs-built_in">dTime</span> ( v ) = ++clock; <span class="hljs-built_in">status</span> ( v ) = DISCOVERED; <span class="hljs-comment">//发现当前顶点v</span><br>   <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> u = <span class="hljs-built_in">firstNbr</span> ( v ); <span class="hljs-number">-1</span> &lt; u; u = <span class="hljs-built_in">nextNbr</span> ( v, u ) ) <span class="hljs-comment">//枚举v的所有邻居u</span><br>      <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> ( <span class="hljs-built_in">status</span> ( u ) ) &#123; <span class="hljs-comment">//并视其状态分别处理</span><br>         <span class="hljs-keyword">case</span> UNDISCOVERED: <span class="hljs-comment">//u尚未发现，意味着支撑树可在此拓展</span><br>            <span class="hljs-built_in">type</span> ( v, u ) = TREE; <span class="hljs-built_in">parent</span> ( u ) = v; <span class="hljs-built_in">DFS</span> ( u, clock ); <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> DISCOVERED: <span class="hljs-comment">//u已被发现但尚未访问完毕，应属被后代指向的祖先</span><br>            <span class="hljs-built_in">type</span> ( v, u ) = BACKWARD; <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>: <span class="hljs-comment">//u已访问完毕（VISITED，有向图），则视承袭关系分为前向边或跨边</span><br>            <span class="hljs-built_in">type</span> ( v, u ) = ( <span class="hljs-built_in">dTime</span> ( v ) &lt; <span class="hljs-built_in">dTime</span> ( u ) ) ? FORWARD : CROSS; <span class="hljs-keyword">break</span>;<br>      &#125;<br>   <span class="hljs-built_in">status</span> ( v ) = VISITED; <span class="hljs-built_in">fTime</span> ( v ) = ++clock; <span class="hljs-comment">//至此，当前顶点v方告访问完毕</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="算法细节-1"><a href="#算法细节-1" class="headerlink" title="算法细节"></a>算法细节</h4><p>当前顶点v找到的邻居u的状态：</p><ul><li><code>UNDISCOVERED</code>：意味着可以从当前顶点u继续拓展，将v通往u的这条边引入到遍历树中，即设置这条边的状态为<code>TREE</code>，将顶点u的父亲设置为v，并将控制权交给顶点u。然后按照策略递归的执行<code>DFS</code>。</li><li><code>DISCOVERED</code>：将v到u的边的状态设置为<code>BACKWARD</code>，即<strong>回向边</strong>。<ul><li>回向边：试图从一个后代去回连到它的祖先。一旦发现了一条回向边，就说明至少出现了一条回路。</li></ul></li><li>default：此时代表u已经被访问完毕，也就是处于最终的<code>VISITED</code>状态，此时判断v和u的<code>dTime</code>大小<ul><li>如果是v更早被发现，就将v到u的边设置为<code>FORWARD</code>，也就是前向边<ul><li>前向边：由遍历树中的祖先节点向前，指向它的后代</li></ul></li><li>如果是u更早被发现，就将v到u的边设置为<code>CROSS</code>，也就是交叉边或跨越边。<ul><li>跨越边：他们的祖先没有直系血缘关系，即他们是姑表亲</li></ul></li></ul></li></ul><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><h4 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/0f8256565d0cf5cf275c8f33b90745c1-2816c.png" alt="无向图"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5ff759952019ed4d149a1082189f7df8-00981.png" alt="无向图"></p><h4 id="有向图及多可达域"><a href="#有向图及多可达域" class="headerlink" title="有向图及多可达域"></a>有向图及多可达域</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/e68472203257620196b4919c2c82956b-002ba.png" alt="有向图"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/405f29d8657dd134bf458822bbb3b891-b75e1.png" alt="有向图"></p><p>从顶点a出发，遍历了它的<strong>可达区域</strong>。</p><p>为了遍历所有的顶点，可以采用BFS中的迭代策略：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/2f3adca2b70ace359dd4dc9fed1c3c82-e7dad.png" alt="迭代策略"></p><h3 id="括号引理（嵌套引理）"><a href="#括号引理（嵌套引理）" class="headerlink" title="括号引理（嵌套引理）"></a>括号引理（嵌套引理）</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/0c3b130c7be6b4dd6e810062ce304ff2-07bde.png" alt="括号引理（嵌套引理"></p><ul><li><p>祖先的活跃期必然包含后代的活跃期</p></li><li><p>如果两个顶点没有血缘关系，那么这两个顶点的活跃期彼此互不相交</p></li></ul><p><strong>作用：</strong>借助时间标签，可以在O(1)的时间内获得两个顶点是否有血缘关系</p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/61f762263aea08abab4bf1cc95cda661-6c114.png" alt="应用"></p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/cd01999f3f36b23847d4a46d7b95e62f-a2461.png" alt="排序"></p><h3 id="零入度算法"><a href="#零入度算法" class="headerlink" title="零入度算法"></a>零入度算法</h3><h4 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h4><ul><li>每次找到一个零入度的顶点，并从图中删除，入队。同时删除连接的边</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5a7e61e9f9abea8eec970b4046163eb4-abeb9.png" alt="构思"></p><p>这种方法有几个缺点：</p><ul><li>每次都要查找零入度的点</li><li>对于顶点和边的删除，会对图的结构进行破坏</li></ul><h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/bbeca65c6a82ebf6eff27fff966f8f9a-65626.png" alt="算法"></p><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/fbe4f6da3dcb9ddc5b2b580fee700786-2addc.png" alt="实例"></p><h3 id="零出度算法"><a href="#零出度算法" class="headerlink" title="零出度算法"></a>零出度算法</h3><h4 id="构思-1"><a href="#构思-1" class="headerlink" title="构思"></a>构思</h4><p>与DFS类似：</p><ul><li>从随机的一个点开始运用DFS</li><li>只要遇到一条backtrack，就将当前的顶点入栈</li></ul><p>重复以上过程，直到所有的顶点被遍历</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/307edaf0240f09806df066278051f081-d8221.png" alt="构思"></p><h4 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tv, <span class="hljs-keyword">typename</span> Te&gt; <span class="hljs-comment">//基于DFS的拓扑排序算法</span><br>Stack&lt;Tv&gt;* Graph&lt;Tv, Te&gt;::<span class="hljs-built_in">tSort</span> ( <span class="hljs-keyword">int</span> s ) &#123; <span class="hljs-comment">//assert: 0 &lt;= s &lt; n</span><br>   <span class="hljs-built_in">reset</span>(); <span class="hljs-keyword">int</span> clock = <span class="hljs-number">0</span>; <span class="hljs-keyword">int</span> v = s;<br>   Stack&lt;Tv&gt;* S = <span class="hljs-keyword">new</span> Stack&lt;Tv&gt;; <span class="hljs-comment">//用栈记录排序顶点</span><br>   <span class="hljs-keyword">do</span> &#123;<br>      <span class="hljs-keyword">if</span> ( UNDISCOVERED == <span class="hljs-built_in">status</span> ( v ) )<br>         <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">TSort</span> ( v, clock, S ) ) &#123; <span class="hljs-comment">//clock并非必需</span><br>            <span class="hljs-comment">/*DSA*/</span><span class="hljs-built_in">print</span> ( S );<br>            <span class="hljs-keyword">while</span> ( !S-&gt;<span class="hljs-built_in">empty</span>() ) <span class="hljs-comment">//任一连通域（亦即整图）非DAG</span><br>               S-&gt;<span class="hljs-built_in">pop</span>(); <span class="hljs-keyword">break</span>; <span class="hljs-comment">//则不必继续计算，故直接返回</span><br>         &#125;<br>   &#125; <span class="hljs-keyword">while</span> ( s != ( v = ( ++v % n ) ) );<br>   <span class="hljs-keyword">return</span> S; <span class="hljs-comment">//若输入为DAG，则S内各顶点自顶向底排序；否则（不存在拓扑排序），S空</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tv, <span class="hljs-keyword">typename</span> Te&gt; <span class="hljs-comment">//基于DFS的拓扑排序算法（单趟）</span><br><span class="hljs-keyword">bool</span> Graph&lt;Tv, Te&gt;::<span class="hljs-built_in">TSort</span> ( <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span>&amp; clock, Stack&lt;Tv&gt;* S ) &#123; <span class="hljs-comment">//assert: 0 &lt;= v &lt; n</span><br>   <span class="hljs-built_in">dTime</span> ( v ) = ++clock; <span class="hljs-built_in">status</span> ( v ) = DISCOVERED; <span class="hljs-comment">//发现顶点v</span><br>   <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> u = <span class="hljs-built_in">firstNbr</span> ( v ); <span class="hljs-number">-1</span> &lt; u; u = <span class="hljs-built_in">nextNbr</span> ( v, u ) ) <span class="hljs-comment">//枚举v的所有邻居u</span><br>      <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> ( <span class="hljs-built_in">status</span> ( u ) ) &#123; <span class="hljs-comment">//并视u的状态分别处理</span><br>         <span class="hljs-keyword">case</span> UNDISCOVERED:<br>            <span class="hljs-built_in">parent</span> ( u ) = v; <span class="hljs-built_in">type</span> ( v, u ) = TREE;<br>            <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">TSort</span> ( u, clock, S ) ) <span class="hljs-comment">//从顶点u处出发深入搜索</span><br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//若u及其后代不能拓扑排序（则全图亦必如此），故返回并报告</span><br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> DISCOVERED:<br>            <span class="hljs-built_in">type</span> ( v, u ) = BACKWARD; <span class="hljs-comment">//一旦发现后向边（非DAG），则</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//不必深入，故返回并报告</span><br>         <span class="hljs-keyword">default</span>: <span class="hljs-comment">//VISITED (digraphs only)</span><br>            <span class="hljs-built_in">type</span> ( v, u ) = ( <span class="hljs-built_in">dTime</span> ( v ) &lt; <span class="hljs-built_in">dTime</span> ( u ) ) ? FORWARD : CROSS;<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   <span class="hljs-built_in">status</span> ( v ) = VISITED; S-&gt;<span class="hljs-built_in">push</span> ( <span class="hljs-built_in">vertex</span> ( v ) ); <span class="hljs-comment">//顶点被标记为VISITED时，随即入栈</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//v及其后代可以拓扑排序</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a4c86fb6b609e89a5e25e8d2a8e29fa3-0f046.png" alt="实例"></p><h2 id="图应用：双连通分量"><a href="#图应用：双连通分量" class="headerlink" title="图应用：双连通分量"></a>图应用：双连通分量</h2><h3 id="准则"><a href="#准则" class="headerlink" title="准则"></a>准则</h3><h4 id="BCC"><a href="#BCC" class="headerlink" title="BCC"></a>BCC</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/e1bebd4cd64a57312a5d0901ae4da8ef-0c8f5.png" alt="BCC"></p><ul><li><p>图中的一个点摘除之后，图中的连通域的数量会有所增加，那么这个点就是关节点。</p></li><li><p>任何一张连通的无向图，都存在着若干个关键点。而且以这些关键点为界，可以把图分割成几个若干个自洽的双连通的部分。</p></li></ul><h4 id="叶子与非叶子"><a href="#叶子与非叶子" class="headerlink" title="叶子与非叶子"></a>叶子与非叶子</h4><p>DFS所构成的连通图中：</p><ul><li><p>叶子不会是关节点</p></li><li><p>根不一定是关节点，因为根在DFS中是随机选的</p><ul><li>如果根有1度，那么它不是关节点</li><li>如果根的度数大于1度，那么它是关节点</li></ul></li><li>内部节点V的子树中，某一个孩子向上通过回边能达到的更高的祖先：<ul><li>比V的辈分大，那么V不是关节点</li><li>如果就是V，那么V就是关节点</li></ul></li></ul><p>所以可以同过一个指标，来判断更高的祖先，这个指标为$hca(v)$</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/0b0f82fe849f20f1e427670761548b22-31c48.png" alt="非叶子"></p><h3 id="算法-4"><a href="#算法-4" class="headerlink" title="算法"></a>算法</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tv, <span class="hljs-keyword">typename</span> Te&gt; <span class="hljs-keyword">void</span> Graph&lt;Tv, Te&gt;::<span class="hljs-built_in">bcc</span> ( <span class="hljs-keyword">int</span> s ) &#123; <span class="hljs-comment">//基于DFS的BCC分解算法</span><br>   <span class="hljs-built_in">reset</span>(); <span class="hljs-keyword">int</span> clock = <span class="hljs-number">0</span>; <span class="hljs-keyword">int</span> v = s; Stack&lt;<span class="hljs-keyword">int</span>&gt; S; <span class="hljs-comment">//栈S用以记录已访问的顶点</span><br>   <span class="hljs-function"><span class="hljs-keyword">do</span></span><br><span class="hljs-function">      <span class="hljs-title">if</span> <span class="hljs-params">( UNDISCOVERED == status ( v ) )</span> </span>&#123; <span class="hljs-comment">//一旦发现未发现的顶点（新连通分量）</span><br>         <span class="hljs-built_in">BCC</span> ( v, clock, S ); <span class="hljs-comment">//即从该顶点出发启动一次BCC</span><br>         S.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//遍历返回后，弹出栈中最后一个顶点——当前连通域的起点</span><br>      &#125;<br>   <span class="hljs-keyword">while</span> ( s != ( v = ( ++v % n ) ) );<br>&#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> hca(x) (fTime(x)) <span class="hljs-comment">//利用此处闲置的fTime[]充当hca[]</span></span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tv, <span class="hljs-keyword">typename</span> Te&gt; <span class="hljs-comment">//顶点类型、边类型</span><br><span class="hljs-keyword">void</span> Graph&lt;Tv, Te&gt;::<span class="hljs-built_in">BCC</span> ( <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span>&amp; clock, Stack&lt;<span class="hljs-keyword">int</span>&gt;&amp; S ) &#123; <span class="hljs-comment">//assert: 0 &lt;= v &lt; n</span><br>   <span class="hljs-built_in">hca</span> ( v ) = <span class="hljs-built_in">dTime</span> ( v ) = ++clock; <span class="hljs-built_in">status</span> ( v ) = DISCOVERED; S.<span class="hljs-built_in">push</span> ( v ); <span class="hljs-comment">//v被发现并入栈</span><br>   <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> u = <span class="hljs-built_in">firstNbr</span> ( v ); <span class="hljs-number">-1</span> &lt; u; u = <span class="hljs-built_in">nextNbr</span> ( v, u ) ) <span class="hljs-comment">//枚举v的所有邻居u</span><br>      <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> ( <span class="hljs-built_in">status</span> ( u ) ) &#123; <span class="hljs-comment">//并视u的状态分别处理</span><br>         <span class="hljs-keyword">case</span> UNDISCOVERED:<br>            <span class="hljs-built_in">parent</span> ( u ) = v; <span class="hljs-built_in">type</span> ( v, u ) = TREE; <span class="hljs-built_in">BCC</span> ( u, clock, S ); <span class="hljs-comment">//从顶点u处深入</span><br>            <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">hca</span> ( u ) &lt; <span class="hljs-built_in">dTime</span> ( v ) ) <span class="hljs-comment">//遍历返回后，若发现u（通过后向边）可指向v的真祖先</span><br>               <span class="hljs-built_in">hca</span> ( v ) = <span class="hljs-built_in">min</span> ( <span class="hljs-built_in">hca</span> ( v ), <span class="hljs-built_in">hca</span> ( u ) ); <span class="hljs-comment">//则v亦必如此</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">//否则，以v为关节点（u以下即是一个BCC，且其中顶点此时正集中于栈S的顶部）</span><br>               <span class="hljs-comment">/*DSA*/</span>&#123;<br>               <span class="hljs-comment">/*DSA*/</span><span class="hljs-built_in">printf</span> ( <span class="hljs-string">&quot;BCC rooted at %c:&quot;</span>, <span class="hljs-built_in">vertex</span> ( v ) );<br>               <span class="hljs-comment">/*DSA*/</span>Stack&lt;<span class="hljs-keyword">int</span>&gt; temp; <span class="hljs-keyword">do</span> &#123; temp.<span class="hljs-built_in">push</span> ( S.<span class="hljs-built_in">pop</span>() ); <span class="hljs-built_in">print</span> ( <span class="hljs-built_in">vertex</span> ( temp.<span class="hljs-built_in">top</span>() ) ); &#125; <span class="hljs-keyword">while</span> ( u != temp.<span class="hljs-built_in">top</span>() ); <span class="hljs-built_in">print</span>( <span class="hljs-built_in">vertex</span> ( <span class="hljs-built_in">parent</span>(u) ) ); <span class="hljs-keyword">while</span> ( !temp.<span class="hljs-built_in">empty</span>() ) S.<span class="hljs-built_in">push</span> ( temp.<span class="hljs-built_in">pop</span>() );<br>               <span class="hljs-keyword">while</span> ( u != S.<span class="hljs-built_in">pop</span>() ); <span class="hljs-comment">//弹出当前BCC中（除v外）的所有节点，可视需要做进一步处理</span><br>               <span class="hljs-comment">/*DSA*/</span><span class="hljs-built_in">printf</span> ( <span class="hljs-string">&quot;\n&quot;</span> );<br>               <span class="hljs-comment">/*DSA*/</span>&#125;<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> DISCOVERED:<br>            <span class="hljs-built_in">type</span> ( v, u ) = BACKWARD; <span class="hljs-comment">//标记(v, u)，并按照“越小越高”的准则</span><br>            <span class="hljs-keyword">if</span> ( u != <span class="hljs-built_in">parent</span> ( v ) ) <span class="hljs-built_in">hca</span> ( v ) = <span class="hljs-built_in">min</span> ( <span class="hljs-built_in">hca</span> ( v ), <span class="hljs-built_in">dTime</span> ( u ) ); <span class="hljs-comment">//更新hca[v]</span><br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>: <span class="hljs-comment">//VISITED (digraphs only)</span><br>            <span class="hljs-built_in">type</span> ( v, u ) = ( <span class="hljs-built_in">dTime</span> ( v ) &lt; <span class="hljs-built_in">dTime</span> ( u ) ) ? FORWARD : CROSS;<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   <span class="hljs-built_in">status</span> ( v ) = VISITED; <span class="hljs-comment">//对v的访问结束</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/4dc655b5ca30071900dbee4f3e5c8c91-47ac8.png" alt="实例"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6398f73b0fbc09e587aa2230760a1749-bb3c4.png" alt="实例"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度优先搜索</tag>
      
      <tag>图</tag>
      
      <tag>广度优先搜索</tag>
      
      <tag>拓扑排序</tag>
      
      <tag>双连通分量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树</title>
    <link href="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E6%A0%91/"/>
    <url>/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>向量擅于静态操作，而列表擅于动态操作，树则在某种程度上兼顾二者。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>树是用来按照层次关系，组织一系列数据项的一种方式。</p><p>比如RPN就可以用树结构来描述</p><h3 id="有根树"><a href="#有根树" class="headerlink" title="有根树"></a>有根树</h3><p>对于任何一组有根树，都可以通过引入一个新的顶点，并且在新的这个顶点与此前各棵有根树的树根之间，引入对应的一条连边，从而构成一棵规模更大的有根树。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a885150ad655a886e9f069e0ffd5b7af-bbddd8.png" alt="有根树"></p><h3 id="有序树"><a href="#有序树" class="headerlink" title="有序树"></a>有序树</h3><ul><li>度：任何一个节点所拥有孩子的个数，被称为<strong>度数</strong></li><li>边数：任何一棵树中所含的<strong>边数</strong>，等于其中<strong>所有顶点</strong>的<strong>度数之和</strong>，也等于所有顶点的个数-1</li><li>有序树：在兄弟之间定义了次序的树，被称为有序树</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/309161fbf9c45002a6d08b2cc5a17f86-3b837f.png" alt="有序树"></p><h3 id="路径-环路"><a href="#路径-环路" class="headerlink" title="路径+环路"></a>路径+环路</h3><ul><li>路径：K+1个节点，它们通过K条边依次相连，就称它们构成了一条路径，或者说通路</li><li>路径长度：构成这条路径的边的数目K</li><li>环路：在通路的基础上发生短路，那么这条路径就被成为环路</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/bcf168fa9875df9e89f0415f22bafb4f-8cc143.png" alt="路径+环路"></p><h3 id="连通-无环"><a href="#连通-无环" class="headerlink" title="连通+无环"></a>连通+无环</h3><p>树实际上是在连通和无环之间达到一个平衡的一种特定的图：</p><ul><li>无环连通图：因为无环，所以边数不会太大。又因为是连通的，所以边数不会太少</li><li>极小连通图：在保证连通的情况下，它的边数能够达到最少</li><li>极大无环图：而在杜绝环路的前提下，它又能够使用尽可能多的边</li></ul><p><strong>推论</strong>：在一棵树中，任何一个节点v，与树根之间都存在且仅存在唯一的一条通路。记作：  </p><script type="math/tex; mode=display">path(v)</script><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8cc8c3d980b2c3200c09800e79489a5b-25b26b.png" alt="连通+无环"></p><p>通路的长度也是唯一的指标。可以根据这个指标，可以将所有的顶点划分为不同的几类。</p><h3 id="深度-层次"><a href="#深度-层次" class="headerlink" title="深度+层次"></a>深度+层次</h3><ul><li>深度：点v的路径长度也被称为深度。根节点的长度为0，所以它的深度也为0</li><li>祖先：对于任何一个节点而言，在它以上的任何一个层次上，它只有一个唯一的祖先。树的根节点，是任意节点的祖先（公共祖先），根节点没有祖先</li><li>后代：对于任何一个节点而言，它在任何一个层次上的后代，却未必是唯一的</li><li>叶节点：没有后代的节点。在树中，叶子节点必然存在</li><li>高度：一棵树中，叶子节点最大的深度，被称为树的高度。树的高度也等于全树根节点的高度。空树的高度为-1</li></ul><p>对于任何一个顶点，它的深度与高度之和，不会超过全树的高度。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/27508e10429d401ab28676012d8dac47-f44c1d.png" alt="深度"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a5fac077506d1f41254afb0e8911bc51-1c7f83.png" alt="高度"></p><p>在一棵树中，顶点p是顶点v的父亲，则它们的高度的关系是<strong>height(v) &lt; height(p)</strong>，而不是<strong>height(v) = height(p) - 1</strong></p><h2 id="树的表示"><a href="#树的表示" class="headerlink" title="树的表示"></a>树的表示</h2><h3 id="父节点表示法"><a href="#父节点表示法" class="headerlink" title="父节点表示法"></a>父节点表示法</h3><p><strong>除根外，任一节点有且仅有一个父节点</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/d501b621cd185247f350f143a35a59f2-722f23.png" alt="父节点"></p><p>向下方向的查询效率低下</p><h3 id="孩子节点表示法"><a href="#孩子节点表示法" class="headerlink" title="孩子节点表示法"></a>孩子节点表示法</h3><p>一个节点查找孩子的复杂度，线性正比于它的孩子的数目，即度数</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/3186996d82a5439854080d47b534fd1f-80da65.png" alt="孩子节点表示法"></p><p>向上方向的查询效率低下</p><h3 id="父节点-孩子节点表示法"><a href="#父节点-孩子节点表示法" class="headerlink" title="父节点+孩子节点表示法"></a>父节点+孩子节点表示法</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/354c6c649ff569a57e89f4460c5af70d-e785b1.png" alt="父节点+孩子节点表示法"></p><p>虽然这种表示法，向上和向下查找都兼顾了，但是原本为O(1)的数据集，由于孩子节点数据集的存在，导致该方法有时候需要一个长达O(n)的数据集。</p><h3 id="长子兄弟表示法"><a href="#长子兄弟表示法" class="headerlink" title="长子兄弟表示法"></a>长子兄弟表示法</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/c9616ec7732fb06a52b6b9e74f7561f6-17e3ea.png" alt="长子兄弟表示法"></p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f193a69e5220d58f1b7ec28bb7a63208-5897cc.png" alt="二叉树"></p><ul><li><p>深度为k的节点，至多$2^k$个</p></li><li><p>含n个节点、高度为h的二叉树中：</p><script type="math/tex; mode=display">h<n<2^{h+1}</script><ul><li>当$n=h+1$时，树退化成了单链条</li><li>当$n=2^{h+1}-1$时，即所谓的满二叉树</li></ul></li></ul><p>宽度是高度的指数，所以对一棵二叉树而言，它的宽涨得非常的快，而高度，相对宽度来说，增长却非常的缓慢。这也是引入二叉搜索树的理论基础。</p><ul><li>问：高度为 h 的完全二叉树<strong>可能</strong>有多少个节点？<ul><li>答：高度为h的完全二叉树节点最多的情况即满二叉树，最少的情况比高度为h-1的满二叉树多1。即完全二叉树的节点个数为$(2^h-1,2^{h+1}-1]$​</li></ul></li></ul><h3 id="真二叉树"><a href="#真二叉树" class="headerlink" title="真二叉树"></a>真二叉树</h3><p>在二叉树的基础上：</p><ul><li>每个节点的度数都为偶数（0或2）</li></ul><p>二叉树转化成真二叉树：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/540e0fd931b0c920cd16af230b4ddb7f-cdafe3.png" alt=""></p><p>这样的策略可以使算法更加简洁的实现</p><h3 id="描述多叉树"><a href="#描述多叉树" class="headerlink" title="描述多叉树"></a>描述多叉树</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/02560538d67ab2c5ade5115b239d66bf-8248a4.png" alt="描述多叉树"></p><p>任何一棵一般性的树，转化为它的长子兄弟表示法，再将它的边顺时针旋转45度，即可变成二叉树。</p><h2 id="二叉树实现"><a href="#二叉树实现" class="headerlink" title="二叉树实现"></a>二叉树实现</h2><h3 id="BinNode类"><a href="#BinNode类" class="headerlink" title="BinNode类"></a>BinNode类</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/******************************************************************************************</span><br><span class="hljs-comment"> * Data Structures in C++</span><br><span class="hljs-comment"> * ISBN: 7-302-33064-6 &amp; 7-302-33065-3 &amp; 7-302-29652-2 &amp; 7-302-26883-3</span><br><span class="hljs-comment"> * Junhui DENG, deng@tsinghua.edu.cn</span><br><span class="hljs-comment"> * Computer Science &amp; Technology, Tsinghua University</span><br><span class="hljs-comment"> * Copyright (c) 2003-2020. All rights reserved.</span><br><span class="hljs-comment"> ******************************************************************************************/</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined( DSA_REDBLACK )</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> stature(p) ((p) ? (p)-&gt;height : 0) <span class="hljs-comment">//红黑树节点的黑高度（NULL视作外部节点，对应于0）</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> stature(p) ((p) ? (p)-&gt;height : -1) <span class="hljs-comment">//其余BST中节点的高度（NUll视作空树，对应于-1）</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> RB_RED, RB_BLACK&#125; RBColor; <span class="hljs-comment">//节点颜色</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BinNode</span>;</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">using</span> BinNodePosi = BinNode&lt;T&gt;*; <span class="hljs-comment">//节点位置</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BinNode</span> &#123;</span> <span class="hljs-comment">//二叉树节点模板类</span><br><span class="hljs-comment">// 成员（为简化描述起见统一开放，读者可根据需要进一步封装）</span><br>   T data; <span class="hljs-comment">//数值</span><br>   BinNodePosi&lt;T&gt; parent, lc, rc; <span class="hljs-comment">//父节点及左、右孩子</span><br>   <span class="hljs-keyword">int</span> height; <span class="hljs-comment">//高度（通用）</span><br>   <span class="hljs-keyword">int</span> npl; <span class="hljs-comment">//Null Path Length（左式堆，也可直接用height代替）</span><br>   RBColor color; <span class="hljs-comment">//颜色（红黑树）</span><br><span class="hljs-comment">// 构造函数</span><br>   <span class="hljs-built_in">BinNode</span>() :<br>      <span class="hljs-built_in">parent</span> ( <span class="hljs-literal">NULL</span> ), <span class="hljs-built_in">lc</span> ( <span class="hljs-literal">NULL</span> ), <span class="hljs-built_in">rc</span> ( <span class="hljs-literal">NULL</span> ), <span class="hljs-built_in">height</span> ( <span class="hljs-number">0</span> ), <span class="hljs-built_in">npl</span> ( <span class="hljs-number">1</span> ), <span class="hljs-built_in">color</span> ( RB_RED ) &#123; &#125;<br>   <span class="hljs-built_in">BinNode</span> ( T e, BinNodePosi&lt;T&gt; p = <span class="hljs-literal">NULL</span>, BinNodePosi&lt;T&gt; lc = <span class="hljs-literal">NULL</span>, BinNodePosi&lt;T&gt; rc = <span class="hljs-literal">NULL</span>,<br>             <span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, RBColor c = RB_RED ) :<br>      <span class="hljs-built_in">data</span> ( e ), <span class="hljs-built_in">parent</span> ( p ), <span class="hljs-built_in">lc</span> ( lc ), <span class="hljs-built_in">rc</span> ( rc ), <span class="hljs-built_in">height</span> ( h ), <span class="hljs-built_in">npl</span> ( l ), <span class="hljs-built_in">color</span> ( c ) &#123; &#125;<br><span class="hljs-comment">// 操作接口</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//统计当前节点后代总数，亦即以其为根的子树的规模</span><br>   <span class="hljs-function">BinNodePosi&lt;T&gt; <span class="hljs-title">insertAsLC</span> <span class="hljs-params">( T <span class="hljs-keyword">const</span> &amp; )</span></span>; <span class="hljs-comment">//作为当前节点的左孩子插入新节点</span><br>   <span class="hljs-function">BinNodePosi&lt;T&gt; <span class="hljs-title">insertAsRC</span> <span class="hljs-params">( T <span class="hljs-keyword">const</span> &amp; )</span></span>; <span class="hljs-comment">//作为当前节点的右孩子插入新节点</span><br>   <span class="hljs-function">BinNodePosi&lt;T&gt; <span class="hljs-title">succ</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//取当前节点的直接后继</span><br>   <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> VST&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">travLevel</span> <span class="hljs-params">( VST&amp; )</span></span>; <span class="hljs-comment">//子树层次遍历</span><br>   <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> VST&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">travPre</span> <span class="hljs-params">( VST&amp; )</span></span>; <span class="hljs-comment">//子树先序遍历</span><br>   <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> VST&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">travIn</span> <span class="hljs-params">( VST&amp; )</span></span>; <span class="hljs-comment">//子树中序遍历</span><br>   <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> VST&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">travPost</span> <span class="hljs-params">( VST&amp; )</span></span>; <span class="hljs-comment">//子树后序遍历</span><br><span class="hljs-comment">// 比较器、判等器（各列其一，其余自行补充）</span><br>   <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; ( BinNode <span class="hljs-keyword">const</span>&amp; bn ) &#123; <span class="hljs-keyword">return</span> data &lt; bn.data; &#125; <span class="hljs-comment">//小于</span><br>   <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>== ( BinNode <span class="hljs-keyword">const</span>&amp; bn ) &#123; <span class="hljs-keyword">return</span> data == bn.data; &#125; <span class="hljs-comment">//等于</span><br>   <span class="hljs-comment">/*DSA*/</span><br>   <span class="hljs-comment">/*DSA*/</span><span class="hljs-function">BinNodePosi&lt;T&gt; <span class="hljs-title">zig</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//顺时针旋转</span><br>   <span class="hljs-comment">/*DSA*/</span><span class="hljs-function">BinNodePosi&lt;T&gt; <span class="hljs-title">zag</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//逆时针旋转</span><br>   <span class="hljs-comment">/*DSA*/</span><span class="hljs-function">BinNodePosi&lt;T&gt; <span class="hljs-title">balance</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//完全平衡化</span><br>   <span class="hljs-comment">/*DSA*/</span><span class="hljs-function">BinNodePosi&lt;T&gt; <span class="hljs-title">imitate</span><span class="hljs-params">( <span class="hljs-keyword">const</span> BinNodePosi&lt;T&gt; )</span></span>;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;BinNode_implementation.h&quot;</span></span><br></code></pre></div></td></tr></table></figure><h3 id="BinNode接口"><a href="#BinNode接口" class="headerlink" title="BinNode接口"></a>BinNode接口</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; BinNodePosi&lt;T&gt; BinNode&lt;T&gt;::<span class="hljs-built_in">insertAsLC</span> ( T <span class="hljs-keyword">const</span>&amp; e )<br>&#123; <span class="hljs-keyword">return</span> lc = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinNode</span> ( e, <span class="hljs-keyword">this</span> ); &#125; <span class="hljs-comment">//将e作为当前节点的左孩子插入二叉树</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; BinNodePosi&lt;T&gt; BinNode&lt;T&gt;::<span class="hljs-built_in">insertAsRC</span> ( T <span class="hljs-keyword">const</span>&amp; e )<br>&#123; <span class="hljs-keyword">return</span> rc = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinNode</span> ( e, <span class="hljs-keyword">this</span> ); &#125; <span class="hljs-comment">//将e作为当前节点的右孩子插入二叉树</span><br><br></code></pre></div></td></tr></table></figure><ul><li>一个节点作为左孩子和右孩子接入的复杂度皆为$O(1)$</li><li>求后代总数为递归式求法。所以它的复杂度为$O(n=|size|)$</li></ul><h3 id="BinTree类"><a href="#BinTree类" class="headerlink" title="BinTree类"></a>BinTree类</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/******************************************************************************************</span><br><span class="hljs-comment"> * Data Structures in C++</span><br><span class="hljs-comment"> * ISBN: 7-302-33064-6 &amp; 7-302-33065-3 &amp; 7-302-29652-2 &amp; 7-302-26883-3</span><br><span class="hljs-comment"> * Junhui DENG, deng@tsinghua.edu.cn</span><br><span class="hljs-comment"> * Computer Science &amp; Technology, Tsinghua University</span><br><span class="hljs-comment"> * Copyright (c) 2003-2020. All rights reserved.</span><br><span class="hljs-comment"> ******************************************************************************************/</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;BinNode.h&quot;</span> <span class="hljs-comment">//引入二叉树节点类</span></span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinTree</span> &#123;</span> <span class="hljs-comment">//二叉树模板类</span><br><span class="hljs-keyword">protected</span>:<br>   <span class="hljs-keyword">int</span> _size; BinNodePosi&lt;T&gt; _root; <span class="hljs-comment">//规模、根节点</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateHeight</span> <span class="hljs-params">( BinNodePosi&lt;T&gt; x )</span></span>; <span class="hljs-comment">//更新节点x的高度</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateHeightAbove</span> <span class="hljs-params">( BinNodePosi&lt;T&gt; x )</span></span>; <span class="hljs-comment">//更新节点x及其祖先的高度</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">BinTree</span>() : _size ( <span class="hljs-number">0</span> ), _root ( <span class="hljs-literal">NULL</span> ) &#123; &#125; <span class="hljs-comment">//构造函数</span><br>   ~<span class="hljs-built_in">BinTree</span>() &#123; <span class="hljs-keyword">if</span> ( <span class="hljs-number">0</span> &lt; _size ) <span class="hljs-built_in">remove</span> ( _root ); &#125; <span class="hljs-comment">//析构函数</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _size; &#125; <span class="hljs-comment">//规模</span><br>   <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> !_root; &#125; <span class="hljs-comment">//判空</span><br>   <span class="hljs-function">BinNodePosi&lt;T&gt; <span class="hljs-title">root</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _root; &#125; <span class="hljs-comment">//树根</span><br>   <span class="hljs-function">BinNodePosi&lt;T&gt; <span class="hljs-title">insertAsRoot</span> <span class="hljs-params">( T <span class="hljs-keyword">const</span>&amp; e )</span></span>; <span class="hljs-comment">//插入根节点</span><br>   <span class="hljs-function">BinNodePosi&lt;T&gt; <span class="hljs-title">insertAsLC</span> <span class="hljs-params">( BinNodePosi&lt;T&gt; x, T <span class="hljs-keyword">const</span>&amp; e )</span></span>; <span class="hljs-comment">//e作为x的左孩子（原无）插入</span><br>   <span class="hljs-function">BinNodePosi&lt;T&gt; <span class="hljs-title">insertAsRC</span> <span class="hljs-params">( BinNodePosi&lt;T&gt; x, T <span class="hljs-keyword">const</span>&amp; e )</span></span>; <span class="hljs-comment">//e作为x的右孩子（原无）插入</span><br>   <span class="hljs-function">BinNodePosi&lt;T&gt; <span class="hljs-title">attachAsLC</span> <span class="hljs-params">( BinNodePosi&lt;T&gt; x, BinTree&lt;T&gt;* &amp;T )</span></span>; <span class="hljs-comment">//T作为x左子树接入</span><br>   <span class="hljs-function">BinNodePosi&lt;T&gt; <span class="hljs-title">attachAsRC</span> <span class="hljs-params">( BinNodePosi&lt;T&gt; x, BinTree&lt;T&gt;* &amp;T )</span></span>; <span class="hljs-comment">//T作为x右子树接入</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">remove</span> <span class="hljs-params">( BinNodePosi&lt;T&gt; x )</span></span>; <span class="hljs-comment">//删除以位置x处节点为根的子树，返回该子树原先的规模</span><br>   <span class="hljs-function">BinTree&lt;T&gt;* <span class="hljs-title">secede</span> <span class="hljs-params">( BinNodePosi&lt;T&gt; x )</span></span>; <span class="hljs-comment">//将子树x从当前树中摘除，并将其转换为一棵独立子树</span><br>   <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> VST&gt; <span class="hljs-comment">//操作器</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">travLevel</span> <span class="hljs-params">( VST&amp; visit )</span> </span>&#123; <span class="hljs-keyword">if</span> ( _root ) _root-&gt;<span class="hljs-built_in">travLevel</span> ( visit ); &#125; <span class="hljs-comment">//层次遍历</span><br>   <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> VST&gt; <span class="hljs-comment">//操作器</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">travPre</span> <span class="hljs-params">( VST&amp; visit )</span> </span>&#123; <span class="hljs-keyword">if</span> ( _root ) _root-&gt;<span class="hljs-built_in">travPre</span> ( visit ); &#125; <span class="hljs-comment">//先序遍历</span><br>   <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> VST&gt; <span class="hljs-comment">//操作器</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">travIn</span> <span class="hljs-params">( VST&amp; visit )</span> </span>&#123; <span class="hljs-keyword">if</span> ( _root ) _root-&gt;<span class="hljs-built_in">travIn</span> ( visit ); &#125; <span class="hljs-comment">//中序遍历</span><br>   <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> VST&gt; <span class="hljs-comment">//操作器</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">travPost</span> <span class="hljs-params">( VST&amp; visit )</span> </span>&#123; <span class="hljs-keyword">if</span> ( _root ) _root-&gt;<span class="hljs-built_in">travPost</span> ( visit ); &#125; <span class="hljs-comment">//后序遍历</span><br>   <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; ( BinTree&lt;T&gt; <span class="hljs-keyword">const</span>&amp; t ) <span class="hljs-comment">//比较器（其余自行补充）</span><br>   &#123; <span class="hljs-keyword">return</span> _root &amp;&amp; t._root &amp;&amp; <span class="hljs-built_in">lt</span> ( _root, t._root ); &#125;<br>   <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>== ( BinTree&lt;T&gt; <span class="hljs-keyword">const</span>&amp; t ) <span class="hljs-comment">//判等器</span><br>   &#123; <span class="hljs-keyword">return</span> _root &amp;&amp; t._root &amp;&amp; ( _root == t._root ); &#125;<br>&#125;; <span class="hljs-comment">//BinTree</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;BinTree_implementation.h&quot;</span></span><br></code></pre></div></td></tr></table></figure><h3 id="高度更新"><a href="#高度更新" class="headerlink" title="高度更新"></a>高度更新</h3><p>高度的定义：对于一个节点来说，在以它为根的子树中，从它同往最深的叶子节点的路径长度就是它的高度。特殊情况：</p><ul><li>单个节点的高度：0</li><li>空树的高度：-1</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> stature(p) ((p)?(p)-&gt;height:1)<span class="hljs-comment">//统一常规情况与特殊情况</span></span><br></code></pre></div></td></tr></table></figure><p>如果要对全树做整体的高度更新，需要从某个节点出发，向上逐层地追溯它的历代祖先，直到最终抵达根节点。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/42ddc773411891d9ac09285199a00a46-1ab018.png" alt="高度更新"></p><p>对于<code>updateHeight()</code>，左右孩子结点的高度在插入时都已经更新在结点的内数据结构了，所以只需要再左右孩子中取高度最大值，并且加上自己1，就是自己的高度了。所以<code>updateHeight()</code>的复杂度为$O(1)$。</p><p>由于x节点的更新路径恰好是根节点到x节点的路径，所以<code>updateHeightAbove()</code>的复杂度为$O(n=depth(x))$，与x节点的深度成正比。</p><ul><li>从n个节点的二叉树的叶节点u逐个节点地上溯到根节点的过程中，每上溯一层，深度减小1，但高度的增加可能大于1，因为节点的高度由其左、右子树中较高者决定。</li></ul><h3 id="节点插入"><a href="#节点插入" class="headerlink" title="节点插入"></a>节点插入</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; BinNodePosi&lt;T&gt; BinTree&lt;T&gt;::<span class="hljs-built_in">insertAsRC</span> ( BinNodePosi&lt;T&gt; x, T <span class="hljs-keyword">const</span>&amp; e )<br>&#123; _size++; x-&gt;<span class="hljs-built_in">insertAsRC</span> ( e ); <span class="hljs-built_in">updateHeightAbove</span> ( x ); <span class="hljs-keyword">return</span> x-&gt;rc; &#125; <span class="hljs-comment">//e插入为x的右孩子</span><br><span class="hljs-comment">//insertAsLC()完全对称，在此省略</span><br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6ef26c6c86e06e4e2f668a80425420fd-0fbaa.png" alt="节点插入"></p><p><strong>注意：A节点插入B节点时，需及时更新B节点和它祖先节点的高度。</strong></p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><h3 id="遍历策略"><a href="#遍历策略" class="headerlink" title="遍历策略"></a>遍历策略</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/2f8bde909dc9c4d45aa80055dad7494a-3a48d5.png" alt="遍历策略"></p><p>以根节点的遍历顺序来定义：</p><ul><li>先序遍历：根节点的遍历位于左右节点之前</li><li>中序遍历：根节点的遍历位于左右节点之间</li><li>后续遍历：根节点的遍历位于左右节点之后</li></ul><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><h4 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> List&lt;T&gt;::<span class="hljs-built_in">traverse</span> ( <span class="hljs-built_in"><span class="hljs-keyword">void</span></span> ( *visit ) ( T&amp; ) ) <span class="hljs-comment">//借助函数指针机制遍历</span><br>&#123;  <span class="hljs-keyword">for</span> ( ListNodePosi&lt;T&gt; p = header-&gt;succ; p != trailer; p = p-&gt;succ ) <span class="hljs-built_in">visit</span> ( p-&gt;data );  &#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> VST&gt; <span class="hljs-comment">//元素类型、操作器</span><br><span class="hljs-keyword">void</span> List&lt;T&gt;::<span class="hljs-built_in">traverse</span> ( VST&amp; visit ) <span class="hljs-comment">//借助函数对象机制遍历</span><br>&#123;  <span class="hljs-keyword">for</span> ( ListNodePosi&lt;T&gt; p = header-&gt;succ; p != trailer; p = p-&gt;succ ) <span class="hljs-built_in">visit</span> ( p-&gt;data );  &#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20fad7e0c3ca3d00ece4dac12fddc256-35ae5.png" alt="递归算法"></p><p>由于在先序遍历的递归中，栈中的<strong>递归</strong>帧虽然说可以看为$O(1)$，但是与<strong>迭代</strong>的栈帧$O(1)$相比，实际上差距是非常大的。</p><p>该算法为<strong>尾递归</strong>。</p><h4 id="迭代算法：版本1"><a href="#迭代算法：版本1" class="headerlink" title="迭代算法：版本1"></a>迭代算法：版本1</h4><p>引入一个辅助栈，并注意左右孩子的入栈顺序，与中序遍历中的左右孩子访问顺序刚好相反。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> VST&gt; <span class="hljs-comment">//元素类型、操作器</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">travPre_I1</span> <span class="hljs-params">( BinNodePosi&lt;T&gt; x, VST&amp; visit )</span> </span>&#123; <span class="hljs-comment">//二叉树先序遍历算法（迭代版#1）</span><br>   Stack&lt;BinNodePosi&lt;T&gt;&gt; S; <span class="hljs-comment">//辅助栈</span><br>   <span class="hljs-keyword">if</span> ( x ) S.<span class="hljs-built_in">push</span> ( x ); <span class="hljs-comment">//根节点入栈</span><br>   <span class="hljs-keyword">while</span> ( !S.<span class="hljs-built_in">empty</span>() ) &#123; <span class="hljs-comment">//在栈变空之前反复循环</span><br>      x = S.<span class="hljs-built_in">pop</span>(); <span class="hljs-built_in">visit</span> ( x-&gt;data ); <span class="hljs-comment">//弹出并访问当前节点，其非空孩子的入栈次序为先右后左</span><br>      <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">HasRChild</span> ( *x ) ) S.<span class="hljs-built_in">push</span> ( x-&gt;rc ); <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">HasLChild</span> ( *x ) ) S.<span class="hljs-built_in">push</span> ( x-&gt;lc );<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6ae658af0bec8256c6e0470d99355b1e-4b11f.png" alt=""></p><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8ec4c54b58e9bc1a4d55bcf5995ec534-458418.png" alt="实例"></p><p>虽然说该算法非常的简明，但是无法推广至中序和后续算法。</p><h4 id="迭代算法：版本2"><a href="#迭代算法：版本2" class="headerlink" title="迭代算法：版本2"></a>迭代算法：版本2</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>左侧链定义：将起始于树根的，总是沿着左侧孩子分支，不断下行的一条链，被称为当前这棵子树的左侧链。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5db73cb819e14f7fc19f8615df9b4b8a-1c4b1c.png" alt="思路"></p><p>对于任何一棵二叉树，都可以抽象地表示为：<strong>沿着左侧链不断下行，同时其他的部分分别地归入于这棵左侧链上沿途各个节点的右子树的形式。</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f4f0b6a45660372158f9f7acdb82e7c0-a384d6.png" alt="思路"></p><p>对于先序遍历的宏观思路：先自顶向下的遍历左侧链，再自底向上的访问右子树。</p><p>所以访问一棵树，都可以看成对这棵树的局部，首先沿着左侧链依次访问各个节点，直到$L_d$，再调转方向，访问右子树。</p><h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//从当前节点出发，沿左分支不断深入，直至没有左分支的节点；沿途节点遇到后立即访问</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> VST&gt; <span class="hljs-comment">//元素类型、操作器</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitAlongVine</span> <span class="hljs-params">( BinNodePosi&lt;T&gt; x, VST&amp; visit, Stack&lt;BinNodePosi&lt;T&gt;&gt;&amp; S )</span> </span>&#123;<br>   <span class="hljs-keyword">while</span> ( x ) &#123;<br>      <span class="hljs-built_in">visit</span> ( x-&gt;data ); <span class="hljs-comment">//访问当前节点</span><br>      S.<span class="hljs-built_in">push</span> ( x-&gt;rc ); <span class="hljs-comment">//右孩子入栈暂存（可优化：通过判断，避免空的右孩子入栈）</span><br>      x = x-&gt;lc;  <span class="hljs-comment">//沿左分支深入一层</span><br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> VST&gt; <span class="hljs-comment">//元素类型、操作器</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">travPre_I2</span> <span class="hljs-params">( BinNodePosi&lt;T&gt; x, VST&amp; visit )</span> </span>&#123; <span class="hljs-comment">//二叉树先序遍历算法（迭代版#2）</span><br>   Stack&lt;BinNodePosi&lt;T&gt;&gt; S; <span class="hljs-comment">//辅助栈</span><br>   <span class="hljs-keyword">while</span> ( <span class="hljs-literal">true</span> ) &#123;<br>      <span class="hljs-built_in">visitAlongVine</span> ( x, visit, S ); <span class="hljs-comment">//从当前节点出发，逐批访问</span><br>      <span class="hljs-keyword">if</span> ( S.<span class="hljs-built_in">empty</span>() ) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//直到栈空</span><br>      x = S.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//弹出下一批的起点</span><br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/9e50f5fbc79cbe1cee2024a08fdff287-b9702.png" alt=""></p><h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a1679bb4309e411cd0f5af23a4d30357-f12830.png" alt="实例"></p><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><h4 id="递归算法-1"><a href="#递归算法-1" class="headerlink" title="递归算法"></a>递归算法</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> VST&gt; <span class="hljs-comment">//元素类型、操作器</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">travIn_R</span> <span class="hljs-params">( BinNodePosi&lt;T&gt; x, VST&amp; visit )</span> </span>&#123; <span class="hljs-comment">//二叉树中序遍历算法（递归版）</span><br>   <span class="hljs-keyword">if</span> ( !x ) <span class="hljs-keyword">return</span>;<br>   <span class="hljs-built_in">travIn_R</span> ( x-&gt;lc, visit );<br>   <span class="hljs-built_in">visit</span> ( x-&gt;data );<br>   <span class="hljs-built_in">travIn_R</span> ( x-&gt;rc, visit );<br>&#125;<br></code></pre></div></td></tr></table></figure><p>由于在该递归算法中，递归调用部分嵌套了对<code>x-&gt;data</code>的访问，所以该算法不是尾递归</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/044b4b2dcbfaed42d5dc81a769b35546-335fd1.png" alt="思路"></p><p>整体来看，首先访问的是整棵树中左侧链的末端，即沿着左侧链向下行进的终点。</p><p>在局部：当某个节点获得控制权，它会尝试把控制权交给左孩子，当左孩子被访问之后，才会深入到它的右子树中。当它的右子树被全部访问完毕后，它才会把控制权交给它的根节点。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5459b90f42ecc87eaadcf125c89bae3e-22bd77.png" alt="思路"></p><p>左侧链上的每一个节点，都对应着一个局部访问阶段。</p><p><strong>从根出发沿左分支下行，直到最深的节点：它就是全局首先被访问者</strong></p><p>与先序遍历的策略类似，可以引入一个辅助栈，将左侧链的节点自顶向下依次入栈，再依次将栈顶元素弹出进行访问。</p><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//从当前节点出发，沿左分支不断深入，直至没有左分支的节点</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">goAlongVine</span> <span class="hljs-params">( BinNodePosi&lt;T&gt; x, Stack&lt;BinNodePosi&lt;T&gt;&gt;&amp; S )</span> </span>&#123;<br>   <span class="hljs-keyword">while</span> ( x ) &#123; S.<span class="hljs-built_in">push</span> ( x ); x = x-&gt;lc; &#125; <span class="hljs-comment">//当前节点入栈后随即向左侧分支深入，迭代直到无左孩子</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> VST&gt; <span class="hljs-comment">//元素类型、操作器</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">travIn_I1</span> <span class="hljs-params">( BinNodePosi&lt;T&gt; x, VST&amp; visit )</span> </span>&#123; <span class="hljs-comment">//二叉树中序遍历算法（迭代版#1）</span><br>   Stack&lt;BinNodePosi&lt;T&gt;&gt; S; <span class="hljs-comment">//辅助栈</span><br>   <span class="hljs-keyword">while</span> ( <span class="hljs-literal">true</span> ) &#123;<br>      <span class="hljs-built_in">goAlongVine</span> ( x, S ); <span class="hljs-comment">//从当前节点出发，逐批入栈</span><br>      <span class="hljs-keyword">if</span> ( S.<span class="hljs-built_in">empty</span>() ) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//直至所有节点处理完毕</span><br>      x = S.<span class="hljs-built_in">pop</span>(); <span class="hljs-built_in">visit</span> ( x-&gt;data ); <span class="hljs-comment">//弹出栈顶节点并访问之</span><br>      x = x-&gt;rc; <span class="hljs-comment">//转向右子树</span><br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/778417e60a97a75476698c8201106bb1-1b8e85.png" alt="实例"></p><h4 id="分摊分析（待证明）"><a href="#分摊分析（待证明）" class="headerlink" title="分摊分析（待证明）"></a>分摊分析（待证明）</h4><p>分摊分析的结果为$O(n)$</p><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/984de4d8a9d7d712d3d80c732430b8b0-1321a6.png" alt="思路"></p><ul><li>第一个访问节点：从根节点开始，对于中途每个节点，能往左就往左，不能往左就往右，若左右都无路可走，则该节点是后序遍历中第一个被访问的节点。</li></ul><h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//在以S栈顶节点为根的子树中，找到最高左侧可见叶节点</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">gotoLeftmostLeaf</span> <span class="hljs-params">( Stack&lt;BinNodePosi&lt;T&gt;&gt;&amp; S )</span> </span>&#123; <span class="hljs-comment">//沿途所遇节点依次入栈</span><br>   <span class="hljs-keyword">while</span> ( BinNodePosi&lt;T&gt; x = S.<span class="hljs-built_in">top</span>() ) <span class="hljs-comment">//自顶而下，反复检查当前节点（即栈顶）</span><br>      <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">HasLChild</span> ( *x ) ) &#123; <span class="hljs-comment">//尽可能向左</span><br>         <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">HasRChild</span> ( *x ) ) S.<span class="hljs-built_in">push</span> ( x-&gt;rc ); <span class="hljs-comment">//若有右孩子，优先入栈</span><br>         S.<span class="hljs-built_in">push</span> ( x-&gt;lc ); <span class="hljs-comment">//然后才转至左孩子</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-comment">//实不得已</span><br>         S.<span class="hljs-built_in">push</span> ( x-&gt;rc ); <span class="hljs-comment">//才向右</span><br>   S.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//返回之前，弹出栈顶的空节点</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> VST&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">travPost_I</span> <span class="hljs-params">( BinNodePosi&lt;T&gt; x, VST&amp; visit )</span> </span>&#123; <span class="hljs-comment">//二叉树的后序遍历（迭代版）</span><br>   Stack&lt;BinNodePosi&lt;T&gt;&gt; S; <span class="hljs-comment">//辅助栈</span><br>   <span class="hljs-keyword">if</span> ( x ) S.<span class="hljs-built_in">push</span> ( x ); <span class="hljs-comment">//根节点入栈</span><br>   <span class="hljs-keyword">while</span> ( !S.<span class="hljs-built_in">empty</span>() ) &#123; <span class="hljs-comment">//x始终为当前节点</span><br>      <span class="hljs-keyword">if</span> ( S.<span class="hljs-built_in">top</span>() != x-&gt;parent ) <span class="hljs-comment">////若栈顶非x之父（而为右兄）</span><br>         <span class="hljs-built_in">gotoLeftmostLeaf</span> ( S ); <span class="hljs-comment">//则在其右兄子树中找到HLVFL（相当于递归深入）</span><br>      x = S.<span class="hljs-built_in">pop</span>(); <span class="hljs-built_in">visit</span> ( x-&gt;data ); <span class="hljs-comment">//弹出栈顶（即前一节点之后继），并访问之</span><br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>假设A为栈顶元素，B为A的下一个元素</p><p>根据入栈顺序，在栈弹出A时，A和此时的栈顶元素B的关系有两种：</p><ul><li>B为A的父亲</li><li>B为A的右兄弟</li></ul><h4 id="后序遍历与RPN"><a href="#后序遍历与RPN" class="headerlink" title="后序遍历与RPN"></a>后序遍历与RPN</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/604b299c076030f4bdbedfa9075c9b36-7cde54.png" alt="后序遍历与RPN"></p><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><p>层次遍历的次序为：自顶向下，自左向右。即按照深度</p><p>先序中序后序这三种遍历方式无法保证树按照深度进行遍历</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>借助队列实现层次遍历</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/*DSA*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;queue/queue.h&quot;</span> <span class="hljs-comment">//引入队列</span></span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> VST&gt; <span class="hljs-comment">//元素类型、操作器</span><br><span class="hljs-keyword">void</span> BinNode&lt;T&gt;::<span class="hljs-built_in">travLevel</span> ( VST&amp; visit ) &#123; <span class="hljs-comment">//二叉树层次遍历算法</span><br>   Queue&lt;BinNodePosi&lt;T&gt;&gt; Q; <span class="hljs-comment">//辅助队列</span><br>   Q.<span class="hljs-built_in">enqueue</span> ( <span class="hljs-keyword">this</span> ); <span class="hljs-comment">//根节点入队</span><br>   <span class="hljs-keyword">while</span> ( !Q.<span class="hljs-built_in">empty</span>() ) &#123; <span class="hljs-comment">//在队列再次变空之前，反复迭代</span><br>      BinNodePosi&lt;T&gt; x = Q.<span class="hljs-built_in">dequeue</span>(); <span class="hljs-built_in">visit</span> ( x-&gt;data ); <span class="hljs-comment">//取出队首节点并访问之</span><br>      <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">HasLChild</span> ( *x ) ) Q.<span class="hljs-built_in">enqueue</span> ( x-&gt;lc ); <span class="hljs-comment">//左孩子入队</span><br>      <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">HasRChild</span> ( *x ) ) Q.<span class="hljs-built_in">enqueue</span> ( x-&gt;rc ); <span class="hljs-comment">//右孩子入队</span><br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/981f78d90726838aef041e979b5ed73f-05e4cd.png" alt="实例"></p><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><h4 id="先序-后序-中序"><a href="#先序-后序-中序" class="headerlink" title="先序|后序+中序"></a>先序|后序+中序</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/e89b645719a6c94c6ff19b9f1e622d3f-87f9c4.png" alt="重构"></p><ul><li>先序+中序：可以</li><li>后序+中序：可以</li><li>先序+后序：无法保证。</li></ul><p>借助中序和后序遍历序列无法保证重构出原来的树：因为在树中，若根的左右子树有一个为空，那么重构的过程中，无法明确除了根节点以外的序列是属于左子树还是右子树。</p><h4 id="先序-后序：真二叉树"><a href="#先序-后序：真二叉树" class="headerlink" title="先序+后序：真二叉树"></a>先序+后序：真二叉树</h4><p>在树为真二叉树的情况下，通过先序和后序遍历序列可以求出原来的真二叉树</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/cbeab84dd0208a1fc503a005e7cda59c-53b453.png" alt="先序+后序：真二叉树"></p><p>通过性质，可以明确的界定左右子树的范围</p><h2 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树</h2><h3 id="PCF：无前缀冲突编码"><a href="#PCF：无前缀冲突编码" class="headerlink" title="PCF：无前缀冲突编码"></a>PCF：无前缀冲突编码</h3><p><strong>编码不当：一个编码会是另一个编码的前缀</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f4eeea9bf8171adbc26ec9e24136696f-cc746e.png" alt="PCF：无前缀冲突编码"></p><p>如果字符集的字符数量为n个，就构造叶子节点数量为n的二叉树。字符所对应的编码蕴含在路径上，任何一个叶子都不会呆在另一个叶子的通路上，所以不会有前缀冲突。</p><h3 id="编码成本"><a href="#编码成本" class="headerlink" title="编码成本"></a>编码成本</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a59030ce6c14459fb05f1d051b096604-bb3801.png" alt="编码成本"></p><p>优化：深度差为2或以上的叶子，将深度低的叶子和深度高的叶子的父节点进行交换。实质上杜绝深度差过大。</p><h3 id="字符频度"><a href="#字符频度" class="headerlink" title="字符频度"></a>字符频度</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6e5e2795f0d707b987df0bb5adcd7ff7-587766.png" alt="字符频度"></p><h3 id="最优带权编码树"><a href="#最优带权编码树" class="headerlink" title="最优带权编码树"></a>最优带权编码树</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/1916d2049377897d516d072ab07e5019-fe4b97.png" alt="最优带权编码树"></p><p>交换后的字符差值：高度差*权重差</p><h3 id="哈夫曼算法"><a href="#哈夫曼算法" class="headerlink" title="哈夫曼算法"></a>哈夫曼算法</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/90b7214bb0a71b081a43c1a1cc9a7913-d534ab.png" alt="哈夫曼算法"></p><h3 id="构造编码树"><a href="#构造编码树" class="headerlink" title="构造编码树"></a>构造编码树</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/762c395298de0f2acad90826ee65a234-713216.png" alt="构造编码树1"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/52972e731f4cd2acb408d94334dda4a9-f4de3e.png" alt="构造编码树2"></p><h3 id="构造编码表"><a href="#构造编码表" class="headerlink" title="构造编码表"></a>构造编码表</h3><p>先中后序遍历都可以编码</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/66835f4166789982178163900c82523f-967270.png" alt="构造编码表"></p><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p>从树根开始，只要遇到叶子节点，就代表获得一个字符，然后从树根重新开始找叶子节点。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>层序遍历</tag>
      
      <tag>二叉树</tag>
      
      <tag>中序遍历</tag>
      
      <tag>前序遍历</tag>
      
      <tag>后序遍历</tag>
      
      <tag>哈夫曼编码树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈与队列</title>
    <link href="/2020/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <url>/2020/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="栈接口与实现"><a href="#栈接口与实现" class="headerlink" title="栈接口与实现"></a>栈接口与实现</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/824c466b75fad2304801135552f63680-ee407e.png" alt=""></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/76ccd18ec322bd16448e9651ea53677d-847060.png" alt="实例"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>可以通过向量实现栈</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5d3adfab74d0d23552fe27d798b5cb6f-20aee5.png" alt="可以通过向量实现栈"></p><p>注意：将向量的尾部作为栈顶，那么<code>push</code>和pop<code>操作</code>的复杂度实际上就为$O(1)$（由<code>insert</code>和<code>remove</code>决定）。而如果相反的，将向量的首部作为栈顶，那么复杂度将会变为原来的$O(n)$。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>逆序输出（conversion）：输出次序与处理过程颠倒；递归深度和输出长度不易预知</li><li>递归嵌套（stack permutation + parenthesis）：具有自相似性的问题可递归描述，但分支位置和嵌套深度不固定</li><li>延迟缓冲（evaluation）：线性扫描算法模式中，在预读足够长之后，方能确定可处理的前缀</li><li>栈式计算（RPN）：基于栈结构的特定计算模式</li></ul><h2 id="栈应用：进制转换（逆序输出）"><a href="#栈应用：进制转换（逆序输出）" class="headerlink" title="栈应用：进制转换（逆序输出）"></a>栈应用：进制转换（逆序输出）</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/365037d7010619717ed69554b487c244-36fe3f.png" alt="算法"></p><p>分析进制转换的过程，会发现结果（1011001）和计算过程中得到的（1001101）正好是相反的，且结果的长度未知。所以当计算出一位时，便将这一位入栈。到最后，栈中的数据排放方式，就是结果。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">convert</span> <span class="hljs-params">( Stack&lt;<span class="hljs-keyword">char</span>&gt;&amp; S, __int64 n, <span class="hljs-keyword">int</span> base )</span> </span>&#123; <span class="hljs-comment">//整数n的1&lt;base&lt;=16进制打印（迭代版）</span><br>   <span class="hljs-keyword">char</span> digit[] = <span class="hljs-string">&quot;0123456789ABCDEF&quot;</span>; <span class="hljs-comment">//数位符号，如有必要可相应扩充</span><br>   <span class="hljs-keyword">while</span> ( n &gt; <span class="hljs-number">0</span> ) &#123; <span class="hljs-comment">//由低到高，逐一计算出新进制下的各数位</span><br>      <span class="hljs-comment">/*DSA*/</span><span class="hljs-built_in">printf</span> ( <span class="hljs-string">&quot;%20I64d = %20I64d * %d + %20I64d\n&quot;</span>, n , n/base, base, n%base );<br>      S.<span class="hljs-built_in">push</span> ( digit[ n % base ] ); <span class="hljs-comment">//余数（当前位）入栈</span><br>      n /= base; <span class="hljs-comment">//n更新为其对base的除商</span><br>      <span class="hljs-comment">/*DSA*/</span><span class="hljs-built_in">print</span> ( S ); <span class="hljs-built_in">getchar</span>();<br>   &#125;<br>&#125; <span class="hljs-comment">//新进制下由高到低的各数位，自顶而下保存于栈S中</span><br></code></pre></div></td></tr></table></figure><h3 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">convert</span> <span class="hljs-params">( Stack&lt;<span class="hljs-keyword">char</span>&gt;&amp; S, __int64 n, <span class="hljs-keyword">int</span> base )</span> </span>&#123; <span class="hljs-comment">//整数n的1&lt;base&lt;=16进制打印（递归版）</span><br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> digit[] = <span class="hljs-string">&quot;0123456789ABCDEF&quot;</span>; <span class="hljs-comment">//数位符号，如有必要可相应扩充</span><br>   <span class="hljs-keyword">if</span> ( <span class="hljs-number">0</span> &lt; n ) &#123; <span class="hljs-comment">//在尚有余数之前，反复地</span><br>      S.<span class="hljs-built_in">push</span> ( digit[n % base] ); <span class="hljs-comment">//逆向记录当前最低位，再</span><br>      <span class="hljs-built_in">convert</span> ( S, n / base, base ); <span class="hljs-comment">//通过递归得到所有更高位</span><br>   &#125;<br>&#125; <span class="hljs-comment">//新进制下由高到低的各数位，自顶而下保存于栈S中</span><br></code></pre></div></td></tr></table></figure><p>打印十进制整数x的y进制表示</p><h2 id="栈应用：括号匹配（递归嵌套）"><a href="#栈应用：括号匹配（递归嵌套）" class="headerlink" title="栈应用：括号匹配（递归嵌套）"></a>栈应用：括号匹配（递归嵌套）</h2><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8728e30e1320795afe9dfd24f984735e-ca0b3b.png" alt="实例"></p><h3 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/e3b9d4ab62bd6d33ad8694e97f1b36b2-81a538.png" alt="尝试"></p><p>减而治之和分而治之在这种情况下无法使用</p><h3 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/1970bb6a24b14084159939a53ff746c0-a03f22.png" alt="构思"></p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">paren</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> exp[], <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi )</span> </span>&#123; <span class="hljs-comment">//表达式括号匹配检查，可兼顾三种括号</span><br>   Stack&lt;<span class="hljs-keyword">char</span>&gt; S; <span class="hljs-comment">//使用栈记录已发现但尚未匹配的左括号</span><br>   <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = lo; i &lt;= hi; i++ ) <span class="hljs-comment">/* 逐一检查当前字符 */</span> <span class="hljs-comment">/*DSA*/</span>&#123;<br>      <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> ( exp[i] ) &#123; <span class="hljs-comment">//左括号直接进栈；右括号若与栈顶失配，则表达式必不匹配</span><br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[&#x27;</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>: S.<span class="hljs-built_in">push</span> ( exp[i] ); <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>: <span class="hljs-keyword">if</span> ( ( S.<span class="hljs-built_in">empty</span>() ) || ( <span class="hljs-string">&#x27;(&#x27;</span> != S.<span class="hljs-built_in">pop</span>() ) ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;]&#x27;</span>: <span class="hljs-keyword">if</span> ( ( S.<span class="hljs-built_in">empty</span>() ) || ( <span class="hljs-string">&#x27;[&#x27;</span> != S.<span class="hljs-built_in">pop</span>() ) ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#125;&#x27;</span>: <span class="hljs-keyword">if</span> ( ( S.<span class="hljs-built_in">empty</span>() ) || ( <span class="hljs-string">&#x27;&#123;&#x27;</span> != S.<span class="hljs-built_in">pop</span>() ) ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>: <span class="hljs-keyword">break</span>; <span class="hljs-comment">//非括号字符一律忽略</span><br>   &#125;<br>   <span class="hljs-keyword">return</span> S.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//最终栈空，当且仅当匹配</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>当匹配到右括号时，栈为空，说明没有多余的左括号与右括号匹配。</p><p>当返回值<code>S.empty()</code>的结果不为空时，说明栈里面还有元素，即没有多余的右括号与左括号匹配。</p><h3 id="反思与拓展"><a href="#反思与拓展" class="headerlink" title="反思与拓展"></a>反思与拓展</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a304f7abfbe927792152fa08a4016af8-c2796b.png" alt="反思"></p><p>对于上图，上方的计数器其实就可以完成下方的栈操作，因为计数器实际上就代表着某一时刻栈中元素的个数。</p><p>但是计数器并不能代替栈，因为计数器只能代表数量，无法进行精确的匹配。比如下图的反例。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/ad4f3b44f3eb8186c94db7639364fd0c-8288d1.png" alt="拓展"></p><h2 id="栈应用：栈混洗"><a href="#栈应用：栈混洗" class="headerlink" title="栈应用：栈混洗"></a>栈应用：栈混洗</h2><h3 id="混洗"><a href="#混洗" class="headerlink" title="混洗"></a>混洗</h3><p><strong>&lt;</strong>为顶，]为底，<strong>S</strong>为中转栈</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7efc2b2249742946bf05bdfd09cb8c52-86bb2d.png" alt="混洗1"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/95ad6123955c89095d39c8ef9277fcd3-ff0010.png" alt="混洗2"></p><h3 id="计数（待证明）"><a href="#计数（待证明）" class="headerlink" title="计数（待证明）"></a>计数（待证明）</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/58597e426089ae5b1f3eb99823abfe25-7c52f4.png" alt="计数"></p><p>栈混洗的合法序列数目公式：</p><script type="math/tex; mode=display">(2n)!/(n+1)!/n!</script><h3 id="甄别算法"><a href="#甄别算法" class="headerlink" title="甄别算法"></a>甄别算法</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/cd6083fd09d68ea2535f89e1d6d9ad1a-36dc7d.png" alt="甄别"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/e4a38d23690da8e80e55be84ffb75568-2044d4.png" alt="甄别算法"></p><h3 id="栈混洗与括号匹配之间的关系"><a href="#栈混洗与括号匹配之间的关系" class="headerlink" title="栈混洗与括号匹配之间的关系"></a>栈混洗与括号匹配之间的关系</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/d0b6e47190b1beb5dac76523cf557b1e-d6cdfe.png" alt=""></p><ul><li>由n对括号所构成的任何一个合法的表达式，就是对n个元素进行栈混洗的一个合法的过程</li><li>合法的栈混洗序列与合法的括号匹配表达式之间，存在一一对应的关系</li><li>n个元素的栈混洗有多少种，n个括号所能构成的合法表达式就有多少种</li></ul><h2 id="栈应用：中缀表达式求值（延迟缓冲）"><a href="#栈应用：中缀表达式求值（延迟缓冲）" class="headerlink" title="栈应用：中缀表达式求值（延迟缓冲）"></a>栈应用：中缀表达式求值（延迟缓冲）</h2><h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7864cdf5387de5df5548902918c16591-39db72.png" alt="表达式求值"></p><h3 id="构思-1"><a href="#构思-1" class="headerlink" title="构思"></a>构思</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/de7ec16642067058e9cde21fdd61d07e-58440a.png" alt="构思"></p><p>如果使用线性扫描，扫描的次序未必与运算的次序一致</p><p>思路：使用栈结构缓冲</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/2a22255b51c53f4a9ba256f95c721f64-13e9f3.png" alt="栈结构缓冲"></p><ul><li>scanned：已经扫描过的部分</li><li>done：经过判断以后，能够及时处理的，能够在局部具有足够高的优先级，并且已经计算过的部分</li><li>buffered：经过判断无法进行处理的部分</li><li>to scan：还未扫描的部分</li></ul><h3 id="求值算法：线性扫描"><a href="#求值算法：线性扫描" class="headerlink" title="求值算法：线性扫描"></a>求值算法：线性扫描</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/e3730a3ba7592224f006ead7c751cad7-1ead5e.png" alt="求值算法：线性扫描"></p><h3 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h3><h4 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/dccbd4c109f5a7806c98e90f5f210439-2b1840.png" alt="整体框架"></p><h4 id="判断运算符优先级思路"><a href="#判断运算符优先级思路" class="headerlink" title="判断运算符优先级思路"></a>判断运算符优先级思路</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/37024000b71c1abb49c2951d614aa418-0b90c1.png" alt="判断运算符优先级思路"></p><ul><li>&lt;：优先级低</li><li>>：优先级高</li><li>=：优先级一样</li><li>“ “：？</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a59beb00fca120f36720b72ddef5eb86-086a5b.png" alt="优先级处理方法"></p><p>当<code>case &#39;=&#39;</code>时，有两种情况。</p><ol><li>说明左括号匹配到了右括号。右括号之前的运算符已经被执行，就是说此时的操作数栈顶为括号中的值。所以直接将运算符栈顶中的左括号出栈即可。</li><li>说明运算符栈最初栈底的那个<code>&#39;\0&#39;</code>被当前运算符中的<code>&#39;\0&#39;</code>所匹配，即当前的运算已经结束，直接将运算符栈底的<code>&#39;\0&#39;</code>出栈即可。</li></ol><h2 id="栈应用：逆波兰表达式（栈式计算）"><a href="#栈应用：逆波兰表达式（栈式计算）" class="headerlink" title="栈应用：逆波兰表达式（栈式计算）"></a>栈应用：逆波兰表达式（栈式计算）</h2><h3 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/70ab0eca59f4bedf2081a86a903fc154-1632db.png" alt="简化"></p><p>在逆波兰表达式中，运算符谁先出现，就先运算</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/3563ddbdb272082de491a0b655d49b60-3a5db2.png" alt="实例"></p><p>读到操作数，便将操作数入栈。读到运算符，根据运算符需要几个操作数，再从操作数栈弹出几个，然后将计算的结果重新推入操作数栈。</p><h3 id="中缀表达式转化为RPN"><a href="#中缀表达式转化为RPN" class="headerlink" title="中缀表达式转化为RPN"></a>中缀表达式转化为RPN</h3><p><strong>运算符</strong>未必保持之前的相对次序，但是<strong>操作数</strong>的相对次序永远不会改变</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/3a3e09c5daa1e31189657c60164b5a0e-63f0bd.png" alt="转化"></p><p>例子：中缀表达式$(1+2<em>3!)/(4</em>5-7)$转化为RPN：$123!<em>+45</em>7-/$</p><h3 id="算法（待证明）"><a href="#算法（待证明）" class="headerlink" title="算法（待证明）"></a>算法（待证明）</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">evaluate</span> <span class="hljs-params">( <span class="hljs-keyword">char</span>* S, <span class="hljs-keyword">char</span>*&amp; RPN )</span> </span>&#123; <span class="hljs-comment">//对（已剔除白空格的）表达式S求值，并转换为逆波兰式RPN</span><br>   Stack&lt;<span class="hljs-keyword">double</span>&gt; opnd; Stack&lt;<span class="hljs-keyword">char</span>&gt; optr; <span class="hljs-comment">//运算数栈、运算符栈 /*DSA*/任何时刻，其中每对相邻元素之间均大小一致</span><br>   <span class="hljs-comment">/*DSA*/</span> <span class="hljs-keyword">char</span>* expr = S;<br>   optr.<span class="hljs-built_in">push</span> ( <span class="hljs-string">&#x27;\0&#x27;</span> ); <span class="hljs-comment">//尾哨兵&#x27;\0&#x27;也作为头哨兵首先入栈</span><br>   <span class="hljs-keyword">while</span> ( !optr.<span class="hljs-built_in">empty</span>() ) &#123; <span class="hljs-comment">//在运算符栈非空之前，逐个处理表达式中各字符</span><br>      <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">isdigit</span> ( *S ) ) &#123; <span class="hljs-comment">//若当前字符为操作数，则</span><br>         <span class="hljs-built_in">readNumber</span> ( S, opnd ); <span class="hljs-built_in">append</span> ( RPN, opnd.<span class="hljs-built_in">top</span>() ); <span class="hljs-comment">//读入操作数，并将其接至RPN末尾</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-comment">//若当前字符为运算符，则</span><br>         <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> ( <span class="hljs-built_in">orderBetween</span> ( optr.<span class="hljs-built_in">top</span>(), *S ) ) &#123; <span class="hljs-comment">//视其与栈顶运算符之间优先级高低分别处理</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>: <span class="hljs-comment">//栈顶运算符优先级更低时</span><br>               optr.<span class="hljs-built_in">push</span> ( *S ); S++; <span class="hljs-comment">//计算推迟，当前运算符进栈</span><br>               <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;=&#x27;</span>: <span class="hljs-comment">//优先级相等（当前运算符为右括号或者尾部哨兵&#x27;\0&#x27;）时</span><br>               optr.<span class="hljs-built_in">pop</span>(); S++; <span class="hljs-comment">//脱括号并接收下一个字符</span><br>               <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>: &#123; <span class="hljs-comment">//栈顶运算符优先级更高时，可实施相应的计算，并将结果重新入栈</span><br>               <span class="hljs-keyword">char</span> op = optr.<span class="hljs-built_in">pop</span>(); <span class="hljs-built_in">append</span> ( RPN, op ); <span class="hljs-comment">//栈顶运算符出栈并续接至RPN末尾</span><br>               <span class="hljs-keyword">if</span> ( <span class="hljs-string">&#x27;!&#x27;</span> == op ) &#123; <span class="hljs-comment">//若属于一元运算符</span><br>                  <span class="hljs-keyword">double</span> pOpnd = opnd.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//只需取出一个操作数，并</span><br>                  opnd.<span class="hljs-built_in">push</span> ( <span class="hljs-built_in">calcu</span> ( op, pOpnd ) ); <span class="hljs-comment">//实施一元计算，结果入栈</span><br>               &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//对于其它（二元）运算符</span><br>                  <span class="hljs-keyword">double</span> pOpnd2 = opnd.<span class="hljs-built_in">pop</span>(), pOpnd1 = opnd.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//取出后、前操作数 /*DSA*/提问：可否省去两个临时变量？</span><br>                  opnd.<span class="hljs-built_in">push</span> ( <span class="hljs-built_in">calcu</span> ( pOpnd1, op, pOpnd2 ) ); <span class="hljs-comment">//实施二元计算，结果入栈</span><br>               &#125;<br>               <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">default</span> : <span class="hljs-built_in">exit</span> ( <span class="hljs-number">-1</span> ); <span class="hljs-comment">//逢语法错误，不做处理直接退出</span><br>         &#125;<span class="hljs-comment">//switch</span><br>      <span class="hljs-comment">/*DSA*/</span><span class="hljs-built_in">displayProgress</span> ( expr, S, opnd, optr, RPN );<br>   &#125;<span class="hljs-comment">//while</span><br>   <span class="hljs-keyword">return</span> opnd.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//弹出并返回最后的计算结果</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="队列接口与实现"><a href="#队列接口与实现" class="headerlink" title="队列接口与实现"></a>队列接口与实现</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/60bb6f2eb0bb7a1790afd23190a89bcb-216718.png" alt="接口"></p><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7883ee153fec58b18e6ef22686658986-6a78eb.png" alt="实例"></p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p><strong>队列继承于列表</strong></p><p>而对于栈继承于向量：</p><ul><li>栈顶的选择会比较敏感，因为会影响到一些方法的效率。所以栈继承于向量，向量的尾部将作为栈的栈顶。</li></ul><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/704e6c0514c9ff071eb94282df0c4d3b-689487.png" alt="实现"></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="使用栈实现队列"><a href="#使用栈实现队列" class="headerlink" title="使用栈实现队列"></a>使用栈实现队列</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/d5648635d5343df1b5013ba55ab417ee-7c7c5b.png" alt="使用栈实现队列"></p><p>该数据结构即为队列。<code>enqueue()</code>的复杂度为O(1)，单次<code>dequeue()的</code>最坏时间复杂度为Ω(n)。但分摊复杂度为O(1)。</p><h3 id="使用队列实现栈"><a href="#使用队列实现栈" class="headerlink" title="使用队列实现栈"></a>使用队列实现栈</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/82f921fe6bf8aebd05c26e3dca788996-259bf9.png" alt="使用队列实现栈"></p><p>该数据结构即为栈，只不过规模为n时，其<code>pop()</code>的时间复杂度高达Ω(n)。</p><h3 id="常见的量"><a href="#常见的量" class="headerlink" title="常见的量"></a>常见的量</h3><ul><li>不同的n位二进制数个数： $ 2^n$</li><li>n对小括号所能构成的合法括号匹配个数：Catalan(n)</li><li>{1, 2 .. n}的不同栈混洗个数：Catalan(n)</li><li>含n个运算符的中缀表达式求值过程中运算符栈push操作的次数：≤n</li></ul><p><strong>注：栈混洗中的push和pop分别对应于括号匹配中的”( ”和”) ”,故它们数量相等</strong></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>列表</title>
    <link href="/2020/02/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E5%88%97%E8%A1%A8/"/>
    <url>/2020/02/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E5%88%97%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="接口与实现"><a href="#接口与实现" class="headerlink" title="接口与实现"></a>接口与实现</h2><h3 id="从静态到动态"><a href="#从静态到动态" class="headerlink" title="从静态到动态"></a>从静态到动态</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210708151945.png" alt="从静态到动态"></p><p>静态操作在向量上效率很高，但是对于动态操作却效率低下</p><h3 id="从向量到列表"><a href="#从向量到列表" class="headerlink" title="从向量到列表"></a>从向量到列表</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210708152420.png" alt="从向量到列表"></p><h3 id="从秩到位置"><a href="#从秩到位置" class="headerlink" title="从秩到位置"></a>从秩到位置</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210708152832.png" alt="从秩到位置"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><h5 id="节点接口"><a href="#节点接口" class="headerlink" title="节点接口"></a>节点接口</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210708152941.png" alt="接口"></p><h5 id="列表接口"><a href="#列表接口" class="headerlink" title="列表接口"></a>列表接口</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210708153054.png" alt="接口2"></p><h4 id="模板类"><a href="#模板类" class="headerlink" title="模板类"></a>模板类</h4><h5 id="节点模板类"><a href="#节点模板类" class="headerlink" title="节点模板类"></a>节点模板类</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210708153142.png" alt="模板类"></p><h5 id="列表模板类"><a href="#列表模板类" class="headerlink" title="列表模板类"></a>列表模板类</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210708153602.png" alt="列表模板类"></p><p>头尾节点对外部隐藏，作为哨兵节点存在。首末节点为实实在在的数据，虽然不一定存在。</p><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> List&lt;T&gt;::<span class="hljs-built_in">init</span>() &#123; <span class="hljs-comment">//列表初始化，在创建列表对象时统一调用</span><br>   header = <span class="hljs-keyword">new</span> ListNode&lt;T&gt;; <span class="hljs-comment">//创建头哨兵节点</span><br>   trailer = <span class="hljs-keyword">new</span> ListNode&lt;T&gt;; <span class="hljs-comment">//创建尾哨兵节点</span><br>   header-&gt;succ = trailer; header-&gt;pred = <span class="hljs-literal">NULL</span>;<br>   trailer-&gt;pred = header; trailer-&gt;succ = <span class="hljs-literal">NULL</span>;<br>   _size = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录规模</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/3e207cd22c3b769aa3dbe771cff9d64e-71603.png" alt="链表构造"></p><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><h3 id="循秩访问-模仿"><a href="#循秩访问-模仿" class="headerlink" title="循秩访问(模仿)"></a>循秩访问(模仿)</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//重载下标操作符，以通过秩直接访问列表节点（虽方便，效率低，需慎用）</span><br>T&amp; List&lt;T&gt;::<span class="hljs-keyword">operator</span>[] ( Rank r ) <span class="hljs-keyword">const</span> &#123; <span class="hljs-comment">//assert: 0 &lt;= r &lt; size</span><br>   ListNodePosi&lt;T&gt; p = <span class="hljs-built_in">first</span>(); <span class="hljs-comment">//从首节点出发</span><br>   <span class="hljs-keyword">while</span> ( <span class="hljs-number">0</span> &lt; r-- ) p = p-&gt;succ; <span class="hljs-comment">//顺数第r个节点即是</span><br>   <span class="hljs-keyword">return</span> p-&gt;data; <span class="hljs-comment">//目标节点，返回其中所存元素</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>平均复杂度为(1+2+3+….+n)/n= $O(n^2)$/n = $O(n)$</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>在节点p（可能是trailer）的n个（真）前驱中，找到等于e的最后者：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//在无序列表内节点p（可能是trailer）的n个（真）前驱中，找到等于e的最后者</span><br>ListNodePosi&lt;T&gt; List&lt;T&gt;::<span class="hljs-built_in">find</span> ( T <span class="hljs-keyword">const</span>&amp; e, <span class="hljs-keyword">int</span> n, ListNodePosi&lt;T&gt; p ) <span class="hljs-keyword">const</span> &#123;<br>   <span class="hljs-keyword">while</span> ( <span class="hljs-number">0</span> &lt; n-- ) <span class="hljs-comment">//（0 &lt;= n &lt;= rank(p) &lt; _size）对于p的最近的n个前驱，从右向左</span><br>      <span class="hljs-keyword">if</span> ( e == ( p = p-&gt;pred )-&gt;data ) <span class="hljs-keyword">return</span> p; <span class="hljs-comment">//逐个比对，直至命中或范围越界</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//p越出左边界意味着区间内不含e，查找失败</span><br>&#125; <span class="hljs-comment">//失败时，返回NULL</span><br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/807b15b70f354fc5775b9042b76bfb2b-0f65f.png" alt="查找"></p><p>最坏复杂度为O(n)</p><p>另外，函数形参特定的排放顺序，虽然对程序没什么影响，但是可以更贴近语义。比如<code>find(e,n,p)</code>可以表示从p的n个前驱节点中查询e；而<code>find(e,p,n)</code>可以表示从p的n个后继节点中查询e。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//将e紧靠当前节点之前插入于当前节点所属列表（设有哨兵头节点header）</span><br>ListNodePosi&lt;T&gt; ListNode&lt;T&gt;::<span class="hljs-built_in">insertAsPred</span> ( T <span class="hljs-keyword">const</span>&amp; e ) &#123;<br>   ListNodePosi&lt;T&gt; x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span> ( e, pred, <span class="hljs-keyword">this</span> ); <span class="hljs-comment">//创建新节点</span><br>   pred-&gt;succ = x; pred = x; <span class="hljs-comment">//设置正向链接</span><br>   <span class="hljs-keyword">return</span> x; <span class="hljs-comment">//返回新节点的位置</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/952eb5e294395fcdd1e8b1a836adf5c4-07b95.png" alt="插入"></p><p>对于特殊情况下，比如当前节点为首节点，由于存在了一个头节点（哨兵节点），所以取首节点的前驱也是安全的。</p><h3 id="基于复制的构造"><a href="#基于复制的构造" class="headerlink" title="基于复制的构造"></a>基于复制的构造</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//列表内部方法：复制列表中自位置p起的n项</span><br><span class="hljs-keyword">void</span> List&lt;T&gt;::<span class="hljs-built_in">copyNodes</span> ( ListNodePosi&lt;T&gt; p, <span class="hljs-keyword">int</span> n ) &#123; <span class="hljs-comment">//p合法，且至少有n-1个真后继节点</span><br>   <span class="hljs-built_in">init</span>(); <span class="hljs-comment">//创建头、尾哨兵节点并做初始化</span><br>   <span class="hljs-keyword">while</span> ( n-- ) &#123; <span class="hljs-built_in">insertAsLast</span> ( p-&gt;data ); p = p-&gt;succ; &#125; <span class="hljs-comment">//将起自p的n项依次作为末节点插入</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; T List&lt;T&gt;::<span class="hljs-built_in">remove</span> ( ListNodePosi&lt;T&gt; p ) &#123; <span class="hljs-comment">//删除合法节点p，返回其数值</span><br>   T e = p-&gt;data; <span class="hljs-comment">//备份待删除节点的数值（假定T类型可直接赋值）</span><br>   p-&gt;pred-&gt;succ = p-&gt;succ; p-&gt;succ-&gt;pred = p-&gt;pred; <span class="hljs-comment">//后继、前驱</span><br>   <span class="hljs-keyword">delete</span> p; _size--; <span class="hljs-comment">//释放节点，更新规模</span><br>   <span class="hljs-keyword">return</span> e; <span class="hljs-comment">//返回备份的数值</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6708837a86e0ab198ffe8a0750af1913-1321a.png" alt="删除"></p><h3 id="析构"><a href="#析构" class="headerlink" title="析构"></a>析构</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">int</span> List&lt;T&gt;::<span class="hljs-built_in">clear</span>() &#123; <span class="hljs-comment">//清空列表</span><br>   <span class="hljs-keyword">int</span> oldSize = _size;<br>   <span class="hljs-keyword">while</span> ( <span class="hljs-number">0</span> &lt; _size ) <span class="hljs-built_in">remove</span> ( header-&gt;succ ); <span class="hljs-comment">//反复删除首节点，直至列表变空</span><br>   <span class="hljs-keyword">return</span> oldSize;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a85ae645960e7c3924a624c48da44f91-3ee8f.png" alt="析构"></p><h3 id="唯一化"><a href="#唯一化" class="headerlink" title="唯一化"></a>唯一化</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">int</span> List&lt;T&gt;::<span class="hljs-built_in">deduplicate</span>() &#123;<br>   <span class="hljs-keyword">int</span> oldSize = _size; ListNodePosi&lt;T&gt; p = <span class="hljs-built_in">first</span>();<br>   <span class="hljs-keyword">for</span> ( Rank r = <span class="hljs-number">0</span>; p != trailer; p = p-&gt;succ ) <span class="hljs-comment">//O(n)</span><br>      <span class="hljs-keyword">if</span> ( ListNodePosi&lt;T&gt; q = <span class="hljs-built_in">find</span>(p-&gt;data, r, p) )<br>         <span class="hljs-built_in">remove</span>(q); <span class="hljs-comment">//此时q与p雷同，但删除前者更为简明</span><br>      <span class="hljs-keyword">else</span> r++; <span class="hljs-comment">//r为无重前缀的长度</span><br>   <span class="hljs-keyword">return</span> oldSize - _size; <span class="hljs-comment">//删除元素总数</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>若找到相同元素，删除q而不删除p的原因是：如果删除了p，那么<code>while(trailer != (p = p-&gt;succ))</code>这条语句将会是不安全的</p><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><h3 id="唯一化-1"><a href="#唯一化-1" class="headerlink" title="唯一化"></a>唯一化</h3><h4 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210708171509.png" alt="构思"></p><p>移动指针p来剔除重复元素</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">int</span> List&lt;T&gt;::<span class="hljs-built_in">uniquify</span>() &#123; <span class="hljs-comment">//成批剔除重复元素，效率更高</span><br>   <span class="hljs-keyword">if</span> ( _size &lt; <span class="hljs-number">2</span> ) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//平凡列表自然无重复</span><br>   <span class="hljs-keyword">int</span> oldSize = _size; <span class="hljs-comment">//记录原规模</span><br>   ListNodePosi&lt;T&gt; p = <span class="hljs-built_in">first</span>(); ListNodePosi&lt;T&gt; q; <span class="hljs-comment">//p为各区段起点，q为其后继</span><br>   <span class="hljs-keyword">while</span> ( trailer != ( q = p-&gt;succ ) ) <span class="hljs-comment">//反复考查紧邻的节点对(p, q)</span><br>      <span class="hljs-keyword">if</span> ( p-&gt;data != q-&gt;data ) p = q; <span class="hljs-comment">//若互异，则转向下一区段</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-built_in">remove</span> ( q ); <span class="hljs-comment">//否则（雷同），删除后者</span><br>   <span class="hljs-keyword">return</span> oldSize - _size; <span class="hljs-comment">//列表规模变化量，即被删除元素总数</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//在有序列表内节点p（可能是trailer）的n个（真）前驱中，找到不大于e的最后者</span><br>ListNodePosi&lt;T&gt; List&lt;T&gt;::<span class="hljs-built_in">search</span> ( T <span class="hljs-keyword">const</span>&amp; e, <span class="hljs-keyword">int</span> n, ListNodePosi&lt;T&gt; p ) <span class="hljs-keyword">const</span> &#123;<br>   <span class="hljs-keyword">do</span> &#123;<br>      p = p-&gt;pred; n--;  <span class="hljs-comment">//从右向左</span><br>   &#125; <span class="hljs-keyword">while</span> ( ( <span class="hljs-number">-1</span> &lt; n ) &amp;&amp; ( e &lt; p-&gt;data ) ); <span class="hljs-comment">//逐个比较，直至命中或越界</span><br>   <span class="hljs-keyword">return</span> p; <span class="hljs-comment">//返回查找终止的位置</span><br>&#125; <span class="hljs-comment">//失败时，返回区间左边界的前驱（可能是header）——调用者可通过valid()判断成功与否</span><br></code></pre></div></td></tr></table></figure><p>向量与列表可以类比于RAM模型和图灵机模型</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="构思-1"><a href="#构思-1" class="headerlink" title="构思"></a>构思</h3><p>对于起泡排序，效率低下的来源为每一次相邻元素的比较、交换，类似于小步慢跑。选择排序就是为了优化这部分低效率的影响</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f4454098e02801507e59e1feb8733d4b.png" alt="实现"></p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//对列表中起始于位置p、宽度为n的区间做选择排序</span><br><span class="hljs-keyword">void</span> List&lt;T&gt;::<span class="hljs-built_in">selectionSort</span> ( ListNodePosi&lt;T&gt; p, <span class="hljs-keyword">int</span> n ) &#123; <span class="hljs-comment">//valid(p) &amp;&amp; rank(p) + n &lt;= size</span><br>   ListNodePosi&lt;T&gt; head = p-&gt;pred, tail = p;<br>   <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++ ) tail = tail-&gt;succ; <span class="hljs-comment">//待排序区间为(head, tail)</span><br>   <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> &lt; n ) &#123; <span class="hljs-comment">//在至少还剩两个节点之前，在待排序区间内</span><br>      ListNodePosi&lt;T&gt; max = <span class="hljs-built_in">selectMax</span> ( head-&gt;succ, n ); <span class="hljs-comment">//找出最大者（歧义时后者优先）</span><br>      <span class="hljs-built_in">insertB</span> ( tail, <span class="hljs-built_in">remove</span> ( max ) ); <span class="hljs-comment">//将其移至无序区间末尾（作为有序区间新的首元素）</span><br>      tail = tail-&gt;pred; n--;<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/746742ba68dc285a435182987eece30a-6746a.png" alt="排序"></p><p><code>selectMax(head-&gt;succ,n)</code>将返回以head-&gt;succ为节点，区域为n的最大值M。然后将M插入到T(tail)的前面，再将T移动到M的位置上。从整个排序区间的角度来看，通过每一次迭代，前面的无序区间[p,T)和后面的有序区间[T,p+n)都在同时的减少和增大。</p><h3 id="推敲"><a href="#推敲" class="headerlink" title="推敲"></a>推敲</h3><ol><li>对于选择排序中出现的<code>insertBefore()</code>和<code>remove()</code>，对于算法来说会简洁一些，但是这两个函数中有<code>new</code>和<code>delete</code>的操作，这两个操作的时间复杂度差不多为O(100)，相对于O(1)多出了两个数量级。</li><li>对于特殊情况，当M正好是T的直接前驱，那么无需再进行<code>insertBefore()</code>操作</li></ol><h3 id="实现：selectMax"><a href="#实现：selectMax" class="headerlink" title="实现：selectMax()"></a>实现：selectMax()</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//从起始于位置p的n个元素中选出最大者</span><br>ListNodePosi&lt;T&gt; List&lt;T&gt;::<span class="hljs-built_in">selectMax</span> ( ListNodePosi&lt;T&gt; p, <span class="hljs-keyword">int</span> n ) &#123;<br>   ListNodePosi&lt;T&gt; max = p; <span class="hljs-comment">//最大者暂定为首节点p</span><br>   <span class="hljs-keyword">for</span> ( ListNodePosi&lt;T&gt; cur = p; <span class="hljs-number">1</span> &lt; n; n-- ) <span class="hljs-comment">//从首节点p出发，将后续节点逐一与max比较</span><br>      <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">lt</span> ( ( cur = cur-&gt;succ )-&gt;data, max-&gt;data ) ) <span class="hljs-comment">//若当前元素不小于max，则</span><br>         max = cur; <span class="hljs-comment">//更新最大元素位置记录</span><br>   <span class="hljs-keyword">return</span> max; <span class="hljs-comment">//返回最大节点位置</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/acc8e71fb0607e3f135fccf7b4034542-eda3c.png" alt="selectMax流程"></p><p>如果cur-&gt;data不小于max-&gt;data（大于等于），那么就更新max。</p><p>这样做的好处，对于selectMax()来说，当最大的值有多个，那么会取位置最靠后的一个，符合规范或者说语义。对于选择排序算法来说，当有多个相同的值，那么最后的排序结果中，这些值的相对位置不会被改变，即符合了算法的稳定性。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5a9f95ffa3fbd7e5c98485db24f8d6c5-ad5717.png" alt="性能"></p><p>虽然说选择排序和起泡排序的复杂度一样，但是实际上由于移动的操作更少，所以会更快一些。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="构思-2"><a href="#构思-2" class="headerlink" title="构思"></a>构思</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/27e7f74b3d4cdbaaa3afd825e16d34a3-c0cb5f.png" alt="构思"></p><h3 id="对比（与选择排序）"><a href="#对比（与选择排序）" class="headerlink" title="对比（与选择排序）"></a>对比（与选择排序）</h3><ol><li>选择排序的unsorted在前，sorted在后。插入排序则相反</li><li>选择排序中unsorted的最大值<strong>不会超过</strong>sorted的最小值，而插入排序没有任何限制</li></ol><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f91d2680c6fc806564d439d0bed4487b-e2c408.png" alt="实例"></p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7eca1f0f90cedec9923d7f47213098f8-1332a5.png" alt="实现"></p><ol><li><code>search()</code>返回一个不大于p的合适的位置k</li><li><code>insertAfter()</code>将p插入到位置k的后面</li><li>此时有序区间内已经有p，无序区间内也有p，所以将无序区间内的p往后移(<code>p=p-&gt;succ</code>)，以用于下一次迭代操作</li><li><code>remove()</code>删除掉本次迭代中，p原本所处位置的节点，因为这个节点已经放入有序区间内</li></ol><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/66c1d062032840604ebdbc2990a0bcac-864fe2.png" alt="性能分析"></p><p>插入排序中的<code>select()</code>采用向量的结构去替代列表，于事无补</p><h4 id="平均性能（待证明）"><a href="#平均性能（待证明）" class="headerlink" title="平均性能（待证明）"></a>平均性能（待证明）</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f66cbc1c3a4e0afdc2ec36696a15104d-84af0c.png" alt="平均性能"></p><p>插入排序的最好情况概率极低，而它的平均复杂度和最坏复杂度都为$O(n^2)$</p><h3 id="逆序对（待证明）"><a href="#逆序对（待证明）" class="headerlink" title="逆序对（待证明）"></a>逆序对（待证明）</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/114437c50d38ac9ec1407555a44d799a-002483.png" alt="逆序对"></p><p>逆序对：一个长度为n的列表中，两个元素（不一定相邻）以”大-&gt;小“的顺序出现</p><p>I：表示长度为n的列表中逆序对的总数。I最多为$n^2$个，最少为0个，即I为无序程度</p><p>由于插入排序大量消耗的时间都在对逆序对进行排序，所以插入排序的复杂度可视为O(I+n)，其中的n为插入排序中元素交换操作的复杂度。所以根据逆序对可得出插入排序的最好和最坏复杂度分别是$O(n)$、$O(n^2)$。</p><p>总结：插入排序的复杂度取决于列表的无序程度，无序程度的范围为0~$n^2$，所以说插入排序是输入敏感的算法</p><p><strong>问：</strong>长度为n的列表，被等分为n/k段，每段长度为k，不同段之间的元素不存在逆序。对该列表进行插入排序的最坏时间复杂度为？</p><p><strong>答：</strong>$O(nk)$。对每段的排序实际上可以视为分别进行。在某些库中的排序算法（比如STL中的sort）会先用其它的排序算法达到以上分段的效果，再对整个序列调用插入排序，以期获得较高的实际效率。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>选择排序</tag>
      
      <tag>插入排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>向量</title>
    <link href="/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E5%90%91%E9%87%8F/"/>
    <url>/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E5%90%91%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="向量的定义"><a href="#向量的定义" class="headerlink" title="向量的定义"></a>向量的定义</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210629230258.png" alt="向量的定义"></p><h2 id="向量的构造和析构"><a href="#向量的构造和析构" class="headerlink" title="向量的构造和析构"></a>向量的构造和析构</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/******************************************************************************************</span><br><span class="hljs-comment"> * Data Structures in C++</span><br><span class="hljs-comment"> * ISBN: 7-302-33064-6 &amp; 7-302-33065-3 &amp; 7-302-29652-2 &amp; 7-302-26883-3</span><br><span class="hljs-comment"> * Junhui DENG, deng@tsinghua.edu.cn</span><br><span class="hljs-comment"> * Computer Science &amp; Technology, Tsinghua University</span><br><span class="hljs-comment"> * Copyright (c) 2003-2020. All rights reserved.</span><br><span class="hljs-comment"> ******************************************************************************************/</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><br><span class="hljs-keyword">using</span> Rank = <span class="hljs-keyword">int</span>; <span class="hljs-comment">//秩</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFAULT_CAPACITY  3 <span class="hljs-comment">//默认的初始容量（实际应用中可设置为更大）</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vector</span> &#123;</span> <span class="hljs-comment">//向量模板类</span><br><span class="hljs-keyword">protected</span>:<br>   Rank _size; <span class="hljs-keyword">int</span> _capacity;  T* _elem; <span class="hljs-comment">//规模、容量、数据区</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copyFrom</span> <span class="hljs-params">( T <span class="hljs-keyword">const</span>* A, Rank lo, Rank hi )</span></span>; <span class="hljs-comment">//复制数组区间A[lo, hi)</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">expand</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//空间不足时扩容</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shrink</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//装填因子过小时压缩</span><br>   <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bubble</span> <span class="hljs-params">( Rank lo, Rank hi )</span></span>; <span class="hljs-comment">//扫描交换</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span> <span class="hljs-params">( Rank lo, Rank hi )</span></span>; <span class="hljs-comment">//起泡排序算法</span><br>   <span class="hljs-function">Rank <span class="hljs-title">maxItem</span> <span class="hljs-params">( Rank lo, Rank hi )</span></span>; <span class="hljs-comment">//选取最大元素</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selectionSort</span> <span class="hljs-params">( Rank lo, Rank hi )</span></span>; <span class="hljs-comment">//选择排序算法</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span> <span class="hljs-params">( Rank lo, Rank mi, Rank hi )</span></span>; <span class="hljs-comment">//归并算法</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span> <span class="hljs-params">( Rank lo, Rank hi )</span></span>; <span class="hljs-comment">//归并排序算法</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span> <span class="hljs-params">( Rank lo, Rank hi )</span></span>; <span class="hljs-comment">//堆排序（稍后结合完全堆讲解）</span><br>   <span class="hljs-function">Rank <span class="hljs-title">partition</span> <span class="hljs-params">( Rank lo, Rank hi )</span></span>; <span class="hljs-comment">//轴点构造算法</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span> <span class="hljs-params">( Rank lo, Rank hi )</span></span>; <span class="hljs-comment">//快速排序算法</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shellSort</span> <span class="hljs-params">( Rank lo, Rank hi )</span></span>; <span class="hljs-comment">//希尔排序算法</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br>   <span class="hljs-built_in">Vector</span> ( <span class="hljs-keyword">int</span> c = DEFAULT_CAPACITY, <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>, T v = <span class="hljs-number">0</span> ) <span class="hljs-comment">//容量为c、规模为s、所有元素初始为v</span><br>   &#123; _elem = <span class="hljs-keyword">new</span> T[_capacity = c]; <span class="hljs-keyword">for</span> ( _size = <span class="hljs-number">0</span>; _size &lt; s; _elem[_size++] = v ); &#125; <span class="hljs-comment">//s&lt;=c</span><br>   <span class="hljs-built_in">Vector</span> ( T <span class="hljs-keyword">const</span>* A, Rank n ) &#123; <span class="hljs-built_in">copyFrom</span> ( A, <span class="hljs-number">0</span>, n ); &#125; <span class="hljs-comment">//数组整体复制</span><br>   <span class="hljs-built_in">Vector</span> ( T <span class="hljs-keyword">const</span>* A, Rank lo, Rank hi ) &#123; <span class="hljs-built_in">copyFrom</span> ( A, lo, hi ); &#125; <span class="hljs-comment">//区间</span><br>   <span class="hljs-built_in">Vector</span> ( Vector&lt;T&gt; <span class="hljs-keyword">const</span>&amp; V ) &#123; <span class="hljs-built_in">copyFrom</span> ( V._elem, <span class="hljs-number">0</span>, V._size ); &#125; <span class="hljs-comment">//向量整体复制</span><br>   <span class="hljs-built_in">Vector</span> ( Vector&lt;T&gt; <span class="hljs-keyword">const</span>&amp; V, Rank lo, Rank hi ) &#123; <span class="hljs-built_in">copyFrom</span> ( V._elem, lo, hi ); &#125; <span class="hljs-comment">//区间</span><br><span class="hljs-comment">// 析构函数</span><br>   ~<span class="hljs-built_in">Vector</span>() &#123; <span class="hljs-keyword">delete</span> [] _elem; &#125; <span class="hljs-comment">//释放内部空间</span><br><span class="hljs-comment">// 只读访问接口</span><br>   <span class="hljs-function">Rank <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _size; &#125; <span class="hljs-comment">//规模</span><br>   <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> !_size; &#125; <span class="hljs-comment">//判空</span><br>   <span class="hljs-function">Rank <span class="hljs-title">find</span> <span class="hljs-params">( T <span class="hljs-keyword">const</span>&amp; e )</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span> ( e, <span class="hljs-number">0</span>, _size ); &#125; <span class="hljs-comment">//无序向量整体查找</span><br>   <span class="hljs-function">Rank <span class="hljs-title">find</span> <span class="hljs-params">( T <span class="hljs-keyword">const</span>&amp; e, Rank lo, Rank hi )</span> <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">//无序向量区间查找</span><br>   <span class="hljs-function">Rank <span class="hljs-title">search</span> <span class="hljs-params">( T <span class="hljs-keyword">const</span>&amp; e )</span> <span class="hljs-keyword">const</span> <span class="hljs-comment">//有序向量整体查找</span></span><br><span class="hljs-function">   </span>&#123; <span class="hljs-keyword">return</span> ( <span class="hljs-number">0</span> &gt;= _size ) ? <span class="hljs-number">-1</span> : <span class="hljs-built_in">search</span> ( e, <span class="hljs-number">0</span>, _size ); &#125;<br>   <span class="hljs-function">Rank <span class="hljs-title">search</span> <span class="hljs-params">( T <span class="hljs-keyword">const</span>&amp; e, Rank lo, Rank hi )</span> <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">//有序向量区间查找</span><br><span class="hljs-comment">// 可写访问接口</span><br>   T&amp; <span class="hljs-keyword">operator</span>[] ( Rank r ); <span class="hljs-comment">//重载下标操作符，可以类似于数组形式引用各元素</span><br>   <span class="hljs-keyword">const</span> T&amp; <span class="hljs-keyword">operator</span>[] ( Rank r ) <span class="hljs-keyword">const</span>; <span class="hljs-comment">//仅限于做右值的重载版本</span><br>   Vector&lt;T&gt; &amp; <span class="hljs-keyword">operator</span>= ( Vector&lt;T&gt; <span class="hljs-keyword">const</span>&amp; ); <span class="hljs-comment">//重载赋值操作符，以便直接克隆向量</span><br>   <span class="hljs-function">T <span class="hljs-title">remove</span> <span class="hljs-params">( Rank r )</span></span>; <span class="hljs-comment">//删除秩为r的元素</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">remove</span> <span class="hljs-params">( Rank lo, Rank hi )</span></span>; <span class="hljs-comment">//删除秩在区间[lo, hi)之内的元素</span><br>   <span class="hljs-function">Rank <span class="hljs-title">insert</span> <span class="hljs-params">( Rank r, T <span class="hljs-keyword">const</span>&amp; e )</span></span>; <span class="hljs-comment">//插入元素</span><br>   <span class="hljs-function">Rank <span class="hljs-title">insert</span> <span class="hljs-params">( T <span class="hljs-keyword">const</span>&amp; e )</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">insert</span> ( _size, e ); &#125; <span class="hljs-comment">//默认作为末元素插入</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span> <span class="hljs-params">( Rank lo, Rank hi )</span></span>; <span class="hljs-comment">//对[lo, hi)排序</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">sort</span> ( <span class="hljs-number">0</span>, _size ); &#125; <span class="hljs-comment">//整体排序</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unsort</span> <span class="hljs-params">( Rank lo, Rank hi )</span></span>; <span class="hljs-comment">//对[lo, hi)置乱</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unsort</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">unsort</span> ( <span class="hljs-number">0</span>, _size ); &#125; <span class="hljs-comment">//整体置乱</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deduplicate</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//无序去重</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquify</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//有序去重</span><br><span class="hljs-comment">// 遍历</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span> <span class="hljs-params">( <span class="hljs-keyword">void</span> (* ) ( T&amp; ) )</span></span>; <span class="hljs-comment">//遍历（使用函数指针，只读或局部性修改）</span><br>   <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> VST&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span> <span class="hljs-params">( VST&amp; )</span></span>; <span class="hljs-comment">//遍历（使用函数对象，可全局性修改）</span><br>&#125;; <span class="hljs-comment">//Vector</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;vector_implementation.h&quot;</span></span><br><br></code></pre></div></td></tr></table></figure><h2 id="向量的复制"><a href="#向量的复制" class="headerlink" title="向量的复制"></a>向量的复制</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//元素类型</span><br><span class="hljs-keyword">void</span> Vector&lt;T&gt;::<span class="hljs-built_in">copyFrom</span> ( T <span class="hljs-keyword">const</span>* A, Rank lo, Rank hi ) &#123; <span class="hljs-comment">//以数组区间A[lo, hi)为蓝本复制向量</span><br>   _elem = <span class="hljs-keyword">new</span> T[ _capacity = <span class="hljs-number">2</span> * ( hi - lo ) ]; <span class="hljs-comment">//分配空间</span><br>   <span class="hljs-keyword">for</span> (_size = <span class="hljs-number">0</span>; lo &lt; hi; _size++, lo++ ) <span class="hljs-comment">//A[lo, hi)内的元素逐一</span><br>      _elem[ _size ] = A[ lo ]; <span class="hljs-comment">//复制至_elem[0, hi - lo)</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/47131e825a6c7ce6a2e481b1d5bb558e-c3e0c.png" alt="向量复制示意"></p><h2 id="可扩充向量"><a href="#可扩充向量" class="headerlink" title="可扩充向量"></a>可扩充向量</h2><h3 id="静态空间管理"><a href="#静态空间管理" class="headerlink" title="静态空间管理"></a>静态空间管理</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210630132508.png" alt="向量的静态空间管理"></p><h3 id="动态空间管理"><a href="#动态空间管理" class="headerlink" title="动态空间管理"></a>动态空间管理</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210630133319.png" alt="动态空间管理"></p><p>动态空间的扩容算法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> Vector&lt;T&gt;::<span class="hljs-built_in">expand</span>() &#123; <span class="hljs-comment">//向量空间不足时扩容</span><br>   <span class="hljs-keyword">if</span> ( _size &lt; _capacity ) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//尚未满员时，不必扩容</span><br>   <span class="hljs-keyword">if</span> ( _capacity &lt; DEFAULT_CAPACITY ) _capacity = DEFAULT_CAPACITY; <span class="hljs-comment">//不低于最小容量</span><br>   T* oldElem = _elem;  _elem = <span class="hljs-keyword">new</span> T[_capacity &lt;&lt;= <span class="hljs-number">1</span>]; <span class="hljs-comment">//容量加倍</span><br>   <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; _size; i++ )<br>      _elem[i] = oldElem[i]; <span class="hljs-comment">//复制原向量内容（T为基本类型，或已重载赋值操作符&#x27;=&#x27;）</span><br>   <span class="hljs-keyword">delete</span> [] oldElem; <span class="hljs-comment">//释放原空间</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>动态空间的扩容算法问题：</p><p><strong>问</strong>：for (int i = 0; i &lt; _size; i++) _elem[i] = oldElem[i];</p><p>替代为：</p><p>memcpy(_elem, oldElem, _size * sizeof(T));</p><p>是否可行？</p><p><strong>答</strong>：不行，当T为非基本类型且有对应的赋值运算符以执行深复制时，前一段代码会调用赋值运算符，而后一段只能进行浅复制。</p><h3 id="扩容方式分析"><a href="#扩容方式分析" class="headerlink" title="扩容方式分析"></a>扩容方式分析</h3><h4 id="递增式扩容"><a href="#递增式扩容" class="headerlink" title="递增式扩容"></a>递增式扩容</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210630134743.png" alt="递增式扩容"></p><h4 id="倍增式扩容"><a href="#倍增式扩容" class="headerlink" title="倍增式扩容"></a>倍增式扩容</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210630135527.png" alt="倍增式扩容"></p><h4 id="递增和倍增扩容的对比"><a href="#递增和倍增扩容的对比" class="headerlink" title="递增和倍增扩容的对比"></a>递增和倍增扩容的对比</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210701112219.png" alt="递增和倍增扩容的对比"></p><h4 id="平均复杂度与分摊复杂度"><a href="#平均复杂度与分摊复杂度" class="headerlink" title="平均复杂度与分摊复杂度"></a>平均复杂度与分摊复杂度</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210701112538.png" alt="平均复杂度与分摊复杂度"></p><h2 id="无序向量"><a href="#无序向量" class="headerlink" title="无序向量"></a>无序向量</h2><h3 id="循秩访问"><a href="#循秩访问" class="headerlink" title="循秩访问"></a>循秩访问</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210701114644.png" alt="无序向量的循秩访问"></p><p>可作为左值的原因是：返回值是引用</p><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//将e作为秩为r元素插入</span><br>Rank Vector&lt;T&gt;::<span class="hljs-built_in">insert</span> ( Rank r, T <span class="hljs-keyword">const</span>&amp; e ) &#123; <span class="hljs-comment">//assert: 0 &lt;= r &lt;= size</span><br>   <span class="hljs-built_in">expand</span>(); <span class="hljs-comment">//若有必要，扩容</span><br>   <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = _size; i &gt; r; i-- ) _elem[i] = _elem[i<span class="hljs-number">-1</span>]; <span class="hljs-comment">//自后向前，后继元素顺次后移一个单元</span><br>   _elem[r] = e; _size++; <span class="hljs-comment">//置入新元素并更新容量</span><br>   <span class="hljs-keyword">return</span> r; <span class="hljs-comment">//返回秩</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/cfe2a77c2bfa4477a2d1e672799128bc-d288c.png" alt="插入操作示意图"></p><p>注意：如果自前向后挪动后继元素，会发生数据覆盖的情况，很危险！</p><h3 id="区间删除"><a href="#区间删除" class="headerlink" title="区间删除"></a>区间删除</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">int</span> Vector&lt;T&gt;::<span class="hljs-built_in">remove</span> ( Rank lo, Rank hi ) &#123; <span class="hljs-comment">//删除区间[lo, hi)</span><br>   <span class="hljs-keyword">if</span> ( lo == hi ) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//出于效率考虑，单独处理退化情况，比如remove(0, 0)</span><br>   <span class="hljs-keyword">while</span> ( hi &lt; _size ) _elem[lo++] = _elem[hi++]; <span class="hljs-comment">//[hi, _size)顺次前移hi - lo个单元</span><br>   _size = lo; <span class="hljs-comment">//更新规模，直接丢弃尾部[lo, _size = hi)区间</span><br>   <span class="hljs-built_in">shrink</span>(); <span class="hljs-comment">//若有必要，则缩容</span><br>   <span class="hljs-keyword">return</span> hi - lo; <span class="hljs-comment">//返回被删除元素的数目</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/0d15857b96107249ee3ce33fc08975cb-9661e.png" alt="删除操作"></p><h3 id="单元素删除"><a href="#单元素删除" class="headerlink" title="单元素删除"></a>单元素删除</h3><p>可以视作区间删除操作的特例：<code>[r] = [r,r+1]</code></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; T Vector&lt;T&gt;::<span class="hljs-built_in">remove</span> ( Rank r ) &#123; <span class="hljs-comment">//删除向量中秩为r的元素，0 &lt;= r &lt; size</span><br>   T e = _elem[r]; <span class="hljs-comment">//备份被删除元素</span><br>   <span class="hljs-built_in">remove</span> ( r, r + <span class="hljs-number">1</span> ); <span class="hljs-comment">//调用区间删除算法，等效于对区间[r, r + 1)的删除</span><br>   <span class="hljs-keyword">return</span> e; <span class="hljs-comment">//返回被删除元素</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="区间删除与单元素删除的讨论"><a href="#区间删除与单元素删除的讨论" class="headerlink" title="区间删除与单元素删除的讨论"></a>区间删除与单元素删除的讨论</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210701120134.png" alt="区间删除与单元素删除的讨论"></p><p><strong>注意：以上的复杂度都基于最坏情况</strong></p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/96438381bd0bae3e86c01423ca2fbdaf-8d7a3.png" alt="查找操作"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//无序向量的顺序查找：返回最后一个元素e的位置；失败时，返回lo - 1</span><br>Rank Vector&lt;T&gt;::<span class="hljs-built_in">find</span> ( T <span class="hljs-keyword">const</span>&amp; e, Rank lo, Rank hi ) <span class="hljs-keyword">const</span> &#123; <span class="hljs-comment">//assert: 0 &lt;= lo &lt; hi &lt;= _size</span><br>   <span class="hljs-keyword">while</span> ( ( lo &lt; hi-- ) &amp;&amp; ( e != _elem[hi] ) ); <span class="hljs-comment">//从后向前，顺序查找</span><br>   <span class="hljs-keyword">return</span> hi; <span class="hljs-comment">//若hi &lt; lo，则意味着失败；否则hi即命中元素的秩</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>逆向查找的原因：</p><blockquote><p>因为相同元素需要返回位置靠后者，这是之前的约定</p></blockquote><h3 id="唯一化"><a href="#唯一化" class="headerlink" title="唯一化"></a>唯一化</h3><p>应用场景：网络搜索的局部结果经过去重操作，汇总为最终报告。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">int</span> Vector&lt;T&gt;::<span class="hljs-built_in">deduplicate</span>() &#123; <span class="hljs-comment">//删除无序向量中重复元素（高效版）</span><br>   <span class="hljs-keyword">int</span> oldSize = _size; <span class="hljs-comment">//记录原规模</span><br>   Rank i = <span class="hljs-number">1</span>; <span class="hljs-comment">//从_elem[1]开始</span><br>   <span class="hljs-keyword">while</span> (i &lt; _size) <span class="hljs-comment">//自前向后逐一考查各元素_elem[i]</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(_elem[i], <span class="hljs-number">0</span>, i) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">//在前缀[0,i)中寻找与之雷同者（至多一个）</span><br>         i++; <span class="hljs-comment">//若无雷同则继续考查其后继</span><br>      <span class="hljs-keyword">else</span><br>         <span class="hljs-built_in">remove</span>(i); <span class="hljs-comment">//否则删除当前元素</span><br>   <span class="hljs-keyword">return</span> oldSize - _size; <span class="hljs-comment">//被删除元素总数</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>对唯一化正确性的讨论：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210701152044.png" alt="对唯一化正确性的讨论"></p><p>唯一化的复杂度：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210701152218.png" alt="唯一化的复杂度"></p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>函数指针与函数对象：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210701153149.png" alt="函数指针与函数对象"></p><p><strong>函数对象更通用！</strong></p><p>实例：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210701153251.png" alt="函数对象实例"></p><h2 id="有序向量：唯一化"><a href="#有序向量：唯一化" class="headerlink" title="有序向量：唯一化"></a>有序向量：唯一化</h2><h3 id="有序性判断"><a href="#有序性判断" class="headerlink" title="有序性判断"></a>有序性判断</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210701155300.png" alt="判断有序性"></p><h3 id="低效版"><a href="#低效版" class="headerlink" title="低效版"></a>低效版</h3><p>算法：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210701155732.png" alt="低效版"></p><p>复杂度：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210701160158.png" alt="复杂度"></p><p>算法低效的原因在于，每个相同的元素需要逐个的进行删除，花费了很多在后继移动上的开销</p><h3 id="高效版"><a href="#高效版" class="headerlink" title="高效版"></a>高效版</h3><p>算法：</p><ul><li>反思：低效的根源在于，同意元素可作为被删除元素的后继多次前移</li><li>启示：若能以重复区间为单位，成批删除雷同元素，性能必将改进</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">int</span> Vector&lt;T&gt;::<span class="hljs-built_in">uniquify</span>() &#123; <span class="hljs-comment">//有序向量重复元素剔除算法（高效版）</span><br>   Rank i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; <span class="hljs-comment">//各对互异“相邻”元素的秩</span><br>   <span class="hljs-keyword">while</span> ( ++j &lt; _size ) <span class="hljs-comment">//逐一扫描，直至末元素</span><br>      <span class="hljs-keyword">if</span> ( _elem[i] != _elem[j] ) <span class="hljs-comment">//跳过雷同者</span><br>         _elem[++i] = _elem[j]; <span class="hljs-comment">//发现不同元素时，向前移至紧邻于前者右侧</span><br>   _size = ++i; <span class="hljs-built_in">shrink</span>(); <span class="hljs-comment">//直接截除尾部多余元素</span><br>   <span class="hljs-keyword">return</span> j - i; <span class="hljs-comment">//向量规模变化量，即被删除元素总数</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/48dc37ab2dd2a0ba5d75126d8f9cd294-c7b67.png" alt="高效版"></p><p>复杂度：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210701161627.png" alt="高效版复杂度"></p><p>高效版不再将重复元素一个个处理，而是整体的并且隐式的覆盖（删除）</p><h2 id="有序向量：二分查找"><a href="#有序向量：二分查找" class="headerlink" title="有序向量：二分查找"></a>有序向量：二分查找</h2><h3 id="接口规范"><a href="#接口规范" class="headerlink" title="接口规范"></a>接口规范</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//在有序向量的区间[lo, hi)内，确定不大于e的最后一个节点的秩</span><br>Rank Vector&lt;T&gt;::<span class="hljs-built_in">search</span> ( T <span class="hljs-keyword">const</span>&amp; e, Rank lo, Rank hi ) <span class="hljs-keyword">const</span> &#123; <span class="hljs-comment">//assert: 0 &lt;= lo &lt; hi &lt;= _size</span><br>   <span class="hljs-keyword">return</span> ( <span class="hljs-built_in">rand</span>() % <span class="hljs-number">2</span> ) ? <span class="hljs-comment">//按各50%的概率随机使用二分查找或Fibonacci查找</span><br>          <span class="hljs-built_in">binSearch</span> ( _elem, e, lo, hi ) : <span class="hljs-built_in">fibSearch</span> ( _elem, e, lo, hi );<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/25eeee35e1b75b7098e69419d99f870e-fc371.png" alt="二分查找"></p><h3 id="语义约束"><a href="#语义约束" class="headerlink" title="语义约束"></a>语义约束</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210701182901.png" alt="语义约束"></p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h4 id="A版本（初始版本）"><a href="#A版本（初始版本）" class="headerlink" title="A版本（初始版本）"></a>A版本（初始版本）</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210701183423.png" alt="二分查找原理"></p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// 二分查找算法（版本A）：在有序向量的区间[lo, hi)内查找元素e，0 &lt;= lo &lt;= hi &lt;= _size</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">static</span> Rank <span class="hljs-title">binSearch</span> <span class="hljs-params">( T* S, T <span class="hljs-keyword">const</span>&amp; e, Rank lo, Rank hi )</span> </span>&#123;<br>   <span class="hljs-keyword">while</span> ( lo &lt; hi ) &#123; <span class="hljs-comment">//每步迭代可能要做两次比较判断，有三个分支</span><br>      Rank mi = ( lo + hi ) &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">//以中点为轴点（区间宽度的折半，等效于宽度之数值表示的右移）</span><br>      <span class="hljs-keyword">if</span>      ( e &lt; S[mi] ) hi = mi; <span class="hljs-comment">//深入前半段[lo, mi)继续查找</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( S[mi] &lt; e ) lo = mi + <span class="hljs-number">1</span>; <span class="hljs-comment">//深入后半段(mi, hi)继续查找</span><br>      <span class="hljs-keyword">else</span>                  <span class="hljs-keyword">return</span> mi; <span class="hljs-comment">//在mi处命中</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">//查找失败</span><br>&#125; <span class="hljs-comment">//有多个命中元素时，不能保证返回秩最大者；查找失败时，简单地返回-1，而不能指示失败的位置</span><br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/ed41a167743c57da26c9f75e56b6858a-be3f5.png" alt="二分查找算法（版本A）"></p><h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210701195155.png" alt="二分查找复杂度分析"></p><h5 id="查找长度"><a href="#查找长度" class="headerlink" title="查找长度"></a>查找长度</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210701200420.png" alt="查找长度"></p><p>粗略估算的情况下，由于4.5=$1.5*log_2{8}$ ,其中的8由n=7粗略+1得来</p><h4 id="B版本（改进）"><a href="#B版本（改进）" class="headerlink" title="B版本（改进）"></a>B版本（改进）</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210701215743.png" alt="二分查找改进"></p><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// 二分查找算法（版本B）：在有序向量的区间[lo, hi)内查找元素e，0 &lt;= lo &lt; hi &lt;= _size</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">static</span> Rank <span class="hljs-title">binSearch</span> <span class="hljs-params">( T* S, T <span class="hljs-keyword">const</span>&amp; e, Rank lo, Rank hi )</span> </span>&#123;<br>   <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> &lt; hi - lo ) &#123; <span class="hljs-comment">//每步迭代仅需做一次比较判断，有两个分支；成功查找不能提前终止</span><br>      Rank mi = ( lo + hi ) &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">//以中点为轴点（区间宽度的折半，等效于宽度之数值表示的右移）</span><br>      ( e &lt; S[mi] ) ? hi = mi : lo = mi; <span class="hljs-comment">//经比较后确定深入[lo, mi)或[mi, hi)</span><br>   &#125; <span class="hljs-comment">//出口时hi = lo + 1，查找区间仅含一个元素A[lo]</span><br>   <span class="hljs-keyword">return</span> e &lt; S[lo] ? lo - <span class="hljs-number">1</span> : lo; <span class="hljs-comment">//返回位置，总是不超过e的最大者</span><br>&#125; <span class="hljs-comment">//有多个命中元素时，不能保证返回秩最大者；查找失败时，简单地返回-1，而不能指示失败的位置</span><br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7ad15b0cbc6eff9bed0dae4a674dad81-6d9c2.png" alt="二分查找算法（版本B）"></p><p>与最开始版本的二分查找的本质区别在于轴点和边界</p><h4 id="C版本（最终）"><a href="#C版本（最终）" class="headerlink" title="C版本（最终）"></a>C版本（最终）</h4><h5 id="语义以及接口规范"><a href="#语义以及接口规范" class="headerlink" title="语义以及接口规范"></a>语义以及接口规范</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210701221151.png" alt="语义以及接口规范"></p><h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// 二分查找算法（版本C）：在有序向量的区间[lo, hi)内查找元素e，0 &lt;= lo &lt;= hi &lt;= _size</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">static</span> Rank <span class="hljs-title">binSearch</span> <span class="hljs-params">( T* S, T <span class="hljs-keyword">const</span>&amp; e, Rank lo, Rank hi )</span> </span>&#123;<br>   <span class="hljs-keyword">while</span> ( lo &lt; hi ) &#123; <span class="hljs-comment">//每步迭代仅需做一次比较判断，有两个分支</span><br>      Rank mi = ( lo + hi ) &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">//以中点为轴点（区间宽度的折半，等效于宽度之数值表示的右移）</span><br>      ( e &lt; S[mi] ) ? hi = mi : lo = mi + <span class="hljs-number">1</span>; <span class="hljs-comment">//经比较后确定深入[lo, mi)或(mi, hi)</span><br>   &#125; <span class="hljs-comment">//成功查找不能提前终止</span><br>   <span class="hljs-keyword">return</span> lo - <span class="hljs-number">1</span>; <span class="hljs-comment">//循环结束时，lo为大于e的元素的最小秩，故lo - 1即不大于e的元素的最大秩</span><br>&#125; <span class="hljs-comment">//有多个命中元素时，总能保证返回秩最大者；查找失败时，能够返回失败的位置</span><br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/1a1254cc27493d45e413deb9c354ef6d-ecd7c.png" alt="与版本B的差异"></p><h5 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210701225546.png" alt="正确性"></p><h3 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h3><h4 id="思路与原理"><a href="#思路与原理" class="headerlink" title="思路与原理"></a>思路与原理</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210701205026.png" alt="思路与原理"></p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;fibonacci/Fib.h&quot;</span> <span class="hljs-comment">//引入Fib数列类</span></span><br><span class="hljs-comment">// Fibonacci查找算法（版本A）：在有序向量的区间[lo, hi)内查找元素e，0 &lt;= lo &lt;= hi &lt;= _size</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">static</span> Rank <span class="hljs-title">fibSearch</span> <span class="hljs-params">( T* S, T <span class="hljs-keyword">const</span>&amp; e, Rank lo, Rank hi )</span> </span>&#123;<br>    <span class="hljs-comment">//用O(log_phi(n = hi - lo)时间创建Fib数列</span><br>   <span class="hljs-keyword">for</span> ( Fib <span class="hljs-built_in">fib</span> ( hi - lo ); lo &lt; hi; ) &#123;  <span class="hljs-comment">//Fib数列制表备查；此后每步迭代仅一次比较、两个分支</span><br>      <span class="hljs-keyword">while</span> ( hi - lo &lt; fib.<span class="hljs-built_in">get</span>() ) fib.<span class="hljs-built_in">prev</span>(); <span class="hljs-comment">//自后向前顺序查找（分摊O(1)）</span><br>      Rank mi = lo + fib.<span class="hljs-built_in">get</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">//确定形如Fib(k) - 1的轴点</span><br>      <span class="hljs-keyword">if</span>      ( e &lt; S[mi] ) hi = mi; <span class="hljs-comment">//深入前半段[lo, mi)继续查找</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( S[mi] &lt; e ) lo = mi + <span class="hljs-number">1</span>; <span class="hljs-comment">//深入后半段(mi, hi)继续查找</span><br>      <span class="hljs-keyword">else</span>                  <span class="hljs-keyword">return</span> mi; <span class="hljs-comment">//在mi处命中</span><br>   &#125; <span class="hljs-comment">//成功查找可以提前终止</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">//查找失败</span><br>&#125; <span class="hljs-comment">//有多个命中元素时，不能保证返回秩最大者；失败时，简单地返回-1，而不能指示失败的位置</span><br></code></pre></div></td></tr></table></figure><h4 id="查找长度-1"><a href="#查找长度-1" class="headerlink" title="查找长度"></a>查找长度</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210701210052.png" alt="查找长度"></p><h4 id="最优性证明"><a href="#最优性证明" class="headerlink" title="最优性证明"></a>最优性证明</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210701210643.png" alt="最优性证明"></p><p>当算法的整体策略不改变的情况下，黄金分割数已经是极限，即最优解</p><h2 id="有序向量：插值查找"><a href="#有序向量：插值查找" class="headerlink" title="有序向量：插值查找"></a>有序向量：插值查找</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210701231130.png" alt="原理"></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210701232417.png" alt="实例"></p><p>注意：插值查找有时候效率会很低，在某些情况下会退化为平凡的顺序查找（最坏情况复杂度O(hi-lo)=O(n)）。显然，最好情况就是一次命中(复杂度为O(n))</p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210702083449.png" alt="性能分析"></p><h3 id="字宽折半"><a href="#字宽折半" class="headerlink" title="字宽折半"></a>字宽折半</h3><p>对于插值查找的待查找区间，每次查询都是对n的不断开方。相应的n的二进制宽度也在不断变化，变化的趋势为不断地二分。即</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210705164031.png" alt="字宽折半" style="zoom:50%;" /></p><p>所以可以说，对于插值查找，可以看作是对于n的二进制宽度进行二分查找</p><h3 id="综合分析"><a href="#综合分析" class="headerlink" title="综合分析"></a>综合分析</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210705165647.png" alt="综合分析"></p><p>插值查找的缺点：</p><ol><li>容易在局部花费很多时间</li><li>引入成本更高的乘法和除法运算</li></ol><p>所以为了避免以上的缺点，可以首先通过插值查找，将查找范围缩小到一定的范围，然后再进行二分查找</p><p><strong>即：</strong></p><p><strong>大规模：插值查找</strong></p><p><strong>中规模：二分查找</strong></p><p><strong>小规模：顺序查找</strong></p><h2 id="起泡排序"><a href="#起泡排序" class="headerlink" title="起泡排序"></a>起泡排序</h2><h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><h4 id="初始版本"><a href="#初始版本" class="headerlink" title="初始版本"></a>初始版本</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210617171713.png" alt="起泡排序算法1"></p><h4 id="第一次改进"><a href="#第一次改进" class="headerlink" title="第一次改进"></a>第一次改进</h4><p>思路：分析初始版本后发现，如果在某一次扫描后，剩下的扫描部分其实已经有序了，即整体向量有序。但是初始版本的算法还是会进行扫描操作，浪费了时间。所以有了第一次改进：在每次扫描后去判断总体的有序性，若在其中的某个时刻，整体向量已经有序，则提前退出算法。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//向量的起泡排序（提前终止版）</span><br><span class="hljs-keyword">void</span> Vector&lt;T&gt;::<span class="hljs-built_in">bubbleSort</span>( Rank lo, Rank hi ) &#123; <span class="hljs-comment">//assert: 0 &lt;= lo &lt; hi &lt;= size</span><br>   <span class="hljs-keyword">for</span>( <span class="hljs-keyword">bool</span> sorted = <span class="hljs-literal">false</span>; sorted = !sorted; )<br>      <span class="hljs-keyword">for</span>( Rank i = lo; i &lt; hi - <span class="hljs-number">1</span>; i++ )<br>         <span class="hljs-keyword">if</span>( _elem[i] &gt; _elem[i + <span class="hljs-number">1</span>] ) <span class="hljs-comment">//若逆序，则</span><br>            <span class="hljs-built_in">swap</span>( _elem[i], _elem[i + <span class="hljs-number">1</span>] ), sorted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">//经交换使局部有序——当然，至此还不能确定已整体有序</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>与初始版本的比较：（x轴为向量规模，y轴为扫描次数）</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210705180153.png" alt="与初始版本的改进"></p><p><strong>完成的扫描交换趟数 = 实际发生元素交换的扫描交换趟数 + 1</strong>，其中的1表示某趟扫描交换中没有发生元素交换（返回值sorted = true）</p><h4 id="第二次改进"><a href="#第二次改进" class="headerlink" title="第二次改进"></a>第二次改进</h4><p>对于第一次改进的版本，有着这么一个缺点。</p><p>假设以下情况（如图）：一个向量中的无序区间（前）与有序区间（后）中元素的个数相差悬殊（即一个足够短的乱序前缀和一个非常长的有序后缀），那么根据第一次改进算法的思路，每一趟扫描实际上处理的是前面无序的区间，而后面的有序区间则会被波及到，造成不必要的开销。即多余的时间消耗，是对有序区间内的已就位元素进行反复扫描交换。</p><p><strong>注意：在这种情况下，假设无序区间的元素个数为r，那么扫描的次数&lt;r（根据起泡排序的单调性可得）。</strong></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210705181420.png" alt="第二次改进思路"></p><p><strong>改进思路：记录在上一趟扫描交换过程中，所进行的最后一次交换</strong></p><p><strong>算法体现：将hi标志位直接指向交换的位置</strong></p><p>第二次改进算法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//向量的起泡排序（跳跃版）</span><br><span class="hljs-keyword">void</span> Vector&lt;T&gt;::<span class="hljs-built_in">bubbleSort</span>( Rank lo, Rank hi ) &#123; <span class="hljs-comment">//assert: 0 &lt;= lo &lt; hi &lt;= size</span><br>   <span class="hljs-keyword">for</span>( Rank last = --hi; lo &lt; hi; hi = last )<br>      <span class="hljs-keyword">for</span>( Rank i = last = lo; i &lt; hi; i++ )<br>         <span class="hljs-keyword">if</span>( _elem[i] &gt; _elem[i + <span class="hljs-number">1</span>] ) <span class="hljs-comment">//若逆序，则</span><br>            <span class="hljs-built_in">swap</span>( _elem[ last = i ], _elem[ i + <span class="hljs-number">1</span> ] ); <span class="hljs-comment">//经交换使局部有序</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于以上的假设情况，在同一个向量中可能连续的出现。即表现为</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210705184130.png" alt="第二次改进算法表现为" style="zoom:50%;" /></p><p><strong>注意：在最坏情况下，第二次改进算法的时间复杂度依然是$O(n^2)$</strong></p><blockquote><p>这个算法真的很巧妙！它利用了起泡排序的特性使得它的正确性得到保障：起泡排序每一次扫描总是将最大的元素（也就是最大的起泡）从某个位置放到序列的最后，在此过程中它与它后面的每一个元素都分别作了一次交换操作。如果当前后半段都没有发生交换操作，说明后半段都已经有序了（否则后半段内部的逆序对会发生交换），而且前半段都比后半段最小的元素小（否则前半段最大的元素会跑到后半段去从而引起后半段的交换）。</p></blockquote><h4 id="综合评价（算法的稳定性）"><a href="#综合评价（算法的稳定性）" class="headerlink" title="综合评价（算法的稳定性）"></a>综合评价（算法的稳定性）</h4><p> <img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210705185237.png" alt="算法的稳定性"></p><p>原因1：<img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210705185346.png" alt=""></p><p>原因2：在交换元素的判断条件中，条件为”&gt;”而不是”&gt;=”。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//...</span><br><span class="hljs-keyword">if</span>(_elem[lo<span class="hljs-number">-1</span>] &gt; _elem[lo])&#123;<br>    ...<br>&#125;<br><span class="hljs-comment">//...</span><br></code></pre></div></td></tr></table></figure><h5 id="拓展：基数排序"><a href="#拓展：基数排序" class="headerlink" title="拓展：基数排序"></a>拓展：基数排序</h5><p><strong>问</strong>： 试用以下算法对V={19, 17, 23}排序：1. 先按个位排序。2. 在上一步基础上，再按十位排序。 这个算法是否正确？</p><p>A.一定正确    B.一定不正确    C.若第2步用的排序算法是稳定的，则正确    D.若第1步用的排序算法是稳定的，则正确</p><p><strong>答</strong>：C。若第2步不稳定，可能的情况是：{19, 17, 23} -&gt; {23, 17, 19} -&gt; {19, 17, 23}</p><p><strong>基数排序适用于被排序元素可分为若干个域的情况，它的正确性要依赖于对每个域分别排序时的稳定性。</strong></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210705191933.png" alt="构思"></p><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//向量归并排序</span><br><span class="hljs-keyword">void</span> Vector&lt;T&gt;::<span class="hljs-built_in">mergeSort</span> ( Rank lo, Rank hi ) &#123; <span class="hljs-comment">//0 &lt;= lo &lt; hi &lt;= size</span><br>   <span class="hljs-comment">/*DSA*/</span> <span class="hljs-comment">//printf ( &quot;\tMERGEsort [%3d, %3d)\n&quot;, lo , hi );</span><br>   <span class="hljs-keyword">if</span> ( hi - lo &lt; <span class="hljs-number">2</span> ) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//单元素区间自然有序，否则...</span><br>   <span class="hljs-keyword">int</span> mi = ( lo + hi ) / <span class="hljs-number">2</span>; <span class="hljs-comment">//以中点为界</span><br>   <span class="hljs-built_in">mergeSort</span> ( lo, mi ); <span class="hljs-built_in">mergeSort</span> ( mi, hi ); <span class="hljs-comment">//分别排序</span><br>   <span class="hljs-built_in">merge</span> ( lo, mi, hi ); <span class="hljs-comment">//归并</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/c06295596349ac24aca5a0fc611c86f7-0df5e.png" alt="向量归并排序"></p><h3 id="二路归并"><a href="#二路归并" class="headerlink" title="二路归并"></a>二路归并</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210705192531.png" alt="原理"></p><h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//有序向量（区间）的归并</span><br><span class="hljs-keyword">void</span> Vector&lt;T&gt;::<span class="hljs-built_in">merge</span> ( Rank lo, Rank mi, Rank hi ) &#123; <span class="hljs-comment">//[lo, mi)和[mi, hi)各自有序，lo &lt; mi &lt; hi</span><br>   Rank i = <span class="hljs-number">0</span>; T* A = _elem + lo; <span class="hljs-comment">//合并后的有序向量A[0, hi - lo) = _elem[lo, hi)，就地</span><br>   Rank j = <span class="hljs-number">0</span>, lb = mi - lo; T* B = <span class="hljs-keyword">new</span> T[lb]; <span class="hljs-comment">//前子向量B[0, lb) &lt;-- _elem[lo, mi)</span><br>   <span class="hljs-keyword">for</span> ( Rank i = <span class="hljs-number">0</span>; i &lt; lb; i++ ) B[i] = A[i]; <span class="hljs-comment">//复制自A的前缀</span><br>   Rank k = <span class="hljs-number">0</span>, lc = hi - mi; T* C = _elem + mi; <span class="hljs-comment">//后子向量C[0, lc) = _elem[mi, hi)，就地</span><br>   <span class="hljs-keyword">while</span> ( ( j &lt; lb ) &amp;&amp; ( k &lt; lc ) ) <span class="hljs-comment">//反复地比较B、C的首元素</span><br>      A[i++] = ( B[j] &lt;= C[k] ) ? B[j++] : C[k++]; <span class="hljs-comment">//将更小者归入A中</span><br>   <span class="hljs-keyword">while</span> ( j &lt; lb ) <span class="hljs-comment">//若C先耗尽，则</span><br>      A[i++] = B[j++]; <span class="hljs-comment">//将B残余的后缀归入A中——若B先耗尽呢？</span><br>   <span class="hljs-keyword">delete</span> [] B; <span class="hljs-comment">//释放临时空间：mergeSort()过程中，如何避免此类反复的new/delete？</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/df38d3c82e5a5ffd3b04ee0e47f04479-5c3a0.png" alt="二路归并"></p><p><strong>如果不开B缓冲区的话，在执行下面的比较和赋值操作，非一般情况下A中的前面部分会被覆盖</strong></p><h4 id="正确性-1"><a href="#正确性-1" class="headerlink" title="正确性"></a>正确性</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210706130145.png" alt="正确性1"></p><p>a情况：由于B是事先开出的缓冲区，而j&lt;=i，所以A的前半部分并不会发生数据覆盖的情况</p><p>b情况：虽然说C是A中的后半部分，对A后半部分的写操作相当于对C的写操作。但是由于此时的i已经处在mi的右侧，且k绝对不会位于i的左侧，说明C[0]~C[k]前的这些元素已经在A[lo]~A[i]中，所以这种情况下依然是安全的。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210706130805.png" alt="正确性2"></p><p>c情况：此时的情况下，虽然B向量已经耗尽，但是此时的哨兵节点lb可看作正无穷，也就是说C中的向量小于正无穷向量，C向量中的剩余元素会被视为更小</p><p>d情况：与c情况相同</p><p>对比c和d情况可得出：当B向量提前耗尽时，由于C向量实质是A向量的后半部分，所以此时的A[i]=C[k]实际上是浪费操作。而C向量提前耗尽时，由于B向量是额外的缓冲区，所以A[i]=B[j]是必要的。</p><p>至此，二路归并有了一个更精简的版本：一旦B提前耗尽，就可以直接终止这个算法</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210706131731.png" alt="精简版本"></p><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210706132553.png" alt="复杂度"></p><p> 对于规模为n的向量，归并排序的最优、最坏时间复杂度都为$O(nlog_2n)$</p><h2 id="随记"><a href="#随记" class="headerlink" title="随记"></a>随记</h2><ol><li>递归版的空间复杂度一般等于最大递归深度</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
      <tag>归并排序</tag>
      
      <tag>起泡排序</tag>
      
      <tag>向量</tag>
      
      <tag>唯一化</tag>
      
      <tag>斐波那契查找</tag>
      
      <tag>插值查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>绪论</title>
    <link href="/2020/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E7%BB%AA%E8%AE%BA/"/>
    <url>/2020/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ADT%EF%BC%9A%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="RAM模型"><a href="#RAM模型" class="headerlink" title="RAM模型"></a>RAM模型</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210620181703.png" alt="RAM模型"></p><p>衡量算法可以依据CPU的执行次数，而不是CPU的好坏快慢，这样更加客观</p><p>RAM模型的实例：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210620182733.png" alt="RAM模型的实例"></p><h2 id="大O记号"><a href="#大O记号" class="headerlink" title="大O记号"></a>大O记号</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210603190443.png" alt="大O记号"></p><ol><li>大O记号可以视为T(n)的悲观的估计</li></ol><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ol><li><p>O(1)：不含转向（循环、调用、递归等）必顺序执行的方法。</p><blockquote><p>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)</p></blockquote></li><li><p>O($n^c$)：多项式复杂度</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210603193838.png" alt="n^c"></p></li></ol><ol><li><p>O($2^n$)：指数形式复杂度 </p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210603194015.png" alt="2^n"></p></li></ol><p>参考：<a href="https://zhuanlan.zhihu.com/p/50479555">算法的时间与空间复杂度（一看就懂）</a></p><h2 id="NP-complete"><a href="#NP-complete" class="headerlink" title="NP-complete"></a>NP-complete</h2><p><strong>含义：就目前的计算机模型而言，不存在可在多项式时间内回答此问题的算法</strong></p><p>例如<strong>2-Subset</strong>问题：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210603200404.png" alt="2-Subset问题"></p><p>答案：直觉算法</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210603200544.png" alt=""></p><p>为了得到上述答案中的$2^n$，除了使用幂集，也可以按照如下的思路：</p><p>考虑每个位置，0是不在集合中，1在集合中。对于n个位置，每个位置两种可能，所以一共是2^n种可能，也即有2^n种子集</p><h2 id="增长速度"><a href="#增长速度" class="headerlink" title="增长速度"></a>增长速度</h2><p>$2^n$的增长速度会在后面超过所有固定阶次的多项式</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210603201142.png" alt="增长速度"></p><h2 id="复杂度分析的方法"><a href="#复杂度分析的方法" class="headerlink" title="复杂度分析的方法"></a>复杂度分析的方法</h2><h3 id="迭代：级数求和"><a href="#迭代：级数求和" class="headerlink" title="迭代：级数求和"></a>迭代：级数求和</h3><ol><li>算术级数（等差）：与末项平方同阶</li><li>幂方级数：比幂次高出一阶</li><li>几何级数（等比）：与末项同阶</li><li>收敛级数：从渐进意义上讲，可以视为常数，所以为O(1)</li><li>特例：未必收敛，但是长度有限的级数（调和级数和对数级数）</li></ol><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210607172639.png" alt="特例级数"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210607172131.png" alt="级数1"></p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210607172726.png" alt="级数2"></p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>常见的循环复杂度分析：</p><ol><li><p>循环中的算数级数：O($n^2$)<img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210617165043.png" alt="循环"><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210617170521.png" alt="循环中的算数级数2"></p></li><li><p>循环中的几何级数</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210617170222.png" alt="循环中的几何级数"> <img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210617170705.png" alt="循环中的几何级数2"></p><h3 id="取非极端元素"><a href="#取非极端元素" class="headerlink" title="取非极端元素"></a>取非极端元素</h3></li></ol><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210617171118.png" alt="取非极端元素"></p><h3 id="起泡排序"><a href="#起泡排序" class="headerlink" title="起泡排序"></a>起泡排序</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210617171620.png" alt="起泡排序问题"></p><p>对起泡排序的分析：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210617172347.png" alt="起泡排序的分析"></p><ol><li>算法1<img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210617171713.png" alt="起泡排序算法1"></li></ol><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="减而治之"><a href="#减而治之" class="headerlink" title="减而治之"></a>减而治之</h3><p>核心思想：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210617181520.png" alt="减而治之"></p><h3 id="递归跟踪"><a href="#递归跟踪" class="headerlink" title="递归跟踪"></a>递归跟踪</h3><p>用于简单的递归形式，比如线性递归</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210619175125.png" alt="线性递归"></p><h3 id="递推方程"><a href="#递推方程" class="headerlink" title="递推方程"></a>递推方程</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210619180029.png" alt="递推方程"></p><p>推导过程：</p><p>T(n) = T(n-1) + O(1) ;T(n-1) = T(n-2) + O(1) ;T(n-2) = T(n-3) + O(1) … T(3) = T(2) + O(1); T(2) = T(1) + O(1); T(1) = T(0) + O(1) ;T(0) = O(1); 左右侧分别相加; 约去中间同等项; 可得T(n) + T(0) = (n + 1)<em>O(1) ;T(n) = n</em>O(1) = O(n)</p><h3 id="数组倒置"><a href="#数组倒置" class="headerlink" title="数组倒置"></a>数组倒置</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210619180615.png" alt="数组倒置的时间复杂度"></p><p><strong>注意：需要考虑到剩下1个和0个元素的情况</strong></p><p>数组倒置（迭代版）的时间复杂度：O(n)</p><h3 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210620164126.png" alt="分而治之"></p><h3 id="数组求和：二分递归"><a href="#数组求和：二分递归" class="headerlink" title="数组求和：二分递归"></a>数组求和：二分递归</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210620172412.png" alt="数组求和：二分递归"></p><p>递归跟踪：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210620172711.png" alt="数组求和的递归跟踪"></p><p>递归方程：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210620172741.png" alt="数组求和的递归方程"></p><h3 id="二分算法：MAX"><a href="#二分算法：MAX" class="headerlink" title="二分算法：MAX"></a>二分算法：MAX</h3><p>简明算法：无论是最好还是最坏情况，比较次数都是(2n-3)</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210620173908.png" alt="二分算法：简明算法"></p><p>迭代算法：最坏情况为(2n-3)</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210620174532.png" alt="二分算法之迭代算法"></p><p>迭代+分治算法：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210620175610.png" alt="迭代+分治算法"></p><p>最坏情况：已知此时每个递归基中需判断三个数，即二叉树的叶子节点为n/3。设树高为h，根据二叉树性质就有n/3=2^(h-1)^。又因为每个递归基的复杂度为3，所以叶子节点的复杂度为3x(n/3)。而单个非叶子节点的复杂度为2，一共有2^(h-1)^-1个，所以非叶子节点的复杂度为2x(2^(h-1)^-1)，将两者的复杂度相加，得到3*n/3+2x2^(h-1)^-1。将前面的n/3=2^(h-1)^带入并化简得到最坏情况下的复杂度为5/3n-2。</p><p>最好情况：已知此时的每个递归基中需要判断两个数，所以叶子节点的个数为n/2，并有n/2=2^(h-1)^。每个递归基的复杂度为2，又因为二叉树的非叶子节点的复杂度也为2，所以可直接看成二叉树的每个节点的复杂度都为2。所以可直接计算2x(2^h^-1)，带入上面的n/2=2^(h-1)^化简后得到最好情况下的复杂度为2n-2</p><blockquote><p>“递归基”是递归函数的一种平凡情况，只有有递归基，递归才不会一直进行下去。</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>简明算法的复杂度分析与封底估算：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210620225756.png" alt="简明算法的复杂度分析与封底估算"></p><p>对于递归版的斐波那契数列的复杂度如此之高的原因在于：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210620230309.png" alt="递归版的斐波那契数列"></p><p>动态规划后的斐波那契数列算法：复杂度为O(n)</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210620231239.png" alt="动态规划后的斐波那契数列算法"></p><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210621000255.png" alt="最长"></p><h3 id="LCS的递归算法（算法过程需要重新证明）"><a href="#LCS的递归算法（算法过程需要重新证明）" class="headerlink" title="LCS的递归算法（算法过程需要重新证明）"></a>LCS的递归算法（算法过程需要重新证明）</h3><p>对于LCS的递归算法分析：</p><p>LCS的递归算法的第一和第二种情况：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210629134105.png" alt="LCS的递归算法的第一和第二种情况"></p><p>LCS的递归算法的第三种情况：</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210629134213.png" alt="LCS的递归算法的第一和第三种情况"></p><p>算法过程：减而治之走“对角线”，分而治之走“上”、”左“两条线路。右下角为起点，每条连通的线路代表一个解。大方格中有九个小方格，大方格表示一个子任务或者递归实例。<strong>数字表示解法的个数</strong>（待证明）</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210629134928.png" alt="LCS递归算法过程"></p><h3 id="LCS的递归算法的复杂度证明（待证明）"><a href="#LCS的递归算法的复杂度证明（待证明）" class="headerlink" title="LCS的递归算法的复杂度证明（待证明）"></a>LCS的递归算法的复杂度证明（待证明）</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210629143226.png" alt="LCS的递归算法的复杂度证明"></p><h3 id="LCS的递归算法的动态规划（待证明）"><a href="#LCS的递归算法的动态规划（待证明）" class="headerlink" title="LCS的递归算法的动态规划（待证明）"></a>LCS的递归算法的动态规划（待证明）</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210629223549.png" alt="LCS的递归算法的动态规划"></p><h2 id="限制与缓存"><a href="#限制与缓存" class="headerlink" title="限制与缓存"></a>限制与缓存</h2><h3 id="就地循环位移"><a href="#就地循环位移" class="headerlink" title="就地循环位移"></a>就地循环位移</h3><p>只能用常数个辅助空间</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/16abc71d3dac8fb8d9b168edcd90f817-e7a0b.png" alt="就地循环位移"></p><h4 id="蛮力版"><a href="#蛮力版" class="headerlink" title="蛮力版"></a>蛮力版</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>一个一个位移，很笨拙，复杂度也很高</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f725d64deedd402b8cee11ee1ddb9e08-4c463.png" alt="蛮力版"></p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/5d356511a1d1554c5073222533d488f4-ea299.png" alt="实现"></p><h4 id="迭代版"><a href="#迭代版" class="headerlink" title="迭代版"></a>迭代版</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/4ee7429416504871888fcf733d138276-fb853.png" alt="迭代版"></p><h5 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h5><p>实际上这种办法的理论基础是数论上的同余。但是同余没法一次性就把整个数组中的元素挪动到相应位置。这个判断依据可以参考n和k是否为互素。</p><ul><li>若n和k互素，比如n=2，k=9。那么这个数组只要一次迭代就可以完成</li><li>若n和k不互素，比如上例的n=6，k=21。他们的最大公约数为3，那么每次迭代整个数组只能完成1/3，所以需要一共三次迭代才能完成整个数组，下一次迭代将从下一个规模为6的同余类开始迭代。即公约数为多少，就需要迭代多少次。</li></ul><h5 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h5><p>$O(g) = O(GCD(n,k))$，与n和k的最大公约数有关，最高不超过$O(2n)$</p><h4 id="倒置版"><a href="#倒置版" class="headerlink" title="倒置版"></a>倒置版</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/4c4232c5cf2228c9b54e4204f9f2a69a-661fc.png" alt="倒置版"></p><h5 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h5><p>翻转k个需要$k/2$次，每次需要三条语句，所以是$O(3k/2)$。下同…</p><h3 id="连续缓存"><a href="#连续缓存" class="headerlink" title="连续缓存"></a>连续缓存</h3><p>比较迭代版和倒置版，虽然从复杂度来看，迭代版的复杂度要好于倒置版，但是实际上，因为有高速缓存的存在，倒置版在程序的局部性上做得更好，速度会更快。</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6c7d5f2b1b119eae1008e907cac5dbcb-6f68a.png" alt="连续缓存"></p><ul><li>倒置版会在一个小小的区间内做数据操作，而迭代版的数据操作跨度大，容易重新加载高速缓存</li></ul><p>另外，像下图这种操作，由于两边操作的数据都在高速缓存内，所以也利用了程序的连续性</p><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/cbf11e2a7d9abbca78f8d1c455fe5543-02587.png" alt="连续缓存"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>内存对齐</title>
    <link href="/2020/01/27/C++/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    <url>/2020/01/27/C++/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="什么是内存对齐"><a href="#什么是内存对齐" class="headerlink" title="什么是内存对齐"></a>什么是内存对齐</h2><p>内存对齐（Memory alignment），也叫字节对齐。现代计算机中内存空间都是按照 Byte 划分的，CPU按照双字、字、字节访问存储内存，并通过总线进行传输（CPU把内存当成是一块一块的，块的大小可以是2、4、8、16字节大小，因此CPU在读取内存时是一块一块进行读取的。）。从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问<strong>特定类型变量</strong>(结构体、联合体等)的时候经常在<strong>特定的内存地址</strong>访问，这就需要各种类型数据按照<strong>一定的规则</strong>在空间上排列，而不是顺序的一个接一个的摆放。若未经一定规则的对齐，CPU的访址操作与总线的传输操作将会异常的复杂，所以现代编译器中都会对内存进行自动的对齐。</p><p><strong>假设</strong><br>在结构体里面有一个整型变量 a。CPU如果想取出结构体里面的变量a，首先装载结构体的首地址，然后根据偏移地址获得变量a：</p><ol><li>在内存对齐的情况下（如图1），由于变量a从偏移地址为 “0” 的位置开始，所以CPU获取a只需一步就能完成。</li><li>在内存未对齐的情况下（如图2），由于变量a从偏移地址 “2” 的位置开始，所以CPU需要先获取 “0” - “3” 内存地址里面的值，并取出其中的 “2” - “3” 中的内容。接着再获取 “4” - “7” 内存地址里面的值，并取出 “4” - “5” 中的内容。最后，将前后两次操作取得的最终值拼接，就获得了变量a。<br><img src="https://img-blog.csdnimg.cn/20200817155349568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkzOTQ4Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="内存"><br>显而易见，CPU在处理两种情况下的内存，效率和时间的差距是非常大的。</li></ol><h2 id="内存对齐的规则"><a href="#内存对齐的规则" class="headerlink" title="内存对齐的规则"></a>内存对齐的规则</h2><ol><li>数据成员对齐规则：第一个数据成员从<strong>特定类型变量</strong>的起始地址(即偏移量为0)开始存放。之后每个数据成员的偏移量K，由<strong>内存对齐系数</strong>和<strong>该数据成员长度</strong>之间最小的数值M的非负整数倍N决定。总结下来就是：K = M * N。如有需要，编译器会在数据成员之间加上填充字节(internal adding)。</li><li>特定类型变量对齐规则：在数据成员完成各自对齐之后，<strong>特定类型变量</strong>本身也要进行对齐。编译器会从<strong>内存对齐系数</strong>和<strong>该特定类型变量中，最大的数据成员的长度</strong>中取得最小值M。与数据成员对齐规则类似，整个特定类型变量的长度是M的非负整数倍N。即满足：sizeof(<em>特定类型变量</em>) = M * N。如有需要，编译器会在最后一个数据成员之后加上填充字节(trailing padding)。</li></ol><h2 id="内存对齐实例"><a href="#内存对齐实例" class="headerlink" title="内存对齐实例"></a>内存对齐实例</h2><h3 id="几个简单的例子"><a href="#几个简单的例子" class="headerlink" title="几个简单的例子"></a>几个简单的例子</h3><h4 id="类的内存对齐"><a href="#类的内存对齐" class="headerlink" title="类的内存对齐"></a>类的内存对齐</h4><h5 id="pragma-pack-n"><a href="#pragma-pack-n" class="headerlink" title="#pragma pack(n)"></a>#pragma pack(n)</h5><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">st1</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">char</span> a;<br><span class="hljs-keyword">int</span>  b;<br><span class="hljs-keyword">short</span> c;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">st2</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">short</span> c;<br><span class="hljs-keyword">char</span>  a;<br><span class="hljs-keyword">int</span>   b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;sizeof(st1) is &quot;</span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(st1) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sizeof(st2) is &quot;</span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(st2) &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(st1) is <span class="hljs-number">12</span><br><span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(st2) is <span class="hljs-number">8</span><br></code></pre></div></td></tr></table></figure><p>由上，我们发现两个问题：</p><ol><li>st1和st2两个结构体sizeof的值不应该都是1(char)+4(int)+2(short)=7byte吗？</li><li><p>st1和st2两个结构体的数据成员完全一样，只是它们的摆放(声明)顺序不一样，为什么最后sizeof出来的结果会不一样？</p><p>根据前文关于内存对齐的描述，我们可以这样解决(VC6默认内存对齐系数为8，以下未指定的内存对齐系数皆为8)：</p><p><strong>结构体st1内存分配过程（结果如下图）</strong></p></li><li>char a ：因为是第一个数据成员，所以它的偏移地址为”0”。</li><li>int b ：内存对齐系数为8，而sizeof(int)为4，两者最小为4。根据规则1，变量b的偏移地址应该为4的非负整数倍。此时该内存块可分配的偏移地址有效值为 “1”…，但是显然，”1”、”2”、”3” 这三个偏移地址并不是4的非负整数倍，只有偏移地址 “4” 符合要求。所以，变量b的偏移地址是 “4”，内存空间为 “4” - “7” 一共四个字节。</li><li>由于变量a从 “0” 开始只占了一个字节，而变量b是从 “4” 开始的，所以”1” - “3” 这三块内存是空闲的。此时编译器会自动填充(这里暂时用0代替填充的值，下文同)，填充的值由编译器来决定(这也就是为什么memcmp不能用来比较两个结构体，memcmp是逐个字节对比的，当字节对齐时，中间的填充部分是随机的，所以比较的结果是不正确的)。</li><li>short c：内存对齐系数为8，而sizeof(short)为2，两者最小为2。根据规则1，变量c的偏移地址应该为2的非负整数倍。此时该内存块可分配的偏移地址有效值为 “8”…，而 “8” 正好符合条件，所以变量c的偏移地址为 “8” ，内存空间为 “8” - “9” 一共两个字节。</li><li>至此，st1中的三个数据成员已经全部分配完毕，接下来就要考虑整体对齐。因为内存对齐系数为8，而st1中最大的数据成员b的长度为4，所以两者中最小为4。此时sizeof(st1)为10，而10并不是4的非负整数倍，不符合规则2，所以编译器会在 “10” - “11” 自动填充，使sizeof(st1)为12，符合规则2。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200817122054212.png#pic_center" alt="str1"></p><p><strong>结构体st2内存分配过程（结果如下图）</strong></p><ol><li>short c ：因为是第一个数据成员，所以它的偏移地址为”0”，内存地址为 “0” - “1” 一共两个字节。</li><li>char a ：内存对齐系数为8，而sizeof(char)为1，两者最小为1。根据规则1，变量a的偏移地址应该为1的非负整数倍。此时该内存块可分配的偏移地址有效值为 “2”…，而偏移地址 “2” 正好符合要求。所以，变量a的偏移地址是 “2”，内存地址为 “2” 一共一个字节。</li><li>int b：内存对齐系数为8，而sizeof(int)为4，两者最小为4。根据规则1，变量b的偏移地址应该为4的非负整数倍。此时该内存块可分配的偏移地址有效值为 “3”…，显然, “3” 并不符合要求，而 “4” 符合要求。所以，变量b的偏移地址为 “4”,内存地址为 “4” - “7” 一共4个字节。</li><li>由于变量a从 “2” 开始只占了一个字节，而变量b是从 “4” 开始的，所以 “3” 这块内存是空闲的，编译器会自动填充。</li><li><p>至此，st2中的三个数据成员已经全部分配完毕，接下来就要考虑整体对齐。因为内存对齐系数为8，而st2中最大的数据成员b的长度为4，所以两者中最小为4。此时sizeof(st2)为8，而8是4的非负整数倍，符合规则2，所以编译器不做任何处理。</p><p><img src="https://img-blog.csdnimg.cn/20200817151951314.png#pic_center" alt="st2"></p></li></ol><h2 id="修改内存对齐系数"><a href="#修改内存对齐系数" class="headerlink" title="修改内存对齐系数"></a>修改内存对齐系数</h2><p>若需修改内存对齐系数，需用：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> pack(n) <span class="hljs-comment">// n为内存对齐系数</span></span><br></code></pre></div></td></tr></table></figure></p><blockquote><p>参考资料：<br><a href="https://zhuanlan.zhihu.com/p/93822540">C/C++中内存对齐问题的一些理解</a><br><a href="https://songlee24.github.io/2014/09/20/memory-alignment/">C/C++内存对齐</a><br><a href="https://blog.csdn.net/N1neDing/article/details/80202103">内存对齐——规则及原因</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
