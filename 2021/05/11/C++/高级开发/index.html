

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;dark&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="开发技巧、对象模型、C++设计模式及部分新特性...">
  <meta name="author" content="zhong shiyu">
  <meta name="keywords" content="">
  
  <title>高级开发 - rushcpp的笔记博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/night-owl.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/shubiao.css#.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":true,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>





<body>
  <header style="height: 30vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>rushcpp</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                笔记
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/archives/">
                    <i class="iconfont icon-archive-fill"></i>
                    归档
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/">
                    <i class="iconfont icon-category-fill"></i>
                    分类
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/tags/">
                    <i class="iconfont icon-tags-fill"></i>
                    标签
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6ef39284af5752bfd935f18f56c1bbfb-666d4.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="高级开发">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-05-11 10:00" pubdate>
        2021年5月11日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      84
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">高级开发</h1>
            
            <div class="markdown-body">
              <h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="类体里的内联函数"><a href="#类体里的内联函数" class="headerlink" title="类体里的内联函数"></a>类体里的内联函数</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br>	<span class="hljs-built_in">complex</span> (T r = <span class="hljs-number">0</span>, T i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i)&#123;&#125; <br>	complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp;); <br>	<span class="hljs-function">T <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125; <span class="hljs-comment">//内联函数的候选人</span><br>	<span class="hljs-function">T <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125; <span class="hljs-comment">//内联函数的候选人</span><br><span class="hljs-keyword">private</span>: <br>	T re, im; <span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-keyword">const</span> complex&amp;);  <br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>在类体里定义的函数会成为内联函数的<strong>候选人</strong>，最终是否为内联函数由编译器决定。</p>
<h3 id="构造函数的重载"><a href="#构造函数的重载" class="headerlink" title="构造函数的重载"></a>构造函数的重载</h3><p>构造函数重载的情况很常见，但是比如</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br>	<span class="hljs-built_in">complex</span> (<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i) &#123;&#125; <span class="hljs-comment">//构造函数1</span><br>	<span class="hljs-built_in">complex</span> () : <span class="hljs-built_in">re</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">im</span>(<span class="hljs-number">0</span>) &#123;&#125; <span class="hljs-comment">//构造函数2</span><br>	complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp;); <br>	<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125; <br>	<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125; <br><span class="hljs-keyword">private</span>: <br>	<span class="hljs-keyword">double</span> re, im; <br>	<br>	<span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-keyword">const</span> complex&amp;);  <br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p><strong>构造函数1</strong>和<strong>构造函数2</strong>是不能同时存在的，原因是<strong>构造函数1</strong>的形参设置了默认值，编译器无法分辨它和<strong>构造函数2</strong>的区别</p>
<h2 id="参数传递与返回值"><a href="#参数传递与返回值" class="headerlink" title="参数传递与返回值"></a>参数传递与返回值</h2><h3 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h3><p>const关键字用于成员函数（如下面代码段中的<strong>一号const</strong>和<strong>二号const</strong>），表示该成员函数所执行的内容不会改变类里面的数据。</p>
<p>另外，const用于变量（如下面代码段中的<strong>三号const</strong>），表示该变量的值无法被修改。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/*xxx.h*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">complex</span> (<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i)  &#123; &#125; <br>    complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp;); <br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125; <span class="hljs-comment">//一号const</span><br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125; <span class="hljs-comment">//二号const</span><br><span class="hljs-keyword">private</span>: <br>    <span class="hljs-keyword">double</span> re, im; <br>    <span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-keyword">const</span> complex&amp;);  <br>&#125;;<br><br><span class="hljs-comment">/*mian.cc*/</span><br><span class="hljs-comment">//...</span><br>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">const</span> complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//三号const</span><br>	cout &lt;&lt; c1.<span class="hljs-built_in">real</span>();<span class="hljs-comment">//代码1</span><br>	cout &lt;&lt; c1.<span class="hljs-built_in">imag</span>();<span class="hljs-comment">//代码2</span><br>&#125;<br><span class="hljs-comment">//...</span><br></code></pre></div></td></tr></table></figure>
<p>假设有两种情况：</p>
<ol>
<li>一号const和二号const存在</li>
<li>一号const和二号const不存在</li>
</ol>
<p>第一种情况是正确的。c1为const，故无法更改c1的内容。又因为<strong>real()</strong>方法为const，所以<strong>代码1</strong>和<strong>代码2</strong>不会报错。</p>
<p>第二种情况是错误的。此时<strong>real()</strong>和<strong>imag()</strong>这两个成员函数不是const，而c1变量又是const，当执行<code>cout&lt;&lt;c1.real();</code>时，编译器认为<strong>real()</strong>这个方法可能会改变c1变量的内容，故会报错。这种情况下把<strong>三号const</strong>也去掉，编译器就不会报错了。</p>
<p>不过为了程序的健壮性与开发规范，没有改变类数据的成员函数加上const是必不可少的。</p>
<h3 id="参数传递和返回值传递"><a href="#参数传递和返回值传递" class="headerlink" title="参数传递和返回值传递"></a>参数传递和返回值传递</h3><ol>
<li>值传递：值有多大就传多大</li>
<li>指针：传地址</li>
<li>引用：引用的底层就是指针，传引用就是传指针</li>
</ol>
<p><strong>参数和返回值传递尽量使用引用</strong>。不过有些情况可以用值，比如值的大小&lt;4字节时，速度会更快点。</p>
<p>引用速度很快，但是它和指针一样，内容会被修改。当我们只想追求参数传递速度而不想改变引用的内容时，可以使用const来修饰引用。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br>	<span class="hljs-built_in">complex</span> (<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i)  &#123; &#125; <br>	complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp;); <span class="hljs-comment">//const引用修饰的形参</span><br>	<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125; <br>	<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125; <br><span class="hljs-keyword">private</span>: <br>	<span class="hljs-keyword">double</span> re, im; <br>	<span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-keyword">const</span> complex&amp;);<span class="hljs-comment">//const引用修饰的返回值</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>当函数返回值为函数的<strong>局部变量</strong>时，禁止使用引用。</p>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>在一个类里声明一个友元函数，表示这个友元函数可以随意访问这个类的内容，比如private修饰的类成员数据。即类对于友元函数失去了封装性。</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br>	<span class="hljs-built_in">complex</span> (<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i)  &#123; &#125; <br>	complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp;); <br>	<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125; <br>	<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125; <br><span class="hljs-keyword">private</span>: <br>	<span class="hljs-keyword">double</span> re, im ; <br>	<span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-keyword">const</span> complex&amp;);  <br>&#125;;<br><br><span class="hljs-keyword">inline</span> complex&amp; __doapl (complex* ths, <span class="hljs-keyword">const</span> complex&amp; r) &#123; <br>    ths - &gt;re += r.re ; <br>    ths - &gt;im += r.im ; <br>    <span class="hljs-keyword">return</span> *ths ; <br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>对于友元函数还有个特例：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span> &#123;</span> <br><span class="hljs-keyword">public</span>: <br>	<span class="hljs-built_in">complex</span> (<span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i)  &#123; &#125; <br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> complex&amp; param)</span> </span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> param.re + param.im; &#125; <br><span class="hljs-keyword">private</span>: <br>	<span class="hljs-keyword">double</span> re, im; <br>&#125;;<br><span class="hljs-comment">//...</span><br>&#123; <br>	<span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>; <br>	complex c2; <br>	c2.<span class="hljs-built_in">func</span>(c1); <br>&#125;<br><span class="hljs-comment">//...</span><br></code></pre></div></td></tr></table></figure>
<p>上面的例子是正确。虽然re和im这两个类成员数据是私有的，但是c2却能访问c1的私有变量。这个隐藏属性用一句话就能解释：</p>
<p><strong>相同 class 的各个 objects 互为 friends (友元)</strong>。</p>
<h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><h3 id="成员函数的隐藏参数"><a href="#成员函数的隐藏参数" class="headerlink" title="成员函数的隐藏参数"></a>成员函数的隐藏参数</h3><p>所有成员函数都自带一个隐藏的<strong>this</strong>指针</p>
<h3 id="返回值引用的语法分析"><a href="#返回值引用的语法分析" class="headerlink" title="返回值引用的语法分析"></a>返回值引用的语法分析</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//XXX.h</span><br><span class="hljs-comment">//方法1</span><br><span class="hljs-keyword">inline</span> complex&amp;<span class="hljs-comment">//返回值是引用类型，速度更快</span><br>__doapl(complex* ths, <span class="hljs-keyword">const</span> complex&amp; r) &#123; <br>    ... <br>    <span class="hljs-keyword">return</span> *ths; <span class="hljs-comment">//这里的*表示取ths这个指针的内容</span><br>&#125; <br><br><span class="hljs-comment">//方法2</span><br><span class="hljs-keyword">inline</span> complex&amp; <span class="hljs-comment">//这里返回值改成“值”类型也是没问题的</span><br>complex::<span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp; r) &#123; <span class="hljs-comment">//这里的参数列表只有一个r,这个r指的是右值。而左值是隐藏的this</span><br>    <span class="hljs-keyword">return</span> __doapl(<span class="hljs-keyword">this</span>,r); <span class="hljs-comment">//调用__doapl</span><br>&#125;<br><br><span class="hljs-comment">//main.c</span><br>&#123;<br>	<span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br>	<span class="hljs-function">complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>	c2 += c1;<span class="hljs-comment">//上面代码的返回值类型的改动不会影响到这行代码的结果</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>__doapl</strong>这个函数的返回值为引用，所以调用该函数者，无论是以值的类型接收还是以引用的类型接收都可以，与<strong>__doapl</strong>无关。</p>
<p>我们设计<strong>方法2</strong>的时候，如果只考虑使用者只会编写出<code>c2 += c1</code>这种情况，那么方法2的返回值类型改成void的也是可以的。但是当使用者编写出<code>c3 += c2 += c1</code>这样的连续赋值的代码时，方法2为void返回值类型就会出错。</p>
<p>一个好的函数设计应该做到：</p>
<p><strong>传递者无需知道接收者是以引用形式接收</strong></p>
<p>那么如何判断一个函数的返回值类型能不能为引用呢？其实很简单，只要判断返回值在函数内是不是该函数的临时变量，如果是，就老老实实的用值类型；如果不是，即该返回值是事先存在的（还没调用到该函数时就已经存在了），那么就可以用引用类型的返回值。</p>
<h3 id="操作符重载的非成员函数与临时对象"><a href="#操作符重载的非成员函数与临时对象" class="headerlink" title="操作符重载的非成员函数与临时对象"></a>操作符重载的非成员函数与临时对象</h3><p>例1：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//函数1</span><br><span class="hljs-keyword">inline</span> complex <br><span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">const</span> complex&amp; x, <span class="hljs-keyword">const</span> complex&amp; y) <br>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>(<span class="hljs-built_in">real</span> (x) + <span class="hljs-built_in">real</span> (y), <span class="hljs-built_in">imag</span> (x) + <span class="hljs-built_in">imag</span> (y)); <br>&#125; <br><br><span class="hljs-comment">//函数2</span><br><span class="hljs-keyword">inline</span> complex <br><span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">const</span> complex&amp; x, <span class="hljs-keyword">double</span> y) <br>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>(<span class="hljs-built_in">real</span> (x) + y, <span class="hljs-built_in">imag</span> (x)); <br>&#125; <br><br><span class="hljs-comment">//函数3</span><br><span class="hljs-keyword">inline</span> complex <br><span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">const</span> complex&amp; y) <br>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>(x + <span class="hljs-built_in">real</span> (y), <span class="hljs-built_in">imag</span> (y)); <br>&#125;<br><br><span class="hljs-comment">//函数4</span><br><span class="hljs-keyword">inline</span> complex<br><span class="hljs-keyword">operator</span> - (<span class="hljs-keyword">const</span> complex&amp; x)<br>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span> (-<span class="hljs-built_in">real</span> (x), -<span class="hljs-built_in">imag</span> (x));<br>&#125;<br><br><span class="hljs-comment">//函数5</span><br><span class="hljs-keyword">inline</span> complex<br><span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">const</span> complex&amp; x)<br>&#123;<br>	<span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-comment">//main.c</span><br>&#123;<br>	<span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br>	complex c2;<br>	c2 = c1 + c2;<span class="hljs-comment">//对应函数1</span><br>	c2 = c1 + <span class="hljs-number">5</span>;<span class="hljs-comment">//对应函数2</span><br>	c2 = <span class="hljs-number">7</span> + c1;<span class="hljs-comment">//对应函数3</span><br>    cout &lt;&lt; -c1;<span class="hljs-comment">//对应函数4</span><br>    cout &lt;&lt; +c1;<span class="hljs-comment">//对应函数5</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面的函数1~4的返回值类型都是值，而不是引用。原因是这几个函数最后返回的complex都是<strong>临时对象</strong>，所以不能用引用，否则会出错。函数5应该可以把返回值类型改成引用，由于代码源自标准库，所以设计者有他的道理或者说该函数不够完美。</p>
<p>例2：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//函数1</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> complex</span><br><span class="hljs-function"><span class="hljs-title">conj</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> complex&amp; x)</span> </span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span> (<span class="hljs-built_in">real</span> (x), -<span class="hljs-built_in">imag</span> (x));<br>&#125;<br><br><span class="hljs-comment">//函数2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream.h&gt;</span></span><br>ostream&amp;<span class="hljs-comment">//函数2的返回值类型</span><br><span class="hljs-keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="hljs-keyword">const</span> complex&amp; x)<br>&#123;<br>	<span class="hljs-keyword">return</span> os &lt;&lt; <span class="hljs-string">&#x27;(&#x27;</span> &lt;&lt; <span class="hljs-built_in">real</span> (x) &lt;&lt; <span class="hljs-string">&#x27;,&#x27;</span> &lt;&lt; <span class="hljs-built_in">imag</span> (x) &lt;&lt; <span class="hljs-string">&#x27;)&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">//main.c</span><br>&#123;<br>	<span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span>;<br>	cout &lt;&lt; <span class="hljs-built_in">conj</span>(c1);<span class="hljs-comment">//代码1</span><br>	cout &lt;&lt; c1 &lt;&lt; <span class="hljs-built_in">conj</span>(c1);<span class="hljs-comment">//代码2</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>对于函数2，返回值类型可以为void，但是只有代码1才能正确执行。当返回值类型为引用时，代码1和代码2都能正确执行。</p>
<p>另外，我们也可以写出<code>c1&lt;&lt;cout;</code>这样的代码，将<strong>函数2</strong>写为成员函数就会出现这种情况，不过一般不这么做，因为不符合规范。</p>
<h2 id="拷贝构造，拷贝复制，析构（Big-Three）"><a href="#拷贝构造，拷贝复制，析构（Big-Three）" class="headerlink" title="拷贝构造，拷贝复制，析构（Big Three）"></a>拷贝构造，拷贝复制，析构（Big Three）</h2><h3 id="默认的Big-Three"><a href="#默认的Big-Three" class="headerlink" title="默认的Big Three"></a>默认的Big Three</h3><p>编译器都会给类默认生成Big Three，当然我们也可以自己写。但是当一个类里面有指针类型的成员变量时，我们最好要自定义Big Three。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">String</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr = <span class="hljs-number">0</span>); <span class="hljs-comment">//构造函数</span><br>	<span class="hljs-built_in">String</span>(<span class="hljs-keyword">const</span> String&amp; str); <span class="hljs-comment">//拷贝构造</span><br>	String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> String&amp; str);<span class="hljs-comment">//拷贝复制 </span><br>	~<span class="hljs-built_in">String</span>(); <span class="hljs-comment">//析构函数</span><br>	<span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">get_c_str</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_data; &#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-keyword">char</span>* m_data;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-title">String::String</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr = <span class="hljs-number">0</span>)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (cstr) &#123;<br>		m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-built_in">strlen</span>(cstr)+<span class="hljs-number">1</span>];<br>		<span class="hljs-built_in">strcpy</span>(m_data, cstr);<br>	&#125;<br>	<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 未指定初值</span><br>		m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1</span>]; *m_data = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>		&#125;<br>&#125;<br><br><span class="hljs-keyword">inline</span><br>String::~<span class="hljs-built_in">String</span>() &#123;<br>	<span class="hljs-keyword">delete</span>[] m_data;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>
<h3 id="对象拥有指针时的拷贝构造"><a href="#对象拥有指针时的拷贝构造" class="headerlink" title="对象拥有指针时的拷贝构造"></a>对象拥有指针时的拷贝构造</h3><p>编译器自带的拷贝构造有缺点，比如当一个对象1中有一个指针指向内存的地址，而通过编译器给的拷贝构造进行拷贝时，对象2也会拥有这个指针，同时也指向同一块内存，所以这并不是真正意义上的拷贝。所以<strong>当类含有指针，我们一定不能使用默认的拷贝构造</strong>。</p>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416173442.png" srcset="/img/loading.gif" lazyload alt="拷贝构造示例"></p>
<h3 id="拷贝复制中的检测自我赋值"><a href="#拷贝复制中的检测自我赋值" class="headerlink" title="拷贝复制中的检测自我赋值"></a>拷贝复制中的检测自我赋值</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">inline</span><br>String&amp; String::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> String&amp; str)<br>&#123;<br>	<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;str)<span class="hljs-comment">//检测自我赋值</span><br>		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>		<br>	<span class="hljs-keyword">delete</span>[] m_data;<span class="hljs-comment">//第一步，删除自己的空间</span><br>	m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-built_in">strlen</span>(str.m_data) + <span class="hljs-number">1</span>];<span class="hljs-comment">//第二步，创建空间，空间大小参考复制的对象</span><br>	<span class="hljs-built_in">strcpy</span>(m_data, str.m_data);<span class="hljs-comment">//第三步，将复制的对象的内容复制到自己的空间里</span><br>	<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210416173919.png" srcset="/img/loading.gif" lazyload alt="检测自我复制"></p>
<p>假设我们执行<code>a=a;</code>,此时若没有<strong>检测自我赋值</strong>，直接执行第一步，那么执行当第二步的时候，由于<code>str.m_data</code>这个指针已经被第一步删除了，所以会出错。</p>
<h2 id="堆、栈与内存管理"><a href="#堆、栈与内存管理" class="headerlink" title="堆、栈与内存管理"></a>堆、栈与内存管理</h2><h3 id="new和delete的详解"><a href="#new和delete的详解" class="headerlink" title="new和delete的详解"></a>new和delete的详解</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417172347.png" srcset="/img/loading.gif" lazyload alt="new"></p>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417172442.png" srcset="/img/loading.gif" lazyload alt="delete"></p>
<h3 id="动态分配所得到的内存块以及array"><a href="#动态分配所得到的内存块以及array" class="headerlink" title="动态分配所得到的内存块以及array"></a>动态分配所得到的内存块以及array</h3><p>一块由动态分配得到的内存如下所示：</p>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417175419.png" srcset="/img/loading.gif" lazyload alt="内存"></p>
<p>须知：分配出来内存的大小必须为16的倍数。</p>
<p>绿色的内存区域是我们为类型分配空间时，该类型占用的存储空间。</p>
<p>头尾两块红色的内存，称为cookie，它的作用是表示这块内存的大小和状态。比如一块内存大小为64的内存，转换为16进制为0x40，但是我们看最左边的那片内存，头尾的cookie却是0x41，原因是当这片内存处于释放状态时，cookie的最后一位为0；而当这片内存处于使用状态时，cookie的最后一位为1。所以0x41实际上代表着：这块内存的大小为64且正在被使用。</p>
<p>灰色的内存区域表示处于debug模式下需要用到的空间，具体名称见下图。</p>
<p>浅绿色的内存区域表示当这块内存区域的大小不是16的倍数时，需要多余的内存区域。这块内存区域纯粹是起到了填充的作用，让整片内存区域变成16的倍数。</p>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417181042.png" srcset="/img/loading.gif" lazyload alt="动态分配array"></p>
<p>上图中String这边对应着下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">String</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr = <span class="hljs-number">0</span>);<br>	<span class="hljs-built_in">String</span>(<span class="hljs-keyword">const</span> String&amp; str);<br>	String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> String&amp; str);<br>	~<span class="hljs-built_in">String</span>();<br>	<span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">get_c_str</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_data; &#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-keyword">char</span>* m_data;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-title">String::String</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr = <span class="hljs-number">0</span>)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (cstr) &#123;<br>		m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-built_in">strlen</span>(cstr)+<span class="hljs-number">1</span>];<span class="hljs-comment">//这里的new使用中括号，会导致下面析构函数的delete使用中括号</span><br>		<span class="hljs-built_in">strcpy</span>(m_data, cstr);<br>	&#125;<br>	<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 未指定初值</span><br>		m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1</span>]; *m_data = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>		&#125;<br>&#125;<br><br><span class="hljs-keyword">inline</span><br>String::~<span class="hljs-built_in">String</span>() &#123;<br>	<span class="hljs-keyword">delete</span>[] m_data;<span class="hljs-comment">//这里的delete使用中括号，是因为上面构造函数的new使用了中括号</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>array new、array delete这两者需要互相搭配</strong>，不然像下图的情况，会导致内存泄露：</p>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417174307.png" srcset="/img/loading.gif" lazyload alt="示意图"></p>
<h3 id="new和delete的重载"><a href="#new和delete的重载" class="headerlink" title="new和delete的重载"></a>new和delete的重载</h3><p>对于new和delete的重载比较特殊，对于<strong>全局</strong>的重载只能改变<code>new</code>内部的<code>operator new</code>。比如</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">Complex* pc = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">//此处的new并不能被重载</span><br><br><span class="hljs-comment">//**********</span><br><span class="hljs-keyword">void</span>* mem = <span class="hljs-keyword">operator</span> <span class="hljs-built_in"><span class="hljs-keyword">new</span></span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Complex));<span class="hljs-comment">//只有这里的new会被重载</span><br>pc = <span class="hljs-keyword">static_cast</span>&lt;Complex*&gt;(mem);<br>pc-&gt;Complex::<span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br><span class="hljs-comment">//**********</span><br></code></pre></div></td></tr></table></figure>
<p>实际上，类里对于<code>operator new</code>的重载必须是<code>static</code>静态方法，因为<code>operator new</code>无法通过对象来调用。但是又因为<strong>必须</strong>是<code>static</code>，所以我们可以省略不写，编译器会自动转成静态方法。</p>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/66788b8ddbd5222fc1305edc2eb807b9-291fd.png" srcset="/img/loading.gif" lazyload alt="new和delete的重载"></p>
<p>成员的重载和全局的重载类似，但是成员的重载只会影响具体的对象，并不会影响到全局。比如：</p>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/802ea01e86c5f33027bb662e7cb8f6eb-fe55d.png" srcset="/img/loading.gif" lazyload alt="成员的重载"></p>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f93c6a1d0fbc45623c36504b87fc7ff7-9832f.png" srcset="/img/loading.gif" lazyload alt="成员的重载"></p>
<p>内存池经常使用这种重载的写法。</p>
<h4 id="new和delete重载例子"><a href="#new和delete重载例子" class="headerlink" title="new和delete重载例子"></a>new和delete重载例子</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/6d9b9f2bcaea735bfe0440039666101e-2c912.png" srcset="/img/loading.gif" lazyload alt="new和delete重载例子"></p>
<p>注意：若使用者想绕过成员重载的new和delete，那么可以使用域运算符强制使用全局的new和delete：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">Foo* pf = ::<span class="hljs-keyword">new</span> Foo;<span class="hljs-comment">//强制使用全局的new</span><br>::<span class="hljs-keyword">delete</span> pf;<span class="hljs-comment">//强制使用全局的delete</span><br></code></pre></div></td></tr></table></figure>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8d373471aa84c1428828b9fbc2b7a43b-483b9.png" srcset="/img/loading.gif" lazyload alt="new和delete重载例子"></p>
<p>本例中的<code>Foo</code>大小为$int(4)+long(4)+string(4) = 12$，五个<code>Foo</code>就是$12<em>5=60$。但是上图中，大小为5的<code>Foo</code>指针数组的<em>*size</em></em>却为64。这多出来的4个字节实际上是计数器，记录了该数组的元素个数，不然当<code>array delete</code>的时候，无法正常释放。</p>
<p>还有一点，上图右边的内存示意图，表示当<code>array new</code>时，对象的构造是自上而下，即从下标为0开始的元素构造到最后一个；而<code>array delete</code>的顺序正好相反。</p>
<h4 id="placement-operator-new-delete"><a href="#placement-operator-new-delete" class="headerlink" title="placement operator new/delete"></a>placement operator new/delete</h4><p>因为new操作符是先分配内存，再执行构造函数，所以当构造函数发生异常后，需要及时的归还内存，否则会造成内存泄漏。</p>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/711308668153592ca45c4aada96ad2bc-c4497.png" srcset="/img/loading.gif" lazyload alt="placement operator new/delete"></p>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/d85663e5f18393030570a21bb364de79-d3e5d.png" srcset="/img/loading.gif" lazyload alt="placement operator new/delete"></p>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/427d96d859f4c379c07aeb0c363f03fc-c443a.png" srcset="/img/loading.gif" lazyload alt="placement operator new/delete"></p>
<h4 id="c-库例子：basic-string使用new-extra-扩充申请量"><a href="#c-库例子：basic-string使用new-extra-扩充申请量" class="headerlink" title="c++库例子：basic_string使用new(extra)扩充申请量"></a>c++库例子：basic_string使用new(extra)扩充申请量</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f40ea2a9e53c950064695b344070ea3f-68f51.png" srcset="/img/loading.gif" lazyload alt="c++库例子：basic_string使用new(extra)扩充申请量"></p>
<h2 id="拓展补充：类模板、函数模板及其他"><a href="#拓展补充：类模板、函数模板及其他" class="headerlink" title="拓展补充：类模板、函数模板及其他"></a>拓展补充：类模板、函数模板及其他</h2><h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><p><strong>每个类成员函数都有一个指向自己所处对象的this指针</strong>，通过对象调用成员函数时，会把对象的地址放到成员函数里变成this指针</p>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417194726.png" srcset="/img/loading.gif" lazyload alt="示意图"></p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ol>
<li>静态数据、静态函数与对象脱离，它不属于对象。它只有一份，存储在内存的某片区域</li>
<li>静态函数没有this指针，所以它只能处理静态的数据</li>
<li>静态函数可以通过类名调用，也可以通过对象名调用</li>
<li>只有调用或执行到含有静态数据的函数或代码块，该静态数据才会被创建</li>
</ol>
<h3 id="模板简介"><a href="#模板简介" class="headerlink" title="模板简介"></a>模板简介</h3><p>类模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">complex</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">complex</span> (T r = <span class="hljs-number">0</span>, T i = <span class="hljs-number">0</span>): <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i) &#123; &#125;<br>	complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-keyword">const</span> complex&amp;);<br>	<span class="hljs-function">T <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125;<br>	<span class="hljs-function">T <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125;<br><span class="hljs-keyword">private</span>:<br>	T re, im;<br>	<span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-keyword">const</span> complex&amp;); <br>&#125;;<br><br>&#123;<br>	<span class="hljs-function">complex&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2.5</span>,<span class="hljs-number">1.5</span>)</span></span>;<span class="hljs-comment">//代码1</span><br>	<span class="hljs-function">complex&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">6</span>)</span></span>;<span class="hljs-comment">//代码2</span><br>...<br>&#125;<br><br></code></pre></div></td></tr></table></figure>
<p>当执行到<strong>代码1</strong>和<strong>代码</strong>2时，类模板会根据<code>double</code>和<code>int</code>生成相应的代码。这种行为会造成代码的膨胀，但是这是必要的。</p>
<p>函数模板：</p>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417201643.png" srcset="/img/loading.gif" lazyload alt="函数模板"></p>
<p>类模板的类型用<strong>typename</strong>来代替，而函数模板用<strong>class</strong>来代替，虽然看起来两者不同，但是意思上是一样的。</p>
<p>类模板和函数模板的不同点在于<strong>引数推导</strong>，即编译器会根据实参的类型来推导，比如上图<code>r3 = min(r1,r2)</code>中的<strong>r1</strong>和<strong>r2</strong>。</p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417212750.png" srcset="/img/loading.gif" lazyload alt="命名空间"></p>
<h2 id="组合与继承"><a href="#组合与继承" class="headerlink" title="组合与继承"></a>组合与继承</h2><h3 id="组合-has-a"><a href="#组合-has-a" class="headerlink" title="组合 has-a"></a>组合 has-a</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417212913.png" srcset="/img/loading.gif" lazyload alt="复合例子1"></p>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417212933.png" srcset="/img/loading.gif" lazyload alt="复合例子2"></p>
<h3 id="组合关系下的构造与析构"><a href="#组合关系下的构造与析构" class="headerlink" title="组合关系下的构造与析构"></a>组合关系下的构造与析构</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417213018.png" srcset="/img/loading.gif" lazyload alt="复合的析构"></p>
<h3 id="委托-Composition-by-reference"><a href="#委托-Composition-by-reference" class="headerlink" title="委托 Composition by reference"></a>委托 Composition by reference</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417213157.png" srcset="/img/loading.gif" lazyload alt="委托"></p>
<p>这样的做法很好，因为这样做可以保持左边不变右边变，即提供给客户端的接口不变，但是实现接口的功能可以改变。这样又称为编译防火墙，因为左边不变，所以左边无需再编译。</p>
<p>委托和组合的区别：</p>
<ol>
<li>组合中，两者的生命周期是同时的。而在委托里，两者的生命周期可以分先后。</li>
</ol>
<h3 id="继承关系下的构造与析构"><a href="#继承关系下的构造与析构" class="headerlink" title="继承关系下的构造与析构"></a>继承关系下的构造与析构</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210417221702.png" srcset="/img/loading.gif" lazyload alt="继承"></p>
<h3 id="继承-组合关系下的构造与析构"><a href="#继承-组合关系下的构造与析构" class="headerlink" title="继承+组合关系下的构造与析构"></a>继承+组合关系下的构造与析构</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/d47977674578fa527e49b603340f0e60-d4e93.png" srcset="/img/loading.gif" lazyload alt="继承+组合关系下的构造与析构"></p>
<h2 id="虚函数与多态"><a href="#虚函数与多态" class="headerlink" title="虚函数与多态"></a>虚函数与多态</h2><h3 id="内存中的继承"><a href="#内存中的继承" class="headerlink" title="内存中的继承"></a>内存中的继承</h3><p>函数继承：子类继承了父类的函数调用权</p>
<h3 id="继承与模板方法"><a href="#继承与模板方法" class="headerlink" title="继承与模板方法"></a>继承与模板方法</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210418075133.png" srcset="/img/loading.gif" lazyload alt="模板方法"></p>
<h3 id="委托-继承与观察者模式"><a href="#委托-继承与观察者模式" class="headerlink" title="委托+继承与观察者模式"></a>委托+继承与观察者模式</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/20210418080207.png" srcset="/img/loading.gif" lazyload alt="观察者模式"></p>
<h4 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/25e2643d8ad391fd2a7ee50d3e4ac2a9-375551.png" srcset="/img/loading.gif" lazyload alt="委托+继承"></p>
<ol>
<li>add()函数不能为纯虚函数的原因：如果是纯虚函数，那么Primitive这个类就必须实现。</li>
<li>Composite是个容器，可以同时存放Primitive和自身。这种情况下可以抽象出两者的父类，并以父类的指针作为容器的元素。</li>
<li>应用场景：可以把Primitive看成文件，Composite看成目录。</li>
</ol>
<h4 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h4><p>若有如下需求：在一个树状继承体系中，创建出一个未来才会实现的类。即在代码中对未来的类进行提前的封装，然后进行相关的操作？</p>
<p>设想：派生出来的子类创建完自己后，将自己的位置告诉给父类，让父类存储。</p>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/cd0bd4e2038edfe0b32e67c780956a79-737a8.png" srcset="/img/loading.gif" lazyload alt="Prototype"></p>
<p>父类：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">imageType</span> &#123;</span> LSAT, SPOT &#125;; <span class="hljs-comment">//子类类型的枚举变量</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Image</span> &#123;</span> <br>	<span class="hljs-keyword">public</span>: <br>    		<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <br>    		<span class="hljs-function"><span class="hljs-keyword">static</span> Image *<span class="hljs-title">findAndClone</span><span class="hljs-params">(imageType)</span></span>; <br>    <br>    <span class="hljs-keyword">protected</span>: <br>    		<span class="hljs-function"><span class="hljs-keyword">virtual</span> imageType <span class="hljs-title">returnType</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//由子类实现，让子类返回自己的类型</span><br>    		<span class="hljs-function"><span class="hljs-keyword">virtual</span> Image *<span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//由子类实现clone过程</span><br>    		<span class="hljs-built_in">addPrototype</span>(Image *image) &#123; <span class="hljs-comment">// 当 Image 的每个子类被声明时，它会注册它的static void原型</span><br>                _prototypes[_nextSlot++] = image;<br>            &#125; <br>    <br>    <span class="hljs-keyword">private</span>: <br>    		<span class="hljs-keyword">static</span> Image *_prototypes[<span class="hljs-number">10</span>]; <span class="hljs-comment">// addPrototype() 在这里保存每个注册的原型</span><br>    		<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _nextSlot; <br>&#125;; <br>Image *Image::_prototypes[]; <br><span class="hljs-keyword">int</span> Image::_nextSlot;<br><span class="hljs-comment">// 客户需要实例时调用这个公共静态成员函数</span><br><span class="hljs-comment">// 返回一个 Image子类</span><br><span class="hljs-function">Image *<span class="hljs-title">Image::findAndClone</span><span class="hljs-params">(imageType type)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; _nextSlot; i++)<br>		<span class="hljs-keyword">if</span> (_prototypes[i]-&gt;<span class="hljs-built_in">returnType</span>() == type)<br>	<span class="hljs-keyword">return</span> _prototypes[i]-&gt;<span class="hljs-built_in">clone</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>子类：<br><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LandSatImage</span>:</span> <span class="hljs-keyword">public</span> Image &#123; <br>    <span class="hljs-keyword">public</span>: <br>    		<span class="hljs-function">imageType <span class="hljs-title">returnType</span><span class="hljs-params">()</span> </span>&#123; <br>        		<span class="hljs-keyword">return</span> LSAT; <br>    		&#125; <br>    		<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;  <br>        		cout &lt;&lt; <span class="hljs-string">&quot;LandSatImage::draw &quot;</span> &lt;&lt; _id &lt;&lt; endl; <br>    		&#125; <br>    		<span class="hljs-comment">// 当clone被调用时, 调用带了一个假参数(dummy)的构造函数：LandSatImage(int dummy)</span><br>    		<span class="hljs-function">Image *<span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123; <br>        		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">LandSatImage</span>(<span class="hljs-number">1</span>); <br>    		&#125; <br>    <span class="hljs-keyword">protected</span>: <br>    		<span class="hljs-comment">// 只会被clone()函数调用 </span><br>    		<span class="hljs-built_in">LandSatImage</span>(<span class="hljs-keyword">int</span> dummy) &#123;<br>                _id = _count++; <br>            &#125; <br>    <span class="hljs-keyword">private</span>: <br>    		<span class="hljs-comment">// 始化 Image 子类 - 这会导致调用默认的构造函数，它注册子类的原型 </span><br>    		<span class="hljs-keyword">static</span> LandSatImage _landSatImage; <br>    		<span class="hljs-comment">// 这仅在初始化私有静态数据成员时调用 </span><br>    		<span class="hljs-built_in">LandSatImage</span>() &#123; <span class="hljs-built_in">addPrototype</span>(<span class="hljs-keyword">this</span>); &#125; <br>    		<span class="hljs-comment">// 区分每个实例所需 </span><br>    		<span class="hljs-keyword">int</span> _id; <br>    		<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _count; <br>&#125;; <br><span class="hljs-comment">// 注册子类的原型</span><br>LandSatImage LandSatImage::_landSatImage; <br><span class="hljs-comment">// 区分每个实例所需</span><br><span class="hljs-keyword">int</span> LandSatImage::_count = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//略</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpotImage</span>:</span> <span class="hljs-keyword">public</span> Image<br>&#123;<br>	<span class="hljs-keyword">public</span>:<br>			<span class="hljs-function">imageType <span class="hljs-title">returnType</span><span class="hljs-params">()</span> </span>&#123;<br>				<span class="hljs-keyword">return</span> SPOT;<br>			&#125;<br>    <span class="hljs-comment">//....与class LandSatImage相似，略</span><br>&#125;<br></code></pre></div></td></tr></table></figure></p>
<p>main:</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 模拟创建请求</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> NUM_IMAGES = <span class="hljs-number">8</span>; <br>imageType input[NUM_IMAGES] = &#123; LSAT, LSAT, LSAT, SPOT, LSAT, SPOT, SPOT, LSAT &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>	Image* images[NUM_IMAGES];<br>	<span class="hljs-comment">// 给定一个图像类型，找到正确的原型，并返回一个克隆</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_IMAGES; i++)<br>		images[i] = Image::<span class="hljs-built_in">findAndClone</span>(input[i]);<br>	<span class="hljs-comment">// 证明已克隆正确的图像对象</span><br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NUM_IMAGES; i++)<br>		images[i]-&gt;<span class="hljs-built_in">draw</span>();<br>	<span class="hljs-comment">// 释放动态内存</span><br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NUM_IMAGES; i++)<br>		<span class="hljs-keyword">delete</span> images[i];<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="conversion-function（转换函数）"><a href="#conversion-function（转换函数）" class="headerlink" title="conversion function（转换函数）"></a>conversion function（转换函数）</h2><ul>
<li>转换函数没有返回类型</li>
<li>为了程序的健壮性，转换函数需要加const</li>
<li>转换类型不一定得是基本类型，自定义类型也行，只要编译器认得转换的类型就可以。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Fraction</span>(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> den=<span class="hljs-number">1</span>) <br>	  : <span class="hljs-built_in">m_numerator</span>(num), <span class="hljs-built_in">m_denominator</span>(den)<br>	&#123;&#125;<br>	<br>    <span class="hljs-comment">//转换函数</span><br> 	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <br>      <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)m_numerator / m_denominator; <br> 	&#125;<br> 	<br><span class="hljs-keyword">private</span>:   <br>   <span class="hljs-keyword">int</span> m_numerator;    <span class="hljs-comment">//分子</span><br>   <span class="hljs-keyword">int</span> m_denominator;  <span class="hljs-comment">//分母</span><br>&#125;;<br><br><span class="hljs-comment">//main.cpp...</span><br><span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-keyword">double</span> d = <span class="hljs-number">4</span> + f;<span class="hljs-comment">//f将会被转换为0.6</span><br></code></pre></div></td></tr></table></figure>
<p>若没有转换函数，重载运算符<code>+</code>，也能运行</p>
<h3 id="STL中的转换函数"><a href="#STL中的转换函数" class="headerlink" title="STL中的转换函数"></a>STL中的转换函数</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/e131cbce529c3873f473dd3a802fbfb5-21f79b.png" srcset="/img/loading.gif" lazyload alt="STL中的转换函数"></p>
<h2 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h2><h3 id="non-explicit-one-argument-ctor"><a href="#non-explicit-one-argument-ctor" class="headerlink" title="non-explicit-one-argument ctor"></a>non-explicit-one-argument ctor</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Fraction</span>(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> den=<span class="hljs-number">1</span>) <br>	  : <span class="hljs-built_in">m_numerator</span>(num), <span class="hljs-built_in">m_denominator</span>(den)&#123;&#125;<br>	<br> 	Fraction <span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">const</span> Fraction&amp; f) &#123;  <br>	   <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fraction</span>(......);<br>	&#125;<br>    <br><span class="hljs-keyword">private</span>:   <br>   <span class="hljs-keyword">int</span> m_numerator;    <span class="hljs-comment">//分子</span><br>   <span class="hljs-keyword">int</span> m_denominator;  <span class="hljs-comment">//分母</span><br>&#125;<br><br><span class="hljs-comment">//main.cpp...</span><br><span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;<br>Fraction d2 = f + <span class="hljs-number">4</span>;<span class="hljs-comment">//调用 non-explicit 构造函数，将4转换为Fraction(4,1)，然后调用operator+</span><br></code></pre></div></td></tr></table></figure>
<p>本例中：</p>
<ul>
<li>Fraction的构造函数，虽然说有两个形式参数，但是由于其中有一个默认值，所以实际上这个构造函数可以看成<strong>单实参</strong>构造函数。（单实参并不是单形参）</li>
<li>在编译器编译到<code>Fraction d2 = f + 4;</code>这条语句的时候，找到了Fraction类中operator+重载函数，但是该重载函数的参数为<code>Fraction&amp;</code>类型，所以编译器接下来会<strong>尝试</strong>将<code>4</code>转换为Fraction类型。在此例中，有了<strong>“单实参构造函数“</strong>的前提条件，编译器将会调用<code>Fraction</code>的构造函数，将<code>4</code>传入，即执行<code>Fraction(4,1)</code>。</li>
</ul>
<h3 id="conversion-function-vs-non-explicit-one-argument-ctor"><a href="#conversion-function-vs-non-explicit-one-argument-ctor" class="headerlink" title="conversion function vs. non-explicit-one-argument ctor"></a>conversion function vs. non-explicit-one-argument ctor</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Fraction</span>(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> den=<span class="hljs-number">1</span>) <br>	  : <span class="hljs-built_in">m_numerator</span>(num), <span class="hljs-built_in">m_denominator</span>(den)&#123;&#125;<br>	<br> 	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <br>      <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)m_numerator / m_denominator; <br> 	&#125;<br> 	<br> 	Fraction <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Fraction&amp; f) &#123;  <br>	   <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fraction</span>(......);<br>	&#125; <br><br><span class="hljs-keyword">private</span>:   <br>   <span class="hljs-keyword">int</span> m_numerator;    <span class="hljs-comment">//分子</span><br>   <span class="hljs-keyword">int</span> m_denominator;  <span class="hljs-comment">//分母</span><br>&#125;;<br><br><span class="hljs-comment">//main.cpp</span><br><span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>; <br>Fraction d2 = f + <span class="hljs-number">4</span>;<span class="hljs-comment">//[Error]ambiguous  </span><br></code></pre></div></td></tr></table></figure>
<p>在本例中，由于同时重载了<code>double()</code>和<code>operator+</code>，所以当编译器编译<code>double d2 = f + 4;</code>时，会遇到问题，即二义性问题。编译器接来下处理<code>f + 4</code>会面临两种抉择：</p>
<ol>
<li>将<code>f</code>通过<code>double()</code>转化<code>0.6</code>，即<code>0.6+4</code></li>
<li>将<code>4</code>通过构造函数转化为<code>Fraction(4,1)</code>，即<code>f+Fraction(4,1)</code></li>
</ol>
<p>编译器不知道该怎么选择，所以会报错：<strong>ambiguous</strong>  </p>
<h3 id="explicit-one-argument-ctor"><a href="#explicit-one-argument-ctor" class="headerlink" title="explicit-one-argument ctor"></a>explicit-one-argument ctor</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fraction</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Fraction</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> den=<span class="hljs-number">1</span>)</span> <span class="hljs-comment">//加入explicit关键字</span></span><br><span class="hljs-function">	  : m_numerator(num), m_denominator(den)&#123;</span>&#125;<br>	<br> 	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <br>      <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)m_numerator / m_denominator; <br> 	&#125;<br> 	<br> 	Fraction <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Fraction&amp; f) &#123;  <br>	   <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fraction</span>(......);<br>	&#125; <br>    <br><span class="hljs-keyword">private</span>:   <br>   <span class="hljs-keyword">int</span> m_numerator;    <span class="hljs-comment">//分子</span><br>   <span class="hljs-keyword">int</span> m_denominator;  <span class="hljs-comment">//分母</span><br>&#125;;<br><br><span class="hljs-comment">//main.cpp</span><br><span class="hljs-function">Fraction <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;<br>Fraction d2 = f + <span class="hljs-number">4</span>;<span class="hljs-comment">//[Error]conversion from &#x27;double&#x27; to &#x27;Fraction&#x27; requested</span><br></code></pre></div></td></tr></table></figure>
<p>本例中，在构造函数的前面添加了<code>explicit</code>关键字。这个关键字的作用就是告诉编译器：</p>
<p><strong>只有当构造函数被显式的调用，编译器才可以调用构造函数</strong></p>
<p>所以当编译器编译<code>Fraction d2 = f + 4;</code>时，已经不会再尝试地将<code>4</code>转化为<code>Fraction(4,1)</code>了，只会将<code>f</code>通过<code>double()</code>进行转换，所以<code>f+4</code>会变成<code>0.6+4</code>。又因为<code>d2</code>是Fraction类型，所以编译器报错是正常的。</p>
<h2 id="pointer-like-classes"><a href="#pointer-like-classes" class="headerlink" title="pointer-like classes"></a>pointer-like classes</h2><p>也可以对类进行分类：比如像指针的类，像函数的类</p>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><h4 id="关于operator-和operator-gt"><a href="#关于operator-和operator-gt" class="headerlink" title="关于operator*和operator-&gt;"></a>关于operator*和operator-&gt;</h4><p>智能指针中都会带有一个一般的指针。</p>
<p>在智能指针中，重载操作符<code>*</code>和<code>-&gt;</code>一般都是固定写法。</p>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/34dc5fe416e326ad1ec2a555b1c1fed6-c414f2.png" srcset="/img/loading.gif" lazyload alt="关于operator*和operator-&gt;"></p>
<p>对于图中三个已经编号的语句：</p>
<ul>
<li>语句1看起来很正常，因为重载操作符<code>*</code>，返回的同样是解引用。所以<code>Foo f(*sp)</code>实际上就是<code>Foo f(*px)</code>。</li>
<li>而对于语句2，如果通过重载操作符<code>-&gt;</code>返回值为<code>px</code>的话，按照正常的思路，<code>sp-&gt;method()</code>就会变成<code>pxmethod()</code>，少了<code>-&gt;</code>。但是实际上，语句2会变成语句3。原因是是C++的语法规定：<strong>-&gt;符号有个特殊的行为，在-&gt;符号作用的结果上，-&gt;符号会继续作用下去。</strong></li>
</ul>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>迭代器其实也是智能指针</p>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/58ff59423d173f39de7f3c07a6639191-a6f205.png" srcset="/img/loading.gif" lazyload alt="迭代器"></p>
<h2 id="function-like-classes：仿函数"><a href="#function-like-classes：仿函数" class="headerlink" title="function-like classes：仿函数"></a>function-like classes：仿函数</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/bcbb678ba6becab283407c1b358ca181-f3318a.png" srcset="/img/loading.gif" lazyload alt="仿函数"></p>
<p>调用方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">select1st&lt;Pair&gt;()()<br>select2nd&lt;Pair&gt;()()<br></code></pre></div></td></tr></table></figure>
<p>在一个class里重载<code>()</code>，说明用意就是想让<strong>class</strong>变成一个<strong>function</strong>。对于这种模仿函数行为的对象，称之为函数对象。（stl里面有很多的仿函数）</p>
<h2 id="namespace经验谈"><a href="#namespace经验谈" class="headerlink" title="namespace经验谈"></a>namespace经验谈</h2><p>对于测试程序，可以使用<code>namespace</code>。比如：</p>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8d4c799728c33e47f9ea6b6385880545-b66f52.png" srcset="/img/loading.gif" lazyload alt="namespace经验谈"></p>
<h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><h3 id="class-template"><a href="#class-template" class="headerlink" title="class template"></a>class template</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/af7e08d3ba53835799e99215f45aa80c-d1a5b2.png" srcset="/img/loading.gif" lazyload alt="类模板"></p>
<h3 id="member-template：成员模板"><a href="#member-template：成员模板" class="headerlink" title="member template：成员模板"></a>member template：成员模板</h3><p>这种成员模板的应用在STL标准库中大量出现：</p>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b8270b8b0d56bd28cc0c9e01e8008574-ae6359.png" srcset="/img/loading.gif" lazyload alt="member template 1"></p>
<p>智能指针中模仿向上转型的做法：</p>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/51f2f90ada34ecd33f6f6380f26ca958-a29028.png" srcset="/img/loading.gif" lazyload alt="member template 2"></p>
<h3 id="specialization：模板特化"><a href="#specialization：模板特化" class="headerlink" title="specialization：模板特化"></a>specialization：模板特化</h3><ul>
<li>特化可以写任意版本</li>
</ul>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8bed3c001f2f63d2ceddcf13ad43eb0d-151429.png" srcset="/img/loading.gif" lazyload alt="模板特化"></p>
<h4 id="partial-specialization：模板偏特化"><a href="#partial-specialization：模板偏特化" class="headerlink" title="partial specialization：模板偏特化"></a>partial specialization：模板偏特化</h4><ul>
<li>模板绑定参数需要从左边到右边进行绑定，比如形参次序为1，2，3，4，5，那么绑定参数不能挑选出1，3，5进行绑定，只能1，2，3这样绑定。</li>
</ul>
<h5 id="个体偏特化"><a href="#个体偏特化" class="headerlink" title="个体偏特化"></a>个体偏特化</h5><p>对某种具体类型的特殊处理，比如对bool类型偏特化：</p>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/cecfd818959022054a9923abcb3d8698-2ddbe1.png" srcset="/img/loading.gif" lazyload alt="单个偏特化"></p>
<h5 id="范围偏特化"><a href="#范围偏特化" class="headerlink" title="范围偏特化"></a>范围偏特化</h5><p>对某个范围的类型进行特殊处理，比如对<strong>所有</strong>指针类型进行偏特化：</p>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/ccf5547367e4a7c109b8db153d0582a4-2cea76.png" srcset="/img/loading.gif" lazyload alt="范围偏特化"></p>
<h3 id="template-template-parameter：模板模板参数"><a href="#template-template-parameter：模板模板参数" class="headerlink" title="template template parameter：模板模板参数"></a>template template parameter：模板模板参数</h3><h4 id="对于list的例子"><a href="#对于list的例子" class="headerlink" title="对于list的例子"></a>对于list的例子</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/33c4d4e3c79a9f39707e67c21c688199-f878bf.png" srcset="/img/loading.gif" lazyload alt="模板模板参数"></p>
<p>现在的需求是：动态的指定<code>list</code>的类型，就相当于<code>list&lt;string&gt;</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">XCls&lt;string,list&gt; mylist1;<span class="hljs-comment">//错误</span><br></code></pre></div></td></tr></table></figure>
<p>虽然说结合上面的模板模板参数，看起来语法正确，但是由于<code>list</code>不止有一个模板参数，所以编译<code>XCls&lt;string,list&gt; mylist1;</code>编译器会报错。为了实现需求，可以使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> Lst = list&lt;T,allocator&lt;T&gt;&gt;;<br></code></pre></div></td></tr></table></figure>
<p>然后再：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">XCls&lt;string,Lst&gt; mylist1;<span class="hljs-comment">//正确</span><br></code></pre></div></td></tr></table></figure>
<h4 id="对于智能指针的例子"><a href="#对于智能指针的例子" class="headerlink" title="对于智能指针的例子"></a>对于智能指针的例子</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/60f943f55fb92522b88c79061ece7635-a17588.png" srcset="/img/loading.gif" lazyload alt="对于智能指针的例子"></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">XCls&lt;string,shared_ptr&gt; p1;<span class="hljs-comment">//正确</span><br>XCls&lt;<span class="hljs-keyword">double</span>,unique_ptr&gt; p2;<span class="hljs-comment">//错误</span><br>XCls&lt;<span class="hljs-keyword">int</span>,weak_ptr&gt; p3;<span class="hljs-comment">//错误</span><br>XCls&lt;<span class="hljs-keyword">long</span>,auto_ptr&gt; p4;<span class="hljs-comment">//正确</span><br></code></pre></div></td></tr></table></figure>
<p>同样的，参考对于list的例子，p2和p3错误的原因也是因为模板的参数不是唯一的。</p>
<h4 id="一个不是模板模板参数的例子"><a href="#一个不是模板模板参数的例子" class="headerlink" title="一个不是模板模板参数的例子"></a>一个不是模板模板参数的例子</h4><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b1dd9c5d60a6f8e2197052c8dd45178e-34bb35.png" srcset="/img/loading.gif" lazyload alt="一个不是模板模板参数的例子"></p>
<p>虽然说<code>Sequence</code>的默认参数是<code>deque&lt;T&gt;</code>，这个默认参数是一个模板类型的参数。但是他作为参数的时候已经不算是模板了，而是由模板初始化而来的一个参数。也就是说它已经被确定了。</p>
<h3 id="variadic-templates：数量不定的模板参数（C-11）"><a href="#variadic-templates：数量不定的模板参数（C-11）" class="headerlink" title="variadic templates：数量不定的模板参数（C++11）"></a>variadic templates：数量不定的模板参数（C++11）</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b6f56c4064300c100f3b179589d66b96-c7d814.png" srcset="/img/loading.gif" lazyload alt="variadic templates：数量不定的模板参数"></p>
<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>可以在指定模板参数后，在模板后面加()直接生成临时的对象。比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span>*p allocator&lt;<span class="hljs-keyword">int</span>&gt;().<span class="hljs-built_in">allocate</span>(<span class="hljs-number">512</span>,(<span class="hljs-keyword">int</span>*)<span class="hljs-number">0</span>);<br></code></pre></div></td></tr></table></figure>
<h2 id="auto（C-11）"><a href="#auto（C-11）" class="headerlink" title="auto（C++11）"></a>auto（C++11）</h2><p>auto关键字可以让编译器自动推导类型</p>
<ul>
<li>所有变量都用auto可取吗？不行：<ul>
<li>对于变量的类型需要很熟悉，且auto的可读性不高</li>
<li>不可能每一次在声明对象的时候都赋值</li>
</ul>
</li>
</ul>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/28998a55f89820c73ef91e0c3fcd8581-7889b2.png" srcset="/img/loading.gif" lazyload alt="auto"></p>
<h2 id="ranged-base-for-：for新写法（C-11）"><a href="#ranged-base-for-：for新写法（C-11）" class="headerlink" title="ranged-base for ：for新写法（C++11）"></a>ranged-base for ：for新写法（C++11）</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/8e75a572eebe3e248f33caa6cd148262-ebcb46.png" srcset="/img/loading.gif" lazyload alt="ranged-base for ：for新写法（C++11）"></p>
<ul>
<li>pass by value：实际上是值传递，<strong>vec</strong>拷贝了一份赋值给<strong>elem</strong>，传值无法修改原来的值</li>
<li>pass by reference：<strong>vec</strong>将当前迭代元素的引用赋值给<strong>elem</strong>，传引用可以修改原来的值</li>
</ul>
<h2 id="reference：引用"><a href="#reference：引用" class="headerlink" title="reference：引用"></a>reference：引用</h2><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/28e8af9de3f3e70f82cd704c38b65447-b2cca6.png" srcset="/img/loading.gif" lazyload alt="reference：引用"></p>
<ul>
<li><p>虽然说引用的底层是指针，指针大小在32位上是4个字节。但是引用代表的东西sizeof多大，引用sizeof就多大</p>
</li>
<li><p>引用代表的东西的地址在哪里，引用的地址就在哪里</p>
</li>
</ul>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/56041a3b3f0c57e698c49ed766c64dca-f12e4d.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h3 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h3><blockquote>
<p>引用就是一个漂亮的指针</p>
</blockquote>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/f49b1cb39974da549e0c65f5d904b80e-4c0f1c.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>Q：const是不是函数签名的一部分？</p>
<p>A：是</p>
<p><strong>注意：函数签名不含返回值</strong></p>
<h2 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h2><h3 id="关于vptr和vtbl"><a href="#关于vptr和vtbl" class="headerlink" title="关于vptr和vtbl"></a>关于vptr和vtbl</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/b4a9e8f6e13e6d20e65eda01095ce90e-d9e28.png" srcset="/img/loading.gif" lazyload alt="关于vptr和vtbl"></p>
<ul>
<li>只要类里面有一个以上的虚函数，那么这个类以及它的派生类在内存里就会多一根指针，这个指针就是虚表指针</li>
<li>继承函数是继承调用权，而不是继承函数的内存大小。所以父类若有虚函数，子类一定也有虚函数</li>
<li>动态绑定的三个条件<ul>
<li>通过指针调用</li>
<li>指针为up-cast，向上转型</li>
<li>调用的是虚函数</li>
</ul>
</li>
<li>静态绑定：编译时直接指定某个地址</li>
</ul>
<h3 id="关于this指针"><a href="#关于this指针" class="headerlink" title="关于this指针"></a>关于this指针</h3><ul>
<li>在C++的成员函数里面，一定有一个隐藏的this作为参数。</li>
</ul>
<p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/a9d134fab38b6f37fc66b43f2e205b77-abf79.png" srcset="/img/loading.gif" lazyload alt="关于this指针"></p>
<h4 id="汇编层面的函数调用"><a href="#汇编层面的函数调用" class="headerlink" title="汇编层面的函数调用"></a>汇编层面的函数调用</h4><h5 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/dc0e09af8263a41969ed8ab2396e9ecc-0f736.png" srcset="/img/loading.gif" lazyload alt="汇编层面的多态"></p>
<h5 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h5><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/7f59aad8017b1fe873dec0b1da9cf192-43f3b.png" srcset="/img/loading.gif" lazyload alt="动态绑定"></p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h3 id="const-member-functions：常量成员函数"><a href="#const-member-functions：常量成员函数" class="headerlink" title="const member functions：常量成员函数"></a>const member functions：常量成员函数</h3><p><img src="https://images-1257780535.cos.ap-shanghai.myqcloud.com/blogs/52c2717bc969b0b16180cc37360601b1-4963e.png" srcset="/img/loading.gif" lazyload alt="const member functions：常量成员函数 "></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/C/">C++</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%96%B0%E7%89%B9%E6%80%A7/">新特性</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/">对象模型</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-info">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/12/09/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98%2017.14.%20%E6%9C%80%E5%B0%8FK%E4%B8%AA%E6%95%B0/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">面试题 17.14. 最小K个数</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/04/10/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Godaddy%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/">
                        <span class="hidden-mobile">域名解析教程</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'preferred-color-scheme';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'zhongshiyu98/commit-utterances');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" lazyload class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo Power By</span></a> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        闽ICP备2021005512号
      </a>
    </span>
    
  </div>


  


  <div>
    <span id="timeDate">载入天数...</span>
    <span id="times">载入时分秒...</span>
    <script>
    var now = new Date();
    function createtime(){
        var grt= new Date("07/02/2020 00:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24;
        dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
        hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){
            hnum = "0" + hnum;
        }
        minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes);
        if(String(mnum).length ==1 ){
                  mnum = "0" + mnum;
        }
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds);
        if(String(snum).length ==1 ){
                  snum = "0" + snum;
        }
        document.getElementById("timeDate").innerHTML = "🚀 已经&nbsp"+dnum+"&nbsp天";  //此次自定义显示内容
        document.getElementById("times").innerHTML = hnum + "&nbsp时&nbsp" + mnum + "&nbsp分&nbsp" + snum + "&nbsp秒";
    }  //此次自定义显示内容
    setInterval("createtime()",250);
    </script>
  </div>


</footer>




  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":true,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.4/es5/tex-svg.js" ></script>

  










  
<script src="/js/custom.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/boom.js"></script>



<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/ Relative)","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":270},"mobile":{"show":false},"react":{"opacityDefault":0.7}});</script></body>
</html>
